{"version":3,"file":"server.js","mappings":"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,aAAa,mBAAO,CAAC,EAAqC;AAC1D,aAAa,mBAAO,CAAC,EAAe;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,YAAY,aAAa,aAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yBAAyB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2IAA2I,OAAO;AAClJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,SAAS,EAAE,gBAAgB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,QAAQ,IAAI,QAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,EAAE;AAC1D;AACA;AACA,4BAA4B,gBAAgB;AAC5C;AACA,sBAAsB,QAAQ,IAAI,MAAM;AACxC;AACA;AACA;AACA;AACA;;;;;;;;ACjRA,sC;;;;;;;ACAa;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gBAAgB,GAAG,kBAAkB,GAAG,mBAAmB,GAAG,aAAa,GAAG,YAAY,GAAG,aAAa,GAAG,cAAc,GAAG,cAAc,GAAG,eAAe;AAC9J;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,gBAAgB;;;;;;;;AC1CH;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB,GAAG,uBAAuB,GAAG,gCAAgC,GAAG,gCAAgC,GAAG,gCAAgC,GAAG,6BAA6B,GAAG,6BAA6B,GAAG,6BAA6B,GAAG,gCAAgC,GAAG,8BAA8B,GAAG,sBAAsB,GAAG,sBAAsB,GAAG,0BAA0B,GAAG,wBAAwB,GAAG,2BAA2B;AACvc,yCAAyC,mBAAO,CAAC,CAAgC;AACjF,WAAW,mBAAO,CAAC,CAAY;AAC/B,aAAa,mBAAO,CAAC,EAAc;AACnC,mBAAmB,mBAAO,CAAC,EAAY;AACvC,wBAAwB,mBAAO,CAAC,EAAiB;AACjD,0BAA0B,mBAAO,CAAC,EAAmB;AACrD,wBAAwB,mBAAO,CAAC,EAAiB;AACjD,yBAAyB,mBAAO,CAAC,EAAkB;AACnD,uBAAuB,mBAAO,CAAC,EAAgB;AAC/C,yBAAyB,mBAAO,CAAC,EAAkB;AACnD,6BAA6B,mBAAO,CAAC,EAAsB;AAC3D,wBAAwB,mBAAO,CAAC,EAAiB;AACjD,sBAAsB,mBAAO,CAAC,EAAe;AAC7C,uBAAuB,mBAAO,CAAC,EAAgB;AAC/C,YAAY,wDAAwD;AACpE,oBAAoB,mBAAO,CAAC,EAAa;AACzC,qBAAqB,mBAAO,CAAC,EAAc;AAC3C,mBAAmB,mBAAO,CAAC,EAAY;AACvC,kBAAkB,mBAAO,CAAC,EAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iHAAiH,eAAe;AAChI;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,uBAAuB,wBAAwB,wBAAwB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,yBAAyB,0BAA0B,0BAA0B;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,gFAAgF,mBAAmB;AACnG,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,oDAAoD;AAClF;AACA;AACA;AACA;AACA;AACA,iCAAiC,wBAAwB;AACzD;AACA,SAAS;AACT,4EAA4E,QAAQ;AACpF;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,8BAA8B,oDAAoD;AAClF;AACA;AACA;AACA,gEAAgE,kEAAkE,IAAI,YAAY;AAClJ,aAAa;AACb,SAAS;AACT,4EAA4E,QAAQ;AACpF;AACA,SAAS;AACT;AACA;AACA;AACA,iCAAiC,YAAY;AAC7C;AACA;AACA,+EAA+E,IAAI;AACnF,SAAS;AACT;AACA;AACA;AACA;AACA,2GAA2G,SAAS,qDAAqD;AACzK,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,wBAAwB,gBAAgB;AACxC,0BAA0B,mBAAmB;AAC7C,uBAAuB,gBAAgB;AACvC,uBAAuB,gBAAgB;AACvC,uBAAuB,sBAAsB;AAC7C,0BAA0B,mBAAmB;AAC7C,0BAA0B,mBAAmB;AAC7C,0BAA0B,mBAAmB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,2BAA2B,gBAAgB;AAC3C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,wBAAwB;;;;;;;;AC5uBX;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gCAAgC;AAChC,eAAe,mBAAO,CAAC,CAAqB;AAC5C,aAAa,mBAAO,CAAC,CAAqB;AAC1C,aAAa,mBAAO,CAAC,EAAe;AACpC;AACA;AACA;AACA,gCAAgC;;;;;;;;AC3BhC;AACA;AACA;AACA;AACa;;AAEb,uCAA2C,C;;;;;;;ACN9B;AACb;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,+BAA+B,GAAG,mCAAmC,GAAG,mCAAmC,GAAG,iCAAiC,GAAG,iCAAiC,GAAG,8BAA8B,GAAG,2BAA2B,GAAG,2BAA2B,GAAG,2BAA2B,GAAG,2BAA2B,GAAG,yBAAyB,GAAG,yBAAyB,GAAG,wBAAwB,GAAG,wBAAwB;AAC1b;AACA;AACA;AACA;AACA,cAAc,mBAAO,CAAC,CAAO;AAC7B;AACA;AACA,aAAa,mBAAO,CAAC,EAAM;AAC3B,WAAW,mBAAO,CAAC,EAAI;AACvB,iBAAiB,mBAAO,CAAC,EAAQ;AACjC,cAAc,mBAAO,CAAC,EAAK;AAC3B,cAAc,mBAAO,CAAC,EAAe;AACrC,aAAa,mBAAO,CAAC,EAAe;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,aAAa;AAC3D;AACA;AACA;AACA,0DAA0D,aAAa;AACvE;AACA;AACA,kDAAkD,aAAa;AAC/D;AACA;AACA;AACA,kEAAkE,OAAO,mBAAmB,OAAO;AACnG;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,qCAAqC;AACrC,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,qCAAqC;AACrC,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,+BAA+B;;;;;;;;AChQlB;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe,mBAAO,CAAC,EAAM;AAC7B,cAAc,mBAAO,CAAC,EAAe;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,qBAAqB;AACrB,SAAS;AACT;AACA;AACA,qBAAqB;AACrB,SAAS;AACT;AACA;AACA,qBAAqB;AACrB;AACA,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kBAAkB;AACnB,kBAAe;;;;;;;;AChKf,iC;;;;;;;ACAa;AACb;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB,GAAG,qBAAqB,GAAG,+BAA+B,GAAG,kBAAkB,GAAG,yBAAyB,GAAG,0BAA0B,GAAG,6BAA6B,GAAG,oCAAoC,GAAG,6BAA6B,GAAG,qBAAqB,GAAG,mCAAmC,GAAG,6BAA6B,GAAG,qBAAqB,GAAG,mCAAmC,GAAG,iCAAiC,GAAG,yBAAyB,GAAG,+BAA+B,GAAG,eAAe,GAAG,aAAa,GAAG,kBAAkB,GAAG,gBAAgB,GAAG,aAAa,GAAG,iBAAiB,GAAG,2BAA2B,GAAG,yBAAyB,GAAG,yBAAyB,GAAG,yBAAyB,GAAG,yBAAyB,GAAG,yBAAyB,GAAG,yBAAyB,GAAG,yBAAyB,GAAG,yBAAyB,GAAG,yBAAyB,GAAG,yBAAyB,GAAG,wBAAwB,GA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CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,cAAc,eAAe,eAAe;;;;;;;;ACjThC;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB,GAAG,aAAa,GAAG,YAAY,GAAG,aAAa,GAAG,cAAc,GAAG,cAAc,GAAG,eAAe;AACtH;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,mBAAmB;;;;;;;;AClCN;AACb;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gBAAgB,GAAG,iBAAiB,GAAG,aAAa;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,YAAY,aAAa,aAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;;;;;;;;AC7YH;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,iBAAiB,kBAAkB,kBAAkB;;;;;;;;ACfzC;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe,GAAG,aAAa;AAC/B,cAAc,mBAAO,CAAC,EAAO;AAC7B;AACA;AACA,0BAA0B;AAC1B,+BAA+B;AAC/B,CAAC,YAAY,aAAa,aAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,+CAA+C;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,SAAS;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,SAAS;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;;;;;;;;AC/Ha;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kBAAkB;AACnB,kBAAe;;;;;;;;ACtBF;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,+BAA+B,GAAG,yBAAyB;AAC3D,cAAc,mBAAO,CAAC,EAAO;AAC7B,WAAW,mBAAO,CAAC,EAAM;AACzB,iBAAiB,mBAAO,CAAC,EAAU;AACnC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wBAAwB,yBAAyB,yBAAyB;AAC3E;AACA;AACA,aAAa,YAAY;AACzB,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;;;;;;;;AC/FlB;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mCAAmC,GAAG,iCAAiC;AACvE,uBAAuB,mBAAO,CAAC,EAAgB;AAC/C;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;;;;;;;;AC3EtB;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mCAAmC,GAAG,6BAA6B,GAAG,qBAAqB;AAC3F,cAAc,mBAAO,CAAC,EAAO;AAC7B,WAAW,mBAAO,CAAC,EAAM;AACzB,iBAAiB,mBAAO,CAAC,EAAU;AACnC,oBAAoB,mBAAO,CAAC,EAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oBAAoB,qBAAqB,qBAAqB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,qDAAqD;AACpH;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,CAAC,oEAAoE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oGAAoG,4CAA4C;AAChJ;AACA;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,2CAA2C;AACrF;AACA;AACA,SAAS;AACT;AACA;AACA,mCAAmC;;;;;;;;ACpMtB;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB;AACjB,cAAc,mBAAO,CAAC,EAAO;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,wBAAwB;AACzD;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;;;;;;;ACnEJ;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oCAAoC,GAAG,6BAA6B,GAAG,qBAAqB;AAC5F,cAAc,mBAAO,CAAC,EAAO;AAC7B,WAAW,mBAAO,CAAC,EAAM;AACzB,oBAAoB,mBAAO,CAAC,EAAa;AACzC,iBAAiB,mBAAO,CAAC,EAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oBAAoB,qBAAqB,qBAAqB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,qDAAqD;AACpH;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,CAAC,oEAAoE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;;;;;;;;AClHvB;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA,yFAAyF,OAAO;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;;;;;;;;ACvJhB;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,+BAA+B,GAAG,yBAAyB,GAAG,uBAAuB,GAAG,4BAA4B,GAAG,kCAAkC,GAAG,oCAAoC,GAAG,2CAA2C,GAAG,sCAAsC,GAAG,0BAA0B,GAAG,uBAAuB,GAAG,wBAAwB,GAAG,4BAA4B,GAAG,4BAA4B,GAAG,mBAAmB,GAAG,mBAAmB,GAAG,aAAa,GAAG,kBAAkB,GAAG,oBAAoB,GAAG,qBAAqB;AACviB,cAAc,mBAAO,CAAC,EAAO;AAC7B,WAAW,mBAAO,CAAC,EAAM;AACzB,mBAAmB,mBAAO,CAAC,EAAY;AACvC,oBAAoB,mBAAO,CAAC,EAAa;AACzC,iBAAiB,mBAAO,CAAC,EAAU;AACnC,uBAAuB,mBAAO,CAAC,EAAgB;AAC/C;AACA;AACA;AACA,CAAC,gDAAgD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oBAAoB,qBAAqB,qBAAqB;AAC/D;AACA;AACA;AACA,CAAC,oDAAoD;AACrD;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD;AACjD,kBAAkB;AAClB,oBAAoB;AACpB,mBAAmB;AACnB,mBAAmB;AACnB;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,YAAY,aAAa,aAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kBAAkB,mBAAmB,mBAAmB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,YAAY,aAAa,aAAa;AACvC;AACA;AACA;AACA;AACA,CAAC,kBAAkB,mBAAmB,mBAAmB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kBAAkB,mBAAmB,mBAAmB;AACzD;AACA;AACA;AACA,CAAC,2BAA2B,4BAA4B,4BAA4B;AACpF;AACA;AACA;AACA,CAAC,2BAA2B,4BAA4B,4BAA4B;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,uBAAuB,wBAAwB,wBAAwB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,yBAAyB,0BAA0B,0BAA0B;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,qCAAqC,sCAAsC,sCAAsC;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0CAA0C,2CAA2C,2CAA2C;AACjI;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC,mCAAmC,oCAAoC,oCAAoC;AAC5G;AACA;AACA;AACA;AACA,oEAAoE,IAAI;AACxE,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,CAAC,iCAAiC,kCAAkC,kCAAkC;AACtG;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,CAAC,2BAA2B,4BAA4B,4BAA4B;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sBAAsB,uBAAuB,uBAAuB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wBAAwB,yBAAyB,yBAAyB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0CAA0C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oHAAoH,uBAAuB,UAAU,qBAAqB;AAC1K;AACA;AACA;AACA;AACA;AACA;AACA,oHAAoH,uBAAuB;AAC3I;AACA;AACA;AACA;AACA;AACA;AACA,oHAAoH,uBAAuB;AAC3I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,oHAAoH,uBAAuB,uBAAuB,cAAc;AAChL;AACA;AACA,oHAAoH,uBAAuB;AAC3I;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4GAA4G,uBAAuB,uBAAuB,cAAc;AACxK;AACA;AACA,4GAA4G,uBAAuB;AACnI;AACA;AACA;AACA;AACA,8GAA8G,sBAAsB;AACpI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF,oDAAoD;AACtI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,uBAAuB,yBAAyB,cAAc;AACxH;AACA;AACA,0DAA0D,uBAAuB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,gBAAgB,UAAU,qBAAqB;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,oCAAoC;AACtF;AACA;AACA;AACA;AACA,iEAAiE,gBAAgB;AACjF;AACA;AACA,iEAAiE,gBAAgB,UAAU,qBAAqB,sBAAsB,eAAe;AACrJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,gBAAgB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,eAAe,yBAAyB,cAAc;AAChH;AACA;AACA,0DAA0D,eAAe;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kGAAkG,iCAAiC;AACnI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,+BAA+B;AACjE;AACA,2CAA2C,gBAAgB,KAAK,WAAW;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,+BAA+B;AACrE;AACA;AACA;AACA;AACA;AACA,gDAAgD,eAAe;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,mCAAmC;AAC7E;AACA;AACA;AACA,0CAA0C,+BAA+B;AACzE;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,QAAQ,KAAK,WAAW,8BAA8B,uBAAuB;AACzH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,+BAA+B;AACjE;AACA,4CAA4C,gBAAgB,KAAK,WAAW;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,+BAA+B;AACrE;AACA;AACA;AACA;AACA;AACA,iDAAiD,eAAe;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,mCAAmC;AAC7E;AACA;AACA;AACA,0CAA0C,+BAA+B;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,uBAAuB,GAAG,mBAAmB;AAC/G,iDAAiD,wBAAwB,KAAK,WAAW,QAAQ,wCAAwC,KAAK,MAAM;AACpJ;AACA;AACA,gDAAgD,YAAY;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,+BAA+B;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yCAAyC;AACzE;AACA;AACA;AACA,gDAAgD,oBAAoB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,gBAAgB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,0BAA0B;AAC/E;AACA;AACA;AACA,4DAA4D,eAAe;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,8DAA8D,OAAO;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,4EAA4E,cAAc;AAC1F,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,gBAAgB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wGAAwG,GAAG;AAC3G;AACA;AACA;AACA;AACA,+EAA+E,IAAI;AACnF,yBAAyB;AACzB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,mCAAmC;AACnF;AACA;AACA;AACA;AACA;AACA,uDAAuD,eAAe;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,+BAA+B;AAC9G;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,+BAA+B;;;;;;;;AC3rC/B,iC;;;;;;;ACAA,+B;;;;;;;ACAA,mC;;;;;;;ACAA,gC;;;;;;;ACAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB,GAAG,gCAAgC;AACxD,aAAa,mBAAO,CAAC,CAAgB;AACrC,aAAa,mBAAO,CAAC,EAA6B;AAClD,aAAa,mBAAO,CAAC,EAAY;AACjC,aAAa,mBAAO,CAAC,EAAY;AACjC,mBAAmB,mBAAO,CAAC,EAAc;AACzC,4DAA2D,EAAE,qCAAqC,iDAAiD,EAAC;AACpJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oBAAoB,qBAAqB,qBAAqB;;;;;;;AC5E/D;AACA,QAAQ,KAA0B;AAClC,wBAAwB,uBAAO;AAC/B;AACA;AACA,aAAa,IAA0C;AACvD,QAAQ,iCAAO,CAAC,mBAAS,EAAE,OAAS,CAAC,oCAAE,OAAO;AAAA;AAAA;AAAA,kGAAC;AAC/C;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,mDAAmD,aAAa;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,wDAAwD;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,gCAAgC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,4CAA4C;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,+CAA+C;AACpD;AACA;AACA,QAAQ,gBAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,6DAA6D,gBAAgB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,+CAA+C;AACpD;AACA;AACA,QAAQ,aAAa;AACrB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,aAAa;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,sCAAsC;AAC3C;AACA;AACA,QAAQ,gBAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,6DAA6D,gBAAgB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,+CAA+C;AACpD;AACA;AACA,QAAQ,oBAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,6DAA6D,oBAAoB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,2DAA2D;AAChE;AACA;AACA,QAAQ,aAAa;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,aAAa;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,sCAAsC;AAC3C;AACA;AACA,QAAQ,wBAAwB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,wBAAwB;AACrF;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,uEAAuE;AAC5E;AACA;AACA,QAAQ,yBAAyB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,wBAAwB;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,0EAA0E;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,uEAAuE;AAC5E;AACA;AACA,QAAQ,oBAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,oBAAoB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,2DAA2D;AAChE;AACA;AACA,QAAQ,oCAAoC;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,oCAAoC;AACjG;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,2GAA2G;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,6EAA6E;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,8DAA8D;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,oEAAoE;AACzE;AACA;AACA,QAAQ,kBAAkB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,kBAAkB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,qDAAqD;AAC1D;AACA;AACA,QAAQ,eAAe;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,uBAAuB;AACpD;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,eAAe;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,4CAA4C;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,SAAS,gCAAgC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,+CAA+C;AACpD;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,uEAAuE;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,qGAAqG;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,SAAS,gCAAgC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,0EAA0E;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,uEAAuE;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,qDAAqD;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,qDAAqD;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,qDAAqD;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,KAAK,8DAA8D;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,qBAAqB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,QAAQ,8BAA8B;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,6DAA6D,8BAA8B;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,yFAAyF;AAC9F;AACA;AACA,QAAQ,uCAAuC;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,6DAA6D,uCAAuC;AACpG;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,oHAAoH;AACzH;AACA;AACA,QAAQ,+CAA+C;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,6DAA6D,+CAA+C;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,4IAA4I;AACjJ;AACA;AACA,QAAQ,wBAAwB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,6DAA6D,wBAAwB;AACrF;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,uEAAuE;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,kBAAkB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,qDAAqD;AAC1D;AACA;AACA;AACA,2DAA2D,qBAAqB;AAChF;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,8DAA8D;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,6EAA6E;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,MAAM;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,uEAAuE;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,0EAA0E;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,6DAA6D,yBAAyB;AACtF;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,0EAA0E;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,iEAAiE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,qGAAqG;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,KAAK,iEAAiE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,KAAK,iEAAiE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,yBAAyB;AACvE;AACA;AACA;AACA,2DAA2D,oBAAoB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,2DAA2D;AAChE;AACA;AACA;AACA,2DAA2D,aAAa;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,sCAAsC;AAC3C;AACA;AACA,QAAQ,4BAA4B;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,6CAA6C,IAAI;AACtF;AACA;AACA,KAAK,mFAAmF;AACxF;AACA;AACA,QAAQ,4BAA4B;AACpC;AACA;AACA;AACA;AACA;AACA,6BAA6B,uBAAuB;AACpD;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,mFAAmF;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,sFAAsF;AAC3F;AACA;AACA,QAAQ,yBAAyB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,0EAA0E;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,qDAAqD;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,kDAAkD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,0EAA0E;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oCAAoC;AACxD,oBAAoB,oCAAoC;AACxD;AACA;AACA,KAAK,oEAAoE;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,sBAAsB;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,iEAAiE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,iEAAiE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,sFAAsF;AAC3F;AACA;AACA,QAAQ,yBAAyB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,yBAAyB;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,0EAA0E;AAC/E;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,qDAAqD;AAC1D;AACA;AACA,QAAQ,gBAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,gBAAgB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,+CAA+C;AACpD;AACA;AACA,QAAQ,yBAAyB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,6DAA6D,yBAAyB;AACtF;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,0EAA0E;AAC/E;AACA;AACA,QAAQ,oBAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,6DAA6D,oBAAoB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,2DAA2D;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,iEAAiE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,6EAA6E;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,yFAAyF;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,iEAAiE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,oEAAoE;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,kGAAkG;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,uHAAuH;AAC5H;AACA;AACA,QAAQ,0BAA0B;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,6DAA6D,0BAA0B;AACvF;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,6EAA6E;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,8DAA8D;AACnE;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,6EAA6E;AAClF;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,kDAAkD;AACvD;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,KAAK,wDAAwD;AAC7D;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,KAAK,mFAAmF;AACxF;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,KAAK,mFAAmF;AACxF;AACA,yBAAyB,+DAA+D;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,wGAAwG;AAC7G;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,KAAK,yFAAyF;AAC9F;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,KAAK,4FAA4F;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,oEAAoE;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,qBAAqB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,iDAAiD,QAAQ;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,2DAA2D;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iBAAiB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,gBAAgB;AACrB,CAAC;;;;;;;AC/tED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qC;;;;;;;ACRa;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gCAAgC,GAAG,iCAAiC,GAAG,2BAA2B,GAAG,4BAA4B,GAAG,wBAAwB,GAAG,wBAAwB;AACvL,yBAAyB,mBAAO,CAAC,CAAgB;AACjD;AACA;AACA;AA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0B;AAC9E;AACA;AACA,IAAI,8BAA8B;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,6BAA6B,8BAA8B,8BAA8B;AAC1F;AACA;AACA,IAAI,sCAAsC;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,qCAAqC,sCAAsC,sCAAsC;AAClH;AACA;AACA,IAAI,uBAAuB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,uBAAuB,wBAAwB,wBAAwB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B,2BAA2B,2BAA2B;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B,6BAA6B,6BAA6B;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B,6BAA6B,6BAA6B;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B,2BAA2B,2BAA2B;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,2BAA2B,4BAA4B,4BAA4B;AACpF;AACA;AACA,IAAI,iCAAiC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC,iCAAiC,iCAAiC;AACnG;AACA;AACA,IAAI,uCAAuC;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC,uCAAuC,uCAAuC;AACrH;AACA;AACA,IAAI,+BAA+B;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B,+BAA+B,+BAA+B;AAC7F;AACA;AACA;AACA,sCAAsC;AACtC,4BAA4B,wBAAwB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wBAAwB,yBAAyB,yBAAyB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,2BAA2B,4BAA4B,4BAA4B;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B,+BAA+B,+BAA+B;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sBAAsB,uBAAuB,uBAAuB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,uBAAuB,wBAAwB,wBAAwB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,yCAAyC,0CAA0C,0CAA0C;AAC9H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kBAAkB,mBAAmB,mBAAmB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B,+BAA+B,+BAA+B;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,yBAAyB,0BAA0B,0BAA0B;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,6BAA6B,8BAA8B,8BAA8B;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,iCAAiC,kCAAkC,kCAAkC;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,2BAA2B,4BAA4B,4BAA4B;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC,uCAAuC,uCAAuC;AACrH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,qCAAqC,sCAAsC,sCAAsC;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC,yCAAyC,yCAAyC;AAC3H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,uCAAuC,wCAAwC,wCAAwC;AACxH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC,uCAAuC,uCAAuC;AACrH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,6BAA6B,8BAA8B,8BAA8B;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,uCAAuC,wCAAwC,wCAAwC;AACxH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,2CAA2C,4CAA4C,4CAA4C;AACpI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC,yCAAyC,yCAAyC;AAC3H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,qBAAqB,sBAAsB,sBAAsB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sBAAsB,uBAAuB,uBAAuB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gBAAgB,iBAAiB,iBAAiB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,qCAAqC,sCAAsC,sCAAsC;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B,6BAA6B,6BAA6B;AACvF;AACA;AACA,yBAAyB,4BAA4B;AACrD,eAAe,uCAAuC,IAAI;AAC1D;AACA;AACA,iDAAiD;AACjD,QAAQ,oDAAoD;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wBAAwB,yBAAyB,yBAAyB;AAC3E;AACA;AACA,yBAAyB,sBAAsB;AAC/C,eAAe,sBAAsB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,+BAA+B,gCAAgC,gCAAgC;AAChG;AACA;AACA,yBAAyB,4BAA4B;AACrD,SAAS,aAAa;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,mBAAmB,oBAAoB,oBAAoB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,+BAA+B,gCAAgC,gCAAgC;AAChG;AACA;AACA;AACA;AACA;AACA,CAAC,2BAA2B,4BAA4B,4BAA4B;AACpF;AACA;AACA,0DAA0D;AAC1D,mCAAmC,kBAAkB;AACrD,IAAI,sBAAsB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wBAAwB,yBAAyB,yBAAyB;AAC3E;AACA;AACA;AACA,SAAS,uBAAuB;AAChC,IAAI,2BAA2B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wBAAwB,yBAAyB,yBAAyB;AAC3E;AACA,yBAAyB,yBAAyB;AAClD,+DAA+D;AAC/D,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,+BAA+B,gCAAgC,gCAAgC;AAChG;AACA;AACA,yBAAyB,8BAA8B;AACvD,wBAAwB,6CAA6C;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B,6BAA6B,6BAA6B;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wBAAwB,yBAAyB,yBAAyB;AAC3E;AACA;AACA,yBAAyB,kBAAkB;AAC3C,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,+BAA+B,gCAAgC,gCAAgC;AAChG;AACA;AACA,WAAW,4BAA4B;AACvC,YAAY,6CAA6C;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,6BAA6B,8BAA8B,8BAA8B;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC,qCAAqC,qCAAqC;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sBAAsB,uBAAuB,uBAAuB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,6BAA6B,8BAA8B,8BAA8B;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,6BAA6B,8BAA8B,8BAA8B;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B,2BAA2B,2BAA2B;AACjF;AACA;AACA,yBAAyB,oBAAoB;AAC7C,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,iCAAiC,kCAAkC,kCAAkC;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC,iCAAiC,iCAAiC;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,qCAAqC,sCAAsC,sCAAsC;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC,uCAAuC,uCAAuC;AACrH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC,uCAAuC,uCAAuC;AACrH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC,qCAAqC,qCAAqC;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oBAAoB,qBAAqB,qBAAqB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,2BAA2B,4BAA4B,4BAA4B;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B,6BAA6B,6BAA6B;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC,iCAAiC,iCAAiC;;;;;;;;AC96BnG;AACA;AACA;AACA;AACa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB,GAAG,kBAAkB,GAAG,mBAAmB,GAAG,aAAa,GAAG,YAAY,GAAG,aAAa,GAAG,cAAc,GAAG,cAAc,GAAG,eAAe;AACnK;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;;;;;;;;AC7CR;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,6BAA6B;AAC7B,mBAAmB,mBAAO,CAAC,EAAY;AACvC;AACA;AACA;AACA;AACA,0DAA0D;AAC1D,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B,6BAA6B,6BAA6B;;;;;;;;ACpB1E;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,6BAA6B;AAC7B,mBAAmB,mBAAO,CAAC,EAAY;AACvC;AACA;AACA;AACA;AACA,0DAA0D;AAC1D,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B,6BAA6B,6BAA6B;;;;;;;;ACpB1E;AACb;AACA;AACA;AACA;AAC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AAG,6BAA6B,GAAG,sCAAsC,GAAG,mBAAmB;AAC7M,mBAAmB,mBAAO,CAAC,EAAY;AACvC;AACA;AACA;AACA;AACA,CAAC,kBAAkB,mBAAmB,mBAAmB;AACzD;AACA;AACA;AACA;AACA,CAAC,qCAAqC,sCAAsC,sCAAsC;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B,6BAA6B,6BAA6B;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,iCAAiC,kCAAkC,kCAAkC;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,iCAAiC,kCAAkC,kCAAkC;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,mCAAmC,oCAAoC,oCAAoC;;;;;;;;ACxD/F;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,2BAA2B;AAC3B,mBAAmB,mBAAO,CAAC,EAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B,2BAA2B,2BAA2B;;;;;;;;ACrBpE;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iCAAiC;AACjC,mBAAmB,mBAAO,CAAC,EAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC,iCAAiC,iCAAiC;;;;;;;;AClBtF;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,8BAA8B,GAAG,kCAAkC,GAAG,kCAAkC,GAAG,8BAA8B,GAAG,kCAAkC,GAAG,8BAA8B,GAAG,gCAAgC;AAClP,mBAAmB,mBAAO,CAAC,EAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,+BAA+B,gCAAgC,gCAAgC;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,6BAA6B,8BAA8B,8BAA8B;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,iCAAiC,kCAAkC,kCAAkC;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,6BAA6B,8BAA8B,8BAA8B;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,iCAAiC,kCAAkC,kCAAkC;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,iCAAiC,kCAAkC,kCAAkC;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,6BAA6B,8BAA8B,8BAA8B;;;;;;;;ACpG7E;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sBAAsB,GAAG,mBAAmB,GAAG,uBAAuB;AACtE,mBAAmB,mBAAO,CAAC,EAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sBAAsB,uBAAuB,uBAAuB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kBAAkB,mBAAmB,mBAAmB;AACzD;AACA;AACA,qCAAqC,iCAAiC;AACtE,4BAA4B,yBAAyB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,qBAAqB,sBAAsB,sBAAsB;;;;;;;;ACnErD;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oCAAoC,GAAG,sCAAsC,GAAG,mCAAmC;AACnH,mBAAmB,mBAAO,CAAC,EAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kCAAkC,mCAAmC,mCAAmC;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,qCAAqC,sCAAsC,sCAAsC;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,mCAAmC,oCAAoC,oCAAoC;;;;;;;;ACzC/F;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iCAAiC,GAAG,0BAA0B;AAC9D,mBAAmB,mBAAO,CAAC,EAAY;AACvC;AACA;AACA,SAAS,wBAAwB;AACjC,IAAI,iCAAiC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,yBAAyB,0BAA0B,0BAA0B;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC,iCAAiC,iCAAiC;;;;;;;;AC7BtF;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,+BAA+B,GAAG,+BAA+B,GAAG,wBAAwB;AAC5F,mBAAmB,mBAAO,CAAC,EAAY;AACvC;AACA;AACA,SAAS,uBAAuB;AAChC,IAAI,6BAA6B;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,uBAAuB,wBAAwB,wBAAwB;AACxE;AACA;AACA,uCAAuC,gBAAgB;AACvD,YAAY,iBAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B,+BAA+B,+BAA+B;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B,+BAA+B,+BAA+B;;;;;;;;AC1ChF;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gCAAgC,GAAG,kCAAkC,GAAG,iCAAiC,GAAG,oCAAoC,GAAG,wCAAwC;AAC3L,yBAAyB,mBAAO,CAAC,CAAgB;AACjD,WAAW,mBAAO,CAAC,EAAY;AAC/B,mBAAmB,mBAAO,CAAC,EAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,uCAAuC,wCAAwC,wCAAwC;AACxH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,mCAAmC,oCAAoC,oCAAoC;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC,iCAAiC,iCAAiC;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,iCAAiC,kCAAkC,kCAAkC;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,+BAA+B,gCAAgC,gCAAgC;;;;;;;;ACzEnF;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,4CAA4C,GAAG,2CAA2C,GAAG,6CAA6C,GAAG,+BAA+B,GAAG,2CAA2C,GAAG,4CAA4C,GAAG,wBAAwB,GAAG,oBAAoB,GAAG,wBAAwB,GAAG,wBAAwB;AACjX,sCAAsC,mBAAO,CAAC,EAA6B;AAC3E,WAAW,mBAAO,CAAC,EAAY;AAC/B,mBAAmB,mBAAO,CAAC,EAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,uBAAuB,wBAAwB,wBAAwB;AACxE;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,uBAAuB,wBAAwB,wBAAwB;AACxE;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oBAAoB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,mBAAmB,oBAAoB,oBAAoB;AAC5D;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,uBAAuB,wBAAwB,wBAAwB;AACxE;AACA;AACA;AACA;AACA;AACA,CAAC,2CAA2C,4CAA4C,4CAA4C;AACpI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0CAA0C,2CAA2C,2CAA2C;AACjI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B,+BAA+B,+BAA+B;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C,6CAA6C,6CAA6C;AACvI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0CAA0C,2CAA2C,2CAA2C;AACjI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,2CAA2C,4CAA4C,4CAA4C;;;;;;;;ACrNvH;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,+BAA+B;AAC/B,mBAAmB,mBAAO,CAAC,EAAY;AACvC;AACA;AACA,SAAS,6BAA6B;AACtC,IAAI,2CAA2C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B,+BAA+B,+BAA+B;;;;;;;;ACrBhF;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gCAAgC;AAChC,yBAAyB,mBAAO,CAAC,CAAgB;AACjD;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,gCAAgC;;;;;;;;ACdnB;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB,GAAG,aAAa,GAAG,cAAc,GAAG,UAAU,GAAG,aAAa;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,UAAU;AACV,gCAAgC,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,GAAG;AACnF;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,oBAAoB;;;;;;;;AChGP;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,2BAA2B,GAAG,uBAAuB,GAAG,sBAAsB;AAC9E,yCAAyC,mBAAO,CAAC,CAAgC;AACjF,eAAe,mBAAO,CAAC,EAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6GAA6G,aAAa;AAC1H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0HAA0H,OAAO;AACjI;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,CAAC,wCAAwC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;;;;;;;;AC9Jd;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,4BAA4B;AAC5B,yCAAyC,mBAAO,CAAC,CAAgC;AACjF,WAAW,mBAAO,CAAC,CAAY;AAC/B;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA,gDAAgD,cAAc;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,4BAA4B;;;;;;;;ACrC5B;AACA;AACA;AACA;AACa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,+BAA+B;AAC/B,yCAAyC,mBAAO,CAAC,CAAgC;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;;;;;;;;AC3C/B;AACA;AACA;AACA;AACa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,4BAA4B;AAC5B,yCAAyC,mBAAO,CAAC,CAAgC;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,4BAA4B;;;;;;;;ACjCf;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,6BAA6B,GAAG,0BAA0B,GAAG,6BAA6B;AAC1F,yCAAyC,mBAAO,CAAC,CAAgC;AACjF;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;;;;;;;;ACzJhB;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,2BAA2B;AAC3B,yCAAyC,mBAAO,CAAC,CAAgC;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;;;;;;;;ACfd;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,6BAA6B;AAC7B,yCAAyC,mBAAO,CAAC,CAAgC;AACjF;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,6BAA6B;;;;;;;;AC1ChB;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iCAAiC;AACjC,yCAAyC,mBAAO,CAAC,CAAgC;AACjF;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iCAAiC;;;;;;;;ACjBjC;AACA;AACA;AACA;AACa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,4BAA4B;AAC5B,yCAAyC,mBAAO,CAAC,CAAgC;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,4BAA4B;;;;;;;;ACjC5B;AACA;AACA;AACA;AACa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,0BAA0B;AAC1B,yCAAyC,mBAAO,CAAC,CAAgC;AACjF;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,0BAA0B;;;;;;;;ACxB1B;AACA;AACA;AACA;AACa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,2BAA2B;AAC3B,yCAAyC,mBAAO,CAAC,CAAgC;AACjF;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,2BAA2B;;;;;;;;ACzB3B;AACA;AACA;AACA;AACa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB;AACxB,yCAAyC,mBAAO,CAAC,CAAgC;AACjF;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,wBAAwB;;;;;;;;AC7BX;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,yBAAyB;AACzB,yCAAyC,mBAAO,CAAC,CAAgC;AACjF;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,yBAAyB;;;;;;;;AC7BzB;AACA;AACA;AACA;AACa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,yBAAyB,GAAG,2BAA2B;AACvD,yCAAyC,mBAAO,CAAC,CAAgC;AACjF,wBAAwB,mBAAO,CAAC,EAAiB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,0EAA0E,+BAA+B;AACzG;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,+BAA+B;AACzG;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,gCAAgC;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,oBAAoB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,gCAAgC;AAC9F;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,oBAAoB;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,qBAAqB;AAChG;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,oCAAoC;AACxE;AACA;AACA;AACA,wCAAwC,0BAA0B;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,mFAAmF;AAC3J;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,2BAA2B;AACjE;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,gCAAgC;AAC/F;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,0EAA0E,0DAA0D;AACpI;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;;;;;;;;AC3PZ;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB;AACrB,yCAAyC,mBAAO,CAAC,CAAgC;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,UAAU;AACrD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,UAAU;AAC9B;AACA,sEAAsE,QAAQ;AAC9E;AACA;AACA;AACA;AACA;AACA,8DAA8D,0BAA0B;AACxF;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,sDAAsD,0BAA0B;AAChF;AACA,SAAS;AACT;AACA;AACA;AACA,sDAAsD,gDAAgD;AACtG;AACA,SAAS;AACT;AACA;AACA;AACA,+DAA+D,gDAAgD;AAC/G;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,qDAAqD,0BAA0B;AAC/E;AACA,SAAS;AACT,0EAA0E,0DAA0D;AACpI;AACA;AACA,qBAAqB;;;;;;;;AC3KrB;AACA;AACA;AACA;AACa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sBAAsB;AACtB,yCAAyC,mBAAO,CAAC,CAAgC;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,sBAAsB;;;;;;;;ACtBT;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,yBAAyB,GAAG,kBAAkB,GAAG,6BAA6B,GAAG,6BAA6B,GAAG,eAAe,GAAG,qBAAqB;AACxJ,YAAY,mBAAO,CAAC,EAAK;AACzB,aAAa,mBAAO,CAAC,EAAM;AAC3B,WAAW,mBAAO,CAAC,EAAI;AACvB,wBAAwB,mBAAO,CAAC,EAAe;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,sCAAsC;AACtC,yBAAyB;AACzB,mBAAmB;AACnB,UAAU;AACV,+BAA+B;AAC/B,aAAa;AACb,oCAAoC;AACpC,iBAAiB,mBAAmB,EAAE;AACtC,UAAU;AACV,oBAAoB;AACpB,iBAAiB,gBAAgB,EAAE;AACnC,UAAU;AACV,UAAU;AACV,UAAU,EAAE;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,oBAAoB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,6EAA6E,YAAY;AACzF;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,8BAA8B,QAAQ;AACtC;AACA;AACA;AACA;AACA,sEAAsE,WAAW;AACjF;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,OAAO;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,iBAAiB,kBAAkB,kBAAkB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,YAAY;AAC9E;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,yBAAyB;;;;;;;;ACrQzB,gC;;;;;;;ACAA,+B;;;;;;;ACAA,0C;;;;;;;ACAA;AACA;AACA;AACA;AACa;;AAEb,uCAA2C,C;;;;;;;ACN9B;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB,GAAG,yBAAyB,GAAG,qBAAqB,GAAG,6BAA6B;AAC5G,yBAAyB,mBAAO,CAAC,EAAkB;AACnD,yDAAwD,EAAE,qCAAqC,kDAAkD,EAAC;AAClJ,WAAW,mBAAO,CAAC,EAA6B;AAChD,aAAa,mBAAO,CAAC,CAAiC;AACtD,wBAAwB,mBAAO,CAAC,EAAiB;AACjD,iDAAgD,EAAE,qCAAqC,yCAAyC,EAAC;AACjI,mBAAmB,mBAAO,CAAC,EAAY;AACvC,qDAAoD,EAAE,qCAAqC,wCAAwC,EAAC;AACpI,aAAa,mBAAO,CAAC,CAAU;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,uBAAuB,wBAAwB,wBAAwB;;;;;;;;ACpCxE;AACA;AACA;AACA;AACa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,+BAA+B;AAC/B,yCAAyC,mBAAO,CAAC,CAAgC;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,+BAA+B;;;;;;;;;;;;ACrB/B;AACA;AACA;AACA;AACa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,SAAS;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,oGAAoG,SAAS;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA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CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA;AACA,aAAa,UAAU;AACvB;AACA,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,GAAG;AAChB,aAAa,SAAS;AACtB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,GAAG;AAChB,aAAa,SAAS;AACtB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,GAAG;AAChB,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA,aAAa,SAAS;AACtB;AACA,aAAa,SAAS;AACtB;AACA,aAAa,SAAS;AACtB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,kBAAkB;AAC3E,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,kDAAkD,OAAO;AACzD;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH,CAAC;;AAED;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB;AACA;AACA,WAAW,SAAS;AACpB;AACA,WAAW,UAAU;AACrB;AACA,WAAW,SAAS;AACpB;AACA,WAAW,UAAU;AACrB;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,kBAAkB;AAC7B;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,uCAAuC,sBAAsB;AAC7D,gCAAgC,4BAA4B;AAC5D;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA,MAAM;AACN,4CAA4C,QAAQ;AACpD;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,mBAAmB,mBAAmB,GAAG,mBAAmB;AAC5D;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;;AAElB;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,QAAQ;AACR,oDAAoD,SAAS;AAC7D;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA,uCAAuC,eAAe;AACtD;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,eAAe;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,4CAA4C;AACvD;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,GAAG;AACd,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2CAA2C,sBAAsB;AACjE,YAAY,kCAAkC;AAC9C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,8BAA8B;AACzC,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,WAAW;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;AC32CA,mC;;;;;;;ACAA,kC;;;;;;;ACAA,iC;;;;;;;ACAA,gC;;;;;;;ACAA,mC;;;;;;;ACAa;;AAEb,aAAa,mBAAO,CAAC,EAAM;;AAE3B,mBAAmB,mBAAO,CAAC,EAAe;AAC1C,gBAAgB,mBAAO,CAAC,GAAW;AACnC,QAAQ,cAAc,EAAE,mBAAO,CAAC,EAAa;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,kBAAkB;AAC/B;AACA,aAAa,SAAS;AACtB;AACA,aAAa,QAAQ;AACrB;AACA,aAAa,kBAAkB;AAC/B;AACA,aAAa,SAAS;AACtB;AACA,aAAa,QAAQ;AACrB;AACA,aAAa,QAAQ;AACrB;AACA,aAAa,QAAQ;AACrB;AACA,aAAa,SAAS;AACtB;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wCAAwC,IAAI;AAC5C;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,gDAAgD,IAAI,KAAK,MAAM;AAC/D;AACA;AACA;AACA,YAAY;AACZ;AACA,8CAA8C,IAAI,KAAK,MAAM;AAC7D;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,8CAA8C,IAAI,KAAK,MAAM;AAC7D;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,8CAA8C,IAAI,KAAK,MAAM;AAC7D;AACA;AACA,UAAU;AACV,gDAAgD,IAAI;AACpD;;AAEA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA,aAAa,iBAAiB;AAC9B,aAAa,SAAS;AACtB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB,aAAa,UAAU;AACvB;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA,kCAAkC,SAAS;AAC3C;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,aAAa,iBAAiB;AAC9B,aAAa,SAAS;AACtB,aAAa,UAAU;AACvB;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,gCAAgC,SAAS;AACzC;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;AC/gBA,iC;;;;;;;ACAa;;AAEb,QAAQ,eAAe,EAAE,mBAAO,CAAC,EAAa;;AAE9C;;AAEA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA,kBAAkB,YAAY;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,GAAG;AACd,YAAY,QAAQ;AACpB,YAAY;AACZ;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,mBAAO,CAAC,EAAY;;AAE3C,IAAI,mBAAmB;AACvB;AACA;AACA;;AAEA,IAAI,qBAAqB;AACzB;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;;;;;;;AClIa;;AAEb;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjBA,uC;;;;;;;ACAa;;AAEb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACtDa;;AAEb,QAAQ,WAAW,EAAE,mBAAO,CAAC,EAAQ;;AAErC,0BAA0B,mBAAO,CAAC,EAAsB;AACxD;AACA;AACA;AACA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,EAAa;AACzB,QAAQ,gCAAgC,EAAE,mBAAO,CAAC,EAAe;AACjE,QAAQ,iCAAiC,EAAE,mBAAO,CAAC,GAAc;;AAEjE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA,aAAa,SAAS;AACtB;AACA,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA;AACA,0BAA0B;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,UAAU;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA,4BAA4B,aAAa;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,oBAAoB;AACxD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,0BAA0B,aAAa;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,UAAU;AACvB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,cAAc,8BAA8B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;;AAEA;AACA;AACA;AACA,mCAAmC,KAAK;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,aAAa,gCAAgC;AAC7C,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,cAAc,oBAAoB;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA,2CAA2C,QAAQ;AACnD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACjsBa;;AAEb,QAAQ,SAAS,EAAE,mBAAO,CAAC,GAAQ;;AAEnC,QAAQ,UAAU,EAAE,mBAAO,CAAC,EAAa;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,GAAG;AACd,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE,0BAA0B;AAC5B;AACA;AACA,EAAE;AACF;AACA,wBAAwB,mBAAO,CAAC,GAAgB;;AAEhD,IAAI,0BAA0B;AAC9B;AACA;AACA,IAAI;AACJ;AACA;AACA;;;;;;;;ACvJA,mC;;;;;;;ACAA,2C;;;;;;;ACAA,sCAAsC,gCAAgC;;AAEzD;;AAEb,QAAQ,SAAS,EAAE,mBAAO,CAAC,EAAQ;AACnC,QAAQ,iBAAiB,EAAE,mBAAO,CAAC,EAAQ;;AAE3C,0BAA0B,mBAAO,CAAC,EAAsB;AACxD,QAAQ,iCAAiC,EAAE,mBAAO,CAAC,EAAa;AAChE,QAAQ,4BAA4B,EAAE,mBAAO,CAAC,GAAc;AAC5D,QAAQ,4BAA4B,EAAE,mBAAO,CAAC,EAAe;;AAE7D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,UAAU;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,iBAAiB;AAC9B,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA,aAAa,UAAU;AACvB;AACA,aAAa,SAAS;AACtB;AACA,aAAa,QAAQ;AACrB;AACA,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA,aAAa,SAAS;AACtB;AACA,cAAc,mBAAmB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,iBAAiB;AAC9B,aAAa,SAAS;AACtB,aAAa,UAAU;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,GAAG;AAChB,aAAa,SAAS;AACtB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,GAAG;AAChB,aAAa,SAAS;AACtB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,GAAG;AAChB,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA,aAAa,SAAS;AACtB;AACA,aAAa,SAAS;AACtB;AACA,aAAa,SAAS;AACtB;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,SAAS;AACtB;AACA,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA,aAAa,UAAU;AACvB;AACA,aAAa,SAAS;AACtB;AACA,aAAa,QAAQ;AACrB;AACA,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA,aAAa,SAAS;AACtB;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA,aAAa,iBAAiB;AAC9B,aAAa,SAAS;AACtB;AACA,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA,aAAa,UAAU;AACvB;AACA,aAAa,SAAS;AACtB;AACA,aAAa,QAAQ;AACrB;AACA,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA,aAAa,SAAS;AACtB;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,qBAAqB;AAClC,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB;AACA;AACA;AACA;;AAEA,kBAAkB,0BAA0B;AAC5C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzlBa;;AAEb,QAAQ,kCAAkC,EAAE,mBAAO,CAAC,EAAa;;AAEjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA,mDAAmD,kBAAkB;AACrE,iDAAiD,kBAAkB;;AAEnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA,aAAa,QAAQ;AACrB;AACA,aAAa,QAAQ;AACrB;AACA,aAAa,SAAS;AACtB;AACA;AACA,gCAAgC;AAChC;;AAEA;AACA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA,sDAAsD,kBAAkB;AACxE,wDAAwD,kBAAkB;AAC1E,0DAA0D,kBAAkB;;AAE5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA,aAAa,GAAG;AAChB,aAAa,QAAQ;AACrB;AACA,gCAAgC;AAChC;;AAEA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA,uDAAuD,kBAAkB;AACzE,yDAAyD,kBAAkB;;AAE3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA,aAAa,GAAG;AAChB;AACA,gCAAgC;AAChC;;AAEA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA,wDAAwD,kBAAkB;;AAE1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,mBAAmB;AAChC,aAAa,QAAQ;AACrB;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,mBAAmB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B,WAAW,GAAG;AACd,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;;;;;;;ACnSa;;AAEb,QAAQ,aAAa,EAAE,mBAAO,CAAC,GAAc;;AAE7C;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,yBAAyB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAS,mBAAmB;AAC5B;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,QAAQ,4BAA4B;AACpC;AACA,iEAAiE,EAAE;AACnE;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA,QAAQ;AACR,+DAA+D,EAAE;AACjE;AACA,MAAM;AACN;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,iEAAiE,EAAE;AACnE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR,+DAA+D,EAAE;AACjE;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,EAAE;AACnE;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV,iEAAiE,EAAE;AACnE;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,iEAAiE,EAAE;AACnE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR,+DAA+D,EAAE;AACjE;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,EAAE,GAAG,EAAE;AAC1D,2BAA2B;AAC3B,eAAe;AACf;AACA,qBAAqB;AACrB,SAAS;AACT;AACA,KAAK;AACL;AACA;;AAEA,mBAAmB;;;;;;;;AC1MnB,sCAAsC,oCAAoC;AAC7D;;AAEb,kBAAkB,mBAAO,CAAC,EAAa;AACvC,QAAQ,SAAS,EAAE,mBAAO,CAAC,EAAQ;;AAEnC;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;AChKA,sCAAsC,yDAAyD;;AAElF;;AAEb,qBAAqB,mBAAO,CAAC,EAAQ;AACrC,aAAa,mBAAO,CAAC,EAAM;AAC3B,QAAQ,SAAS,EAAE,mBAAO,CAAC,EAAQ;AACnC,QAAQ,aAAa,EAAE,mBAAO,CAAC,EAAQ;;AAEvC,kBAAkB,mBAAO,CAAC,GAAa;AACvC,0BAA0B,mBAAO,CAAC,EAAsB;AACxD,oBAAoB,mBAAO,CAAC,GAAe;AAC3C,kBAAkB,mBAAO,CAAC,EAAa;AACvC,QAAQ,mBAAmB,EAAE,mBAAO,CAAC,EAAa;;AAElD,iCAAiC,GAAG;;AAEpC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA;AACA,aAAa,SAAS;AACtB;AACA,aAAa,QAAQ;AACrB;AACA,aAAa,SAAS;AACtB;AACA,aAAa,UAAU;AACvB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA,aAAa,SAAS;AACtB,aAAa,QAAQ;AACrB,aAAa,kBAAkB;AAC/B;AACA,aAAa,QAAQ;AACrB,aAAa,4BAA4B;AACzC;AACA,aAAa,SAAS;AACtB;AACA,aAAa,UAAU;AACvB,aAAa,UAAU;AACvB;AACA,aAAa,UAAU;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,aAAa,sBAAsB;AACnC,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,sBAAsB;AACnC,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,UAAU;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,kDAAkD;AAC3E;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,KAAK;AAClB,aAAa,sBAAsB;AACnC,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,UAAU;AACvB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,+BAA+B,OAAO;AACtC;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gDAAgD,SAAS;AACzD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,gDAAgD,MAAM;AACtD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,2BAA2B;AACtC,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,gBAAgB,MAAM,EAAE,wBAAwB;AAChD;AACA,uBAAuB,EAAE,IAAI,WAAW;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B,WAAW,sBAAsB;AACjC,WAAW,QAAQ;AACnB,WA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;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,YAAY,mBAAmB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,mCAAmC;AACzF;AACA;AACA;AACA,gBAAgB,0BAA0B;AAC1C,wBAAwB,mCAAmC;AAC3D;AACA;AACA;AACA,+CAA+C,YAAY,IAAI,QAAQ;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,QAAQ,IAAI,GAAG;AAC1D;AACA;AACA;AACA,2CAA2C,QAAQ,IAAI,GAAG;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,aAAa;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,cAAc,IAAI,6BAA6B;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,GAAG,IAAI,YAAY;AAClE;AACA;AACA;AACA;AACA;AACA,wHAAwH,WAAW;AACnI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,8BAA8B;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB;;;;;;;;AC7NH;;AAEb,eAAe,mBAAO,CAAC,GAAsB;AAC7C,YAAY,mBAAO,CAAC,GAAa;;AAEjC;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,MAAM;AACN;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,QAAQ;AACnE;AACA;AACA;AACA;AACA,gDAAgD,KAAK;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA;AACA;AACA,6DAA6D,QAAQ;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,0CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,IAAI;AAC/C;AACA;AACA;AACA,wBAAwB,2BAA2B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,QAAQ,EAAE,OAAO;AACpD;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,2BAA2B;;AAE3B,kBAAkB;;;;;;;;ACjLL;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa;AACb,WAAW;AACX,WAAW;AACX,iBAAiB;AACjB,YAAY;AACZ,cAAc;AACd,WAAW;AACX,iBAAiB;AACjB,eAAe;AACf,oBAAoB;AACpB,kBAAkB;AAClB,aAAa;AACb,cAAc;AACd,cAAc;AACd,gBAAgB;AAChB,aAAa;;;;;;;;ACpDA;;AAEb,eAAe,mBAAO,CAAC,GAAqB;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,IAAI;AACxD;AACA;;AAEA,aAAa;AACb,kBAAkB;;;;;;;;AC3OL;;AAEb,YAAY,mBAAO,CAAC,GAAmB;AACvC,iBAAiB,mBAAO,CAAC,GAAwB;AACjD,eAAe,mBAAO,CAAC,GAAsB;AAC7C,WAAW,mBAAO,CAAC,GAAkB;AACrC,WAAW,mBAAO,CAAC,GAAkB;AACrC,aAAa,mBAAO,CAAC,GAAqB;AAC1C,wBAAwB,mBAAO,CAAC,GAAmC;AACnE,cAAc,mBAAO,CAAC,GAAc;AACpC,mBAAmB,mBAAO,CAAC,GAAmB;AAC9C,iBAAiB,mBAAO,CAAC,GAAiB;AAC1C,iBAAiB,mBAAO,CAAC,GAAiB;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,qBAAqB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,cAAc,UAAU;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,SAAS;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC,SAAS;AACT;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,WAAW;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0EAA0E;AAC1F,gBAAgB,sCAAsC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,gBAAgB;AAClF,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,SAAS;AAC3E,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,GAAG;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,iBAAiB;AAC9E;AACA;AACA,WAAW,4DAA4D,IAAI;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,aAAa;AACtC;AACA;AACA,mDAAmD,SAAS;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gDAAgD;AAC3E;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,+EAA+E,EAAE;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB;;;;;;;;AChVH;;AAEb,cAAc,mBAAO,CAAC,GAAmB;AACzC,YAAY,mBAAO,CAAC,GAAa;AACjC,eAAe,mBAAO,CAAC,GAAe;AACtC,WAAW,mBAAO,CAAC,GAAW;AAC9B,WAAW,mBAAO,CAAC,GAAW;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,gBAAgB,8BAA8B;AAC9C;AACA;AACA,uFAAuF,YAAY;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA,2FAA2F,YAAY;AACvG;AACA;AACA;AACA,0BAA0B,KAAK;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa;;;;;;;;ACnHA;;AAEb,eAAe,mBAAO,CAAC,GAAsB;AAC7C,YAAY,mBAAO,CAAC,GAAa;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA,iFAAiF,GAAG;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B,wBAAwB,OAAO,EAAE,EAAE;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA,qBAAqB;AACrB,mBAAmB;AACnB,yBAAyB;AACzB,qBAAqB;;;;;;;;AC3ER;;AAEb,mBAAmB,mBAAO,CAAC,GAAwB;AACnD,eAAe,mBAAO,CAAC,GAAe;AACtC,WAAW,mBAAO,CAAC,GAAW;;AAE9B;AACA;AACA,0DAA0D,aAAa;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,6CAA6C,IAAI;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,aAAa;AACtC;AACA;AACA,mDAAmD,SAAS;AAC5D;AACA;AACA;;AAEA,gBAAgB;;;;;;;;ACvCH;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,SAAS;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB;;;;;;;;ACxDP;;AAEb,eAAe,mBAAO,CAAC,GAAe;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,YAAY;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY;;;;;;;;ACtCC;;AAEb,iBAAiB,mBAAO,CAAC,GAAsB;AAC/C,eAAe,mBAAO,CAAC,GAAe;AACtC,WAAW,mBAAO,CAAC,GAAW;;AAE9B;AACA;AACA,kCAAkC,QAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,YAAY;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,IAAI,oBAAoB,KAAK;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,IAAI,oBAAoB,KAAK;AACxF;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,IAAI,oBAAoB,KAAK;AAC5F;AACA;AACA;;AAEA,kBAAkB;AAClB,0BAA0B;AAC1B,mBAAmB;;;;;;;;ACtJN;;AAEb,YAAY,mBAAO,CAAC,GAAmB;AACvC,eAAe,mBAAO,CAAC,GAAsB;AAC7C,aAAa,mBAAO,CAAC,GAAoB;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,SAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mEAAmE;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;;;;;;;;ACzFL;;AAEb,eAAe,mBAAO,CAAC,GAAe;AACtC,WAAW,mBAAO,CAAC,GAAW;AAC9B,WAAW,mBAAO,CAAC,GAAW;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc;AACd,qBAAqB;;;;;;;;AC1BR;;AAEb,iBAAiB,mBAAO,CAAC,GAAsB;AAC/C,oBAAoB,mBAAO,CAAC,GAA+B;AAC3D,qBAAqB,mBAAO,CAAC,GAAqB;AAClD,eAAe,mBAAO,CAAC,GAAe;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,sBAAsB;AAChF;AACA;AACA;AACA;AACA,cAAc,aAAa;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY;AACZ,kBAAkB;;;;;;;;ACtCL;;AAEb,eAAe,mBAAO,CAAC,GAAsB;AAC7C,aAAa,mBAAO,CAAC,GAAoB;AACzC,gBAAgB,mBAAO,CAAC,GAAgB;AACxC,uBAAuB,mBAAO,CAAC,GAAuB;;AAEtD,yBAAyB,YAAY;AACrC,YAAY,mDAAmD,yCAAyC;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,IAAI;AAC7D;AACA;AACA;AACA,mBAAmB,IAAI;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,IAAI,IAAI,OAAO;AAClC;AACA;AACA,iBAAiB,IAAI;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+CAA+C;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,WAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,WAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB;;;;;;;;ACvJR;;AAEb,cAAc,mBAAO,CAAC,GAAmB;AACzC,eAAe,mBAAO,CAAC,GAAsB;AAC7C,uBAAuB,mBAAO,CAAC,GAAuB;AACtD,sBAAsB,mBAAO,CAAC,GAAsB;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,MAAM;AACtD;AACA;AACA;AACA;AACA,wCAAwC,yBAAyB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,6BAA6B;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD,aAAa,OAAO,EAAE,IAAI;AAC1B,aAAa,MAAM,IAAI,WAAW,EAAE,IAAI;AACxC;;AAEA,8BAA8B;AAC9B,iBAAiB;;;;;;;;AClIJ;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB;AACrB,mBAAmB;AACnB,wBAAwB;;;;;;;;ACvBX;;AAEb,aAAa,mBAAO,CAAC,GAAoB;AACzC,oBAAoB,mBAAO,CAAC,GAAoB;;AAEhD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,YAAY;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA,kCAAkC,IAAI;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,OAAO;AAC9E;AACA;AACA;AACA;AACA;AACA,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C,YAAY,uCAAuC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,cAAc;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,iDAAiD,OAAO;AACxD;AACA;AACA;AACA;AACA;AACA,uBAAuB,yBAAyB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,OAAO;AAClD;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,OAAO;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,MAAM,EAAE,YAAY,EAAE,IAAI;AAC9E;AACA,uBAAuB,OAAO,IAAI,OAAO,EAAE,KAAK;AAChD;AACA,uCAAuC,OAAO;AAC9C,eAAe,OAAO,IAAI,OAAO,EAAE,MAAM,EAAE,MAAM,EAAE,IAAI;AACvD;AACA;AACA,YAAY,cAAc;AAC1B,YAAY,wDAAwD;AACpE;AACA,0BAA0B;AAC1B;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA,gBAAgB,eAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,sBAAsB;AAClC;AACA;AACA,0BAA0B,UAAU,2BAA2B;AAC/D,UAAU,OAAO;AACjB;AACA;AACA,4CAA4C,KAAK,IAAI,KAAK;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oCAAoC;AACpD;AACA;AACA;AACA,+DAA+D,EAAE;AACjE;AACA;AACA;;AAEA,uBAAuB;;;;;;;;ACjVV;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,0EAA0E,IAAI;AACpI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA,uBAAuB,OAAO,EAAE,mBAAmB;AACnD;AACA;AACA,0BAA0B,WAAW;AACrC,wBAAwB,OAAO,EAAE,0BAA0B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;AAClB,iBAAiB;AACjB,mBAAmB;AACnB,qBAAqB;;;;;;;;ACtJR;;AAEb,UAAU,mBAAO,CAAC,GAAW;AAC7B,YAAY,mBAAO,CAAC,GAA6B;AACjD,gBAAgB,mBAAO,CAAC,GAA2B;AACnD,eAAe,mBAAO,CAAC,GAAe;AACtC,WAAW,mBAAO,CAAC,GAAW;;AAE9B,oCAAoC,YAAY;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iIAAiI,QAAQ;AACzI;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB;;;;;;;;AChET;;AAEb,mBAAmB,mBAAO,CAAC,GAAS;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa;AACb,YAAY;;;;;;;;AClBC;;AAEb,eAAe,mBAAO,CAAC,GAAyB;AAChD,aAAa,mBAAO,CAAC,GAAuB;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA,uBAAuB;AACvB,kBAAkB;AAClB,aAAa;;;;;;;;ACnEA;;AAEb,eAAe,mBAAO,CAAC,GAAsB;AAC7C,UAAU,mBAAO,CAAC,GAAiB;AACnC,UAAU,mBAAO,CAAC,GAAiB;AACnC,aAAa,mBAAO,CAAC,GAAoB;AACzC,WAAW,mBAAO,CAAC,GAAW;;AAE9B;AACA;AACA,kBAAkB,uFAAuF;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,gBAAgB;AACpE,uDAAuD,sBAAsB;AAC7E,oDAAoD,gBAAgB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc;;;;;;;;ACtCD;;AAEb,eAAe,mBAAO,CAAC,GAAyB;AAChD,cAAc,mBAAO,CAAC,GAAwB;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,WAAW;;;;;;;;AClBE;;AAEb,0BAA0B,mBAAO,CAAC,GAAqC;AACvE,qBAAqB,mBAAO,CAAC,GAAqB;AAClD,iBAAiB,mBAAO,CAAC,GAAiB;AAC1C,eAAe,mBAAO,CAAC,GAAe;AACtC,WAAW,mBAAO,CAAC,GAAW;AAC9B,aAAa,mBAAO,CAAC,GAAa;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0BAA0B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,QAAQ,sBAAsB;AAC5F;AACA;AACA,kCAAkC,SAAS,qBAAqB;AAChE;AACA;AACA,yBAAyB,SAAS,UAAU,GAAG;AAC/C;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA,eAAe;AACf,gBAAgB;;;;;;;;AClJH;;AAEb,eAAe,mBAAO,CAAC,GAAsB;AAC7C,gBAAgB,mBAAO,CAAC,GAAgB;AACxC,uBAAuB,mBAAO,CAAC,GAAuB;;AAEtD;AACA;AACA;AACA;AACA;AACA,oCAAoC,gBAAgB,SAAS,gEAAgE;AAC7H,YAAY,mBAAmB,kBAAkB;AACjD,oCAAoC,SAAS,gCAAgC;AAC7E,2BAA2B;AAC3B;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA,+BAA+B,OAAO,EAAE,KAAK;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,OAAO,SAAS,uBAAuB;AAC1E,YAAY,iEAAiE,kBAAkB;AAC/F;AACA,oCAAoC;AACpC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,WAAW,EAAE,OAAO,EAAE,KAAK;AAC9D,sBAAsB,IAAI,IAAI,OAAO,EAAE,IAAI;AAC3C;AACA;AACA,sBAAsB,MAAM,EAAE,UAAU,EAAE,gBAAgB,EAAE,UAAU,EAAE,IAAI;AAC5E;AACA;AACA;AACA,4BAA4B,mBAAmB,iBAAiB;AAChE;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;;AAEA,2BAA2B;;;;;;;;AChJd;;AAEb,eAAe,mBAAO,CAAC,GAAyB;AAChD,cAAc,mBAAO,CAAC,GAAwB;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,WAAW;;;;;;;;AClBE;;AAEb,iBAAiB,mBAAO,CAAC,GAAsB;AAC/C,0BAA0B,mBAAO,CAAC,GAAqC;AACvE,iBAAiB,mBAAO,CAAC,GAAiB;AAC1C,eAAe,mBAAO,CAAC,GAAe;AACtC,aAAa,mBAAO,CAAC,GAAa;AAClC,WAAW,mBAAO,CAAC,GAAW;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,IAAI;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,sBAAsB;AAC/C;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe;;;;;;;;AClHF;;AAEb,sBAAsB,mBAAO,CAAC,GAAoC;;AAElE;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,oBAAoB;AAClD;AACA;AACA;;AAEA,cAAc;;;;;;;;ACfD;;AAEb,UAAU,mBAAO,CAAC,GAAiB;AACnC,YAAY,mBAAO,CAAC,GAAkB;AACtC,UAAU,mBAAO,CAAC,GAAiB;AACnC,aAAa,mBAAO,CAAC,GAAoB;AACzC,WAAW,mBAAO,CAAC,GAAgB;AACnC,YAAY,mBAAO,CAAC,GAAiB;AACrC,UAAU,mBAAO,CAAC,GAAe;AACjC,aAAa,mBAAO,CAAC,GAAkB;AACvC,eAAe,mBAAO,CAAC,GAAkB;AACzC,aAAa,mBAAO,CAAC,GAAsB;AAC3C,YAAY,mBAAO,CAAC,GAAqB;AACzC,WAAW,mBAAO,CAAC,GAAoB;AACvC,YAAY,mBAAO,CAAC,GAAqB;AACzC,eAAe,mBAAO,CAAC,GAAsB;AAC7C,UAAU,mBAAO,CAAC,GAAmB;AACrC,gBAAgB,mBAAO,CAAC,GAAyB;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,WAAW,GAAG,aAAa,MAAM;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,UAAU,aAAa,KAAK;AAC9E;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA,qBAAqB;AACrB,eAAe;;;;;;;;AClGF;;AAEb,aAAa,mBAAO,CAAC,GAAuB;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA;AACA;;AAEA,eAAe;;;;;;;;AChBF;;AAEb,aAAa,mBAAO,CAAC,GAAuB;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,eAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe;;;;;;;;ACpBF;;AAEb,aAAa,mBAAO,CAAC,GAAuB;AAC5C,sBAAsB,mBAAO,CAAC,GAAoC;;AAElE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,aAAa;AACb,gBAAgB;AAChB,gBAAgB;;;;;;;;AC9CH;;AAEb,2BAA2B,uCAAuC;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB;;;;;;;;ACzBV;;AAEb,sBAAsB,mBAAO,CAAC,GAAoC;;AAElE;AACA,0CAA0C,aAAa;AACvD;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW;AACX,cAAc;AACd,cAAc;;;;;;;;ACzCD;;AAEb,UAAU,mBAAO,CAAC,GAAkB;AACpC,YAAY,mBAAO,CAAC,GAAmB;AACvC,UAAU,mBAAO,CAAC,GAAkB;AACpC,aAAa,mBAAO,CAAC,GAAqB;AAC1C,WAAW,mBAAO,CAAC,GAAW;AAC9B,YAAY,mBAAO,CAAC,GAAY;AAChC,UAAU,mBAAO,CAAC,GAAU;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc;;;;;;;;ACxBD;;AAEb,aAAa,mBAAO,CAAC,GAAuB;AAC5C,UAAU,mBAAO,CAAC,GAAkB;AACpC,UAAU,mBAAO,CAAC,GAAkB;;AAEpC;AACA;AACA;AACA,yBAAyB,OAAO;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,mCAAmC,aAAa;AAChD,sBAAsB,OAAO;AAC7B,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,oBAAoB;AAC/D;AACA;AACA;AACA;;AAEA,cAAc;;;;;;;;AC/DD;;AAEb,kBAAkB,mBAAO,CAAC,GAAQ;AAClC,aAAa,mBAAO,CAAC,GAAuB;AAC5C,sBAAsB,mBAAO,CAAC,GAAoC;;AAElE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,oBAAoB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA;AACA,4EAA4E;AAC5E;AACA;AACA,KAAK;AACL,gBAAgB,sBAAsB;AACtC;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA;AACA,oFAAoF;AACpF;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;AACA,iDAAiD,2BAA2B;AAC5E;AACA;;AAEA,cAAc;;;;;;;;ACrED;;AAEb,eAAe,mBAAO,CAAC,GAAyB;AAChD,WAAW,mBAAO,CAAC,GAAqB;AACxC,cAAc,mBAAO,CAAC,GAAwB;AAC9C,cAAc,mBAAO,CAAC,GAAwB;AAC9C,YAAY,mBAAO,CAAC,GAAY;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,MAAM;AAC3B;AACA;AACA,6EAA6E,UAAU;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,gBAAgB;AAChB,YAAY;;;;;;;;AC5EC;;AAEb,eAAe,mBAAO,CAAC,GAAyB;AAChD,WAAW,mBAAO,CAAC,GAAqB;AACxC,aAAa,mBAAO,CAAC,GAAuB;AAC5C,cAAc,mBAAO,CAAC,GAAwB;;AAE9C;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,mBAAmB,IAAI,uBAAuB;AAC3E;AACA;AACA;AACA;AACA,6BAA6B,aAAa,IAAI,WAAW;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,GAAG;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,aAAa;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB;AACnB,aAAa;AACb,oBAAoB;;;;;;;;ACjFP;;AAEb,UAAU,mBAAO,CAAC,GAAkB;AACpC,YAAY,mBAAO,CAAC,GAAmB;AACvC,UAAU,mBAAO,CAAC,GAAkB;AACpC,aAAa,mBAAO,CAAC,GAAqB;AAC1C,aAAa,mBAAO,CAAC,GAAa;AAClC,WAAW,mBAAO,CAAC,GAAW;AAC9B,YAAY,mBAAO,CAAC,GAAY;AAChC,UAAU,mBAAO,CAAC,GAAU;AAC5B,YAAY,mBAAO,CAAC,GAAY;AAChC,WAAW,mBAAO,CAAC,GAAW;AAC9B,YAAY,mBAAO,CAAC,GAAY;AAChC,UAAU,mBAAO,CAAC,GAAU;AAC5B,gBAAgB,mBAAO,CAAC,GAAgB;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc;;;;;;;;ACxCD;;AAEb,aAAa,mBAAO,CAAC,GAAuB;;AAE5C,yBAAyB,eAAe;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB;AAChB,eAAe;;;;;;;;AC5BF;;AAEb,aAAa,mBAAO,CAAC,GAAuB;AAC5C,sBAAsB,mBAAO,CAAC,GAAoC;;AAElE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,aAAa;AACb,gBAAgB;AAChB,gBAAgB;;;;;;;;ACjDH;;AAEb,sBAAsB,mBAAO,CAAC,GAAoC;;AAElE;AACA,0CAA0C,aAAa;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,IAAI;AAC/B;AACA;AACA,2BAA2B,IAAI;AAC/B;AACA;AACA,2BAA2B,IAAI;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW;AACX,cAAc;AACd,cAAc;AACd,cAAc;;;;;;;;AC3ED;;AAEb,eAAe,mBAAO,CAAC,GAAyB;AAChD,WAAW,mBAAO,CAAC,GAAqB;AACxC,cAAc,mBAAO,CAAC,GAAwB;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6FAA6F,aAAa;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,SAAS,qBAAqB;AAChF;AACA;AACA;AACA;AACA,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe;AACf,WAAW;;;;;;;;AC/FE;;AAEb,sBAAsB,mBAAO,CAAC,GAAoC;;AAElE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,QAAQ;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,aAAa;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,EAAE,SAAS,IAAI,SAAS,IAAI;AACtD;AACA;AACA,gBAAgB,IAAI,SAAS,IAAI,SAAS,IAAI;AAC9C,+CAA+C,EAAE;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,kBAAkB,OAAO;AACzB;;AAEA,iBAAiB;AACjB,eAAe;AACf,iBAAiB;;;;;;;;ACxGJ;;AAEb,eAAe,mBAAO,CAAC,GAAsB;AAC7C,gBAAgB,mBAAO,CAAC,GAAgB;AACxC,uBAAuB,mBAAO,CAAC,GAAuB;;AAEtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,KAAK;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,GAAG;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB;;;;;;;;ACtFZ;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB,iCAAiC,KAAK,WAAW,IAAI;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,QAAQ,IAAI,QAAQ;AACrD;AACA;;AAEA,iBAAiB;AACjB,sBAAsB;AACtB,mBAAmB;AACnB,qBAAqB;;;;;;;;AC7DR;;AAEb,eAAe,mBAAO,CAAC,GAAoB;AAC3C,kBAAkB,mBAAO,CAAC,GAAmB;AAC7C,iBAAiB,mBAAO,CAAC,GAAkB;AAC3C,mBAAmB,mBAAO,CAAC,GAAoB;;AAE/C,2CAA2C,2BAA2B;AACtE,iCAAiC,yBAAyB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;;;;;;;;AC5CL;;AAEb,YAAY,mBAAO,CAAC,GAAmB;AACvC,eAAe,mBAAO,CAAC,GAAsB;AAC7C,wBAAwB,mBAAO,CAAC,GAAyB;AACzD,oBAAoB,mBAAO,CAAC,GAAqB;AACjD,iBAAiB,mBAAO,CAAC,GAAkB;AAC3C,8BAA8B,mBAAO,CAAC,GAAiC;;AAEvE,aAAa;AACb;AACA;AACA,YAAY,oCAAoC;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,WAAW;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,wCAAwC;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS,IAAI,qBAAqB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB;AACxB,mBAAmB;;;;;;;;ACxGN;;AAEb,eAAe,mBAAO,CAAC,GAAsB;AAC7C,aAAa,mBAAO,CAAC,GAAoB;AACzC,cAAc,mBAAO,CAAC,GAAqB;AAC3C,cAAc,mBAAO,CAAC,GAAqB;AAC3C,sBAAsB,mBAAO,CAAC,GAAwB;AACtD,sBAAsB,mBAAO,CAAC,GAAwB;AACtD,4BAA4B,mBAAO,CAAC,GAA8B;;AAElE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,+BAA+B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,QAAQ,gBAAgB;AACzE;AACA;AACA;AACA;AACA,4DAA4D,QAAQ,WAAW,SAAS,0BAA0B,0BAA0B;AAC5I;AACA;AACA,2EAA2E,QAAQ;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB;;;;;;;;ACzFZ;;AAEb,WAAW,mBAAO,CAAC,GAAkB;AACrC,cAAc,mBAAO,CAAC,GAAqB;AAC3C,mBAAmB,mBAAO,CAAC,GAAoB;AAC/C,0BAA0B,mBAAO,CAAC,GAA4B;AAC9D,0BAA0B,mBAAO,CAAC,GAA6B;AAC/D,sBAAsB,mBAAO,CAAC,GAAwB;;AAEtD;AACA,2BAA2B,+BAA+B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yBAAyB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB;;;;;;;;ACpHV;;AAEb,gCAAgC,sEAAsE;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2FAA2F,cAAc;AACzG;AACA,qEAAqE,cAAc,KAAK,qBAAqB;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E,KAAK;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,YAAY;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB;;;;;;;;ACnJP;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB;;;;;;;;ACnCV;;AAEb,0BAA0B,mBAAO,CAAC,GAA4B;;AAE9D;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB;;;;;;;;AChBV;;AAEb,eAAe,mBAAO,CAAC,GAAsB;;AAE7C;AACA,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB;;;;;;;;ACdN;;AAEb,cAAc,mBAAO,CAAC,GAAqB;AAC3C,mBAAmB,mBAAO,CAAC,GAAoB;AAC/C,0BAA0B,mBAAO,CAAC,GAA6B;;AAE/D,2BAA2B,+BAA+B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB;;;;;;;;AClDV;;AAEb,eAAe,mBAAO,CAAC,GAAsB;AAC7C,WAAW,mBAAO,CAAC,GAAkB;AACrC,cAAc,mBAAO,CAAC,GAAqB;AAC3C,cAAc,mBAAO,CAAC,GAAqB;AAC3C,iBAAiB,mBAAO,CAAC,GAAkB;AAC3C,mBAAmB,mBAAO,CAAC,GAAoB;AAC/C,0BAA0B,mBAAO,CAAC,GAA4B;AAC9D,sBAAsB,mBAAO,CAAC,GAAwB;;AAEtD;AACA;AACA,iCAAiC,+BAA+B;AAChE,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA,gBAAgB,yBAAyB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,gFAAgF,OAAO;AACvF;AACA,yFAAyF,OAAO;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,OAAO;AACnF;AACA;AACA;AACA,0EAA0E,QAAQ;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,OAAO;AACtF;AACA,wFAAwF,QAAQ;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,MAAM,kBAAkB,YAAY;AACrD,iBAAiB,MAAM,mEAAmE,YAAY;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,6BAA6B;;;;;;;;AChNhB;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,MAAM;AAC3E;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA,kBAAkB;;;;;;;;ACtCL;;AAEb,eAAe,mBAAO,CAAC,GAAsB;AAC7C,aAAa,mBAAO,CAAC,GAAoB;AACzC,yBAAyB,mBAAO,CAAC,GAA2B;AAC5D,wBAAwB,mBAAO,CAAC,GAA0B;;AAE1D;AACA,YAAY,8BAA8B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,QAAQ,iCAAiC;AAClF;AACA;AACA,+DAA+D,QAAQ;AACvE;AACA;AACA,+BAA+B,2BAA2B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,IAAI,KAAK,GAAG;AACrE;AACA;AACA;AACA;AACA;;AAEA,qBAAqB;;;;;;;;ACvFR;;AAEb,aAAa,mBAAO,CAAC,GAAoB;;AAEzC;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,mCAAmC,QAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iBAAiB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA,+BAA+B,gBAAgB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF,IAAI;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,kBAAkB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,kCAAkC,eAAe;AACjD;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6FAA6F,OAAO;AACpG;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,WAAW;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;;AAEA,0BAA0B;;;;;;;;ACvMb;;AAEb,aAAa,mBAAO,CAAC,GAAoB;AACzC,iBAAiB,mBAAO,CAAC,GAAkB;;AAE3C;AACA,YAAY,4BAA4B;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4FAA4F,KAAK;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,UAAU;AAC1D;AACA;AACA;AACA;AACA,4CAA4C,UAAU;AACtD;AACA;AACA;AACA;AACA,wEAAwE,QAAQ;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,kBAAkB;AACnD;AACA;AACA;AACA;AACA;AACA,2EAA2E,IAAI;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,IAAI;AAC5E;AACA;AACA;AACA;;AAEA,yBAAyB;;;;;;;;AChOZ;;AAEb;AACA;AACA;AACA,8BAA8B,QAAQ;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2BAA2B;;;;;;;;AC3Bd;;AAEb,gBAAgB,mBAAO,CAAC,GAAiB;AACzC,mBAAmB,mBAAO,CAAC,GAAoB;AAC/C,eAAe,mBAAO,CAAC,GAAgB;;AAEvC;AACA,gBAAgB,KAAK;AACrB;AACA,yBAAyB;AACzB;AACA,yBAAyB;AACzB;AACA,uBAAuB;AACvB;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB;AACzB,uBAAuB;AACvB,sBAAsB;AACtB,iBAAiB;AACjB,aAAa;AACb,WAAW;AACX,gBAAgB;AAChB,gBAAgB;AAChB,cAAc;AACd,oBAAoB;AACpB,gBAAgB;AAChB,mBAAmB;AACnB,iBAAiB;;;;;;;;AC/GJ;;AAEb,yBAAyB,mBAAO,CAAC,GAAoC;AACrE,wBAAwB,mBAAO,CAAC,GAAmC;AACnE,aAAa,mBAAO,CAAC,GAAc;AACnC,sBAAsB,mBAAO,CAAC,GAAiC;;AAE/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,WAAW,UAAU;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,2EAA2E;AACvF,qDAAqD,aAAa;AAClE;AACA;AACA;AACA,mBAAmB;AACnB,KAAK;AACL;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,6BAA6B,mDAAmD;AAChF,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD,UAAU,8DAA8D;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,aAAa;AAClE;AACA;AACA;AACA,mBAAmB;AACnB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA,cAAc;AACd;AACA;AACA,yBAAyB,mDAAmD;AAC5E;AACA;AACA;AACA,+BAA+B,mDAAmD;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,mBAAmB;AACtD;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,mCAAmC,yBAAyB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,2BAA2B;AAC9D;AACA;AACA;;AAEA,yBAAyB;AACzB,uBAAuB;AACvB,sBAAsB;;;;;;;;ACzNT;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wBAAwB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB;;;;;;;;AC9DJ;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,wBAAwB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa;;;;;;;;AClGA;;AAEb,UAAU,mBAAO,CAAC,GAAU;;AAE5B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2FAA2F;AAC3F,yCAAyC;AACzC,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,KAAK;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD,kDAAkD;AAClD;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA,qCAAqC,uBAAuB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa;;;;;;;;AC9sBA;;AAEb;AACA;AACA,kCAAkC,WAAW;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,yBAAyB;AACzB;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA,mBAAmB;;;;;;;;ACxCN;;AAEb,mBAAmB,mBAAO,CAAC,GAAS;AACpC,UAAU,mBAAO,CAAC,GAAU;AAC5B,YAAY,mBAAO,CAAC,GAAY;;AAEhC;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,wBAAwB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,OAAO;AACxD,8BAA8B,qDAAqD;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA,yCAAyC,gCAAgC;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,qBAAqB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,yBAAyB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,gCAAgC;AACzE;AACA;AACA;AACA,4CAA4C,qBAAqB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,mBAAmB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,WAAW;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yBAAyB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,2BAA2B;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,2BAA2B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,mBAAmB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,OAAO;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,0BAA0B;AACnE;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,8CAA8C;AACpF,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,oCAAoC;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,2CAA2C;AACzF,iCAAiC;AACjC;AACA;AACA;AACA,6CAA6C,+CAA+C;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,2CAA2C;AACrF,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,iBAAiB;AAC3D,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,oCAAoC;AACpF;AACA;AACA,6CAA6C,2CAA2C;AACxF;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,+CAA+C;AACzF,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,yBAAyB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,kBAAkB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,2BAA2B;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,2BAA2B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,2BAA2B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,2BAA2B;AACnE;AACA;AACA;AACA;AACA;AACA,wCAAwC,+CAA+C;AACvF;AACA;AACA;AACA,4CAA4C,oCAAoC;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,2BAA2B;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,6BAA6B;AACrE;AACA;AACA;AACA,4CAA4C,kBAAkB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,qBAAqB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,2BAA2B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,0BAA0B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,2CAA2C;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc;;;;;;;;AC38BD;;AAEb,eAAe,mBAAO,CAAC,GAAuB;AAC9C,eAAe,mBAAO,CAAC,GAAmB;AAC1C,aAAa,mBAAO,CAAC,GAAa;AAClC,UAAU,mBAAO,CAAC,GAAU;AAC5B,eAAe,mBAAO,CAAC,GAAqB;AAC5C,kBAAkB,mBAAO,CAAC,GAAyB;AACnD,aAAa,mBAAO,CAAC,GAAmB;;AAExC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C,YAAY,4BAA4B;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,aAAa;AAC5C;AACA;AACA,2CAA2C;AAC3C,YAAY,4BAA4B;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oIAAoI;AACpI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,YAAY,IAAI;AAC1E;AACA;AACA,gBAAgB,gBAAgB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa;AACb,yBAAyB;AACzB,qBAAqB;AACrB,iBAAiB;;;;;;;;;;;;;;;;;;;;AC1GjB,mCAAyB;AACzB,qCAA8B;AAE9B,8DAMqC;AAErC,kDAAiD;AACjD,kDAAyD;AAEzD,4DAKqC;AAJnC,gIAAQ;AACR,0HAAK;AACL,4IAAc;AACd,oJAAkB;AAGP,kBAAU,GAAG,IAAI,8BAAa,CAAC,CAAO,IAAY,EAAE,EAAE;IACjE,MAAM,UAAU,GAAG,MAAM,0CAAqB,GAAE,CA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A;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;;AAEA,+CAA+C;AAC/C;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;;;;;;AC/RA,eAAe,mBAAO,CAAC,EAAQ;AAC/B,aAAa,mBAAO,CAAC,EAAM;AAC3B;;AAEA;AACA;AACA;;AAEA,4BAA4B,qCAAqC;AACjE;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA,gCAAgC,iBAAiB;AACjD;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;;;;;;;AC1IA,eAAe,mBAAO,CAAC,EAAQ;AAC/B,aAAa,mBAAO,CAAC,EAAM;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,uDAAuD;;AAEvD,4B;;;;;;ACbA,eAAe,mBAAO,CAAC,EAAQ;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;;;;;AClBA,oBAAoB,mBAAO,CAAC,GAAe;;AAE3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gEAAgE;AAChE;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,E;;;;;;ACtDA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,E;;;;;;ACZA,eAAe,mBAAO,CAAC,EAAQ;AAC/B,cAAc,mBAAO,CAAC,GAAS;AAC/B,kBAAkB,mBAAO,CAAC,GAAW;AACrC,qBAAqB,mBAAO,CAAC,GAAgB;;AAE7C;AACA,uCAAuC,gBAAgB;AACvD;AACA,sCAAsC,gBAAgB;AACtD;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;ACrDa;;AAEb,aAAa,mBAAO,CAAC,GAAiB;;AAEtC;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;AACL;AACA;;AAEA,kEAAkE,cAAc,sBAAsB;;AAEtG;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,4BAA4B;;;;;;;AC3E5B,aAAa,mBAAO,CAAC,EAAQ;AAC7B;AACA;AACA;AACA,EAAE,gBAAgB;AAClB,EAAE,gBAAgB;AAClB,EAAE,cAAc;AAChB,EAAE,iBAAiB;AACnB,EAAE,mBAAmB;AACrB,EAAE,cAAc;AAChB,EAAE;AACF,YAAY,yCAAqD;AACjE,EAAE,cAAc;AAChB,EAAE,gBAAgB;AAClB,EAAE,2CAAuD;AACzD,EAAE,yCAAmD;AACrD,EAAE,4CAAyD;AAC3D,EAAE,8CAA6D;AAC/D;;;;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;;AAEA,UAAU,mBAAO,CAAC,GAAsB;AACxC;;AAEA;;AAEA;AACA,cAAc,mBAAO,CAAC,GAAS;AAC/B;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS,sCAA8B;;AAEvC;AACA;AACA;AACA;;AAEA;AACA,aAAa,mBAAO,CAAC,GAA2B;AAChD;;AAEA;;AAEA,aAAa,iCAA6B;AAC1C,8IAA8I;AAC9I;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,yBAAyB,mBAAO,CAAC,GAAc;AAC/C,gBAAgB,mBAAO,CAAC,GAAU;AAClC;;AAEA;AACA,gBAAgB,mBAAO,CAAC,EAAM;AAC9B;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA,iBAAiB,mBAAO,CAAC,GAA+B;AACxD,kBAAkB,mBAAO,CAAC,GAA4B;AACtD;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yEAAyE,6EAA6E;AACtJ;;AAEA;AACA,qBAAqB,mBAAO,CAAC,GAAkB;;AAE/C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iDAAiD,0FAA0F;;AAE3I;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,wCAAwC,wCAAwC;AAChF;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,mBAAO,CAAC,GAAkB;;AAE/C;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA,kGAAkG;AAClG,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA,4FAA4F;AAC5F,UAAU;AACV;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,gDAAgD;;AAEhD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,sCAAsC,wCAAwC;AAC9E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sCAAsC;;AAEtC;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,4CAA4C;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB;;AAErB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,SAAS;AAC7B,sCAAsC,mBAAmB;AACzD,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA,4EAA4E;;AAE5E;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mDAAmD;AACnD;AACA,mDAAmD,iEAAiE;AACpH;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA,uCAAuC;AACvC,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC,OAAO;AACxC;AACA;AACA;AACA,C;;;;;;;AC1/Ba;;AAEb;AACA;AACA;AACA;AACA,qBAAqB;AACrB,EAAE;AACF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;AC3CA,iBAAiB;;AAEjB;AACA;AACA;;;;;;;ACJA,wCAAkC;;;;;;;ACAlC;AACA,aAAa,mBAAO,CAAC,GAAQ;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE,cAAc;AAChB;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;;AAEf;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA,cAAc;;AAEd;AACA;AACA;AACA,yBAAyB;;AAEzB;AACA;AACA;AACA,gBAAgB;;AAEhB;AACA;AACA;AACA,gBAAgB;;AAEhB;AACA;AACA;AACA,gBAAgB;;AAEhB;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA;AACA;AACA,gBAAgB;;AAEhB;AACA;AACA;AACA,gBAAgB;;AAEhB;AACA;AACA;AACA,cAAc;;AAEd;AACA;AACA;AACA,eAAe;;AAEf;AACA;AACA;AACA,kBAAkB;;AAElB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;;AAEnB,2DAAoD;;AAEpD;AACA;AACA;;;;;;;AC1GA;AACA,aAAa,mBAAO,CAAC,EAAM;AAC3B;AACA;AACA;AACA,EAAE;AACF;AACA,EAAE,yCAAiD;AACnD;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1Ba;;AAEb,kDAAkD,0CAA0C;;AAE5F,aAAa,iCAA6B;AAC1C,WAAW,mBAAO,CAAC,EAAM;;AAEzB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB;AAClB,gDAAgD;AAChD;AACA;AACA;;AAEA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA,6BAA6B,qBAAqB;AAClD;AACA;AACA,C;;;;;;;AC7Ea;;AAEb;;AAEA,UAAU,mBAAO,CAAC,GAAsB;AACxC;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,E;;;;;;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEa;;AAEb;;AAEA,UAAU,mBAAO,CAAC,GAAsB;AACxC;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;AACA,yBAAyB,mBAAO,CAAC,GAAc;AAC/C,gBAAgB,mBAAO,CAAC,GAAU;AAClC;;AAEA,eAAe,mBAAO,CAAC,GAAoB;AAC3C,eAAe,mBAAO,CAAC,GAAoB;;AAE3C;;AAEA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA,E;;;;;;;AClIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEa;;AAEb;;AAEA,UAAU,mBAAO,CAAC,GAAsB;AACxC;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,yBAAyB,mBAAO,CAAC,GAAc;AAC/C,gBAAgB,mBAAO,CAAC,GAAU;AAClC;;AAEA;AACA;AACA,aAAa,mBAAO,CAAC,GAAgB;AACrC;AACA;;AAEA;AACA,aAAa,mBAAO,CAAC,GAA2B;AAChD;;AAEA;;AAEA,aAAa,iCAA6B;AAC1C,8IAA8I;AAC9I;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,kBAAkB,mBAAO,CAAC,GAA4B;;AAEtD;;AAEA;;AAEA;AACA,qBAAqB,mBAAO,CAAC,GAAkB;;AAE/C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,iDAAiD,0FAA0F;;AAE3I;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,IAAI;AACJ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,mBAAO,CAAC,GAAkB;;AAE/C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iCAAiC;;AAEjC;;AAEA,2CAA2C;AAC3C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,oDAAoD;AACpD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,E;;;;;;;AC3qBA;AACA;AACA;;AAEA,kDAA0C;;;;;;;;ACL1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;;AAEA,aAAa,iCAA6B;AAC1C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6BAA6B,sCAAsC,sCAAsC;AACzG;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,C;;;;;;ACvSA;AACA,aAAa,mBAAO,CAAC,GAAQ;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE,cAAc;AAChB;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,aAAa;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;;AAEA,aAAa,mBAAO,CAAC,GAAkB;;AAEvC;AACA,yBAAyB,mBAAO,CAAC,GAAc;AAC/C,gBAAgB,mBAAO,CAAC,GAAU;AAClC;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,C;;;;;;;ACrNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEa;;AAEb;;AAEA,gBAAgB,mBAAO,CAAC,GAAqB;;AAE7C;AACA,yBAAyB,mBAAO,CAAC,GAAc;AAC/C,gBAAgB,mBAAO,CAAC,GAAU;AAClC;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,E;;;;;;AC9CA;;AAEA,cAAc,mBAAO,CAAC,GAAS;AAC/B,WAAW,mBAAO,CAAC,GAAU;AAC7B,aAAa,mBAAO,CAAC,EAAM;AAC3B,eAAe,mBAAO,CAAC,EAAQ;AAC/B,kBAAkB,mBAAO,CAAC,GAAW;;AAErC;AACA;AACA;;AAEA;;AAEA,yCAAyC,iBAAiB;AAC1D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA,oDAAoD,kBAAkB;;AAEtE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;;;;;;;AC7DY;;AAEZ;AACA;AACA,KAAK,mBAAO,CAAC,GAAM;AACnB;AACA,KAAK,mBAAO,CAAC,GAAQ;AACrB,KAAK,mBAAO,CAAC,GAAS;AACtB,KAAK,mBAAO,CAAC,GAAU;AACvB,KAAK,mBAAO,CAAC,GAAQ;AACrB,KAAK,mBAAO,CAAC,GAAU;AACvB,KAAK,mBAAO,CAAC,GAAQ;AACrB,KAAK,mBAAO,CAAC,GAAe;AAC5B,KAAK,mBAAO,CAAC,GAAe;AAC5B,KAAK,mBAAO,CAAC,GAAU;AACvB;;;;;;;;ACfY;AACZ;AACA;AACA,UAAU,uCAAoC;AAC9C,WAAW,mBAAO,CAAC,GAAa;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;AAEA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mBAAmB;AACnC,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,sBAAsB;AACtC,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,uBAAuB;AACvC,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA,EAAE,uBAAuB;AACzB,EAAE;AACF;AACA;AACA;AACA;AACA;;;;;;;;ACjJY;;AAEZ,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG,YAAY,gBAAgB;AAC/B;;AAEA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,YAAY,gBAAgB;AAC/B;;;;;;;ACvBA,SAAS,mBAAO,CAAC,EAAI;AACrB,gBAAgB,mBAAO,CAAC,GAAgB;AACxC,aAAa,mBAAO,CAAC,GAAqB;AAC1C,YAAY,mBAAO,CAAC,GAAY;;AAEhC,WAAW,mBAAO,CAAC,EAAM;;AAEzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA;AACA;AACA,MAAM,8BAAuB;AAC7B,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB,8BAA8B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;AC/bA,gBAAgB,mBAAO,CAAC,GAAW;;AAEnC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,YAAY;AACZ,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,cAAc;AACd,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA,MAAM;AACN,+CAA+C;AAC/C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;AClWA,sC;;;;;;ACAA,aAAa,gCAAwB;;AAErC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB;AACrB;;AAEA;;AAEA;AACA;AACA,8CAA8C,gBAAgB;AAC9D;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB;;AAEA;;AAEA;AACA;AACA,8CAA8C,gBAAgB;AAC9D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrHY;;AAEZ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;;;;;;;;ACtBA,mC;;;;;;;ACAY;;AAEZ,UAAU,sCAAmC;AAC7C;AACA,UAAU,mBAAO,CAAC,GAAQ;AAC1B,YAAY,mBAAO,CAAC,GAAa;AACjC;;;;;;;;ACNY;;AAEZ,WAAW,mBAAO,CAAC,GAAO;AAC1B,aAAa,mBAAO,CAAC,EAAM;AAC3B,QAAQ,SAAS,EAAE,mBAAO,CAAC,GAAW;AACtC,QAAQ,aAAa,EAAE,mBAAO,CAAC,GAAgB;AAC/C,QAAQ,eAAe,EAAE,mBAAO,CAAC,GAAgB;AACjD,aAAa,mBAAO,CAAC,GAAc;;AAEnC,yCAAyC;AACzC;AACA,aAAa;AACb;;AAEA;AACA;;AAEA;AACA;AACA;AACA,6EAA6E;AAC7E;AACA;AACA;AACA;;AAEA,UAAU,oBAAoB;;AAE9B;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,wEAAwE,IAAI;AAC5E,oEAAoE,IAAI;AACxE,mCAAmC,IAAI;AACvC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wBAAwB,KAAK;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0EAA0E,UAAU;AACpF;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,YAAY,kCAAkC,aAAa;AAC/F;;AAEA;AACA;AACA;AACA;AACA,yCAAyC,aAAa,UAAU,YAAY;AAC5E;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;ACrLY;AACZ,UAAU,sCAAmC;AAC7C,QAAQ,iCAAiC,EAAE,mBAAO,CAAC,GAAY;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACbY;AACZ,WAAW,mBAAO,CAAC,GAAO;AAC1B,QAAQ,YAAY,EAAE,mBAAO,CAAC,GAAS;;AAEvC;AACA,qBAAqB;AACrB;AACA,YAAY,yBAAyB;AACrC;;AAEA,sBAAsB;AACtB;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA,0BAA0B;AAC1B;;AAEA;AACA;AACA;AACA,GAAG;AACH;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACY;AACZ,aAAa,mBAAO,CAAC,EAAM;;AAE3B;AACA;AACA,wBAAwB;AACxB;AACA;;AAEA;AACA,mEAAmE,IAAI;AACvE;AACA;AACA;AACA;AACA;;;;;;;;ACpBY;AACZ,UAAU,sCAAmC;AAC7C,WAAW,mBAAO,CAAC,GAAO;;AAE1B;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;ACXY;;AAEZ,WAAW,mBAAO,CAAC,GAAO;AAC1B,UAAU,sCAAmC;;AAE7C;AACA;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;ACnCY;;AAEZ,WAAW,mBAAO,CAAC,GAAO;AAC1B,aAAa,mBAAO,CAAC,EAAM;AAC3B,UAAU,sCAAmC;;AAE7C;AACA;AACA,gCAAgC,cAAc;AAC9C,iCAAiC,cAAc;AAC/C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,sCAAsC,mBAAmB;AACzD;;AAEA;AACA;AACA;AACA,oCAAoC,cAAc;AAClD,qCAAqC,cAAc;AACnD;AACA;AACA;AACA,IAAI;AACJ,wCAAwC;AACxC;AACA;AACA,WAAW;AACX;;AAEA;AACA,UAAU,oBAAoB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,yDAAyD,KAAK,oBAAoB,IAAI;AACtF;AACA;AACA,qDAAqD,KAAK,wBAAwB,IAAI;AACtF;AACA;;AAEA;AACA;AACA;;AAEA,WAAW;AACX;;AAEA;AACA,UAAU,oBAAoB;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,yDAAyD,KAAK,oBAAoB,IAAI;AACtF;AACA;AACA,qDAAqD,KAAK,wBAAwB,IAAI;AACtF;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2CAA2C,cAAc;AACzD,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,cAAc;AACvD,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,UAAU,GAAG,IAAI,kCAAkC,KAAK;AAC3E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7JY;;AAEZ,WAAW,mBAAO,CAAC,GAAa;AAChC,aAAa,mBAAO,CAAC,EAAM;AAC3B,mBAAmB,qCAA+B;AAClD,yBAAyB,2CAA0C;AACnE,aAAa,mBAAO,CAAC,GAAc;;AAEnC;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,6EAA6E;AAC7E;AACA;AACA;AACA;;AAEA,UAAU,oBAAoB;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,6EAA6E,IAAI;AACjF,yEAAyE,IAAI;AAC7E,mCAAmC,IAAI;AACvC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ,wBAAwB,KAAK;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU,WAAW;AACr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AE/C,UAAU,sCAAmC;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;ACpGY;;AAEZ,WAAW,mBAAO,CAAC,GAAO;AAC1B,UAAU,sCAAmC;;AAE7C;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;ACjCY;;AAEZ,UAAU,sCAAmC;AAC7C,iBAAiB,mBAAO,CAAC,GAAY;;AAErC,wBAAwB,mBAAO,CAAC,GAAe;AAC/C,0BAA0B,mBAAO,CAAC,GAAoB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACfY;;AAEZ,iBAAiB,mBAAO,CAAC,GAAU;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACVA;AACA;AACA,QAAQ,mBAAO,CAAC,GAAa;AAC7B,EAAE;AACF,QAAQ,mBAAO,CAAC,EAAI;AACpB;AACA,qBAAqB,mBAAO,CAAC,GAAc;AAC3C,QAAQ,sBAAsB,EAAE,mBAAO,CAAC,GAAS;;AAEjD,4CAA4C;AAC5C;AACA,gBAAgB;AAChB;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA,uBAAuB,KAAK,IAAI,YAAY;AAC5C;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,yCAAyC;AACzC;AACA,gBAAgB;AAChB;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,uBAAuB,KAAK,IAAI,YAAY;AAC5C;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA,kDAAkD;AAClD;;AAEA;;AAEA;AACA;;AAEA;;AAEA,+CAA+C;AAC/C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACvFA,2BAA2B,uDAAuD,IAAI;AACtF;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB;;;;;;;;ACbP;;AAEZ,QAAQ,YAAY,EAAE,mBAAO,CAAC,GAAgB;AAC9C,QAAQ,aAAa,EAAE,mBAAO,CAAC,GAAgB;;AAE/C,mDAAmD;AACnD;;AAEA;AACA;;AAEA;;;;;;;;ACXY;;AAEZ,UAAU,sCAAmC;AAC7C,WAAW,mBAAO,CAAC,GAAO;AAC1B,aAAa,mBAAO,CAAC,EAAM;AAC3B,cAAc,mBAAO,CAAC,GAAW;AACjC,mBAAmB,qCAAoC;;AAEvD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;AC9BY;;AAEZ,QAAQ,YAAY,EAAE,mBAAO,CAAC,GAAgB;AAC9C,QAAQ,iBAAiB,EAAE,mBAAO,CAAC,GAAgB;;AAEnD;AACA;;AAEA;AACA;;AAEA;;;;;;;;ACXY;;AAEZ,UAAU,sCAAmC;AAC7C;AACA,UAAU,mBAAO,CAAC,GAAQ;AAC1B,YAAY,mBAAO,CAAC,GAAa;AACjC;;;;;;;;ACNY;;AAEZ,WAAW,mBAAO,CAAC,GAAO;AAC1B,aAAa,mBAAO,CAAC,EAAM;AAC3B,QAAQ,OAAO,EAAE,mBAAO,CAAC,GAAS;AAClC,QAAQ,SAAS,EAAE,mBAAO,CAAC,GAAW;AACtC,QAAQ,SAAS,EAAE,mBAAO,CAAC,GAAW;AACtC,QAAQ,aAAa,EAAE,mBAAO,CAAC,GAAgB;AAC/C,aAAa,mBAAO,CAAC,GAAc;;AAEnC,yCAAyC;AACzC;;AAEA,UAAU,kCAAkC;;AAE5C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;AC1DY;;AAEZ,WAAW,mBAAO,CAAC,GAAa;AAChC,aAAa,mBAAO,CAAC,EAAM;AAC3B,iBAAiB,mCAA2B;AAC5C,mBAAmB,qCAA+B;AAClD,mBAAmB,qCAA+B;AAClD,aAAa,mBAAO,CAAC,GAAc;;AAEnC;AACA;AACA;;AAEA,UAAU,kCAAkC;AAC5C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACtDA,WAAW,mBAAO,CAAC,GAAa;AAChC,kBAAkB,mBAAO,CAAC,GAAa;AACvC,eAAe,mBAAO,CAAC,EAAQ;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,8CAA8C,WAAW;AACzD,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,gBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA,YAAY,sCAAsC,EAAE,mBAAO,CAAC,GAAoB;AAChF;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,OAAO,GAAG,IAAI;AAC5C,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;;AAEX;AACA,OAAO;AACP;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;;;;;;;AC5IA,mBAAmB,mBAAO,CAAC,GAAe;AAC1C,cAAc,mBAAO,CAAC,GAAS;AAC/B,qBAAqB,mBAAO,CAAC,GAAiB;AAC9C,wBAAwB,mBAAO,CAAC,GAAoB;AACpD,aAAa,mBAAO,CAAC,EAAM;AAC3B,WAAW,mBAAO,CAAC,GAAU;AAC7B,sBAAsB,mBAAO,CAAC,GAAkB;AAChD,oBAAoB,mBAAO,CAAC,GAAgB;AAC5C,iBAAiB,mBAAO,CAAC,GAAU;;AAEnC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wCAAwC,8BAA8B;AACtE;;AAEA;AACA,KAAK;AACL;AACA,6BAA6B,iDAAiD;AAC9E,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,+BAA+B,6CAA6C;AAC5E;AACA;AACA,WAAW;AACX,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,4DAA4D,kBAAkB;;AAE9E;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW,IAAI,0DAA0D;AACzE,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,OAAO;;AAEP;AACA,KAAK;AACL;;;;;;;AClPA,gBAAgB,mBAAO,CAAC,GAAY;AACpC,mBAAmB,mBAAO,CAAC,GAAe;AAC1C,eAAe,mBAAO,CAAC,EAAQ;AAC/B,aAAa,mBAAO,CAAC,EAAM;AAC3B,wBAAwB,mBAAO,CAAC,GAAoB;AACpD,sBAAsB,mBAAO,CAAC,GAAkB;AAChD,oBAAoB,mBAAO,CAAC,GAAgB;;AAE5C;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,eAAe;;AAEf,4BAA4B,mBAAmB;AAC/C;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;;AAEL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,mCAAmC,0BAA0B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,GAAG;AACH;AACA;AACA,KAAK;;AAEL;AACA;;;;;;;ACvHA,cAAc,mBAAO,CAAC,GAAY;AAClC,aAAa,mBAAO,CAAC,EAAQ;;AAE7B;;AAEA;AACA,WAAW,mBAAO,CAAC,GAAiB;;AAEpC;;AAEA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,yB;;;;;;AC7FA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,QAAQ;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3Qa;AACb;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,eAAe,mBAAO,CAAC,GAAW;AAClC;AACA;;;;;;;;ACVa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,mBAAO,CAAC,GAAQ;AAC3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,wCAAoC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAU,mBAAO,CAAC,GAAO;AACzB,YAAY,mBAAO,CAAC,GAAS;AAC7B;AACA,uCAAuC,aAAa;AACpD,aAAa,mBAAO,CAAC,GAAU;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,mBAAO,CAAC,GAAa;AAC/C;AACA,IAAI,mBAAO,CAAC,GAAiB;AAC7B;AACA,cAAc,mBAAO,CAAC,GAAW;AACjC;AACA;;AAEA,YAAY,mBAAO,CAAC,GAAiB;AACrC;AACA;AACA;AACA,IAAI,mBAAO,CAAC,GAAW;AACvB,kBAAkB,mBAAO,CAAC,GAAgB;AAC1C,yBAAyB,mBAAO,CAAC,GAAY;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB,aAAa;AACjC;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA,MAAM;AACN;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA,0BAA0B;AAC1B,yBAAyB;;AAEzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAO,CAAC,GAAU;AAClB;AACA,mBAAO,CAAC,GAAQ;AAChB,mBAAO,CAAC,GAAU;AAClB,mBAAO,CAAC,GAAkB;AAC1B,mBAAO,CAAC,GAA0B;AAClC,mBAAO,CAAC,GAAQ;AAChB;AACA;AACA;AACA,mBAAO,CAAC,GAAe;AACvB,mBAAO,CAAC,GAAiB;AACzB,mBAAO,CAAC,GAAU;AAClB,mBAAO,CAAC,GAAc;AACtB,mBAAO,CAAC,GAAgB;AACxB,mBAAO,CAAC,GAAY;AACpB,mBAAO,CAAC,GAAW;AACnB,mBAAO,CAAC,GAAa;AACrB,mBAAO,CAAC,GAAa;AACrB,mBAAO,CAAC,GAAW;AACnB,mBAAO,CAAC,GAAa;AACrB,mBAAO,CAAC,GAAY;AACpB,mBAAO,CAAC,GAAU;AAClB,mBAAO,CAAC,GAAW;AACnB,mBAAO,CAAC,GAAa;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,eAAe,KAAK;AACpB,eAAe,KAAK;AACpB;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AClzBa;AACb,UAAU,mBAAO,CAAC,GAAO;AACzB;;AAEA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB;;AAEpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,+BAA+B;AACvD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,gCAAgC,iBAAiB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,wBAAwB;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,oCAAoC,+BAA+B;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AAAA,EAAU;AACd;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,wBAAwB;AACxB;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,aAAa;AACb;;AAEA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,6CAA6C,6BAA6B,iBAAiB,cAAc,QAAQ;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,kBAAkB,wCAAoC;AACtD;AACA,MAAM;AACN;AACA;AACA;AACA,CAAC;;AAED;;AAEA,KAAK,qBAAqB,WAAW;AACrC;;;;;;;ACpaA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF,gBAAgB;AAChB,gBAAgB;AAChB,kBAAkB;;AAElB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/EA,wC;;;;;;;ACAa;AACb;AACA,KAAK,qBAAqB,WAAW;AACrC,eAAe,mBAAO,CAAC,GAAY;AACnC,YAAY,mBAAO,CAAC,GAAS;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA,SAAS;AACT,MAAM;AACN;AACA;AACA,SAAS;AACT,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,6BAA6B;;;;;;;;ACvHhB;AACb,WAAW,mBAAO,CAAC,GAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,iCAAiC;AACjC,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,KAAK;AACL,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;;;;;;;AC7Da;AACb;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACxEa;AACb,UAAU,mBAAO,CAAC,GAAO;AACzB;AACA,WAAW,mBAAO,CAAC,GAAQ;AAC3B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;;AAEA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnHa;AACb;AACA,WAAW,mBAAO,CAAC,GAAQ;AAC3B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA,gBAAgB;AAChB;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;ACrFa;AACb;AACA;AACA,WAAW,mBAAO,CAAC,GAAQ;AAC3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;;ACzLa;AACb;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;AAC5C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpEa;AACb;AACA;AACA;AACA,cAAc,kCAA2B;AACzC,WAAW,mBAAO,CAAC,GAAQ;AAC3B,UAAU,mBAAO,CAAC,GAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,MAAK;AAC9B;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,qBAAqB;AAC/D;AACA,yCAAyC,oBAAoB;;AAE7D;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,yDAAyD,qBAAqB;AAC9E,wDAAwD,oBAAoB;AAC5E;AACA;AACA,UAAU;AACV;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,KAAK;AACL;AACA,gBAAgB;AAChB,KAAK;AACL;AACA,gBAAgB;AAChB,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA,8BAA8B;;AAE9B;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gCAAgC,uBAAuB;;AAEvD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;;AAEA,sCAAsC,QAAQ;AAC9C;AACA;AACA;AACA;AACA;;AAEA,0CAA0C,QAAQ;AAClD;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4BAA4B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,2BAA2B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iCAAiC,oBAAoB;AACrD;AACA;AACA;AACA;AACA,6BAA6B,QAAQ;AACrC;AACA;AACA;AACA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,uBAAuB;AACvB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACh/Ba;AACb;AACA,WAAW,mBAAO,CAAC,GAAQ;AAC3B;AACA;AACA,kBAAkB,mBAAO,CAAC,GAAgB;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,oBAAoB,aAAa;AACjC;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;;;;;;ACjJa;AACb;AACA,WAAW,mBAAO,CAAC,GAAQ;AAC3B,cAAc,+BAAqB;AACnC;AACA;;AAEA;AACA;AACA;AACA,uCAAuC,sBAAsB;AAC7D;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,cAAc;AACd;AACA,gCAAgC,iBAAiB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;ACzCa;AACb,WAAW,mBAAO,CAAC,GAAQ;AAC3B;AACA,aAAa,mBAAO,CAAC,GAAU;AAC/B;AACA,UAAU,mBAAO,CAAC,GAAO;;AAEzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV,yCAAyC,8CAA8C,iBAAiB,aAAa,QAAQ;AAC7H;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AClDa;AACb;AACA;AACA,WAAW,mBAAO,CAAC,GAAQ;AAC3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;;;;;;;ACtDa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;AClEa;AACb;AACA,WAAW,mBAAO,CAAC,GAAQ;AAC3B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,6BAA6B;AACrD;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;AChIa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yCAAyC,aAAa;AACtD;;AAEA;AACA;AACA;AACA,wCAAwC,eAAe;AACvD;;AAEA;AACA;AACA;AACA,4CAA4C,eAAe;AAC3D,MAAM;AACN;AACA,kCAAkC;AAClC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,6CAA6C,aAAa;AAC1D,MAAM;AACN;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;;;;;;;;AC7Ca;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;ACtGa;AACb;AACA;AACA,WAAW,mBAAO,CAAC,GAAQ;AAC3B;AACA;AACA;AACA;;AAEA,IAAI,IAAM;AACV;AACA;AACA;AACA,6EAA6E;AAC7E,6EAA6E;AAC7E,6EAA6E;AAC7E;AACA;;AAEA;AACA;AACA,6EAA6E;AAC7E,6EAA6E;AAC7E;AACA;;AAEA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA,sDAAsD;AACtD,2CAA2C;AAC3C;AACA,6EAA6E;AAC7E,6EAA6E;AAC7E,6EAA6E;AAC7E,6EAA6E;AAC7E;AACA,SAAS;AACT;AACA;;;AAGA,6EAA6E;AAC7E,6EAA6E;AAC7E,6EAA6E;AAC7E;AACA,6EAA6E;AAC7E,6EAA6E;AAC7E,6EAA6E;AAC7E,6EAA6E;AAC7E;AACA,6EAA6E;AAC7E,6EAA6E;AAC7E,6EAA6E;AAC7E,6EAA6E;AAC7E,6EAA6E;AAC7E,6EAA6E;AAC7E,kBAAkB,2DAA2D;AAC7E,6EAA6E;AAC7E,6EAA6E;AAC7E,6EAA6E;AAC7E;AACA,6EAA6E;AAC7E,6EAA6E;AAC7E,6EAA6E;AAC7E,6EAA6E;AAC7E,6EAA6E;AAC7E,sBAAsB,uDAAuD;AAC7E,6EAA6E;AAC7E,6EAA6E;AAC7E;AACA,6EAA6E;AAC7E,6EAA6E;AAC7E;AACA,6EAA6E;AAC7E;AACA,6EAA6E;AAC7E;AACA,6EAA6E;AAC7E,SAAS,oEAAoE;AAC7E;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,IAAM;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA,gCAAgC,UAAU;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,0BAA0B;AAC1B;AACA,0BAA0B;AAC1B;AACA;AACA,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,6BAA6B,iBAAiB,cAAc,QAAQ;AACrG;AACA;AACA;AACA;;AAEA;;;;;;;;ACpKa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,mBAAO,CAAC,GAAQ;AAC3B;AACA;;AAEA;AACA;AACA,IAAI,IAAM;AACV;AACA;AACA,6EAA6E;AAC7E;AACA,6EAA6E;AAC7E,6EAA6E;AAC7E,6EAA6E;AAC7E,6EAA6E;AAC7E,6EAA6E;AAC7E,6EAA6E;AAC7E,6EAA6E;AAC7E;AACA,6EAA6E;AAC7E,6EAA6E;AAC7E,6EAA6E;AAC7E;AACA;;AAEA;AACA;AACA,6EAA6E;AAC7E,6EAA6E;AAC7E;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,SAAS;AACrC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,8CAA8C,iBAAiB,aAAa,QAAQ;AACrH,QAAQ,IAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;;;;;;;AC1Ha;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,mBAAO,CAAC,GAAU;AAC/B;AACA,WAAW,mBAAO,CAAC,GAAQ;AAC3B;AACA;AACA;;AAEA;AACA,oBAAoB,0BAA0B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9Na;AACb;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,mBAAO,CAAC,GAAQ;AAC3B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;;;;;;;;AC9Ka;AACb;AACA,WAAW,mBAAO,CAAC,GAAQ;AAC3B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzDa;AACb;AACA;AACA,WAAW,mBAAO,CAAC,GAAQ;AAC3B,yBAAyB,mBAAO,CAAC,GAAY;AAC7C;AACA;AACA;AACA,gBAAgB,oCAA6B;AAC7C;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA,4BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAI,IAAM;AACV;AACA;AACA;AACA,yCAAyC,UAAU;AACnD;AACA;AACA,yCAAyC,QAAQ;AACjD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,+CAA+C,MAAM,aAAa,MAAM;AACxE,UAAU;AACV;AACA,oCAAoC,MAAM,aAAa,MAAM;AAC7D,mDAAmD,MAAM,aAAa,MAAM;AAC5E;AACA,8BAA8B,MAAM;AACpC;;AAEA;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA;;AAEA;AACA;AACA,6EAA6E;AAC7E,6EAA6E;AAC7E,4BAA4B,SAAS,wCAAwC;AAC7E,6EAA6E;AAC7E,6EAA6E;AAC7E,6EAA6E;AAC7E;AACA,6EAA6E;AAC7E;AACA,oEAAoE;AACpE,wEAAwE;AACxE;AACA;;AAEA;AACA;AACA;AACA,6EAA6E;AAC7E,6EAA6E;AAC7E,6EAA6E;AAC7E,6EAA6E;AAC7E,6EAA6E;AAC7E,6EAA6E;AAC7E,6EAA6E;AAC7E,6EAA6E;AAC7E,6EAA6E;AAC7E,6EAA6E;AAC7E;AACA,6EAA6E;AAC7E,6EAA6E;AAC7E,6EAA6E;AAC7E,6EAA6E;AAC7E,6EAA6E;AAC7E,6EAA6E;AAC7E,6EAA6E;AAC7E,6EAA6E;AAC7E,6EAA6E;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mCAAmC,aAAa;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;ACxTa;AACb;AACA;AACA,WAAW,mBAAO,CAAC,GAAQ;AAC3B;AACA,UAAU,mBAAO,CAAC,GAAO;AACzB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,iDAAiD,SAAS;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;ACrHa;AACb;AACA;AACA,WAAW,mBAAO,CAAC,GAAQ;;AAE3B;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,SAAS;AACpD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;AChDa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,mBAAO,CAAC,GAAQ;AAC3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;;AAEA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtLa;AACb;AACA;AACA;AACA,WAAW,mBAAO,CAAC,GAAQ;;AAE3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;AC9Ca;AACb;AACA;AACA,WAAW,mBAAO,CAAC,GAAQ;AAC3B,iBAAiB,qCAA8B;AAC/C,qBAAqB,yCAAkC;AACvD;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oCAAoC,yBAAyB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;;ACnJa;AACb;AACA,WAAW,mBAAO,CAAC,GAAQ;AAC3B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,yCAAyC,iBAAiB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;AC5Fa;AACb;AACA;AACA,eAAe,mBAAO,CAAC,GAAQ;AAC/B,oBAAoB,oCAA6B;AACjD,mBAAmB,mCAA0B;AAC7C;AACA;AACA;;AAEA;AACA,8BAA8B,SAAS;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,+BAA+B;AACvD;AACA;;AAEA;AACA;AACA,gCAAgC,wBAAwB;AACxD;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACjOa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;ACpBa;AACb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;AC5Ba;AACb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;ACXA,e;;;;;;;ACAa;;AAEb,4BAEC;AAGD,8BAEC;AAED,8BAEC;AAED,4BAEC;AAOD,gCAEC;AAxBD,SAAgB,QAAQ,CAAC,GAAY;IACnC,OAAO,OAAO,GAAG,KAAK,QAAQ,CAAC;AACjC,CAAC;AAED,wDAAwD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","sources":["webpack://esphome-lang-server/./src/server.ts","webpack://esphome-lang-server/./node_modules/vscode-languageserver/node.js","webpack://esphome-lang-server/./node_modules/vscode-languageserver/lib/node/main.js","webpack://esphome-lang-server/external node-commonjs \"node:util\"","webpack://esphome-lang-server/./node_modules/vscode-languageserver/lib/common/utils/is.js","webpack://esphome-lang-server/./node_modules/vscode-languageserver/lib/common/server.js","webpack://esphome-lang-server/./node_modules/vscode-languageserver-protocol/lib/node/main.js","webpack://esphome-lang-server/./node_modules/vscode-jsonrpc/node.js","webpack://esphome-lang-server/./node_modules/vscode-jsonrpc/lib/node/main.js","webpack://esphome-lang-server/./node_modules/vscode-jsonrpc/lib/node/ril.js","webpack://esphome-lang-server/external node-commonjs \"util\"","webpack://esphome-lang-server/./node_modules/vscode-jsonrpc/lib/common/api.js","webpack://esphome-lang-server/./node_modules/vscode-jsonrpc/lib/common/messages.js","webpack://esphome-lang-server/./node_modules/vscode-jsonrpc/lib/common/is.js","webpack://esphome-lang-server/./node_modules/vscode-jsonrpc/lib/common/linkedMap.js","webpack://esphome-lang-server/./node_modules/vscode-jsonrpc/lib/common/disposable.js","webpack://esphome-lang-server/./node_modules/vscode-jsonrpc/lib/common/events.js","webpack://esphome-lang-server/./node_modules/vscode-jsonrpc/lib/common/ral.js","webpack://esphome-lang-server/./node_modules/vscode-jsonrpc/lib/common/cancellation.js","webpack://esphome-lang-server/./node_modules/vscode-jsonrpc/lib/common/sharedArrayCancellation.js","webpack://esphome-lang-server/./node_modules/vscode-jsonrpc/lib/common/messageReader.js","webpack://esphome-lang-server/./node_modules/vscode-jsonrpc/lib/common/semaphore.js","webpack://esphome-lang-server/./node_modules/vscode-jsonrpc/lib/common/messageWriter.js","webpack://esphome-lang-server/./node_modules/vscode-jsonrpc/lib/common/messageBuffer.js","webpack://esphome-lang-server/./node_modules/vscode-jsonrpc/lib/common/connection.js","webpack://esphome-lang-server/external node-commonjs \"path\"","webpack://esphome-lang-server/external node-commonjs \"os\"","webpack://esphome-lang-server/external node-commonjs \"crypto\"","webpack://esphome-lang-server/external node-commonjs \"net\"","webpack://esphome-lang-server/./node_modules/vscode-languageserver-protocol/lib/common/api.js","webpack://esphome-lang-server/./node_modules/vscode-languageserver-types/lib/umd/main.js","webpack://esphome-lang-server/./node_modules/vscode-languageserver-types/lib/umd/ sync","webpack://esphome-lang-server/./node_modules/vscode-languageserver-protocol/lib/common/messages.js","webpack://esphome-lang-server/./node_modules/vscode-languageserver-protocol/lib/common/protocol.js","webpack://esphome-lang-server/./node_modules/vscode-languageserver-protocol/lib/common/utils/is.js","webpack://esphome-lang-server/./node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js","webpack://esphome-lang-server/./node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js","webpack://esphome-lang-server/./node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolder.js","webpack://esphome-lang-server/./node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js","webpack://esphome-lang-server/./node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js","webpack://esphome-lang-server/./node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js","webpack://esphome-lang-server/./node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js","webpack://esphome-lang-server/./node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js","webpack://esphome-lang-server/./node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js","webpack://esphome-lang-server/./node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js","webpack://esphome-lang-server/./node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js","webpack://esphome-lang-server/./node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js","webpack://esphome-lang-server/./node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js","webpack://esphome-lang-server/./node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js","webpack://esphome-lang-server/./node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js","webpack://esphome-lang-server/./node_modules/vscode-languageserver-protocol/lib/common/protocol.typeHierarchy.js","webpack://esphome-lang-server/./node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineValue.js","webpack://esphome-lang-server/./node_modules/vscode-languageserver-protocol/lib/common/protocol.inlayHint.js","webpack://esphome-lang-server/./node_modules/vscode-languageserver-protocol/lib/common/protocol.diagnostic.js","webpack://esphome-lang-server/./node_modules/vscode-languageserver-protocol/lib/common/protocol.notebook.js","webpack://esphome-lang-server/./node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineCompletion.js","webpack://esphome-lang-server/./node_modules/vscode-languageserver-protocol/lib/common/connection.js","webpack://esphome-lang-server/./node_modules/vscode-languageserver/lib/common/utils/uuid.js","webpack://esphome-lang-server/./node_modules/vscode-languageserver/lib/common/progress.js","webpack://esphome-lang-server/./node_modules/vscode-languageserver/lib/common/configuration.js","webpack://esphome-lang-server/./node_modules/vscode-languageserver/lib/common/workspaceFolder.js","webpack://esphome-lang-server/./node_modules/vscode-languageserver/lib/common/callHierarchy.js","webpack://esphome-lang-server/./node_modules/vscode-languageserver/lib/common/semanticTokens.js","webpack://esphome-lang-server/./node_modules/vscode-languageserver/lib/common/showDocument.js","webpack://esphome-lang-server/./node_modules/vscode-languageserver/lib/common/fileOperations.js","webpack://esphome-lang-server/./node_modules/vscode-languageserver/lib/common/linkedEditingRange.js","webpack://esphome-lang-server/./node_modules/vscode-languageserver/lib/common/typeHierarchy.js","webpack://esphome-lang-server/./node_modules/vscode-languageserver/lib/common/inlineValue.js","webpack://esphome-lang-server/./node_modules/vscode-languageserver/lib/common/foldingRange.js","webpack://esphome-lang-server/./node_modules/vscode-languageserver/lib/common/inlayHint.js","webpack://esphome-lang-server/./node_modules/vscode-languageserver/lib/common/diagnostic.js","webpack://esphome-lang-server/./node_modules/vscode-languageserver/lib/common/notebook.js","webpack://esphome-lang-server/./node_modules/vscode-languageserver/lib/common/textDocuments.js","webpack://esphome-lang-server/./node_modules/vscode-languageserver/lib/common/moniker.js","webpack://esphome-lang-server/./node_modules/vscode-languageserver/lib/node/files.js","webpack://esphome-lang-server/external node-commonjs \"url\"","webpack://esphome-lang-server/external node-commonjs \"fs\"","webpack://esphome-lang-server/external node-commonjs \"child_process\"","webpack://esphome-lang-server/./node_modules/vscode-languageserver-protocol/node.js","webpack://esphome-lang-server/./node_modules/vscode-languageserver/lib/common/api.js","webpack://esphome-lang-server/./node_modules/vscode-languageserver/lib/common/inlineCompletion.proposed.js","webpack://esphome-lang-server/./node_modules/vscode-languageserver-textdocument/lib/esm/main.js","webpack://esphome-lang-server/./src/validation.ts","webpack://esphome-lang-server/./src/types.ts","webpack://esphome-lang-server/./node_modules/vscode-uri/lib/umd/index.js","webpack://esphome-lang-server/./src/file-accessor.ts","webpack://esphome-lang-server/./src/connection-source.ts","webpack://esphome-lang-server/./src/connection-dashboard.ts","webpack://esphome-lang-server/./node_modules/ws/index.js","webpack://esphome-lang-server/./node_modules/ws/lib/websocket.js","webpack://esphome-lang-server/external node-commonjs \"events\"","webpack://esphome-lang-server/external node-commonjs \"https\"","webpack://esphome-lang-server/external node-commonjs \"http\"","webpack://esphome-lang-server/external node-commonjs \"tls\"","webpack://esphome-lang-server/external node-commonjs \"stream\"","webpack://esphome-lang-server/./node_modules/ws/lib/permessage-deflate.js","webpack://esphome-lang-server/external node-commonjs \"zlib\"","webpack://esphome-lang-server/./node_modules/ws/lib/buffer-util.js","webpack://esphome-lang-server/./node_modules/ws/lib/constants.js","webpack://esphome-lang-server/external commonjs \"bufferutil\"","webpack://esphome-lang-server/./node_modules/ws/lib/limiter.js","webpack://esphome-lang-server/./node_modules/ws/lib/receiver.js","webpack://esphome-lang-server/./node_modules/ws/lib/validation.js","webpack://esphome-lang-server/external node-commonjs \"buffer\"","webpack://esphome-lang-server/external commonjs \"utf-8-validate\"","webpack://esphome-lang-server/./node_modules/ws/lib/sender.js","webpack://esphome-lang-server/./node_modules/ws/lib/event-target.js","webpack://esphome-lang-server/./node_modules/ws/lib/extension.js","webpack://esphome-lang-server/./node_modules/ws/lib/stream.js","webpack://esphome-lang-server/./node_modules/ws/lib/websocket-server.js","webpack://esphome-lang-server/./node_modules/ws/lib/subprotocol.js","webpack://esphome-lang-server/./src/connection.ts","webpack://esphome-lang-server/./src/connection-local.ts","webpack://esphome-lang-server/external node-commonjs \"process\"","webpack://esphome-lang-server/./src/hover-handler.ts","webpack://esphome-lang-server/./node_modules/yaml/dist/index.js","webpack://esphome-lang-server/./node_modules/yaml/dist/compose/composer.js","webpack://esphome-lang-server/./node_modules/yaml/dist/doc/directives.js","webpack://esphome-lang-server/./node_modules/yaml/dist/nodes/identity.js","webpack://esphome-lang-server/./node_modules/yaml/dist/visit.js","webpack://esphome-lang-server/./node_modules/yaml/dist/doc/Document.js","webpack://esphome-lang-server/./node_modules/yaml/dist/nodes/Alias.js","webpack://esphome-lang-server/./node_modules/yaml/dist/doc/anchors.js","webpack://esphome-lang-server/./node_modules/yaml/dist/nodes/Node.js","webpack://esphome-lang-server/./node_modules/yaml/dist/doc/applyReviver.js","webpack://esphome-lang-server/./node_modules/yaml/dist/nodes/toJS.js","webpack://esphome-lang-server/./node_modules/yaml/dist/nodes/Collection.js","webpack://esphome-lang-server/./node_modules/yaml/dist/doc/createNode.js","webpack://esphome-lang-server/./node_modules/yaml/dist/nodes/Scalar.js","webpack://esphome-lang-server/./node_modules/yaml/dist/nodes/Pair.js","webpack://esphome-lang-server/./node_modules/yaml/dist/stringify/stringifyPair.js","webpack://esphome-lang-server/./node_modules/yaml/dist/stringify/stringify.js","webpack://esphome-lang-server/./node_modules/yaml/dist/stringify/stringifyComment.js","webpack://esphome-lang-server/./node_modules/yaml/dist/stringify/stringifyString.js","webpack://esphome-lang-server/./node_modules/yaml/dist/stringify/foldFlowLines.js","webpack://esphome-lang-server/./node_modules/yaml/dist/nodes/addPairToJSMap.js","webpack://esphome-lang-server/./node_modules/yaml/dist/log.js","webpack://esphome-lang-server/./node_modules/yaml/dist/schema/yaml-1.1/merge.js","webpack://esphome-lang-server/./node_modules/yaml/dist/schema/Schema.js","webpack://esphome-lang-server/./node_modules/yaml/dist/schema/common/map.js","webpack://esphome-lang-server/./node_modules/yaml/dist/nodes/YAMLMap.js","webpack://esphome-lang-server/./node_modules/yaml/dist/stringify/stringifyCollection.js","webpack://esphome-lang-server/./node_modules/yaml/dist/schema/common/seq.js","webpack://esphome-lang-server/./node_modules/yaml/dist/nodes/YAMLSeq.js","webpack://esphome-lang-server/./node_modules/yaml/dist/schema/common/string.js","webpack://esphome-lang-server/./node_modules/yaml/dist/schema/tags.js","webpack://esphome-lang-server/./node_modules/yaml/dist/schema/common/null.js","webpack://esphome-lang-server/./node_modules/yaml/dist/schema/core/bool.js","webpack://esphome-lang-server/./node_modules/yaml/dist/schema/core/float.js","webpack://esphome-lang-server/./node_modules/yaml/dist/stringify/stringifyNumber.js","webpack://esphome-lang-server/./node_modules/yaml/dist/schema/core/int.js","webpack://esphome-lang-server/./node_modules/yaml/dist/schema/core/schema.js","webpack://esphome-lang-server/./node_modules/yaml/dist/schema/json/schema.js","webpack://esphome-lang-server/./node_modules/yaml/dist/schema/yaml-1.1/binary.js","webpack://esphome-lang-server/./node_modules/yaml/dist/schema/yaml-1.1/omap.js","webpack://esphome-lang-server/./node_modules/yaml/dist/schema/yaml-1.1/pairs.js","webpack://esphome-lang-server/./node_modules/yaml/dist/schema/yaml-1.1/schema.js","webpack://esphome-lang-server/./node_modules/yaml/dist/schema/yaml-1.1/bool.js","webpack://esphome-lang-server/./node_modules/yaml/dist/schema/yaml-1.1/float.js","webpack://esphome-lang-server/./node_modules/yaml/dist/schema/yaml-1.1/int.js","webpack://esphome-lang-server/./node_modules/yaml/dist/schema/yaml-1.1/set.js","webpack://esphome-lang-server/./node_modules/yaml/dist/schema/yaml-1.1/timestamp.js","webpack://esphome-lang-server/./node_modules/yaml/dist/stringify/stringifyDocument.js","webpack://esphome-lang-server/./node_modules/yaml/dist/errors.js","webpack://esphome-lang-server/./node_modules/yaml/dist/compose/compose-doc.js","webpack://esphome-lang-server/./node_modules/yaml/dist/compose/compose-node.js","webpack://esphome-lang-server/./node_modules/yaml/dist/compose/compose-collection.js","webpack://esphome-lang-server/./node_modules/yaml/dist/compose/resolve-block-map.js","webpack://esphome-lang-server/./node_modules/yaml/dist/compose/resolve-props.js","webpack://esphome-lang-server/./node_modules/yaml/dist/compose/util-contains-newline.js","webpack://esphome-lang-server/./node_modules/yaml/dist/compose/util-flow-indent-check.js","webpack://esphome-lang-server/./node_modules/yaml/dist/compose/util-map-includes.js","webpack://esphome-lang-server/./node_modules/yaml/dist/compose/resolve-block-seq.js","webpack://esphome-lang-server/./node_modules/yaml/dist/compose/resolve-flow-collection.js","webpack://esphome-lang-server/./node_modules/yaml/dist/compose/resolve-end.js","webpack://esphome-lang-server/./node_modules/yaml/dist/compose/compose-scalar.js","webpack://esphome-lang-server/./node_modules/yaml/dist/compose/resolve-block-scalar.js","webpack://esphome-lang-server/./node_modules/yaml/dist/compose/resolve-flow-scalar.js","webpack://esphome-lang-server/./node_modules/yaml/dist/compose/util-empty-scalar-position.js","webpack://esphome-lang-server/./node_modules/yaml/dist/parse/cst.js","webpack://esphome-lang-server/./node_modules/yaml/dist/parse/cst-scalar.js","webpack://esphome-lang-server/./node_modules/yaml/dist/parse/cst-stringify.js","webpack://esphome-lang-server/./node_modules/yaml/dist/parse/cst-visit.js","webpack://esphome-lang-server/./node_modules/yaml/dist/parse/lexer.js","webpack://esphome-lang-server/./node_modules/yaml/dist/parse/line-counter.js","webpack://esphome-lang-server/./node_modules/yaml/dist/parse/parser.js","webpack://esphome-lang-server/./node_modules/yaml/dist/public-api.js","webpack://esphome-lang-server/./src/editor-shims.ts","webpack://esphome-lang-server/./src/esphome-schema.ts","webpack://esphome-lang-server/./src/schema-fetcher.ts","webpack://esphome-lang-server/./node_modules/unzipper/unzip.js","webpack://esphome-lang-server/./node_modules/unzipper/lib/parse.js","webpack://esphome-lang-server/./node_modules/unzipper/lib/PullStream.js","webpack://esphome-lang-server/./node_modules/unzipper/lib/NoopStream.js","webpack://esphome-lang-server/./node_modules/unzipper/lib/BufferStream.js","webpack://esphome-lang-server/./node_modules/unzipper/lib/parseExtraField.js","webpack://esphome-lang-server/./node_modules/unzipper/lib/parseBuffer.js","webpack://esphome-lang-server/./node_modules/unzipper/lib/parseDateTime.js","webpack://esphome-lang-server/./node_modules/unzipper/lib/parseOne.js","webpack://esphome-lang-server/./node_modules/duplexer2/index.js","webpack://esphome-lang-server/./node_modules/readable-stream/readable.js","webpack://esphome-lang-server/./node_modules/readable-stream/lib/_stream_readable.js","webpack://esphome-lang-server/./node_modules/process-nextick-args/index.js","webpack://esphome-lang-server/./node_modules/isarray/index.js","webpack://esphome-lang-server/./node_modules/readable-stream/lib/internal/streams/stream.js","webpack://esphome-lang-server/./node_modules/readable-stream/node_modules/safe-buffer/index.js","webpack://esphome-lang-server/./node_modules/core-util-is/lib/util.js","webpack://esphome-lang-server/./node_modules/inherits/inherits.js","webpack://esphome-lang-server/./node_modules/inherits/inherits_browser.js","webpack://esphome-lang-server/./node_modules/readable-stream/lib/internal/streams/BufferList.js","webpack://esphome-lang-server/./node_modules/readable-stream/lib/internal/streams/destroy.js","webpack://esphome-lang-server/./node_modules/readable-stream/lib/_stream_duplex.js","webpack://esphome-lang-server/./node_modules/readable-stream/lib/_stream_writable.js","webpack://esphome-lang-server/./node_modules/util-deprecate/node.js","webpack://esphome-lang-server/./node_modules/string_decoder/lib/string_decoder.js","webpack://esphome-lang-server/./node_modules/string_decoder/node_modules/safe-buffer/index.js","webpack://esphome-lang-server/./node_modules/readable-stream/lib/_stream_transform.js","webpack://esphome-lang-server/./node_modules/readable-stream/lib/_stream_passthrough.js","webpack://esphome-lang-server/./node_modules/unzipper/lib/extract.js","webpack://esphome-lang-server/./node_modules/fs-extra/lib/index.js","webpack://esphome-lang-server/./node_modules/fs-extra/lib/fs/index.js","webpack://esphome-lang-server/./node_modules/universalify/index.js","webpack://esphome-lang-server/./node_modules/graceful-fs/graceful-fs.js","webpack://esphome-lang-server/./node_modules/graceful-fs/polyfills.js","webpack://esphome-lang-server/external node-commonjs \"constants\"","webpack://esphome-lang-server/./node_modules/graceful-fs/legacy-streams.js","webpack://esphome-lang-server/./node_modules/graceful-fs/clone.js","webpack://esphome-lang-server/external node-commonjs \"assert\"","webpack://esphome-lang-server/./node_modules/fs-extra/lib/copy/index.js","webpack://esphome-lang-server/./node_modules/fs-extra/lib/copy/copy.js","webpack://esphome-lang-server/./node_modules/fs-extra/lib/mkdirs/index.js","webpack://esphome-lang-server/./node_modules/fs-extra/lib/mkdirs/make-dir.js","webpack://esphome-lang-server/./node_modules/fs-extra/lib/mkdirs/utils.js","webpack://esphome-lang-server/./node_modules/fs-extra/lib/path-exists/index.js","webpack://esphome-lang-server/./node_modules/fs-extra/lib/util/utimes.js","webpack://esphome-lang-server/./node_modules/fs-extra/lib/util/stat.js","webpack://esphome-lang-server/./node_modules/fs-extra/lib/copy/copy-sync.js","webpack://esphome-lang-server/./node_modules/fs-extra/lib/empty/index.js","webpack://esphome-lang-server/./node_modules/fs-extra/lib/remove/index.js","webpack://esphome-lang-server/./node_modules/fs-extra/lib/ensure/index.js","webpack://esphome-lang-server/./node_modules/fs-extra/lib/ensure/file.js","webpack://esphome-lang-server/./node_modules/fs-extra/lib/ensure/link.js","webpack://esphome-lang-server/./node_modules/fs-extra/lib/ensure/symlink.js","webpack://esphome-lang-server/./node_modules/fs-extra/lib/ensure/symlink-paths.js","webpack://esphome-lang-server/./node_modules/fs-extra/lib/ensure/symlink-type.js","webpack://esphome-lang-server/./node_modules/fs-extra/lib/json/index.js","webpack://esphome-lang-server/./node_modules/fs-extra/lib/json/jsonfile.js","webpack://esphome-lang-server/./node_modules/jsonfile/index.js","webpack://esphome-lang-server/./node_modules/jsonfile/utils.js","webpack://esphome-lang-server/./node_modules/fs-extra/lib/json/output-json.js","webpack://esphome-lang-server/./node_modules/fs-extra/lib/output-file/index.js","webpack://esphome-lang-server/./node_modules/fs-extra/lib/json/output-json-sync.js","webpack://esphome-lang-server/./node_modules/fs-extra/lib/move/index.js","webpack://esphome-lang-server/./node_modules/fs-extra/lib/move/move.js","webpack://esphome-lang-server/./node_modules/fs-extra/lib/move/move-sync.js","webpack://esphome-lang-server/./node_modules/unzipper/lib/Open/index.js","webpack://esphome-lang-server/./node_modules/unzipper/lib/Open/directory.js","webpack://esphome-lang-server/./node_modules/unzipper/lib/Open/unzip.js","webpack://esphome-lang-server/./node_modules/unzipper/lib/Decrypt.js","webpack://esphome-lang-server/./node_modules/node-int64/Int64.js","webpack://esphome-lang-server/./node_modules/bluebird/js/release/bluebird.js","webpack://esphome-lang-server/./node_modules/bluebird/js/release/promise.js","webpack://esphome-lang-server/./node_modules/bluebird/js/release/util.js","webpack://esphome-lang-server/./node_modules/bluebird/js/release/es5.js","webpack://esphome-lang-server/external node-commonjs \"async_hooks\"","webpack://esphome-lang-server/./node_modules/bluebird/js/release/async.js","webpack://esphome-lang-server/./node_modules/bluebird/js/release/schedule.js","webpack://esphome-lang-server/./node_modules/bluebird/js/release/queue.js","webpack://esphome-lang-server/./node_modules/bluebird/js/release/errors.js","webpack://esphome-lang-server/./node_modules/bluebird/js/release/thenables.js","webpack://esphome-lang-server/./node_modules/bluebird/js/release/promise_array.js","webpack://esphome-lang-server/./node_modules/bluebird/js/release/context.js","webpack://esphome-lang-server/./node_modules/bluebird/js/release/debuggability.js","webpack://esphome-lang-server/./node_modules/bluebird/js/release/finally.js","webpack://esphome-lang-server/./node_modules/bluebird/js/release/catch_filter.js","webpack://esphome-lang-server/./node_modules/bluebird/js/release/nodeback.js","webpack://esphome-lang-server/./node_modules/bluebird/js/release/method.js","webpack://esphome-lang-server/./node_modules/bluebird/js/release/bind.js","webpack://esphome-lang-server/./node_modules/bluebird/js/release/cancel.js","webpack://esphome-lang-server/./node_modules/bluebird/js/release/direct_resolve.js","webpack://esphome-lang-server/./node_modules/bluebird/js/release/synchronous_inspection.js","webpack://esphome-lang-server/./node_modules/bluebird/js/release/join.js","webpack://esphome-lang-server/./node_modules/bluebird/js/release/call_get.js","webpack://esphome-lang-server/./node_modules/bluebird/js/release/generators.js","webpack://esphome-lang-server/./node_modules/bluebird/js/release/map.js","webpack://esphome-lang-server/./node_modules/bluebird/js/release/nodeify.js","webpack://esphome-lang-server/./node_modules/bluebird/js/release/promisify.js","webpack://esphome-lang-server/./node_modules/bluebird/js/release/props.js","webpack://esphome-lang-server/./node_modules/bluebird/js/release/race.js","webpack://esphome-lang-server/./node_modules/bluebird/js/release/reduce.js","webpack://esphome-lang-server/./node_modules/bluebird/js/release/settle.js","webpack://esphome-lang-server/./node_modules/bluebird/js/release/some.js","webpack://esphome-lang-server/./node_modules/bluebird/js/release/timers.js","webpack://esphome-lang-server/./node_modules/bluebird/js/release/using.js","webpack://esphome-lang-server/./node_modules/bluebird/js/release/any.js","webpack://esphome-lang-server/./node_modules/bluebird/js/release/each.js","webpack://esphome-lang-server/./node_modules/bluebird/js/release/filter.js","webpack://esphome-lang-server/ignored|/usr/local/workspace/sublime-packages/LSP-esphome/language-server/temp/server/node_modules/unzipper/lib/Open|@aws-sdk/client-s3","webpack://esphome-lang-server/./src/utils/objects.ts","webpack://esphome-lang-server/./src/esphome-document.ts","webpack://esphome-lang-server/./src/utils/text-buffer.ts","webpack://esphome-lang-server/./src/completions-handler.ts","webpack://esphome-lang-server/./src/definition-handler.ts","webpack://esphome-lang-server/webpack/bootstrap","webpack://esphome-lang-server/webpack/runtime/define property getters","webpack://esphome-lang-server/webpack/runtime/hasOwnProperty shorthand","webpack://esphome-lang-server/webpack/runtime/make namespace object","webpack://esphome-lang-server/webpack/before-startup","webpack://esphome-lang-server/webpack/startup","webpack://esphome-lang-server/webpack/after-startup"],"sourcesContent":["import {\n  createConnection,\n  TextDocuments,\n  Diagnostic,\n  ProposedFeatures,\n  InitializeParams,\n  DidChangeConfigurationNotification,\n  TextDocumentSyncKind,\n  InitializeResult,\n} from \"vscode-languageserver/node\";\n\nimport { TextDocument } from \"vscode-languageserver-textdocument\";\nimport { Validation } from \"./validation\";\nimport { VsCodeFileAccessor } from \"./file-accessor\";\nimport { ESPHomeConnectionSource } from \"./connection-source\";\nimport { ESPHomeSettings } from \"./settings\";\nimport { HoverHandler } from \"./hover-handler\";\nimport { ESPHomeDocuments } from \"./esphome-document\";\nimport { TextBuffer } from \"./utils/text-buffer\";\nimport { CompletionsHandler } from \"./completions-handler\";\nimport { DefinitionHandler } from \"./definition-handler\";\n\n// Create a connection for the server, using Node's IPC as a transport.\n// Also include all preview / proposed LSP features.\nlet connection = createConnection(ProposedFeatures.all);\n\nconsole.log = connection.console.log.bind(connection.console);\nconsole.warn = connection.window.showWarningMessage.bind(connection.window);\nconsole.error = connection.window.showErrorMessage.bind(connection.window);\n\n// Create a simple text document manager.\nlet documents: TextDocuments<TextDocument> = new TextDocuments(TextDocument);\n\nconst esphomeDocuments: ESPHomeDocuments = new ESPHomeDocuments();\n\nlet hasConfigurationCapability: boolean = false;\nlet hasWorkspaceFolderCapability: boolean = false;\n\nconst sendDiagnostics = (uri: string, diagnostics: Diagnostic[]) => {\n  connection.sendDiagnostics({\n    uri,\n    diagnostics,\n  });\n};\nlet fileAccessor: VsCodeFileAccessor;\n\nconst esphomeConnection = new ESPHomeConnectionSource();\nlet pythonPath = \"\";\n\nconnection.onInitialize((params: InitializeParams) => {\n  let capabilities = params.capabilities;\n\n  // Does the client support the `workspace/configuration` request?\n  // If not, we fall back using global settings.\n  hasConfigurationCapability = !!(\n    capabilities.workspace && !!capabilities.workspace.configuration\n  );\n  hasWorkspaceFolderCapability = !!(\n    capabilities.workspace && !!capabilities.workspace.workspaceFolders\n  );\n\n  const result: InitializeResult = {\n    capabilities: {\n      textDocumentSync: TextDocumentSyncKind.Incremental,\n      // Tell the client that this server supports code completion.\n      completionProvider: {\n        resolveProvider: false,\n      },\n      hoverProvider: {\n        workDoneProgress: false,\n      },\n      definitionProvider: true,\n    },\n  };\n  if (hasWorkspaceFolderCapability) {\n    result.capabilities.workspace = {\n      workspaceFolders: {\n        supported: true,\n      },\n    };\n  }\n\n  fileAccessor = new VsCodeFileAccessor(documents);\n  pythonPath = params.initializationOptions?.pythonPath;\n\n  return result;\n});\n\nconnection.onInitialized(async () => {\n  if (hasConfigurationCapability) {\n    // Register for all configuration changes.\n    connection.client.register(\n      DidChangeConfigurationNotification.type,\n      undefined,\n    );\n  }\n  if (hasWorkspaceFolderCapability) {\n    connection.workspace.onDidChangeWorkspaceFolders((_event) => {\n      connection.console.log(\"Workspace folder change event received.\");\n    });\n  }\n\n  esphomeConnection.configure(await getSettings());\n\n  const validation = new Validation(\n    fileAccessor,\n    esphomeConnection,\n    sendDiagnostics,\n  );\n\n  documents.onDidOpen((e) => validation.onDocumentChange(e));\n\n  documents.onDidChangeContent((e) => validation.onDocumentChange(e));\n\n  const completionHandler = new CompletionsHandler(esphomeDocuments);\n  connection.onCompletion((p) => {\n    const doc = documents.get(p.textDocument.uri);\n    if (!doc) return;\n    esphomeDocuments.update(p.textDocument.uri, new TextBuffer(doc));\n    return completionHandler.getCompletions(p.textDocument.uri, p.position);\n  });\n\n  const hoverHandler = new HoverHandler(esphomeDocuments);\n  connection.onHover((p) => {\n    const doc = documents.get(p.textDocument.uri);\n    if (!doc) return;\n    esphomeDocuments.update(p.textDocument.uri, new TextBuffer(doc));\n    return hoverHandler.getHover(p.textDocument.uri, p.position);\n  });\n  const definitionHandler = new DefinitionHandler(esphomeDocuments);\n  connection.onDefinition((p) => {\n    const doc = documents.get(p.textDocument.uri);\n    if (!doc) return;\n    esphomeDocuments.update(p.textDocument.uri, new TextBuffer(doc));\n    return definitionHandler.getDefinition(p.textDocument.uri, p.position);\n  });\n});\n\nasync function getSettings(): Promise<ESPHomeSettings> {\n  let settings = !hasConfigurationCapability\n    ? globalSettings\n    : await connection.workspace.getConfiguration({\n        scopeUri: \".\",\n        section: \"esphome\",\n      });\n\n  return { ...settings, pythonPath };\n}\n\n// The global settings, used when the `workspace/configuration` request is not supported by the client.\n// Please note that this is not the case when using this server with the client provided in this example\n// but could happen with other clients.\nconst defaultSettings: ESPHomeSettings = { validator: \"local\" };\nlet globalSettings: ESPHomeSettings = defaultSettings;\n\nconnection.onDidChangeConfiguration(async (change) => {\n  esphomeConnection.configure(await getSettings());\n});\n\n// Only keep settings for open documents, and clear diagnostics.\ndocuments.onDidClose((e) => {\n  sendDiagnostics(e.document.uri, []);\n});\n\nconnection.onDidChangeWatchedFiles((_change) => {\n  // Monitored files have change in VSCode\n  // connection.console.log('We received an file change event');\n});\n\n// Make the text document manager listen on the connection\n// for open, change and close text document events\ndocuments.listen(connection);\n\n// Listen on the connection\nconnection.listen();\n","/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ----------------------------------------------------------------------------------------- */\n'use strict';\n\nmodule.exports = require('./lib/node/main');","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n/// <reference path=\"../../typings/thenable.d.ts\" />\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createConnection = exports.Files = void 0;\nconst node_util_1 = require(\"node:util\");\nconst Is = require(\"../common/utils/is\");\nconst server_1 = require(\"../common/server\");\nconst fm = require(\"./files\");\nconst node_1 = require(\"vscode-languageserver-protocol/node\");\n__exportStar(require(\"vscode-languageserver-protocol/node\"), exports);\n__exportStar(require(\"../common/api\"), exports);\nvar Files;\n(function (Files) {\n    Files.uriToFilePath = fm.uriToFilePath;\n    Files.resolveGlobalNodePath = fm.resolveGlobalNodePath;\n    Files.resolveGlobalYarnPath = fm.resolveGlobalYarnPath;\n    Files.resolve = fm.resolve;\n    Files.resolveModulePath = fm.resolveModulePath;\n})(Files || (exports.Files = Files = {}));\nlet _protocolConnection;\nfunction endProtocolConnection() {\n    if (_protocolConnection === undefined) {\n        return;\n    }\n    try {\n        _protocolConnection.end();\n    }\n    catch (_err) {\n        // Ignore. The client process could have already\n        // did and we can't send an end into the connection.\n    }\n}\nlet _shutdownReceived = false;\nlet exitTimer = undefined;\nfunction setupExitTimer() {\n    const argName = '--clientProcessId';\n    function runTimer(value) {\n        try {\n            let processId = parseInt(value);\n            if (!isNaN(processId)) {\n                exitTimer = setInterval(() => {\n                    try {\n                        process.kill(processId, 0);\n                    }\n                    catch (ex) {\n                        // Parent process doesn't exist anymore. Exit the server.\n                        endProtocolConnection();\n                        process.exit(_shutdownReceived ? 0 : 1);\n                    }\n                }, 3000);\n            }\n        }\n        catch (e) {\n            // Ignore errors;\n        }\n    }\n    for (let i = 2; i < process.argv.length; i++) {\n        let arg = process.argv[i];\n        if (arg === argName && i + 1 < process.argv.length) {\n            runTimer(process.argv[i + 1]);\n            return;\n        }\n        else {\n            let args = arg.split('=');\n            if (args[0] === argName) {\n                runTimer(args[1]);\n            }\n        }\n    }\n}\nsetupExitTimer();\nconst watchDog = {\n    initialize: (params) => {\n        const processId = params.processId;\n        if (Is.number(processId) && exitTimer === undefined) {\n            // We received a parent process id. Set up a timer to periodically check\n            // if the parent is still alive.\n            setInterval(() => {\n                try {\n                    process.kill(processId, 0);\n                }\n                catch (ex) {\n                    // Parent process doesn't exist anymore. Exit the server.\n                    process.exit(_shutdownReceived ? 0 : 1);\n                }\n            }, 3000);\n        }\n    },\n    get shutdownReceived() {\n        return _shutdownReceived;\n    },\n    set shutdownReceived(value) {\n        _shutdownReceived = value;\n    },\n    exit: (code) => {\n        endProtocolConnection();\n        process.exit(code);\n    }\n};\nfunction createConnection(arg1, arg2, arg3, arg4) {\n    let factories;\n    let input;\n    let output;\n    let options;\n    if (arg1 !== void 0 && arg1.__brand === 'features') {\n        factories = arg1;\n        arg1 = arg2;\n        arg2 = arg3;\n        arg3 = arg4;\n    }\n    if (node_1.ConnectionStrategy.is(arg1) || node_1.ConnectionOptions.is(arg1)) {\n        options = arg1;\n    }\n    else {\n        input = arg1;\n        output = arg2;\n        options = arg3;\n    }\n    return _createConnection(input, output, options, factories);\n}\nexports.createConnection = createConnection;\nfunction _createConnection(input, output, options, factories) {\n    let stdio = false;\n    if (!input && !output && process.argv.length > 2) {\n        let port = void 0;\n        let pipeName = void 0;\n        let argv = process.argv.slice(2);\n        for (let i = 0; i < argv.length; i++) {\n            let arg = argv[i];\n            if (arg === '--node-ipc') {\n                input = new node_1.IPCMessageReader(process);\n                output = new node_1.IPCMessageWriter(process);\n                break;\n            }\n            else if (arg === '--stdio') {\n                stdio = true;\n                input = process.stdin;\n                output = process.stdout;\n                break;\n            }\n            else if (arg === '--socket') {\n                port = parseInt(argv[i + 1]);\n                break;\n            }\n            else if (arg === '--pipe') {\n                pipeName = argv[i + 1];\n                break;\n            }\n            else {\n                var args = arg.split('=');\n                if (args[0] === '--socket') {\n                    port = parseInt(args[1]);\n                    break;\n                }\n                else if (args[0] === '--pipe') {\n                    pipeName = args[1];\n                    break;\n                }\n            }\n        }\n        if (port) {\n            let transport = (0, node_1.createServerSocketTransport)(port);\n            input = transport[0];\n            output = transport[1];\n        }\n        else if (pipeName) {\n            let transport = (0, node_1.createServerPipeTransport)(pipeName);\n            input = transport[0];\n            output = transport[1];\n        }\n    }\n    var commandLineMessage = 'Use arguments of createConnection or set command line parameters: \\'--node-ipc\\', \\'--stdio\\' or \\'--socket={number}\\'';\n    if (!input) {\n        throw new Error('Connection input stream is not set. ' + commandLineMessage);\n    }\n    if (!output) {\n        throw new Error('Connection output stream is not set. ' + commandLineMessage);\n    }\n    // Backwards compatibility\n    if (Is.func(input.read) && Is.func(input.on)) {\n        let inputStream = input;\n        inputStream.on('end', () => {\n            endProtocolConnection();\n            process.exit(_shutdownReceived ? 0 : 1);\n        });\n        inputStream.on('close', () => {\n            endProtocolConnection();\n            process.exit(_shutdownReceived ? 0 : 1);\n        });\n    }\n    const connectionFactory = (logger) => {\n        const result = (0, node_1.createProtocolConnection)(input, output, logger, options);\n        if (stdio) {\n            patchConsole(logger);\n        }\n        return result;\n    };\n    return (0, server_1.createConnection)(connectionFactory, watchDog, factories);\n}\nfunction patchConsole(logger) {\n    function serialize(args) {\n        return args.map(arg => typeof arg === 'string' ? arg : (0, node_util_1.inspect)(arg)).join(' ');\n    }\n    const counters = new Map();\n    console.assert = function assert(assertion, ...args) {\n        if (assertion) {\n            return;\n        }\n        if (args.length === 0) {\n            logger.error('Assertion failed');\n        }\n        else {\n            const [message, ...rest] = args;\n            logger.error(`Assertion failed: ${message} ${serialize(rest)}`);\n        }\n    };\n    console.count = function count(label = 'default') {\n        const message = String(label);\n        let counter = counters.get(message) ?? 0;\n        counter += 1;\n        counters.set(message, counter);\n        logger.log(`${message}: ${message}`);\n    };\n    console.countReset = function countReset(label) {\n        if (label === undefined) {\n            counters.clear();\n        }\n        else {\n            counters.delete(String(label));\n        }\n    };\n    console.debug = function debug(...args) {\n        logger.log(serialize(args));\n    };\n    console.dir = function dir(arg, options) {\n        // @ts-expect-error https://github.com/DefinitelyTyped/DefinitelyTyped/pull/66626\n        logger.log((0, node_util_1.inspect)(arg, options));\n    };\n    console.log = function log(...args) {\n        logger.log(serialize(args));\n    };\n    console.error = function error(...args) {\n        logger.error(serialize(args));\n    };\n    console.trace = function trace(...args) {\n        const stack = new Error().stack.replace(/(.+\\n){2}/, '');\n        let message = 'Trace';\n        if (args.length !== 0) {\n            message += `: ${serialize(args)}`;\n        }\n        logger.log(`${message}\\n${stack}`);\n    };\n    console.warn = function warn(...args) {\n        logger.warn(serialize(args));\n    };\n}\n","module.exports = require(\"node:util\");","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.thenable = exports.typedArray = exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;\nfunction boolean(value) {\n    return value === true || value === false;\n}\nexports.boolean = boolean;\nfunction string(value) {\n    return typeof value === 'string' || value instanceof String;\n}\nexports.string = string;\nfunction number(value) {\n    return typeof value === 'number' || value instanceof Number;\n}\nexports.number = number;\nfunction error(value) {\n    return value instanceof Error;\n}\nexports.error = error;\nfunction func(value) {\n    return typeof value === 'function';\n}\nexports.func = func;\nfunction array(value) {\n    return Array.isArray(value);\n}\nexports.array = array;\nfunction stringArray(value) {\n    return array(value) && value.every(elem => string(elem));\n}\nexports.stringArray = stringArray;\nfunction typedArray(value, check) {\n    return Array.isArray(value) && value.every(check);\n}\nexports.typedArray = typedArray;\nfunction thenable(value) {\n    return value && func(value.then);\n}\nexports.thenable = thenable;\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createConnection = exports.combineFeatures = exports.combineNotebooksFeatures = exports.combineLanguagesFeatures = exports.combineWorkspaceFeatures = exports.combineWindowFeatures = exports.combineClientFeatures = exports.combineTracerFeatures = exports.combineTelemetryFeatures = exports.combineConsoleFeatures = exports._NotebooksImpl = exports._LanguagesImpl = exports.BulkUnregistration = exports.BulkRegistration = exports.ErrorMessageTracker = void 0;\nconst vscode_languageserver_protocol_1 = require(\"vscode-languageserver-protocol\");\nconst Is = require(\"./utils/is\");\nconst UUID = require(\"./utils/uuid\");\nconst progress_1 = require(\"./progress\");\nconst configuration_1 = require(\"./configuration\");\nconst workspaceFolder_1 = require(\"./workspaceFolder\");\nconst callHierarchy_1 = require(\"./callHierarchy\");\nconst semanticTokens_1 = require(\"./semanticTokens\");\nconst showDocument_1 = require(\"./showDocument\");\nconst fileOperations_1 = require(\"./fileOperations\");\nconst linkedEditingRange_1 = require(\"./linkedEditingRange\");\nconst typeHierarchy_1 = require(\"./typeHierarchy\");\nconst inlineValue_1 = require(\"./inlineValue\");\nconst foldingRange_1 = require(\"./foldingRange\");\n// import { InlineCompletionFeatureShape, InlineCompletionFeature } from './inlineCompletion.proposed';\nconst inlayHint_1 = require(\"./inlayHint\");\nconst diagnostic_1 = require(\"./diagnostic\");\nconst notebook_1 = require(\"./notebook\");\nconst moniker_1 = require(\"./moniker\");\nfunction null2Undefined(value) {\n    if (value === null) {\n        return undefined;\n    }\n    return value;\n}\n/**\n * Helps tracking error message. Equal occurrences of the same\n * message are only stored once. This class is for example\n * useful if text documents are validated in a loop and equal\n * error message should be folded into one.\n */\nclass ErrorMessageTracker {\n    constructor() {\n        this._messages = Object.create(null);\n    }\n    /**\n     * Add a message to the tracker.\n     *\n     * @param message The message to add.\n     */\n    add(message) {\n        let count = this._messages[message];\n        if (!count) {\n            count = 0;\n        }\n        count++;\n        this._messages[message] = count;\n    }\n    /**\n     * Send all tracked messages to the connection's window.\n     *\n     * @param connection The connection established between client and server.\n     */\n    sendErrors(connection) {\n        Object.keys(this._messages).forEach(message => {\n            connection.window.showErrorMessage(message);\n        });\n    }\n}\nexports.ErrorMessageTracker = ErrorMessageTracker;\nclass RemoteConsoleImpl {\n    constructor() {\n    }\n    rawAttach(connection) {\n        this._rawConnection = connection;\n    }\n    attach(connection) {\n        this._connection = connection;\n    }\n    get connection() {\n        if (!this._connection) {\n            throw new Error('Remote is not attached to a connection yet.');\n        }\n        return this._connection;\n    }\n    fillServerCapabilities(_capabilities) {\n    }\n    initialize(_capabilities) {\n    }\n    error(message) {\n        this.send(vscode_languageserver_protocol_1.MessageType.Error, message);\n    }\n    warn(message) {\n        this.send(vscode_languageserver_protocol_1.MessageType.Warning, message);\n    }\n    info(message) {\n        this.send(vscode_languageserver_protocol_1.MessageType.Info, message);\n    }\n    log(message) {\n        this.send(vscode_languageserver_protocol_1.MessageType.Log, message);\n    }\n    debug(message) {\n        this.send(vscode_languageserver_protocol_1.MessageType.Debug, message);\n    }\n    send(type, message) {\n        if (this._rawConnection) {\n            this._rawConnection.sendNotification(vscode_languageserver_protocol_1.LogMessageNotification.type, { type, message }).catch(() => {\n                (0, vscode_languageserver_protocol_1.RAL)().console.error(`Sending log message failed`);\n            });\n        }\n    }\n}\nclass _RemoteWindowImpl {\n    constructor() {\n    }\n    attach(connection) {\n        this._connection = connection;\n    }\n    get connection() {\n        if (!this._connection) {\n            throw new Error('Remote is not attached to a connection yet.');\n        }\n        return this._connection;\n    }\n    initialize(_capabilities) {\n    }\n    fillServerCapabilities(_capabilities) {\n    }\n    showErrorMessage(message, ...actions) {\n        let params = { type: vscode_languageserver_protocol_1.MessageType.Error, message, actions };\n        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);\n    }\n    showWarningMessage(message, ...actions) {\n        let params = { type: vscode_languageserver_protocol_1.MessageType.Warning, message, actions };\n        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);\n    }\n    showInformationMessage(message, ...actions) {\n        let params = { type: vscode_languageserver_protocol_1.MessageType.Info, message, actions };\n        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);\n    }\n}\nconst RemoteWindowImpl = (0, showDocument_1.ShowDocumentFeature)((0, progress_1.ProgressFeature)(_RemoteWindowImpl));\nvar BulkRegistration;\n(function (BulkRegistration) {\n    /**\n     * Creates a new bulk registration.\n     * @return an empty bulk registration.\n     */\n    function create() {\n        return new BulkRegistrationImpl();\n    }\n    BulkRegistration.create = create;\n})(BulkRegistration || (exports.BulkRegistration = BulkRegistration = {}));\nclass BulkRegistrationImpl {\n    constructor() {\n        this._registrations = [];\n        this._registered = new Set();\n    }\n    add(type, registerOptions) {\n        const method = Is.string(type) ? type : type.method;\n        if (this._registered.has(method)) {\n            throw new Error(`${method} is already added to this registration`);\n        }\n        const id = UUID.generateUuid();\n        this._registrations.push({\n            id: id,\n            method: method,\n            registerOptions: registerOptions || {}\n        });\n        this._registered.add(method);\n    }\n    asRegistrationParams() {\n        return {\n            registrations: this._registrations\n        };\n    }\n}\nvar BulkUnregistration;\n(function (BulkUnregistration) {\n    function create() {\n        return new BulkUnregistrationImpl(undefined, []);\n    }\n    BulkUnregistration.create = create;\n})(BulkUnregistration || (exports.BulkUnregistration = BulkUnregistration = {}));\nclass BulkUnregistrationImpl {\n    constructor(_connection, unregistrations) {\n        this._connection = _connection;\n        this._unregistrations = new Map();\n        unregistrations.forEach(unregistration => {\n            this._unregistrations.set(unregistration.method, unregistration);\n        });\n    }\n    get isAttached() {\n        return !!this._connection;\n    }\n    attach(connection) {\n        this._connection = connection;\n    }\n    add(unregistration) {\n        this._unregistrations.set(unregistration.method, unregistration);\n    }\n    dispose() {\n        let unregistrations = [];\n        for (let unregistration of this._unregistrations.values()) {\n            unregistrations.push(unregistration);\n        }\n        let params = {\n            unregisterations: unregistrations\n        };\n        this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).catch(() => {\n            this._connection.console.info(`Bulk unregistration failed.`);\n        });\n    }\n    disposeSingle(arg) {\n        const method = Is.string(arg) ? arg : arg.method;\n        const unregistration = this._unregistrations.get(method);\n        if (!unregistration) {\n            return false;\n        }\n        let params = {\n            unregisterations: [unregistration]\n        };\n        this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).then(() => {\n            this._unregistrations.delete(method);\n        }, (_error) => {\n            this._connection.console.info(`Un-registering request handler for ${unregistration.id} failed.`);\n        });\n        return true;\n    }\n}\nclass RemoteClientImpl {\n    attach(connection) {\n        this._connection = connection;\n    }\n    get connection() {\n        if (!this._connection) {\n            throw new Error('Remote is not attached to a connection yet.');\n        }\n        return this._connection;\n    }\n    initialize(_capabilities) {\n    }\n    fillServerCapabilities(_capabilities) {\n    }\n    register(typeOrRegistrations, registerOptionsOrType, registerOptions) {\n        if (typeOrRegistrations instanceof BulkRegistrationImpl) {\n            return this.registerMany(typeOrRegistrations);\n        }\n        else if (typeOrRegistrations instanceof BulkUnregistrationImpl) {\n            return this.registerSingle1(typeOrRegistrations, registerOptionsOrType, registerOptions);\n        }\n        else {\n            return this.registerSingle2(typeOrRegistrations, registerOptionsOrType);\n        }\n    }\n    registerSingle1(unregistration, type, registerOptions) {\n        const method = Is.string(type) ? type : type.method;\n        const id = UUID.generateUuid();\n        let params = {\n            registrations: [{ id, method, registerOptions: registerOptions || {} }]\n        };\n        if (!unregistration.isAttached) {\n            unregistration.attach(this.connection);\n        }\n        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {\n            unregistration.add({ id: id, method: method });\n            return unregistration;\n        }, (_error) => {\n            this.connection.console.info(`Registering request handler for ${method} failed.`);\n            return Promise.reject(_error);\n        });\n    }\n    registerSingle2(type, registerOptions) {\n        const method = Is.string(type) ? type : type.method;\n        const id = UUID.generateUuid();\n        let params = {\n            registrations: [{ id, method, registerOptions: registerOptions || {} }]\n        };\n        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {\n            return vscode_languageserver_protocol_1.Disposable.create(() => {\n                this.unregisterSingle(id, method).catch(() => { this.connection.console.info(`Un-registering capability with id ${id} failed.`); });\n            });\n        }, (_error) => {\n            this.connection.console.info(`Registering request handler for ${method} failed.`);\n            return Promise.reject(_error);\n        });\n    }\n    unregisterSingle(id, method) {\n        let params = {\n            unregisterations: [{ id, method }]\n        };\n        return this.connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).catch(() => {\n            this.connection.console.info(`Un-registering request handler for ${id} failed.`);\n        });\n    }\n    registerMany(registrations) {\n        let params = registrations.asRegistrationParams();\n        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then(() => {\n            return new BulkUnregistrationImpl(this._connection, params.registrations.map(registration => { return { id: registration.id, method: registration.method }; }));\n        }, (_error) => {\n            this.connection.console.info(`Bulk registration failed.`);\n            return Promise.reject(_error);\n        });\n    }\n}\nclass _RemoteWorkspaceImpl {\n    constructor() {\n    }\n    attach(connection) {\n        this._connection = connection;\n    }\n    get connection() {\n        if (!this._connection) {\n            throw new Error('Remote is not attached to a connection yet.');\n        }\n        return this._connection;\n    }\n    initialize(_capabilities) {\n    }\n    fillServerCapabilities(_capabilities) {\n    }\n    applyEdit(paramOrEdit) {\n        function isApplyWorkspaceEditParams(value) {\n            return value && !!value.edit;\n        }\n        let params = isApplyWorkspaceEditParams(paramOrEdit) ? paramOrEdit : { edit: paramOrEdit };\n        return this.connection.sendRequest(vscode_languageserver_protocol_1.ApplyWorkspaceEditRequest.type, params);\n    }\n}\nconst RemoteWorkspaceImpl = (0, fileOperations_1.FileOperationsFeature)((0, workspaceFolder_1.WorkspaceFoldersFeature)((0, configuration_1.ConfigurationFeature)(_RemoteWorkspaceImpl)));\nclass TracerImpl {\n    constructor() {\n        this._trace = vscode_languageserver_protocol_1.Trace.Off;\n    }\n    attach(connection) {\n        this._connection = connection;\n    }\n    get connection() {\n        if (!this._connection) {\n            throw new Error('Remote is not attached to a connection yet.');\n        }\n        return this._connection;\n    }\n    initialize(_capabilities) {\n    }\n    fillServerCapabilities(_capabilities) {\n    }\n    set trace(value) {\n        this._trace = value;\n    }\n    log(message, verbose) {\n        if (this._trace === vscode_languageserver_protocol_1.Trace.Off) {\n            return;\n        }\n        this.connection.sendNotification(vscode_languageserver_protocol_1.LogTraceNotification.type, {\n            message: message,\n            verbose: this._trace === vscode_languageserver_protocol_1.Trace.Verbose ? verbose : undefined\n        }).catch(() => {\n            // Very hard to decide what to do. We tried to send a log\n            // message which failed so we can't simply send another :-(.\n        });\n    }\n}\nclass TelemetryImpl {\n    constructor() {\n    }\n    attach(connection) {\n        this._connection = connection;\n    }\n    get connection() {\n        if (!this._connection) {\n            throw new Error('Remote is not attached to a connection yet.');\n        }\n        return this._connection;\n    }\n    initialize(_capabilities) {\n    }\n    fillServerCapabilities(_capabilities) {\n    }\n    logEvent(data) {\n        this.connection.sendNotification(vscode_languageserver_protocol_1.TelemetryEventNotification.type, data).catch(() => {\n            this.connection.console.log(`Sending TelemetryEventNotification failed`);\n        });\n    }\n}\nclass _LanguagesImpl {\n    constructor() {\n    }\n    attach(connection) {\n        this._connection = connection;\n    }\n    get connection() {\n        if (!this._connection) {\n            throw new Error('Remote is not attached to a connection yet.');\n        }\n        return this._connection;\n    }\n    initialize(_capabilities) {\n    }\n    fillServerCapabilities(_capabilities) {\n    }\n    attachWorkDoneProgress(params) {\n        return (0, progress_1.attachWorkDone)(this.connection, params);\n    }\n    attachPartialResultProgress(_type, params) {\n        return (0, progress_1.attachPartialResult)(this.connection, params);\n    }\n}\nexports._LanguagesImpl = _LanguagesImpl;\nconst LanguagesImpl = (0, foldingRange_1.FoldingRangeFeature)((0, moniker_1.MonikerFeature)((0, diagnostic_1.DiagnosticFeature)((0, inlayHint_1.InlayHintFeature)((0, inlineValue_1.InlineValueFeature)((0, typeHierarchy_1.TypeHierarchyFeature)((0, linkedEditingRange_1.LinkedEditingRangeFeature)((0, semanticTokens_1.SemanticTokensFeature)((0, callHierarchy_1.CallHierarchyFeature)(_LanguagesImpl)))))))));\nclass _NotebooksImpl {\n    constructor() {\n    }\n    attach(connection) {\n        this._connection = connection;\n    }\n    get connection() {\n        if (!this._connection) {\n            throw new Error('Remote is not attached to a connection yet.');\n        }\n        return this._connection;\n    }\n    initialize(_capabilities) {\n    }\n    fillServerCapabilities(_capabilities) {\n    }\n    attachWorkDoneProgress(params) {\n        return (0, progress_1.attachWorkDone)(this.connection, params);\n    }\n    attachPartialResultProgress(_type, params) {\n        return (0, progress_1.attachPartialResult)(this.connection, params);\n    }\n}\nexports._NotebooksImpl = _NotebooksImpl;\nconst NotebooksImpl = (0, notebook_1.NotebookSyncFeature)(_NotebooksImpl);\nfunction combineConsoleFeatures(one, two) {\n    return function (Base) {\n        return two(one(Base));\n    };\n}\nexports.combineConsoleFeatures = combineConsoleFeatures;\nfunction combineTelemetryFeatures(one, two) {\n    return function (Base) {\n        return two(one(Base));\n    };\n}\nexports.combineTelemetryFeatures = combineTelemetryFeatures;\nfunction combineTracerFeatures(one, two) {\n    return function (Base) {\n        return two(one(Base));\n    };\n}\nexports.combineTracerFeatures = combineTracerFeatures;\nfunction combineClientFeatures(one, two) {\n    return function (Base) {\n        return two(one(Base));\n    };\n}\nexports.combineClientFeatures = combineClientFeatures;\nfunction combineWindowFeatures(one, two) {\n    return function (Base) {\n        return two(one(Base));\n    };\n}\nexports.combineWindowFeatures = combineWindowFeatures;\nfunction combineWorkspaceFeatures(one, two) {\n    return function (Base) {\n        return two(one(Base));\n    };\n}\nexports.combineWorkspaceFeatures = combineWorkspaceFeatures;\nfunction combineLanguagesFeatures(one, two) {\n    return function (Base) {\n        return two(one(Base));\n    };\n}\nexports.combineLanguagesFeatures = combineLanguagesFeatures;\nfunction combineNotebooksFeatures(one, two) {\n    return function (Base) {\n        return two(one(Base));\n    };\n}\nexports.combineNotebooksFeatures = combineNotebooksFeatures;\nfunction combineFeatures(one, two) {\n    function combine(one, two, func) {\n        if (one && two) {\n            return func(one, two);\n        }\n        else if (one) {\n            return one;\n        }\n        else {\n            return two;\n        }\n    }\n    let result = {\n        __brand: 'features',\n        console: combine(one.console, two.console, combineConsoleFeatures),\n        tracer: combine(one.tracer, two.tracer, combineTracerFeatures),\n        telemetry: combine(one.telemetry, two.telemetry, combineTelemetryFeatures),\n        client: combine(one.client, two.client, combineClientFeatures),\n        window: combine(one.window, two.window, combineWindowFeatures),\n        workspace: combine(one.workspace, two.workspace, combineWorkspaceFeatures),\n        languages: combine(one.languages, two.languages, combineLanguagesFeatures),\n        notebooks: combine(one.notebooks, two.notebooks, combineNotebooksFeatures)\n    };\n    return result;\n}\nexports.combineFeatures = combineFeatures;\nfunction createConnection(connectionFactory, watchDog, factories) {\n    const logger = (factories && factories.console ? new (factories.console(RemoteConsoleImpl))() : new RemoteConsoleImpl());\n    const connection = connectionFactory(logger);\n    logger.rawAttach(connection);\n    const tracer = (factories && factories.tracer ? new (factories.tracer(TracerImpl))() : new TracerImpl());\n    const telemetry = (factories && factories.telemetry ? new (factories.telemetry(TelemetryImpl))() : new TelemetryImpl());\n    const client = (factories && factories.client ? new (factories.client(RemoteClientImpl))() : new RemoteClientImpl());\n    const remoteWindow = (factories && factories.window ? new (factories.window(RemoteWindowImpl))() : new RemoteWindowImpl());\n    const workspace = (factories && factories.workspace ? new (factories.workspace(RemoteWorkspaceImpl))() : new RemoteWorkspaceImpl());\n    const languages = (factories && factories.languages ? new (factories.languages(LanguagesImpl))() : new LanguagesImpl());\n    const notebooks = (factories && factories.notebooks ? new (factories.notebooks(NotebooksImpl))() : new NotebooksImpl());\n    const allRemotes = [logger, tracer, telemetry, client, remoteWindow, workspace, languages, notebooks];\n    function asPromise(value) {\n        if (value instanceof Promise) {\n            return value;\n        }\n        else if (Is.thenable(value)) {\n            return new Promise((resolve, reject) => {\n                value.then((resolved) => resolve(resolved), (error) => reject(error));\n            });\n        }\n        else {\n            return Promise.resolve(value);\n        }\n    }\n    let shutdownHandler = undefined;\n    let initializeHandler = undefined;\n    let exitHandler = undefined;\n    let protocolConnection = {\n        listen: () => connection.listen(),\n        sendRequest: (type, ...params) => connection.sendRequest(Is.string(type) ? type : type.method, ...params),\n        onRequest: (type, handler) => connection.onRequest(type, handler),\n        sendNotification: (type, param) => {\n            const method = Is.string(type) ? type : type.method;\n            return connection.sendNotification(method, param);\n        },\n        onNotification: (type, handler) => connection.onNotification(type, handler),\n        onProgress: connection.onProgress,\n        sendProgress: connection.sendProgress,\n        onInitialize: (handler) => {\n            initializeHandler = handler;\n            return {\n                dispose: () => {\n                    initializeHandler = undefined;\n                }\n            };\n        },\n        onInitialized: (handler) => connection.onNotification(vscode_languageserver_protocol_1.InitializedNotification.type, handler),\n        onShutdown: (handler) => {\n            shutdownHandler = handler;\n            return {\n                dispose: () => {\n                    shutdownHandler = undefined;\n                }\n            };\n        },\n        onExit: (handler) => {\n            exitHandler = handler;\n            return {\n                dispose: () => {\n                    exitHandler = undefined;\n                }\n            };\n        },\n        get console() { return logger; },\n        get telemetry() { return telemetry; },\n        get tracer() { return tracer; },\n        get client() { return client; },\n        get window() { return remoteWindow; },\n        get workspace() { return workspace; },\n        get languages() { return languages; },\n        get notebooks() { return notebooks; },\n        onDidChangeConfiguration: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, handler),\n        onDidChangeWatchedFiles: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type, handler),\n        __textDocumentSync: undefined,\n        onDidOpenTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type, handler),\n        onDidChangeTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, handler),\n        onDidCloseTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type, handler),\n        onWillSaveTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type, handler),\n        onWillSaveTextDocumentWaitUntil: (handler) => connection.onRequest(vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type, handler),\n        onDidSaveTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type, handler),\n        sendDiagnostics: (params) => connection.sendNotification(vscode_languageserver_protocol_1.PublishDiagnosticsNotification.type, params),\n        onHover: (handler) => connection.onRequest(vscode_languageserver_protocol_1.HoverRequest.type, (params, cancel) => {\n            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), undefined);\n        }),\n        onCompletion: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CompletionRequest.type, (params, cancel) => {\n            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));\n        }),\n        onCompletionResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, handler),\n        onSignatureHelp: (handler) => connection.onRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, (params, cancel) => {\n            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), undefined);\n        }),\n        onDeclaration: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DeclarationRequest.type, (params, cancel) => {\n            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));\n        }),\n        onDefinition: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, (params, cancel) => {\n            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));\n        }),\n        onTypeDefinition: (handler) => connection.onRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, (params, cancel) => {\n            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));\n        }),\n        onImplementation: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, (params, cancel) => {\n            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));\n        }),\n        onReferences: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, (params, cancel) => {\n            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));\n        }),\n        onDocumentHighlight: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, (params, cancel) => {\n            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));\n        }),\n        onDocumentSymbol: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, (params, cancel) => {\n            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));\n        }),\n        onWorkspaceSymbol: (handler) => connection.onRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, (params, cancel) => {\n            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));\n        }),\n        onWorkspaceSymbolResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.WorkspaceSymbolResolveRequest.type, handler),\n        onCodeAction: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, (params, cancel) => {\n            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));\n        }),\n        onCodeActionResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeActionResolveRequest.type, (params, cancel) => {\n            return handler(params, cancel);\n        }),\n        onCodeLens: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, (params, cancel) => {\n            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));\n        }),\n        onCodeLensResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, (params, cancel) => {\n            return handler(params, cancel);\n        }),\n        onDocumentFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, (params, cancel) => {\n            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), undefined);\n        }),\n        onDocumentRangeFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, (params, cancel) => {\n            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), undefined);\n        }),\n        onDocumentOnTypeFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, (params, cancel) => {\n            return handler(params, cancel);\n        }),\n        onRenameRequest: (handler) => connection.onRequest(vscode_languageserver_protocol_1.RenameRequest.type, (params, cancel) => {\n            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), undefined);\n        }),\n        onPrepareRename: (handler) => connection.onRequest(vscode_languageserver_protocol_1.PrepareRenameRequest.type, (params, cancel) => {\n            return handler(params, cancel);\n        }),\n        onDocumentLinks: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, (params, cancel) => {\n            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));\n        }),\n        onDocumentLinkResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, (params, cancel) => {\n            return handler(params, cancel);\n        }),\n        onDocumentColor: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentColorRequest.type, (params, cancel) => {\n            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));\n        }),\n        onColorPresentation: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, (params, cancel) => {\n            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));\n        }),\n        onFoldingRanges: (handler) => connection.onRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, (params, cancel) => {\n            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));\n        }),\n        onSelectionRanges: (handler) => connection.onRequest(vscode_languageserver_protocol_1.SelectionRangeRequest.type, (params, cancel) => {\n            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));\n        }),\n        onExecuteCommand: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, (params, cancel) => {\n            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), undefined);\n        }),\n        dispose: () => connection.dispose()\n    };\n    for (let remote of allRemotes) {\n        remote.attach(protocolConnection);\n    }\n    connection.onRequest(vscode_languageserver_protocol_1.InitializeRequest.type, (params) => {\n        watchDog.initialize(params);\n        if (Is.string(params.trace)) {\n            tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.trace);\n        }\n        for (let remote of allRemotes) {\n            remote.initialize(params.capabilities);\n        }\n        if (initializeHandler) {\n            let result = initializeHandler(params, new vscode_languageserver_protocol_1.CancellationTokenSource().token, (0, progress_1.attachWorkDone)(connection, params), undefined);\n            return asPromise(result).then((value) => {\n                if (value instanceof vscode_languageserver_protocol_1.ResponseError) {\n                    return value;\n                }\n                let result = value;\n                if (!result) {\n                    result = { capabilities: {} };\n                }\n                let capabilities = result.capabilities;\n                if (!capabilities) {\n                    capabilities = {};\n                    result.capabilities = capabilities;\n                }\n                if (capabilities.textDocumentSync === undefined || capabilities.textDocumentSync === null) {\n                    capabilities.textDocumentSync = Is.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;\n                }\n                else if (!Is.number(capabilities.textDocumentSync) && !Is.number(capabilities.textDocumentSync.change)) {\n                    capabilities.textDocumentSync.change = Is.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;\n                }\n                for (let remote of allRemotes) {\n                    remote.fillServerCapabilities(capabilities);\n                }\n                return result;\n            });\n        }\n        else {\n            let result = { capabilities: { textDocumentSync: vscode_languageserver_protocol_1.TextDocumentSyncKind.None } };\n            for (let remote of allRemotes) {\n                remote.fillServerCapabilities(result.capabilities);\n            }\n            return result;\n        }\n    });\n    connection.onRequest(vscode_languageserver_protocol_1.ShutdownRequest.type, () => {\n        watchDog.shutdownReceived = true;\n        if (shutdownHandler) {\n            return shutdownHandler(new vscode_languageserver_protocol_1.CancellationTokenSource().token);\n        }\n        else {\n            return undefined;\n        }\n    });\n    connection.onNotification(vscode_languageserver_protocol_1.ExitNotification.type, () => {\n        try {\n            if (exitHandler) {\n                exitHandler();\n            }\n        }\n        finally {\n            if (watchDog.shutdownReceived) {\n                watchDog.exit(0);\n            }\n            else {\n                watchDog.exit(1);\n            }\n        }\n    });\n    connection.onNotification(vscode_languageserver_protocol_1.SetTraceNotification.type, (params) => {\n        tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.value);\n    });\n    return protocolConnection;\n}\nexports.createConnection = createConnection;\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createProtocolConnection = void 0;\nconst node_1 = require(\"vscode-jsonrpc/node\");\n__exportStar(require(\"vscode-jsonrpc/node\"), exports);\n__exportStar(require(\"../common/api\"), exports);\nfunction createProtocolConnection(input, output, logger, options) {\n    return (0, node_1.createMessageConnection)(input, output, logger, options);\n}\nexports.createProtocolConnection = createProtocolConnection;\n","/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ----------------------------------------------------------------------------------------- */\n'use strict';\n\nmodule.exports = require('./lib/node/main');","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createMessageConnection = exports.createServerSocketTransport = exports.createClientSocketTransport = exports.createServerPipeTransport = exports.createClientPipeTransport = exports.generateRandomPipeName = exports.StreamMessageWriter = exports.StreamMessageReader = exports.SocketMessageWriter = exports.SocketMessageReader = exports.PortMessageWriter = exports.PortMessageReader = exports.IPCMessageWriter = exports.IPCMessageReader = void 0;\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ----------------------------------------------------------------------------------------- */\nconst ril_1 = require(\"./ril\");\n// Install the node runtime abstract.\nril_1.default.install();\nconst path = require(\"path\");\nconst os = require(\"os\");\nconst crypto_1 = require(\"crypto\");\nconst net_1 = require(\"net\");\nconst api_1 = require(\"../common/api\");\n__exportStar(require(\"../common/api\"), exports);\nclass IPCMessageReader extends api_1.AbstractMessageReader {\n    constructor(process) {\n        super();\n        this.process = process;\n        let eventEmitter = this.process;\n        eventEmitter.on('error', (error) => this.fireError(error));\n        eventEmitter.on('close', () => this.fireClose());\n    }\n    listen(callback) {\n        this.process.on('message', callback);\n        return api_1.Disposable.create(() => this.process.off('message', callback));\n    }\n}\nexports.IPCMessageReader = IPCMessageReader;\nclass IPCMessageWriter extends api_1.AbstractMessageWriter {\n    constructor(process) {\n        super();\n        this.process = process;\n        this.errorCount = 0;\n        const eventEmitter = this.process;\n        eventEmitter.on('error', (error) => this.fireError(error));\n        eventEmitter.on('close', () => this.fireClose);\n    }\n    write(msg) {\n        try {\n            if (typeof this.process.send === 'function') {\n                this.process.send(msg, undefined, undefined, (error) => {\n                    if (error) {\n                        this.errorCount++;\n                        this.handleError(error, msg);\n                    }\n                    else {\n                        this.errorCount = 0;\n                    }\n                });\n            }\n            return Promise.resolve();\n        }\n        catch (error) {\n            this.handleError(error, msg);\n            return Promise.reject(error);\n        }\n    }\n    handleError(error, msg) {\n        this.errorCount++;\n        this.fireError(error, msg, this.errorCount);\n    }\n    end() {\n    }\n}\nexports.IPCMessageWriter = IPCMessageWriter;\nclass PortMessageReader extends api_1.AbstractMessageReader {\n    constructor(port) {\n        super();\n        this.onData = new api_1.Emitter;\n        port.on('close', () => this.fireClose);\n        port.on('error', (error) => this.fireError(error));\n        port.on('message', (message) => {\n            this.onData.fire(message);\n        });\n    }\n    listen(callback) {\n        return this.onData.event(callback);\n    }\n}\nexports.PortMessageReader = PortMessageReader;\nclass PortMessageWriter extends api_1.AbstractMessageWriter {\n    constructor(port) {\n        super();\n        this.port = port;\n        this.errorCount = 0;\n        port.on('close', () => this.fireClose());\n        port.on('error', (error) => this.fireError(error));\n    }\n    write(msg) {\n        try {\n            this.port.postMessage(msg);\n            return Promise.resolve();\n        }\n        catch (error) {\n            this.handleError(error, msg);\n            return Promise.reject(error);\n        }\n    }\n    handleError(error, msg) {\n        this.errorCount++;\n        this.fireError(error, msg, this.errorCount);\n    }\n    end() {\n    }\n}\nexports.PortMessageWriter = PortMessageWriter;\nclass SocketMessageReader extends api_1.ReadableStreamMessageReader {\n    constructor(socket, encoding = 'utf-8') {\n        super((0, ril_1.default)().stream.asReadableStream(socket), encoding);\n    }\n}\nexports.SocketMessageReader = SocketMessageReader;\nclass SocketMessageWriter extends api_1.WriteableStreamMessageWriter {\n    constructor(socket, options) {\n        super((0, ril_1.default)().stream.asWritableStream(socket), options);\n        this.socket = socket;\n    }\n    dispose() {\n        super.dispose();\n        this.socket.destroy();\n    }\n}\nexports.SocketMessageWriter = SocketMessageWriter;\nclass StreamMessageReader extends api_1.ReadableStreamMessageReader {\n    constructor(readable, encoding) {\n        super((0, ril_1.default)().stream.asReadableStream(readable), encoding);\n    }\n}\nexports.StreamMessageReader = StreamMessageReader;\nclass StreamMessageWriter extends api_1.WriteableStreamMessageWriter {\n    constructor(writable, options) {\n        super((0, ril_1.default)().stream.asWritableStream(writable), options);\n    }\n}\nexports.StreamMessageWriter = StreamMessageWriter;\nconst XDG_RUNTIME_DIR = process.env['XDG_RUNTIME_DIR'];\nconst safeIpcPathLengths = new Map([\n    ['linux', 107],\n    ['darwin', 103]\n]);\nfunction generateRandomPipeName() {\n    const randomSuffix = (0, crypto_1.randomBytes)(21).toString('hex');\n    if (process.platform === 'win32') {\n        return `\\\\\\\\.\\\\pipe\\\\vscode-jsonrpc-${randomSuffix}-sock`;\n    }\n    let result;\n    if (XDG_RUNTIME_DIR) {\n        result = path.join(XDG_RUNTIME_DIR, `vscode-ipc-${randomSuffix}.sock`);\n    }\n    else {\n        result = path.join(os.tmpdir(), `vscode-${randomSuffix}.sock`);\n    }\n    const limit = safeIpcPathLengths.get(process.platform);\n    if (limit !== undefined && result.length > limit) {\n        (0, ril_1.default)().console.warn(`WARNING: IPC handle \"${result}\" is longer than ${limit} characters.`);\n    }\n    return result;\n}\nexports.generateRandomPipeName = generateRandomPipeName;\nfunction createClientPipeTransport(pipeName, encoding = 'utf-8') {\n    let connectResolve;\n    const connected = new Promise((resolve, _reject) => {\n        connectResolve = resolve;\n    });\n    return new Promise((resolve, reject) => {\n        let server = (0, net_1.createServer)((socket) => {\n            server.close();\n            connectResolve([\n                new SocketMessageReader(socket, encoding),\n                new SocketMessageWriter(socket, encoding)\n            ]);\n        });\n        server.on('error', reject);\n        server.listen(pipeName, () => {\n            server.removeListener('error', reject);\n            resolve({\n                onConnected: () => { return connected; }\n            });\n        });\n    });\n}\nexports.createClientPipeTransport = createClientPipeTransport;\nfunction createServerPipeTransport(pipeName, encoding = 'utf-8') {\n    const socket = (0, net_1.createConnection)(pipeName);\n    return [\n        new SocketMessageReader(socket, encoding),\n        new SocketMessageWriter(socket, encoding)\n    ];\n}\nexports.createServerPipeTransport = createServerPipeTransport;\nfunction createClientSocketTransport(port, encoding = 'utf-8') {\n    let connectResolve;\n    const connected = new Promise((resolve, _reject) => {\n        connectResolve = resolve;\n    });\n    return new Promise((resolve, reject) => {\n        const server = (0, net_1.createServer)((socket) => {\n            server.close();\n            connectResolve([\n                new SocketMessageReader(socket, encoding),\n                new SocketMessageWriter(socket, encoding)\n            ]);\n        });\n        server.on('error', reject);\n        server.listen(port, '127.0.0.1', () => {\n            server.removeListener('error', reject);\n            resolve({\n                onConnected: () => { return connected; }\n            });\n        });\n    });\n}\nexports.createClientSocketTransport = createClientSocketTransport;\nfunction createServerSocketTransport(port, encoding = 'utf-8') {\n    const socket = (0, net_1.createConnection)(port, '127.0.0.1');\n    return [\n        new SocketMessageReader(socket, encoding),\n        new SocketMessageWriter(socket, encoding)\n    ];\n}\nexports.createServerSocketTransport = createServerSocketTransport;\nfunction isReadableStream(value) {\n    const candidate = value;\n    return candidate.read !== undefined && candidate.addListener !== undefined;\n}\nfunction isWritableStream(value) {\n    const candidate = value;\n    return candidate.write !== undefined && candidate.addListener !== undefined;\n}\nfunction createMessageConnection(input, output, logger, options) {\n    if (!logger) {\n        logger = api_1.NullLogger;\n    }\n    const reader = isReadableStream(input) ? new StreamMessageReader(input) : input;\n    const writer = isWritableStream(output) ? new StreamMessageWriter(output) : output;\n    if (api_1.ConnectionStrategy.is(options)) {\n        options = { connectionStrategy: options };\n    }\n    return (0, api_1.createMessageConnection)(reader, writer, logger, options);\n}\nexports.createMessageConnection = createMessageConnection;\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst util_1 = require(\"util\");\nconst api_1 = require(\"../common/api\");\nclass MessageBuffer extends api_1.AbstractMessageBuffer {\n    constructor(encoding = 'utf-8') {\n        super(encoding);\n    }\n    emptyBuffer() {\n        return MessageBuffer.emptyBuffer;\n    }\n    fromString(value, encoding) {\n        return Buffer.from(value, encoding);\n    }\n    toString(value, encoding) {\n        if (value instanceof Buffer) {\n            return value.toString(encoding);\n        }\n        else {\n            return new util_1.TextDecoder(encoding).decode(value);\n        }\n    }\n    asNative(buffer, length) {\n        if (length === undefined) {\n            return buffer instanceof Buffer ? buffer : Buffer.from(buffer);\n        }\n        else {\n            return buffer instanceof Buffer ? buffer.slice(0, length) : Buffer.from(buffer, 0, length);\n        }\n    }\n    allocNative(length) {\n        return Buffer.allocUnsafe(length);\n    }\n}\nMessageBuffer.emptyBuffer = Buffer.allocUnsafe(0);\nclass ReadableStreamWrapper {\n    constructor(stream) {\n        this.stream = stream;\n    }\n    onClose(listener) {\n        this.stream.on('close', listener);\n        return api_1.Disposable.create(() => this.stream.off('close', listener));\n    }\n    onError(listener) {\n        this.stream.on('error', listener);\n        return api_1.Disposable.create(() => this.stream.off('error', listener));\n    }\n    onEnd(listener) {\n        this.stream.on('end', listener);\n        return api_1.Disposable.create(() => this.stream.off('end', listener));\n    }\n    onData(listener) {\n        this.stream.on('data', listener);\n        return api_1.Disposable.create(() => this.stream.off('data', listener));\n    }\n}\nclass WritableStreamWrapper {\n    constructor(stream) {\n        this.stream = stream;\n    }\n    onClose(listener) {\n        this.stream.on('close', listener);\n        return api_1.Disposable.create(() => this.stream.off('close', listener));\n    }\n    onError(listener) {\n        this.stream.on('error', listener);\n        return api_1.Disposable.create(() => this.stream.off('error', listener));\n    }\n    onEnd(listener) {\n        this.stream.on('end', listener);\n        return api_1.Disposable.create(() => this.stream.off('end', listener));\n    }\n    write(data, encoding) {\n        return new Promise((resolve, reject) => {\n            const callback = (error) => {\n                if (error === undefined || error === null) {\n                    resolve();\n                }\n                else {\n                    reject(error);\n                }\n            };\n            if (typeof data === 'string') {\n                this.stream.write(data, encoding, callback);\n            }\n            else {\n                this.stream.write(data, callback);\n            }\n        });\n    }\n    end() {\n        this.stream.end();\n    }\n}\nconst _ril = Object.freeze({\n    messageBuffer: Object.freeze({\n        create: (encoding) => new MessageBuffer(encoding)\n    }),\n    applicationJson: Object.freeze({\n        encoder: Object.freeze({\n            name: 'application/json',\n            encode: (msg, options) => {\n                try {\n                    return Promise.resolve(Buffer.from(JSON.stringify(msg, undefined, 0), options.charset));\n                }\n                catch (err) {\n                    return Promise.reject(err);\n                }\n            }\n        }),\n        decoder: Object.freeze({\n            name: 'application/json',\n            decode: (buffer, options) => {\n                try {\n                    if (buffer instanceof Buffer) {\n                        return Promise.resolve(JSON.parse(buffer.toString(options.charset)));\n                    }\n                    else {\n                        return Promise.resolve(JSON.parse(new util_1.TextDecoder(options.charset).decode(buffer)));\n                    }\n                }\n                catch (err) {\n                    return Promise.reject(err);\n                }\n            }\n        })\n    }),\n    stream: Object.freeze({\n        asReadableStream: (stream) => new ReadableStreamWrapper(stream),\n        asWritableStream: (stream) => new WritableStreamWrapper(stream)\n    }),\n    console: console,\n    timer: Object.freeze({\n        setTimeout(callback, ms, ...args) {\n            const handle = setTimeout(callback, ms, ...args);\n            return { dispose: () => clearTimeout(handle) };\n        },\n        setImmediate(callback, ...args) {\n            const handle = setImmediate(callback, ...args);\n            return { dispose: () => clearImmediate(handle) };\n        },\n        setInterval(callback, ms, ...args) {\n            const handle = setInterval(callback, ms, ...args);\n            return { dispose: () => clearInterval(handle) };\n        }\n    })\n});\nfunction RIL() {\n    return _ril;\n}\n(function (RIL) {\n    function install() {\n        api_1.RAL.install(_ril);\n    }\n    RIL.install = install;\n})(RIL || (RIL = {}));\nexports.default = RIL;\n","module.exports = require(\"util\");","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n/// <reference path=\"../../typings/thenable.d.ts\" />\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ProgressType = exports.ProgressToken = exports.createMessageConnection = exports.NullLogger = exports.ConnectionOptions = exports.ConnectionStrategy = exports.AbstractMessageBuffer = exports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = exports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = exports.SharedArrayReceiverStrategy = exports.SharedArraySenderStrategy = exports.CancellationToken = exports.CancellationTokenSource = exports.Emitter = exports.Event = exports.Disposable = exports.LRUCache = exports.Touch = exports.LinkedMap = exports.ParameterStructures = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.ErrorCodes = exports.ResponseError = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType0 = exports.RequestType = exports.Message = exports.RAL = void 0;\nexports.MessageStrategy = exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.TraceValues = exports.Trace = void 0;\nconst messages_1 = require(\"./messages\");\nObject.defineProperty(exports, \"Message\", { enumerable: true, get: function () { return messages_1.Message; } });\nObject.defineProperty(exports, \"RequestType\", { enumerable: true, get: function () { return messages_1.RequestType; } });\nObject.defineProperty(exports, \"RequestType0\", { enumerable: true, get: function () { return messages_1.RequestType0; } });\nObject.defineProperty(exports, \"RequestType1\", { enumerable: true, get: function () { return messages_1.RequestType1; } });\nObject.defineProperty(exports, \"RequestType2\", { enumerable: true, get: function () { return messages_1.RequestType2; } });\nObject.defineProperty(exports, \"RequestType3\", { enumerable: true, get: function () { return messages_1.RequestType3; } });\nObject.defineProperty(exports, \"RequestType4\", { enumerable: true, get: function () { return messages_1.RequestType4; } });\nObject.defineProperty(exports, \"RequestType5\", { enumerable: true, get: function () { return messages_1.RequestType5; } });\nObject.defineProperty(exports, \"RequestType6\", { enumerable: true, get: function () { return messages_1.RequestType6; } });\nObject.defineProperty(exports, \"RequestType7\", { enumerable: true, get: function () { return messages_1.RequestType7; } });\nObject.defineProperty(exports, \"RequestType8\", { enumerable: true, get: function () { return messages_1.RequestType8; } });\nObject.defineProperty(exports, \"RequestType9\", { enumerable: true, get: function () { return messages_1.RequestType9; } });\nObject.defineProperty(exports, \"ResponseError\", { enumerable: true, get: function () { return messages_1.ResponseError; } });\nObject.defineProperty(exports, \"ErrorCodes\", { enumerable: true, get: function () { return messages_1.ErrorCodes; } });\nObject.defineProperty(exports, \"NotificationType\", { enumerable: true, get: function () { return messages_1.NotificationType; } });\nObject.defineProperty(exports, \"NotificationType0\", { enumerable: true, get: function () { return messages_1.NotificationType0; } });\nObject.defineProperty(exports, \"NotificationType1\", { enumerable: true, get: function () { return messages_1.NotificationType1; } });\nObject.defineProperty(exports, \"NotificationType2\", { enumerable: true, get: function () { return messages_1.NotificationType2; } });\nObject.defineProperty(exports, \"NotificationType3\", { enumerable: true, get: function () { return messages_1.NotificationType3; } });\nObject.defineProperty(exports, \"NotificationType4\", { enumerable: true, get: function () { return messages_1.NotificationType4; } });\nObject.defineProperty(exports, \"NotificationType5\", { enumerable: true, get: function () { return messages_1.NotificationType5; } });\nObject.defineProperty(exports, \"NotificationType6\", { enumerable: true, get: function () { return messages_1.NotificationType6; } });\nObject.defineProperty(exports, \"NotificationType7\", { enumerable: true, get: function () { return messages_1.NotificationType7; } });\nObject.defineProperty(exports, \"NotificationType8\", { enumerable: true, get: function () { return messages_1.NotificationType8; } });\nObject.defineProperty(exports, \"NotificationType9\", { enumerable: true, get: function () { return messages_1.NotificationType9; } });\nObject.defineProperty(exports, \"ParameterStructures\", { enumerable: true, get: function () { return messages_1.ParameterStructures; } });\nconst linkedMap_1 = require(\"./linkedMap\");\nObject.defineProperty(exports, \"LinkedMap\", { enumerable: true, get: function () { return linkedMap_1.LinkedMap; } });\nObject.defineProperty(exports, \"LRUCache\", { enumerable: true, get: function () { return linkedMap_1.LRUCache; } });\nObject.defineProperty(exports, \"Touch\", { enumerable: true, get: function () { return linkedMap_1.Touch; } });\nconst disposable_1 = require(\"./disposable\");\nObject.defineProperty(exports, \"Disposable\", { enumerable: true, get: function () { return disposable_1.Disposable; } });\nconst events_1 = require(\"./events\");\nObject.defineProperty(exports, \"Event\", { enumerable: true, get: function () { return events_1.Event; } });\nObject.defineProperty(exports, \"Emitter\", { enumerable: true, get: function () { return events_1.Emitter; } });\nconst cancellation_1 = require(\"./cancellation\");\nObject.defineProperty(exports, \"CancellationTokenSource\", { enumerable: true, get: function () { return cancellation_1.CancellationTokenSource; } });\nObject.defineProperty(exports, \"CancellationToken\", { enumerable: true, get: function () { return cancellation_1.CancellationToken; } });\nconst sharedArrayCancellation_1 = require(\"./sharedArrayCancellation\");\nObject.defineProperty(exports, \"SharedArraySenderStrategy\", { enumerable: true, get: function () { return sharedArrayCancellation_1.SharedArraySenderStrategy; } });\nObject.defineProperty(exports, \"SharedArrayReceiverStrategy\", { enumerable: true, get: function () { return sharedArrayCancellation_1.SharedArrayReceiverStrategy; } });\nconst messageReader_1 = require(\"./messageReader\");\nObject.defineProperty(exports, \"MessageReader\", { enumerable: true, get: function () { return messageReader_1.MessageReader; } });\nObject.defineProperty(exports, \"AbstractMessageReader\", { enumerable: true, get: function () { return messageReader_1.AbstractMessageReader; } });\nObject.defineProperty(exports, \"ReadableStreamMessageReader\", { enumerable: true, get: function () { return messageReader_1.ReadableStreamMessageReader; } });\nconst messageWriter_1 = require(\"./messageWriter\");\nObject.defineProperty(exports, \"MessageWriter\", { enumerable: true, get: function () { return messageWriter_1.MessageWriter; } });\nObject.defineProperty(exports, \"AbstractMessageWriter\", { enumerable: true, get: function () { return messageWriter_1.AbstractMessageWriter; } });\nObject.defineProperty(exports, \"WriteableStreamMessageWriter\", { enumerable: true, get: function () { return messageWriter_1.WriteableStreamMessageWriter; } });\nconst messageBuffer_1 = require(\"./messageBuffer\");\nObject.defineProperty(exports, \"AbstractMessageBuffer\", { enumerable: true, get: function () { return messageBuffer_1.AbstractMessageBuffer; } });\nconst connection_1 = require(\"./connection\");\nObject.defineProperty(exports, \"ConnectionStrategy\", { enumerable: true, get: function () { return connection_1.ConnectionStrategy; } });\nObject.defineProperty(exports, \"ConnectionOptions\", { enumerable: true, get: function () { return connection_1.ConnectionOptions; } });\nObject.defineProperty(exports, \"NullLogger\", { enumerable: true, get: function () { return connection_1.NullLogger; } });\nObject.defineProperty(exports, \"createMessageConnection\", { enumerable: true, get: function () { return connection_1.createMessageConnection; } });\nObject.defineProperty(exports, \"ProgressToken\", { enumerable: true, get: function () { return connection_1.ProgressToken; } });\nObject.defineProperty(exports, \"ProgressType\", { enumerable: true, get: function () { return connection_1.ProgressType; } });\nObject.defineProperty(exports, \"Trace\", { enumerable: true, get: function () { return connection_1.Trace; } });\nObject.defineProperty(exports, \"TraceValues\", { enumerable: true, get: function () { return connection_1.TraceValues; } });\nObject.defineProperty(exports, \"TraceFormat\", { enumerable: true, get: function () { return connection_1.TraceFormat; } });\nObject.defineProperty(exports, \"SetTraceNotification\", { enumerable: true, get: function () { return connection_1.SetTraceNotification; } });\nObject.defineProperty(exports, \"LogTraceNotification\", { enumerable: true, get: function () { return connection_1.LogTraceNotification; } });\nObject.defineProperty(exports, \"ConnectionErrors\", { enumerable: true, get: function () { return connection_1.ConnectionErrors; } });\nObject.defineProperty(exports, \"ConnectionError\", { enumerable: true, get: function () { return connection_1.ConnectionError; } });\nObject.defineProperty(exports, \"CancellationReceiverStrategy\", { enumerable: true, get: function () { return connection_1.CancellationReceiverStrategy; } });\nObject.defineProperty(exports, \"CancellationSenderStrategy\", { enumerable: true, get: function () { return connection_1.CancellationSenderStrategy; } });\nObject.defineProperty(exports, \"CancellationStrategy\", { enumerable: true, get: function () { return connection_1.CancellationStrategy; } });\nObject.defineProperty(exports, \"MessageStrategy\", { enumerable: true, get: function () { return connection_1.MessageStrategy; } });\nconst ral_1 = require(\"./ral\");\nexports.RAL = ral_1.default;\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Message = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType = exports.RequestType0 = exports.AbstractMessageSignature = exports.ParameterStructures = exports.ResponseError = exports.ErrorCodes = void 0;\nconst is = require(\"./is\");\n/**\n * Predefined error codes.\n */\nvar ErrorCodes;\n(function (ErrorCodes) {\n    // Defined by JSON RPC\n    ErrorCodes.ParseError = -32700;\n    ErrorCodes.InvalidRequest = -32600;\n    ErrorCodes.MethodNotFound = -32601;\n    ErrorCodes.InvalidParams = -32602;\n    ErrorCodes.InternalError = -32603;\n    /**\n     * This is the start range of JSON RPC reserved error codes.\n     * It doesn't denote a real error code. No application error codes should\n     * be defined between the start and end range. For backwards\n     * compatibility the `ServerNotInitialized` and the `UnknownErrorCode`\n     * are left in the range.\n     *\n     * @since 3.16.0\n    */\n    ErrorCodes.jsonrpcReservedErrorRangeStart = -32099;\n    /** @deprecated use  jsonrpcReservedErrorRangeStart */\n    ErrorCodes.serverErrorStart = -32099;\n    /**\n     * An error occurred when write a message to the transport layer.\n     */\n    ErrorCodes.MessageWriteError = -32099;\n    /**\n     * An error occurred when reading a message from the transport layer.\n     */\n    ErrorCodes.MessageReadError = -32098;\n    /**\n     * The connection got disposed or lost and all pending responses got\n     * rejected.\n     */\n    ErrorCodes.PendingResponseRejected = -32097;\n    /**\n     * The connection is inactive and a use of it failed.\n     */\n    ErrorCodes.ConnectionInactive = -32096;\n    /**\n     * Error code indicating that a server received a notification or\n     * request before the server has received the `initialize` request.\n     */\n    ErrorCodes.ServerNotInitialized = -32002;\n    ErrorCodes.UnknownErrorCode = -32001;\n    /**\n     * This is the end range of JSON RPC reserved error codes.\n     * It doesn't denote a real error code.\n     *\n     * @since 3.16.0\n    */\n    ErrorCodes.jsonrpcReservedErrorRangeEnd = -32000;\n    /** @deprecated use  jsonrpcReservedErrorRangeEnd */\n    ErrorCodes.serverErrorEnd = -32000;\n})(ErrorCodes || (exports.ErrorCodes = ErrorCodes = {}));\n/**\n * An error object return in a response in case a request\n * has failed.\n */\nclass ResponseError extends Error {\n    constructor(code, message, data) {\n        super(message);\n        this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;\n        this.data = data;\n        Object.setPrototypeOf(this, ResponseError.prototype);\n    }\n    toJson() {\n        const result = {\n            code: this.code,\n            message: this.message\n        };\n        if (this.data !== undefined) {\n            result.data = this.data;\n        }\n        return result;\n    }\n}\nexports.ResponseError = ResponseError;\nclass ParameterStructures {\n    constructor(kind) {\n        this.kind = kind;\n    }\n    static is(value) {\n        return value === ParameterStructures.auto || value === ParameterStructures.byName || value === ParameterStructures.byPosition;\n    }\n    toString() {\n        return this.kind;\n    }\n}\nexports.ParameterStructures = ParameterStructures;\n/**\n * The parameter structure is automatically inferred on the number of parameters\n * and the parameter type in case of a single param.\n */\nParameterStructures.auto = new ParameterStructures('auto');\n/**\n * Forces `byPosition` parameter structure. This is useful if you have a single\n * parameter which has a literal type.\n */\nParameterStructures.byPosition = new ParameterStructures('byPosition');\n/**\n * Forces `byName` parameter structure. This is only useful when having a single\n * parameter. The library will report errors if used with a different number of\n * parameters.\n */\nParameterStructures.byName = new ParameterStructures('byName');\n/**\n * An abstract implementation of a MessageType.\n */\nclass AbstractMessageSignature {\n    constructor(method, numberOfParams) {\n        this.method = method;\n        this.numberOfParams = numberOfParams;\n    }\n    get parameterStructures() {\n        return ParameterStructures.auto;\n    }\n}\nexports.AbstractMessageSignature = AbstractMessageSignature;\n/**\n * Classes to type request response pairs\n */\nclass RequestType0 extends AbstractMessageSignature {\n    constructor(method) {\n        super(method, 0);\n    }\n}\nexports.RequestType0 = RequestType0;\nclass RequestType extends AbstractMessageSignature {\n    constructor(method, _parameterStructures = ParameterStructures.auto) {\n        super(method, 1);\n        this._parameterStructures = _parameterStructures;\n    }\n    get parameterStructures() {\n        return this._parameterStructures;\n    }\n}\nexports.RequestType = RequestType;\nclass RequestType1 extends AbstractMessageSignature {\n    constructor(method, _parameterStructures = ParameterStructures.auto) {\n        super(method, 1);\n        this._parameterStructures = _parameterStructures;\n    }\n    get parameterStructures() {\n        return this._parameterStructures;\n    }\n}\nexports.RequestType1 = RequestType1;\nclass RequestType2 extends AbstractMessageSignature {\n    constructor(method) {\n        super(method, 2);\n    }\n}\nexports.RequestType2 = RequestType2;\nclass RequestType3 extends AbstractMessageSignature {\n    constructor(method) {\n        super(method, 3);\n    }\n}\nexports.RequestType3 = RequestType3;\nclass RequestType4 extends AbstractMessageSignature {\n    constructor(method) {\n        super(method, 4);\n    }\n}\nexports.RequestType4 = RequestType4;\nclass RequestType5 extends AbstractMessageSignature {\n    constructor(method) {\n        super(method, 5);\n    }\n}\nexports.RequestType5 = RequestType5;\nclass RequestType6 extends AbstractMessageSignature {\n    constructor(method) {\n        super(method, 6);\n    }\n}\nexports.RequestType6 = RequestType6;\nclass RequestType7 extends AbstractMessageSignature {\n    constructor(method) {\n        super(method, 7);\n    }\n}\nexports.RequestType7 = RequestType7;\nclass RequestType8 extends AbstractMessageSignature {\n    constructor(method) {\n        super(method, 8);\n    }\n}\nexports.RequestType8 = RequestType8;\nclass RequestType9 extends AbstractMessageSignature {\n    constructor(method) {\n        super(method, 9);\n    }\n}\nexports.RequestType9 = RequestType9;\nclass NotificationType extends AbstractMessageSignature {\n    constructor(method, _parameterStructures = ParameterStructures.auto) {\n        super(method, 1);\n        this._parameterStructures = _parameterStructures;\n    }\n    get parameterStructures() {\n        return this._parameterStructures;\n    }\n}\nexports.NotificationType = NotificationType;\nclass NotificationType0 extends AbstractMessageSignature {\n    constructor(method) {\n        super(method, 0);\n    }\n}\nexports.NotificationType0 = NotificationType0;\nclass NotificationType1 extends AbstractMessageSignature {\n    constructor(method, _parameterStructures = ParameterStructures.auto) {\n        super(method, 1);\n        this._parameterStructures = _parameterStructures;\n    }\n    get parameterStructures() {\n        return this._parameterStructures;\n    }\n}\nexports.NotificationType1 = NotificationType1;\nclass NotificationType2 extends AbstractMessageSignature {\n    constructor(method) {\n        super(method, 2);\n    }\n}\nexports.NotificationType2 = NotificationType2;\nclass NotificationType3 extends AbstractMessageSignature {\n    constructor(method) {\n        super(method, 3);\n    }\n}\nexports.NotificationType3 = NotificationType3;\nclass NotificationType4 extends AbstractMessageSignature {\n    constructor(method) {\n        super(method, 4);\n    }\n}\nexports.NotificationType4 = NotificationType4;\nclass NotificationType5 extends AbstractMessageSignature {\n    constructor(method) {\n        super(method, 5);\n    }\n}\nexports.NotificationType5 = NotificationType5;\nclass NotificationType6 extends AbstractMessageSignature {\n    constructor(method) {\n        super(method, 6);\n    }\n}\nexports.NotificationType6 = NotificationType6;\nclass NotificationType7 extends AbstractMessageSignature {\n    constructor(method) {\n        super(method, 7);\n    }\n}\nexports.NotificationType7 = NotificationType7;\nclass NotificationType8 extends AbstractMessageSignature {\n    constructor(method) {\n        super(method, 8);\n    }\n}\nexports.NotificationType8 = NotificationType8;\nclass NotificationType9 extends AbstractMessageSignature {\n    constructor(method) {\n        super(method, 9);\n    }\n}\nexports.NotificationType9 = NotificationType9;\nvar Message;\n(function (Message) {\n    /**\n     * Tests if the given message is a request message\n     */\n    function isRequest(message) {\n        const candidate = message;\n        return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));\n    }\n    Message.isRequest = isRequest;\n    /**\n     * Tests if the given message is a notification message\n     */\n    function isNotification(message) {\n        const candidate = message;\n        return candidate && is.string(candidate.method) && message.id === void 0;\n    }\n    Message.isNotification = isNotification;\n    /**\n     * Tests if the given message is a response message\n     */\n    function isResponse(message) {\n        const candidate = message;\n        return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);\n    }\n    Message.isResponse = isResponse;\n})(Message || (exports.Message = Message = {}));\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;\nfunction boolean(value) {\n    return value === true || value === false;\n}\nexports.boolean = boolean;\nfunction string(value) {\n    return typeof value === 'string' || value instanceof String;\n}\nexports.string = string;\nfunction number(value) {\n    return typeof value === 'number' || value instanceof Number;\n}\nexports.number = number;\nfunction error(value) {\n    return value instanceof Error;\n}\nexports.error = error;\nfunction func(value) {\n    return typeof value === 'function';\n}\nexports.func = func;\nfunction array(value) {\n    return Array.isArray(value);\n}\nexports.array = array;\nfunction stringArray(value) {\n    return array(value) && value.every(elem => string(elem));\n}\nexports.stringArray = stringArray;\n","\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar _a;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LRUCache = exports.LinkedMap = exports.Touch = void 0;\nvar Touch;\n(function (Touch) {\n    Touch.None = 0;\n    Touch.First = 1;\n    Touch.AsOld = Touch.First;\n    Touch.Last = 2;\n    Touch.AsNew = Touch.Last;\n})(Touch || (exports.Touch = Touch = {}));\nclass LinkedMap {\n    constructor() {\n        this[_a] = 'LinkedMap';\n        this._map = new Map();\n        this._head = undefined;\n        this._tail = undefined;\n        this._size = 0;\n        this._state = 0;\n    }\n    clear() {\n        this._map.clear();\n        this._head = undefined;\n        this._tail = undefined;\n        this._size = 0;\n        this._state++;\n    }\n    isEmpty() {\n        return !this._head && !this._tail;\n    }\n    get size() {\n        return this._size;\n    }\n    get first() {\n        return this._head?.value;\n    }\n    get last() {\n        return this._tail?.value;\n    }\n    has(key) {\n        return this._map.has(key);\n    }\n    get(key, touch = Touch.None) {\n        const item = this._map.get(key);\n        if (!item) {\n            return undefined;\n        }\n        if (touch !== Touch.None) {\n            this.touch(item, touch);\n        }\n        return item.value;\n    }\n    set(key, value, touch = Touch.None) {\n        let item = this._map.get(key);\n        if (item) {\n            item.value = value;\n            if (touch !== Touch.None) {\n                this.touch(item, touch);\n            }\n        }\n        else {\n            item = { key, value, next: undefined, previous: undefined };\n            switch (touch) {\n                case Touch.None:\n                    this.addItemLast(item);\n                    break;\n                case Touch.First:\n                    this.addItemFirst(item);\n                    break;\n                case Touch.Last:\n                    this.addItemLast(item);\n                    break;\n                default:\n                    this.addItemLast(item);\n                    break;\n            }\n            this._map.set(key, item);\n            this._size++;\n        }\n        return this;\n    }\n    delete(key) {\n        return !!this.remove(key);\n    }\n    remove(key) {\n        const item = this._map.get(key);\n        if (!item) {\n            return undefined;\n        }\n        this._map.delete(key);\n        this.removeItem(item);\n        this._size--;\n        return item.value;\n    }\n    shift() {\n        if (!this._head && !this._tail) {\n            return undefined;\n        }\n        if (!this._head || !this._tail) {\n            throw new Error('Invalid list');\n        }\n        const item = this._head;\n        this._map.delete(item.key);\n        this.removeItem(item);\n        this._size--;\n        return item.value;\n    }\n    forEach(callbackfn, thisArg) {\n        const state = this._state;\n        let current = this._head;\n        while (current) {\n            if (thisArg) {\n                callbackfn.bind(thisArg)(current.value, current.key, this);\n            }\n            else {\n                callbackfn(current.value, current.key, this);\n            }\n            if (this._state !== state) {\n                throw new Error(`LinkedMap got modified during iteration.`);\n            }\n            current = current.next;\n        }\n    }\n    keys() {\n        const state = this._state;\n        let current = this._head;\n        const iterator = {\n            [Symbol.iterator]: () => {\n                return iterator;\n            },\n            next: () => {\n                if (this._state !== state) {\n                    throw new Error(`LinkedMap got modified during iteration.`);\n                }\n                if (current) {\n                    const result = { value: current.key, done: false };\n                    current = current.next;\n                    return result;\n                }\n                else {\n                    return { value: undefined, done: true };\n                }\n            }\n        };\n        return iterator;\n    }\n    values() {\n        const state = this._state;\n        let current = this._head;\n        const iterator = {\n            [Symbol.iterator]: () => {\n                return iterator;\n            },\n            next: () => {\n                if (this._state !== state) {\n                    throw new Error(`LinkedMap got modified during iteration.`);\n                }\n                if (current) {\n                    const result = { value: current.value, done: false };\n                    current = current.next;\n                    return result;\n                }\n                else {\n                    return { value: undefined, done: true };\n                }\n            }\n        };\n        return iterator;\n    }\n    entries() {\n        const state = this._state;\n        let current = this._head;\n        const iterator = {\n            [Symbol.iterator]: () => {\n                return iterator;\n            },\n            next: () => {\n                if (this._state !== state) {\n                    throw new Error(`LinkedMap got modified during iteration.`);\n                }\n                if (current) {\n                    const result = { value: [current.key, current.value], done: false };\n                    current = current.next;\n                    return result;\n                }\n                else {\n                    return { value: undefined, done: true };\n                }\n            }\n        };\n        return iterator;\n    }\n    [(_a = Symbol.toStringTag, Symbol.iterator)]() {\n        return this.entries();\n    }\n    trimOld(newSize) {\n        if (newSize >= this.size) {\n            return;\n        }\n        if (newSize === 0) {\n            this.clear();\n            return;\n        }\n        let current = this._head;\n        let currentSize = this.size;\n        while (current && currentSize > newSize) {\n            this._map.delete(current.key);\n            current = current.next;\n            currentSize--;\n        }\n        this._head = current;\n        this._size = currentSize;\n        if (current) {\n            current.previous = undefined;\n        }\n        this._state++;\n    }\n    addItemFirst(item) {\n        // First time Insert\n        if (!this._head && !this._tail) {\n            this._tail = item;\n        }\n        else if (!this._head) {\n            throw new Error('Invalid list');\n        }\n        else {\n            item.next = this._head;\n            this._head.previous = item;\n        }\n        this._head = item;\n        this._state++;\n    }\n    addItemLast(item) {\n        // First time Insert\n        if (!this._head && !this._tail) {\n            this._head = item;\n        }\n        else if (!this._tail) {\n            throw new Error('Invalid list');\n        }\n        else {\n            item.previous = this._tail;\n            this._tail.next = item;\n        }\n        this._tail = item;\n        this._state++;\n    }\n    removeItem(item) {\n        if (item === this._head && item === this._tail) {\n            this._head = undefined;\n            this._tail = undefined;\n        }\n        else if (item === this._head) {\n            // This can only happened if size === 1 which is handle\n            // by the case above.\n            if (!item.next) {\n                throw new Error('Invalid list');\n            }\n            item.next.previous = undefined;\n            this._head = item.next;\n        }\n        else if (item === this._tail) {\n            // This can only happened if size === 1 which is handle\n            // by the case above.\n            if (!item.previous) {\n                throw new Error('Invalid list');\n            }\n            item.previous.next = undefined;\n            this._tail = item.previous;\n        }\n        else {\n            const next = item.next;\n            const previous = item.previous;\n            if (!next || !previous) {\n                throw new Error('Invalid list');\n            }\n            next.previous = previous;\n            previous.next = next;\n        }\n        item.next = undefined;\n        item.previous = undefined;\n        this._state++;\n    }\n    touch(item, touch) {\n        if (!this._head || !this._tail) {\n            throw new Error('Invalid list');\n        }\n        if ((touch !== Touch.First && touch !== Touch.Last)) {\n            return;\n        }\n        if (touch === Touch.First) {\n            if (item === this._head) {\n                return;\n            }\n            const next = item.next;\n            const previous = item.previous;\n            // Unlink the item\n            if (item === this._tail) {\n                // previous must be defined since item was not head but is tail\n                // So there are more than on item in the map\n                previous.next = undefined;\n                this._tail = previous;\n            }\n            else {\n                // Both next and previous are not undefined since item was neither head nor tail.\n                next.previous = previous;\n                previous.next = next;\n            }\n            // Insert the node at head\n            item.previous = undefined;\n            item.next = this._head;\n            this._head.previous = item;\n            this._head = item;\n            this._state++;\n        }\n        else if (touch === Touch.Last) {\n            if (item === this._tail) {\n                return;\n            }\n            const next = item.next;\n            const previous = item.previous;\n            // Unlink the item.\n            if (item === this._head) {\n                // next must be defined since item was not tail but is head\n                // So there are more than on item in the map\n                next.previous = undefined;\n                this._head = next;\n            }\n            else {\n                // Both next and previous are not undefined since item was neither head nor tail.\n                next.previous = previous;\n                previous.next = next;\n            }\n            item.next = undefined;\n            item.previous = this._tail;\n            this._tail.next = item;\n            this._tail = item;\n            this._state++;\n        }\n    }\n    toJSON() {\n        const data = [];\n        this.forEach((value, key) => {\n            data.push([key, value]);\n        });\n        return data;\n    }\n    fromJSON(data) {\n        this.clear();\n        for (const [key, value] of data) {\n            this.set(key, value);\n        }\n    }\n}\nexports.LinkedMap = LinkedMap;\nclass LRUCache extends LinkedMap {\n    constructor(limit, ratio = 1) {\n        super();\n        this._limit = limit;\n        this._ratio = Math.min(Math.max(0, ratio), 1);\n    }\n    get limit() {\n        return this._limit;\n    }\n    set limit(limit) {\n        this._limit = limit;\n        this.checkTrim();\n    }\n    get ratio() {\n        return this._ratio;\n    }\n    set ratio(ratio) {\n        this._ratio = Math.min(Math.max(0, ratio), 1);\n        this.checkTrim();\n    }\n    get(key, touch = Touch.AsNew) {\n        return super.get(key, touch);\n    }\n    peek(key) {\n        return super.get(key, Touch.None);\n    }\n    set(key, value) {\n        super.set(key, value, Touch.Last);\n        this.checkTrim();\n        return this;\n    }\n    checkTrim() {\n        if (this.size > this._limit) {\n            this.trimOld(Math.round(this._limit * this._ratio));\n        }\n    }\n}\nexports.LRUCache = LRUCache;\n","\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Disposable = void 0;\nvar Disposable;\n(function (Disposable) {\n    function create(func) {\n        return {\n            dispose: func\n        };\n    }\n    Disposable.create = create;\n})(Disposable || (exports.Disposable = Disposable = {}));\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Emitter = exports.Event = void 0;\nconst ral_1 = require(\"./ral\");\nvar Event;\n(function (Event) {\n    const _disposable = { dispose() { } };\n    Event.None = function () { return _disposable; };\n})(Event || (exports.Event = Event = {}));\nclass CallbackList {\n    add(callback, context = null, bucket) {\n        if (!this._callbacks) {\n            this._callbacks = [];\n            this._contexts = [];\n        }\n        this._callbacks.push(callback);\n        this._contexts.push(context);\n        if (Array.isArray(bucket)) {\n            bucket.push({ dispose: () => this.remove(callback, context) });\n        }\n    }\n    remove(callback, context = null) {\n        if (!this._callbacks) {\n            return;\n        }\n        let foundCallbackWithDifferentContext = false;\n        for (let i = 0, len = this._callbacks.length; i < len; i++) {\n            if (this._callbacks[i] === callback) {\n                if (this._contexts[i] === context) {\n                    // callback & context match => remove it\n                    this._callbacks.splice(i, 1);\n                    this._contexts.splice(i, 1);\n                    return;\n                }\n                else {\n                    foundCallbackWithDifferentContext = true;\n                }\n            }\n        }\n        if (foundCallbackWithDifferentContext) {\n            throw new Error('When adding a listener with a context, you should remove it with the same context');\n        }\n    }\n    invoke(...args) {\n        if (!this._callbacks) {\n            return [];\n        }\n        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);\n        for (let i = 0, len = callbacks.length; i < len; i++) {\n            try {\n                ret.push(callbacks[i].apply(contexts[i], args));\n            }\n            catch (e) {\n                // eslint-disable-next-line no-console\n                (0, ral_1.default)().console.error(e);\n            }\n        }\n        return ret;\n    }\n    isEmpty() {\n        return !this._callbacks || this._callbacks.length === 0;\n    }\n    dispose() {\n        this._callbacks = undefined;\n        this._contexts = undefined;\n    }\n}\nclass Emitter {\n    constructor(_options) {\n        this._options = _options;\n    }\n    /**\n     * For the public to allow to subscribe\n     * to events from this Emitter\n     */\n    get event() {\n        if (!this._event) {\n            this._event = (listener, thisArgs, disposables) => {\n                if (!this._callbacks) {\n                    this._callbacks = new CallbackList();\n                }\n                if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {\n                    this._options.onFirstListenerAdd(this);\n                }\n                this._callbacks.add(listener, thisArgs);\n                const result = {\n                    dispose: () => {\n                        if (!this._callbacks) {\n                            // disposable is disposed after emitter is disposed.\n                            return;\n                        }\n                        this._callbacks.remove(listener, thisArgs);\n                        result.dispose = Emitter._noop;\n                        if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {\n                            this._options.onLastListenerRemove(this);\n                        }\n                    }\n                };\n                if (Array.isArray(disposables)) {\n                    disposables.push(result);\n                }\n                return result;\n            };\n        }\n        return this._event;\n    }\n    /**\n     * To be kept private to fire an event to\n     * subscribers\n     */\n    fire(event) {\n        if (this._callbacks) {\n            this._callbacks.invoke.call(this._callbacks, event);\n        }\n    }\n    dispose() {\n        if (this._callbacks) {\n            this._callbacks.dispose();\n            this._callbacks = undefined;\n        }\n    }\n}\nexports.Emitter = Emitter;\nEmitter._noop = function () { };\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nlet _ral;\nfunction RAL() {\n    if (_ral === undefined) {\n        throw new Error(`No runtime abstraction layer installed`);\n    }\n    return _ral;\n}\n(function (RAL) {\n    function install(ral) {\n        if (ral === undefined) {\n            throw new Error(`No runtime abstraction layer provided`);\n        }\n        _ral = ral;\n    }\n    RAL.install = install;\n})(RAL || (RAL = {}));\nexports.default = RAL;\n","\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CancellationTokenSource = exports.CancellationToken = void 0;\nconst ral_1 = require(\"./ral\");\nconst Is = require(\"./is\");\nconst events_1 = require(\"./events\");\nvar CancellationToken;\n(function (CancellationToken) {\n    CancellationToken.None = Object.freeze({\n        isCancellationRequested: false,\n        onCancellationRequested: events_1.Event.None\n    });\n    CancellationToken.Cancelled = Object.freeze({\n        isCancellationRequested: true,\n        onCancellationRequested: events_1.Event.None\n    });\n    function is(value) {\n        const candidate = value;\n        return candidate && (candidate === CancellationToken.None\n            || candidate === CancellationToken.Cancelled\n            || (Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested));\n    }\n    CancellationToken.is = is;\n})(CancellationToken || (exports.CancellationToken = CancellationToken = {}));\nconst shortcutEvent = Object.freeze(function (callback, context) {\n    const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);\n    return { dispose() { handle.dispose(); } };\n});\nclass MutableToken {\n    constructor() {\n        this._isCancelled = false;\n    }\n    cancel() {\n        if (!this._isCancelled) {\n            this._isCancelled = true;\n            if (this._emitter) {\n                this._emitter.fire(undefined);\n                this.dispose();\n            }\n        }\n    }\n    get isCancellationRequested() {\n        return this._isCancelled;\n    }\n    get onCancellationRequested() {\n        if (this._isCancelled) {\n            return shortcutEvent;\n        }\n        if (!this._emitter) {\n            this._emitter = new events_1.Emitter();\n        }\n        return this._emitter.event;\n    }\n    dispose() {\n        if (this._emitter) {\n            this._emitter.dispose();\n            this._emitter = undefined;\n        }\n    }\n}\nclass CancellationTokenSource {\n    get token() {\n        if (!this._token) {\n            // be lazy and create the token only when\n            // actually needed\n            this._token = new MutableToken();\n        }\n        return this._token;\n    }\n    cancel() {\n        if (!this._token) {\n            // save an object by returning the default\n            // cancelled token when cancellation happens\n            // before someone asks for the token\n            this._token = CancellationToken.Cancelled;\n        }\n        else {\n            this._token.cancel();\n        }\n    }\n    dispose() {\n        if (!this._token) {\n            // ensure to initialize with an empty token if we had none\n            this._token = CancellationToken.None;\n        }\n        else if (this._token instanceof MutableToken) {\n            // actually dispose\n            this._token.dispose();\n        }\n    }\n}\nexports.CancellationTokenSource = CancellationTokenSource;\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SharedArrayReceiverStrategy = exports.SharedArraySenderStrategy = void 0;\nconst cancellation_1 = require(\"./cancellation\");\nvar CancellationState;\n(function (CancellationState) {\n    CancellationState.Continue = 0;\n    CancellationState.Cancelled = 1;\n})(CancellationState || (CancellationState = {}));\nclass SharedArraySenderStrategy {\n    constructor() {\n        this.buffers = new Map();\n    }\n    enableCancellation(request) {\n        if (request.id === null) {\n            return;\n        }\n        const buffer = new SharedArrayBuffer(4);\n        const data = new Int32Array(buffer, 0, 1);\n        data[0] = CancellationState.Continue;\n        this.buffers.set(request.id, buffer);\n        request.$cancellationData = buffer;\n    }\n    async sendCancellation(_conn, id) {\n        const buffer = this.buffers.get(id);\n        if (buffer === undefined) {\n            return;\n        }\n        const data = new Int32Array(buffer, 0, 1);\n        Atomics.store(data, 0, CancellationState.Cancelled);\n    }\n    cleanup(id) {\n        this.buffers.delete(id);\n    }\n    dispose() {\n        this.buffers.clear();\n    }\n}\nexports.SharedArraySenderStrategy = SharedArraySenderStrategy;\nclass SharedArrayBufferCancellationToken {\n    constructor(buffer) {\n        this.data = new Int32Array(buffer, 0, 1);\n    }\n    get isCancellationRequested() {\n        return Atomics.load(this.data, 0) === CancellationState.Cancelled;\n    }\n    get onCancellationRequested() {\n        throw new Error(`Cancellation over SharedArrayBuffer doesn't support cancellation events`);\n    }\n}\nclass SharedArrayBufferCancellationTokenSource {\n    constructor(buffer) {\n        this.token = new SharedArrayBufferCancellationToken(buffer);\n    }\n    cancel() {\n    }\n    dispose() {\n    }\n}\nclass SharedArrayReceiverStrategy {\n    constructor() {\n        this.kind = 'request';\n    }\n    createCancellationTokenSource(request) {\n        const buffer = request.$cancellationData;\n        if (buffer === undefined) {\n            return new cancellation_1.CancellationTokenSource();\n        }\n        return new SharedArrayBufferCancellationTokenSource(buffer);\n    }\n}\nexports.SharedArrayReceiverStrategy = SharedArrayReceiverStrategy;\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = void 0;\nconst ral_1 = require(\"./ral\");\nconst Is = require(\"./is\");\nconst events_1 = require(\"./events\");\nconst semaphore_1 = require(\"./semaphore\");\nvar MessageReader;\n(function (MessageReader) {\n    function is(value) {\n        let candidate = value;\n        return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) &&\n            Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);\n    }\n    MessageReader.is = is;\n})(MessageReader || (exports.MessageReader = MessageReader = {}));\nclass AbstractMessageReader {\n    constructor() {\n        this.errorEmitter = new events_1.Emitter();\n        this.closeEmitter = new events_1.Emitter();\n        this.partialMessageEmitter = new events_1.Emitter();\n    }\n    dispose() {\n        this.errorEmitter.dispose();\n        this.closeEmitter.dispose();\n    }\n    get onError() {\n        return this.errorEmitter.event;\n    }\n    fireError(error) {\n        this.errorEmitter.fire(this.asError(error));\n    }\n    get onClose() {\n        return this.closeEmitter.event;\n    }\n    fireClose() {\n        this.closeEmitter.fire(undefined);\n    }\n    get onPartialMessage() {\n        return this.partialMessageEmitter.event;\n    }\n    firePartialMessage(info) {\n        this.partialMessageEmitter.fire(info);\n    }\n    asError(error) {\n        if (error instanceof Error) {\n            return error;\n        }\n        else {\n            return new Error(`Reader received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);\n        }\n    }\n}\nexports.AbstractMessageReader = AbstractMessageReader;\nvar ResolvedMessageReaderOptions;\n(function (ResolvedMessageReaderOptions) {\n    function fromOptions(options) {\n        let charset;\n        let result;\n        let contentDecoder;\n        const contentDecoders = new Map();\n        let contentTypeDecoder;\n        const contentTypeDecoders = new Map();\n        if (options === undefined || typeof options === 'string') {\n            charset = options ?? 'utf-8';\n        }\n        else {\n            charset = options.charset ?? 'utf-8';\n            if (options.contentDecoder !== undefined) {\n                contentDecoder = options.contentDecoder;\n                contentDecoders.set(contentDecoder.name, contentDecoder);\n            }\n            if (options.contentDecoders !== undefined) {\n                for (const decoder of options.contentDecoders) {\n                    contentDecoders.set(decoder.name, decoder);\n                }\n            }\n            if (options.contentTypeDecoder !== undefined) {\n                contentTypeDecoder = options.contentTypeDecoder;\n                contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);\n            }\n            if (options.contentTypeDecoders !== undefined) {\n                for (const decoder of options.contentTypeDecoders) {\n                    contentTypeDecoders.set(decoder.name, decoder);\n                }\n            }\n        }\n        if (contentTypeDecoder === undefined) {\n            contentTypeDecoder = (0, ral_1.default)().applicationJson.decoder;\n            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);\n        }\n        return { charset, contentDecoder, contentDecoders, contentTypeDecoder, contentTypeDecoders };\n    }\n    ResolvedMessageReaderOptions.fromOptions = fromOptions;\n})(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));\nclass ReadableStreamMessageReader extends AbstractMessageReader {\n    constructor(readable, options) {\n        super();\n        this.readable = readable;\n        this.options = ResolvedMessageReaderOptions.fromOptions(options);\n        this.buffer = (0, ral_1.default)().messageBuffer.create(this.options.charset);\n        this._partialMessageTimeout = 10000;\n        this.nextMessageLength = -1;\n        this.messageToken = 0;\n        this.readSemaphore = new semaphore_1.Semaphore(1);\n    }\n    set partialMessageTimeout(timeout) {\n        this._partialMessageTimeout = timeout;\n    }\n    get partialMessageTimeout() {\n        return this._partialMessageTimeout;\n    }\n    listen(callback) {\n        this.nextMessageLength = -1;\n        this.messageToken = 0;\n        this.partialMessageTimer = undefined;\n        this.callback = callback;\n        const result = this.readable.onData((data) => {\n            this.onData(data);\n        });\n        this.readable.onError((error) => this.fireError(error));\n        this.readable.onClose(() => this.fireClose());\n        return result;\n    }\n    onData(data) {\n        try {\n            this.buffer.append(data);\n            while (true) {\n                if (this.nextMessageLength === -1) {\n                    const headers = this.buffer.tryReadHeaders(true);\n                    if (!headers) {\n                        return;\n                    }\n                    const contentLength = headers.get('content-length');\n                    if (!contentLength) {\n                        this.fireError(new Error(`Header must provide a Content-Length property.\\n${JSON.stringify(Object.fromEntries(headers))}`));\n                        return;\n                    }\n                    const length = parseInt(contentLength);\n                    if (isNaN(length)) {\n                        this.fireError(new Error(`Content-Length value must be a number. Got ${contentLength}`));\n                        return;\n                    }\n                    this.nextMessageLength = length;\n                }\n                const body = this.buffer.tryReadBody(this.nextMessageLength);\n                if (body === undefined) {\n                    /** We haven't received the full message yet. */\n                    this.setPartialMessageTimer();\n                    return;\n                }\n                this.clearPartialMessageTimer();\n                this.nextMessageLength = -1;\n                // Make sure that we convert one received message after the\n                // other. Otherwise it could happen that a decoding of a second\n                // smaller message finished before the decoding of a first larger\n                // message and then we would deliver the second message first.\n                this.readSemaphore.lock(async () => {\n                    const bytes = this.options.contentDecoder !== undefined\n                        ? await this.options.contentDecoder.decode(body)\n                        : body;\n                    const message = await this.options.contentTypeDecoder.decode(bytes, this.options);\n                    this.callback(message);\n                }).catch((error) => {\n                    this.fireError(error);\n                });\n            }\n        }\n        catch (error) {\n            this.fireError(error);\n        }\n    }\n    clearPartialMessageTimer() {\n        if (this.partialMessageTimer) {\n            this.partialMessageTimer.dispose();\n            this.partialMessageTimer = undefined;\n        }\n    }\n    setPartialMessageTimer() {\n        this.clearPartialMessageTimer();\n        if (this._partialMessageTimeout <= 0) {\n            return;\n        }\n        this.partialMessageTimer = (0, ral_1.default)().timer.setTimeout((token, timeout) => {\n            this.partialMessageTimer = undefined;\n            if (token === this.messageToken) {\n                this.firePartialMessage({ messageToken: token, waitingTime: timeout });\n                this.setPartialMessageTimer();\n            }\n        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);\n    }\n}\nexports.ReadableStreamMessageReader = ReadableStreamMessageReader;\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Semaphore = void 0;\nconst ral_1 = require(\"./ral\");\nclass Semaphore {\n    constructor(capacity = 1) {\n        if (capacity <= 0) {\n            throw new Error('Capacity must be greater than 0');\n        }\n        this._capacity = capacity;\n        this._active = 0;\n        this._waiting = [];\n    }\n    lock(thunk) {\n        return new Promise((resolve, reject) => {\n            this._waiting.push({ thunk, resolve, reject });\n            this.runNext();\n        });\n    }\n    get active() {\n        return this._active;\n    }\n    runNext() {\n        if (this._waiting.length === 0 || this._active === this._capacity) {\n            return;\n        }\n        (0, ral_1.default)().timer.setImmediate(() => this.doRunNext());\n    }\n    doRunNext() {\n        if (this._waiting.length === 0 || this._active === this._capacity) {\n            return;\n        }\n        const next = this._waiting.shift();\n        this._active++;\n        if (this._active > this._capacity) {\n            throw new Error(`To many thunks active`);\n        }\n        try {\n            const result = next.thunk();\n            if (result instanceof Promise) {\n                result.then((value) => {\n                    this._active--;\n                    next.resolve(value);\n                    this.runNext();\n                }, (err) => {\n                    this._active--;\n                    next.reject(err);\n                    this.runNext();\n                });\n            }\n            else {\n                this._active--;\n                next.resolve(result);\n                this.runNext();\n            }\n        }\n        catch (err) {\n            this._active--;\n            next.reject(err);\n            this.runNext();\n        }\n    }\n}\nexports.Semaphore = Semaphore;\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = void 0;\nconst ral_1 = require(\"./ral\");\nconst Is = require(\"./is\");\nconst semaphore_1 = require(\"./semaphore\");\nconst events_1 = require(\"./events\");\nconst ContentLength = 'Content-Length: ';\nconst CRLF = '\\r\\n';\nvar MessageWriter;\n(function (MessageWriter) {\n    function is(value) {\n        let candidate = value;\n        return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) &&\n            Is.func(candidate.onError) && Is.func(candidate.write);\n    }\n    MessageWriter.is = is;\n})(MessageWriter || (exports.MessageWriter = MessageWriter = {}));\nclass AbstractMessageWriter {\n    constructor() {\n        this.errorEmitter = new events_1.Emitter();\n        this.closeEmitter = new events_1.Emitter();\n    }\n    dispose() {\n        this.errorEmitter.dispose();\n        this.closeEmitter.dispose();\n    }\n    get onError() {\n        return this.errorEmitter.event;\n    }\n    fireError(error, message, count) {\n        this.errorEmitter.fire([this.asError(error), message, count]);\n    }\n    get onClose() {\n        return this.closeEmitter.event;\n    }\n    fireClose() {\n        this.closeEmitter.fire(undefined);\n    }\n    asError(error) {\n        if (error instanceof Error) {\n            return error;\n        }\n        else {\n            return new Error(`Writer received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);\n        }\n    }\n}\nexports.AbstractMessageWriter = AbstractMessageWriter;\nvar ResolvedMessageWriterOptions;\n(function (ResolvedMessageWriterOptions) {\n    function fromOptions(options) {\n        if (options === undefined || typeof options === 'string') {\n            return { charset: options ?? 'utf-8', contentTypeEncoder: (0, ral_1.default)().applicationJson.encoder };\n        }\n        else {\n            return { charset: options.charset ?? 'utf-8', contentEncoder: options.contentEncoder, contentTypeEncoder: options.contentTypeEncoder ?? (0, ral_1.default)().applicationJson.encoder };\n        }\n    }\n    ResolvedMessageWriterOptions.fromOptions = fromOptions;\n})(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));\nclass WriteableStreamMessageWriter extends AbstractMessageWriter {\n    constructor(writable, options) {\n        super();\n        this.writable = writable;\n        this.options = ResolvedMessageWriterOptions.fromOptions(options);\n        this.errorCount = 0;\n        this.writeSemaphore = new semaphore_1.Semaphore(1);\n        this.writable.onError((error) => this.fireError(error));\n        this.writable.onClose(() => this.fireClose());\n    }\n    async write(msg) {\n        return this.writeSemaphore.lock(async () => {\n            const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer) => {\n                if (this.options.contentEncoder !== undefined) {\n                    return this.options.contentEncoder.encode(buffer);\n                }\n                else {\n                    return buffer;\n                }\n            });\n            return payload.then((buffer) => {\n                const headers = [];\n                headers.push(ContentLength, buffer.byteLength.toString(), CRLF);\n                headers.push(CRLF);\n                return this.doWrite(msg, headers, buffer);\n            }, (error) => {\n                this.fireError(error);\n                throw error;\n            });\n        });\n    }\n    async doWrite(msg, headers, data) {\n        try {\n            await this.writable.write(headers.join(''), 'ascii');\n            return this.writable.write(data);\n        }\n        catch (error) {\n            this.handleError(error, msg);\n            return Promise.reject(error);\n        }\n    }\n    handleError(error, msg) {\n        this.errorCount++;\n        this.fireError(error, msg, this.errorCount);\n    }\n    end() {\n        this.writable.end();\n    }\n}\nexports.WriteableStreamMessageWriter = WriteableStreamMessageWriter;\n","\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AbstractMessageBuffer = void 0;\nconst CR = 13;\nconst LF = 10;\nconst CRLF = '\\r\\n';\nclass AbstractMessageBuffer {\n    constructor(encoding = 'utf-8') {\n        this._encoding = encoding;\n        this._chunks = [];\n        this._totalLength = 0;\n    }\n    get encoding() {\n        return this._encoding;\n    }\n    append(chunk) {\n        const toAppend = typeof chunk === 'string' ? this.fromString(chunk, this._encoding) : chunk;\n        this._chunks.push(toAppend);\n        this._totalLength += toAppend.byteLength;\n    }\n    tryReadHeaders(lowerCaseKeys = false) {\n        if (this._chunks.length === 0) {\n            return undefined;\n        }\n        let state = 0;\n        let chunkIndex = 0;\n        let offset = 0;\n        let chunkBytesRead = 0;\n        row: while (chunkIndex < this._chunks.length) {\n            const chunk = this._chunks[chunkIndex];\n            offset = 0;\n            column: while (offset < chunk.length) {\n                const value = chunk[offset];\n                switch (value) {\n                    case CR:\n                        switch (state) {\n                            case 0:\n                                state = 1;\n                                break;\n                            case 2:\n                                state = 3;\n                                break;\n                            default:\n                                state = 0;\n                        }\n                        break;\n                    case LF:\n                        switch (state) {\n                            case 1:\n                                state = 2;\n                                break;\n                            case 3:\n                                state = 4;\n                                offset++;\n                                break row;\n                            default:\n                                state = 0;\n                        }\n                        break;\n                    default:\n                        state = 0;\n                }\n                offset++;\n            }\n            chunkBytesRead += chunk.byteLength;\n            chunkIndex++;\n        }\n        if (state !== 4) {\n            return undefined;\n        }\n        // The buffer contains the two CRLF at the end. So we will\n        // have two empty lines after the split at the end as well.\n        const buffer = this._read(chunkBytesRead + offset);\n        const result = new Map();\n        const headers = this.toString(buffer, 'ascii').split(CRLF);\n        if (headers.length < 2) {\n            return result;\n        }\n        for (let i = 0; i < headers.length - 2; i++) {\n            const header = headers[i];\n            const index = header.indexOf(':');\n            if (index === -1) {\n                throw new Error(`Message header must separate key and value using ':'\\n${header}`);\n            }\n            const key = header.substr(0, index);\n            const value = header.substr(index + 1).trim();\n            result.set(lowerCaseKeys ? key.toLowerCase() : key, value);\n        }\n        return result;\n    }\n    tryReadBody(length) {\n        if (this._totalLength < length) {\n            return undefined;\n        }\n        return this._read(length);\n    }\n    get numberOfBytes() {\n        return this._totalLength;\n    }\n    _read(byteCount) {\n        if (byteCount === 0) {\n            return this.emptyBuffer();\n        }\n        if (byteCount > this._totalLength) {\n            throw new Error(`Cannot read so many bytes!`);\n        }\n        if (this._chunks[0].byteLength === byteCount) {\n            // super fast path, precisely first chunk must be returned\n            const chunk = this._chunks[0];\n            this._chunks.shift();\n            this._totalLength -= byteCount;\n            return this.asNative(chunk);\n        }\n        if (this._chunks[0].byteLength > byteCount) {\n            // fast path, the reading is entirely within the first chunk\n            const chunk = this._chunks[0];\n            const result = this.asNative(chunk, byteCount);\n            this._chunks[0] = chunk.slice(byteCount);\n            this._totalLength -= byteCount;\n            return result;\n        }\n        const result = this.allocNative(byteCount);\n        let resultOffset = 0;\n        let chunkIndex = 0;\n        while (byteCount > 0) {\n            const chunk = this._chunks[chunkIndex];\n            if (chunk.byteLength > byteCount) {\n                // this chunk will survive\n                const chunkPart = chunk.slice(0, byteCount);\n                result.set(chunkPart, resultOffset);\n                resultOffset += byteCount;\n                this._chunks[chunkIndex] = chunk.slice(byteCount);\n                this._totalLength -= byteCount;\n                byteCount -= byteCount;\n            }\n            else {\n                // this chunk will be entirely read\n                result.set(chunk, resultOffset);\n                resultOffset += chunk.byteLength;\n                this._chunks.shift();\n                this._totalLength -= chunk.byteLength;\n                byteCount -= chunk.byteLength;\n            }\n        }\n        return result;\n    }\n}\nexports.AbstractMessageBuffer = AbstractMessageBuffer;\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createMessageConnection = exports.ConnectionOptions = exports.MessageStrategy = exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.RequestCancellationReceiverStrategy = exports.IdCancellationReceiverStrategy = exports.ConnectionStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.TraceValues = exports.Trace = exports.NullLogger = exports.ProgressType = exports.ProgressToken = void 0;\nconst ral_1 = require(\"./ral\");\nconst Is = require(\"./is\");\nconst messages_1 = require(\"./messages\");\nconst linkedMap_1 = require(\"./linkedMap\");\nconst events_1 = require(\"./events\");\nconst cancellation_1 = require(\"./cancellation\");\nvar CancelNotification;\n(function (CancelNotification) {\n    CancelNotification.type = new messages_1.NotificationType('$/cancelRequest');\n})(CancelNotification || (CancelNotification = {}));\nvar ProgressToken;\n(function (ProgressToken) {\n    function is(value) {\n        return typeof value === 'string' || typeof value === 'number';\n    }\n    ProgressToken.is = is;\n})(ProgressToken || (exports.ProgressToken = ProgressToken = {}));\nvar ProgressNotification;\n(function (ProgressNotification) {\n    ProgressNotification.type = new messages_1.NotificationType('$/progress');\n})(ProgressNotification || (ProgressNotification = {}));\nclass ProgressType {\n    constructor() {\n    }\n}\nexports.ProgressType = ProgressType;\nvar StarRequestHandler;\n(function (StarRequestHandler) {\n    function is(value) {\n        return Is.func(value);\n    }\n    StarRequestHandler.is = is;\n})(StarRequestHandler || (StarRequestHandler = {}));\nexports.NullLogger = Object.freeze({\n    error: () => { },\n    warn: () => { },\n    info: () => { },\n    log: () => { }\n});\nvar Trace;\n(function (Trace) {\n    Trace[Trace[\"Off\"] = 0] = \"Off\";\n    Trace[Trace[\"Messages\"] = 1] = \"Messages\";\n    Trace[Trace[\"Compact\"] = 2] = \"Compact\";\n    Trace[Trace[\"Verbose\"] = 3] = \"Verbose\";\n})(Trace || (exports.Trace = Trace = {}));\nvar TraceValues;\n(function (TraceValues) {\n    /**\n     * Turn tracing off.\n     */\n    TraceValues.Off = 'off';\n    /**\n     * Trace messages only.\n     */\n    TraceValues.Messages = 'messages';\n    /**\n     * Compact message tracing.\n     */\n    TraceValues.Compact = 'compact';\n    /**\n     * Verbose message tracing.\n     */\n    TraceValues.Verbose = 'verbose';\n})(TraceValues || (exports.TraceValues = TraceValues = {}));\n(function (Trace) {\n    function fromString(value) {\n        if (!Is.string(value)) {\n            return Trace.Off;\n        }\n        value = value.toLowerCase();\n        switch (value) {\n            case 'off':\n                return Trace.Off;\n            case 'messages':\n                return Trace.Messages;\n            case 'compact':\n                return Trace.Compact;\n            case 'verbose':\n                return Trace.Verbose;\n            default:\n                return Trace.Off;\n        }\n    }\n    Trace.fromString = fromString;\n    function toString(value) {\n        switch (value) {\n            case Trace.Off:\n                return 'off';\n            case Trace.Messages:\n                return 'messages';\n            case Trace.Compact:\n                return 'compact';\n            case Trace.Verbose:\n                return 'verbose';\n            default:\n                return 'off';\n        }\n    }\n    Trace.toString = toString;\n})(Trace || (exports.Trace = Trace = {}));\nvar TraceFormat;\n(function (TraceFormat) {\n    TraceFormat[\"Text\"] = \"text\";\n    TraceFormat[\"JSON\"] = \"json\";\n})(TraceFormat || (exports.TraceFormat = TraceFormat = {}));\n(function (TraceFormat) {\n    function fromString(value) {\n        if (!Is.string(value)) {\n            return TraceFormat.Text;\n        }\n        value = value.toLowerCase();\n        if (value === 'json') {\n            return TraceFormat.JSON;\n        }\n        else {\n            return TraceFormat.Text;\n        }\n    }\n    TraceFormat.fromString = fromString;\n})(TraceFormat || (exports.TraceFormat = TraceFormat = {}));\nvar SetTraceNotification;\n(function (SetTraceNotification) {\n    SetTraceNotification.type = new messages_1.NotificationType('$/setTrace');\n})(SetTraceNotification || (exports.SetTraceNotification = SetTraceNotification = {}));\nvar LogTraceNotification;\n(function (LogTraceNotification) {\n    LogTraceNotification.type = new messages_1.NotificationType('$/logTrace');\n})(LogTraceNotification || (exports.LogTraceNotification = LogTraceNotification = {}));\nvar ConnectionErrors;\n(function (ConnectionErrors) {\n    /**\n     * The connection is closed.\n     */\n    ConnectionErrors[ConnectionErrors[\"Closed\"] = 1] = \"Closed\";\n    /**\n     * The connection got disposed.\n     */\n    ConnectionErrors[ConnectionErrors[\"Disposed\"] = 2] = \"Disposed\";\n    /**\n     * The connection is already in listening mode.\n     */\n    ConnectionErrors[ConnectionErrors[\"AlreadyListening\"] = 3] = \"AlreadyListening\";\n})(ConnectionErrors || (exports.ConnectionErrors = ConnectionErrors = {}));\nclass ConnectionError extends Error {\n    constructor(code, message) {\n        super(message);\n        this.code = code;\n        Object.setPrototypeOf(this, ConnectionError.prototype);\n    }\n}\nexports.ConnectionError = ConnectionError;\nvar ConnectionStrategy;\n(function (ConnectionStrategy) {\n    function is(value) {\n        const candidate = value;\n        return candidate && Is.func(candidate.cancelUndispatched);\n    }\n    ConnectionStrategy.is = is;\n})(ConnectionStrategy || (exports.ConnectionStrategy = ConnectionStrategy = {}));\nvar IdCancellationReceiverStrategy;\n(function (IdCancellationReceiverStrategy) {\n    function is(value) {\n        const candidate = value;\n        return candidate && (candidate.kind === undefined || candidate.kind === 'id') && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === undefined || Is.func(candidate.dispose));\n    }\n    IdCancellationReceiverStrategy.is = is;\n})(IdCancellationReceiverStrategy || (exports.IdCancellationReceiverStrategy = IdCancellationReceiverStrategy = {}));\nvar RequestCancellationReceiverStrategy;\n(function (RequestCancellationReceiverStrategy) {\n    function is(value) {\n        const candidate = value;\n        return candidate && candidate.kind === 'request' && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === undefined || Is.func(candidate.dispose));\n    }\n    RequestCancellationReceiverStrategy.is = is;\n})(RequestCancellationReceiverStrategy || (exports.RequestCancellationReceiverStrategy = RequestCancellationReceiverStrategy = {}));\nvar CancellationReceiverStrategy;\n(function (CancellationReceiverStrategy) {\n    CancellationReceiverStrategy.Message = Object.freeze({\n        createCancellationTokenSource(_) {\n            return new cancellation_1.CancellationTokenSource();\n        }\n    });\n    function is(value) {\n        return IdCancellationReceiverStrategy.is(value) || RequestCancellationReceiverStrategy.is(value);\n    }\n    CancellationReceiverStrategy.is = is;\n})(CancellationReceiverStrategy || (exports.CancellationReceiverStrategy = CancellationReceiverStrategy = {}));\nvar CancellationSenderStrategy;\n(function (CancellationSenderStrategy) {\n    CancellationSenderStrategy.Message = Object.freeze({\n        sendCancellation(conn, id) {\n            return conn.sendNotification(CancelNotification.type, { id });\n        },\n        cleanup(_) { }\n    });\n    function is(value) {\n        const candidate = value;\n        return candidate && Is.func(candidate.sendCancellation) && Is.func(candidate.cleanup);\n    }\n    CancellationSenderStrategy.is = is;\n})(CancellationSenderStrategy || (exports.CancellationSenderStrategy = CancellationSenderStrategy = {}));\nvar CancellationStrategy;\n(function (CancellationStrategy) {\n    CancellationStrategy.Message = Object.freeze({\n        receiver: CancellationReceiverStrategy.Message,\n        sender: CancellationSenderStrategy.Message\n    });\n    function is(value) {\n        const candidate = value;\n        return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);\n    }\n    CancellationStrategy.is = is;\n})(CancellationStrategy || (exports.CancellationStrategy = CancellationStrategy = {}));\nvar MessageStrategy;\n(function (MessageStrategy) {\n    function is(value) {\n        const candidate = value;\n        return candidate && Is.func(candidate.handleMessage);\n    }\n    MessageStrategy.is = is;\n})(MessageStrategy || (exports.MessageStrategy = MessageStrategy = {}));\nvar ConnectionOptions;\n(function (ConnectionOptions) {\n    function is(value) {\n        const candidate = value;\n        return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy) || MessageStrategy.is(candidate.messageStrategy));\n    }\n    ConnectionOptions.is = is;\n})(ConnectionOptions || (exports.ConnectionOptions = ConnectionOptions = {}));\nvar ConnectionState;\n(function (ConnectionState) {\n    ConnectionState[ConnectionState[\"New\"] = 1] = \"New\";\n    ConnectionState[ConnectionState[\"Listening\"] = 2] = \"Listening\";\n    ConnectionState[ConnectionState[\"Closed\"] = 3] = \"Closed\";\n    ConnectionState[ConnectionState[\"Disposed\"] = 4] = \"Disposed\";\n})(ConnectionState || (ConnectionState = {}));\nfunction createMessageConnection(messageReader, messageWriter, _logger, options) {\n    const logger = _logger !== undefined ? _logger : exports.NullLogger;\n    let sequenceNumber = 0;\n    let notificationSequenceNumber = 0;\n    let unknownResponseSequenceNumber = 0;\n    const version = '2.0';\n    let starRequestHandler = undefined;\n    const requestHandlers = new Map();\n    let starNotificationHandler = undefined;\n    const notificationHandlers = new Map();\n    const progressHandlers = new Map();\n    let timer;\n    let messageQueue = new linkedMap_1.LinkedMap();\n    let responsePromises = new Map();\n    let knownCanceledRequests = new Set();\n    let requestTokens = new Map();\n    let trace = Trace.Off;\n    let traceFormat = TraceFormat.Text;\n    let tracer;\n    let state = ConnectionState.New;\n    const errorEmitter = new events_1.Emitter();\n    const closeEmitter = new events_1.Emitter();\n    const unhandledNotificationEmitter = new events_1.Emitter();\n    const unhandledProgressEmitter = new events_1.Emitter();\n    const disposeEmitter = new events_1.Emitter();\n    const cancellationStrategy = (options && options.cancellationStrategy) ? options.cancellationStrategy : CancellationStrategy.Message;\n    function createRequestQueueKey(id) {\n        if (id === null) {\n            throw new Error(`Can't send requests with id null since the response can't be correlated.`);\n        }\n        return 'req-' + id.toString();\n    }\n    function createResponseQueueKey(id) {\n        if (id === null) {\n            return 'res-unknown-' + (++unknownResponseSequenceNumber).toString();\n        }\n        else {\n            return 'res-' + id.toString();\n        }\n    }\n    function createNotificationQueueKey() {\n        return 'not-' + (++notificationSequenceNumber).toString();\n    }\n    function addMessageToQueue(queue, message) {\n        if (messages_1.Message.isRequest(message)) {\n            queue.set(createRequestQueueKey(message.id), message);\n        }\n        else if (messages_1.Message.isResponse(message)) {\n            queue.set(createResponseQueueKey(message.id), message);\n        }\n        else {\n            queue.set(createNotificationQueueKey(), message);\n        }\n    }\n    function cancelUndispatched(_message) {\n        return undefined;\n    }\n    function isListening() {\n        return state === ConnectionState.Listening;\n    }\n    function isClosed() {\n        return state === ConnectionState.Closed;\n    }\n    function isDisposed() {\n        return state === ConnectionState.Disposed;\n    }\n    function closeHandler() {\n        if (state === ConnectionState.New || state === ConnectionState.Listening) {\n            state = ConnectionState.Closed;\n            closeEmitter.fire(undefined);\n        }\n        // If the connection is disposed don't sent close events.\n    }\n    function readErrorHandler(error) {\n        errorEmitter.fire([error, undefined, undefined]);\n    }\n    function writeErrorHandler(data) {\n        errorEmitter.fire(data);\n    }\n    messageReader.onClose(closeHandler);\n    messageReader.onError(readErrorHandler);\n    messageWriter.onClose(closeHandler);\n    messageWriter.onError(writeErrorHandler);\n    function triggerMessageQueue() {\n        if (timer || messageQueue.size === 0) {\n            return;\n        }\n        timer = (0, ral_1.default)().timer.setImmediate(() => {\n            timer = undefined;\n            processMessageQueue();\n        });\n    }\n    function handleMessage(message) {\n        if (messages_1.Message.isRequest(message)) {\n            handleRequest(message);\n        }\n        else if (messages_1.Message.isNotification(message)) {\n            handleNotification(message);\n        }\n        else if (messages_1.Message.isResponse(message)) {\n            handleResponse(message);\n        }\n        else {\n            handleInvalidMessage(message);\n        }\n    }\n    function processMessageQueue() {\n        if (messageQueue.size === 0) {\n            return;\n        }\n        const message = messageQueue.shift();\n        try {\n            const messageStrategy = options?.messageStrategy;\n            if (MessageStrategy.is(messageStrategy)) {\n                messageStrategy.handleMessage(message, handleMessage);\n            }\n            else {\n                handleMessage(message);\n            }\n        }\n        finally {\n            triggerMessageQueue();\n        }\n    }\n    const callback = (message) => {\n        try {\n            // We have received a cancellation message. Check if the message is still in the queue\n            // and cancel it if allowed to do so.\n            if (messages_1.Message.isNotification(message) && message.method === CancelNotification.type.method) {\n                const cancelId = message.params.id;\n                const key = createRequestQueueKey(cancelId);\n                const toCancel = messageQueue.get(key);\n                if (messages_1.Message.isRequest(toCancel)) {\n                    const strategy = options?.connectionStrategy;\n                    const response = (strategy && strategy.cancelUndispatched) ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);\n                    if (response && (response.error !== undefined || response.result !== undefined)) {\n                        messageQueue.delete(key);\n                        requestTokens.delete(cancelId);\n                        response.id = toCancel.id;\n                        traceSendingResponse(response, message.method, Date.now());\n                        messageWriter.write(response).catch(() => logger.error(`Sending response for canceled message failed.`));\n                        return;\n                    }\n                }\n                const cancellationToken = requestTokens.get(cancelId);\n                // The request is already running. Cancel the token\n                if (cancellationToken !== undefined) {\n                    cancellationToken.cancel();\n                    traceReceivedNotification(message);\n                    return;\n                }\n                else {\n                    // Remember the cancel but still queue the message to\n                    // clean up state in process message.\n                    knownCanceledRequests.add(cancelId);\n                }\n            }\n            addMessageToQueue(messageQueue, message);\n        }\n        finally {\n            triggerMessageQueue();\n        }\n    };\n    function handleRequest(requestMessage) {\n        if (isDisposed()) {\n            // we return here silently since we fired an event when the\n            // connection got disposed.\n            return;\n        }\n        function reply(resultOrError, method, startTime) {\n            const message = {\n                jsonrpc: version,\n                id: requestMessage.id\n            };\n            if (resultOrError instanceof messages_1.ResponseError) {\n                message.error = resultOrError.toJson();\n            }\n            else {\n                message.result = resultOrError === undefined ? null : resultOrError;\n            }\n            traceSendingResponse(message, method, startTime);\n            messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));\n        }\n        function replyError(error, method, startTime) {\n            const message = {\n                jsonrpc: version,\n                id: requestMessage.id,\n                error: error.toJson()\n            };\n            traceSendingResponse(message, method, startTime);\n            messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));\n        }\n        function replySuccess(result, method, startTime) {\n            // The JSON RPC defines that a response must either have a result or an error\n            // So we can't treat undefined as a valid response result.\n            if (result === undefined) {\n                result = null;\n            }\n            const message = {\n                jsonrpc: version,\n                id: requestMessage.id,\n                result: result\n            };\n            traceSendingResponse(message, method, startTime);\n            messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));\n        }\n        traceReceivedRequest(requestMessage);\n        const element = requestHandlers.get(requestMessage.method);\n        let type;\n        let requestHandler;\n        if (element) {\n            type = element.type;\n            requestHandler = element.handler;\n        }\n        const startTime = Date.now();\n        if (requestHandler || starRequestHandler) {\n            const tokenKey = requestMessage.id ?? String(Date.now()); //\n            const cancellationSource = IdCancellationReceiverStrategy.is(cancellationStrategy.receiver)\n                ? cancellationStrategy.receiver.createCancellationTokenSource(tokenKey)\n                : cancellationStrategy.receiver.createCancellationTokenSource(requestMessage);\n            if (requestMessage.id !== null && knownCanceledRequests.has(requestMessage.id)) {\n                cancellationSource.cancel();\n            }\n            if (requestMessage.id !== null) {\n                requestTokens.set(tokenKey, cancellationSource);\n            }\n            try {\n                let handlerResult;\n                if (requestHandler) {\n                    if (requestMessage.params === undefined) {\n                        if (type !== undefined && type.numberOfParams !== 0) {\n                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but received none.`), requestMessage.method, startTime);\n                            return;\n                        }\n                        handlerResult = requestHandler(cancellationSource.token);\n                    }\n                    else if (Array.isArray(requestMessage.params)) {\n                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byName) {\n                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);\n                            return;\n                        }\n                        handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);\n                    }\n                    else {\n                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {\n                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);\n                            return;\n                        }\n                        handlerResult = requestHandler(requestMessage.params, cancellationSource.token);\n                    }\n                }\n                else if (starRequestHandler) {\n                    handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);\n                }\n                const promise = handlerResult;\n                if (!handlerResult) {\n                    requestTokens.delete(tokenKey);\n                    replySuccess(handlerResult, requestMessage.method, startTime);\n                }\n                else if (promise.then) {\n                    promise.then((resultOrError) => {\n                        requestTokens.delete(tokenKey);\n                        reply(resultOrError, requestMessage.method, startTime);\n                    }, error => {\n                        requestTokens.delete(tokenKey);\n                        if (error instanceof messages_1.ResponseError) {\n                            replyError(error, requestMessage.method, startTime);\n                        }\n                        else if (error && Is.string(error.message)) {\n                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);\n                        }\n                        else {\n                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);\n                        }\n                    });\n                }\n                else {\n                    requestTokens.delete(tokenKey);\n                    reply(handlerResult, requestMessage.method, startTime);\n                }\n            }\n            catch (error) {\n                requestTokens.delete(tokenKey);\n                if (error instanceof messages_1.ResponseError) {\n                    reply(error, requestMessage.method, startTime);\n                }\n                else if (error && Is.string(error.message)) {\n                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);\n                }\n                else {\n                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);\n                }\n            }\n        }\n        else {\n            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);\n        }\n    }\n    function handleResponse(responseMessage) {\n        if (isDisposed()) {\n            // See handle request.\n            return;\n        }\n        if (responseMessage.id === null) {\n            if (responseMessage.error) {\n                logger.error(`Received response message without id: Error is: \\n${JSON.stringify(responseMessage.error, undefined, 4)}`);\n            }\n            else {\n                logger.error(`Received response message without id. No further error information provided.`);\n            }\n        }\n        else {\n            const key = responseMessage.id;\n            const responsePromise = responsePromises.get(key);\n            traceReceivedResponse(responseMessage, responsePromise);\n            if (responsePromise !== undefined) {\n                responsePromises.delete(key);\n                try {\n                    if (responseMessage.error) {\n                        const error = responseMessage.error;\n                        responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));\n                    }\n                    else if (responseMessage.result !== undefined) {\n                        responsePromise.resolve(responseMessage.result);\n                    }\n                    else {\n                        throw new Error('Should never happen.');\n                    }\n                }\n                catch (error) {\n                    if (error.message) {\n                        logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);\n                    }\n                    else {\n                        logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);\n                    }\n                }\n            }\n        }\n    }\n    function handleNotification(message) {\n        if (isDisposed()) {\n            // See handle request.\n            return;\n        }\n        let type = undefined;\n        let notificationHandler;\n        if (message.method === CancelNotification.type.method) {\n            const cancelId = message.params.id;\n            knownCanceledRequests.delete(cancelId);\n            traceReceivedNotification(message);\n            return;\n        }\n        else {\n            const element = notificationHandlers.get(message.method);\n            if (element) {\n                notificationHandler = element.handler;\n                type = element.type;\n            }\n        }\n        if (notificationHandler || starNotificationHandler) {\n            try {\n                traceReceivedNotification(message);\n                if (notificationHandler) {\n                    if (message.params === undefined) {\n                        if (type !== undefined) {\n                            if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {\n                                logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received none.`);\n                            }\n                        }\n                        notificationHandler();\n                    }\n                    else if (Array.isArray(message.params)) {\n                        // There are JSON-RPC libraries that send progress message as positional params although\n                        // specified as named. So convert them if this is the case.\n                        const params = message.params;\n                        if (message.method === ProgressNotification.type.method && params.length === 2 && ProgressToken.is(params[0])) {\n                            notificationHandler({ token: params[0], value: params[1] });\n                        }\n                        else {\n                            if (type !== undefined) {\n                                if (type.parameterStructures === messages_1.ParameterStructures.byName) {\n                                    logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);\n                                }\n                                if (type.numberOfParams !== message.params.length) {\n                                    logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${params.length} arguments`);\n                                }\n                            }\n                            notificationHandler(...params);\n                        }\n                    }\n                    else {\n                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {\n                            logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);\n                        }\n                        notificationHandler(message.params);\n                    }\n                }\n                else if (starNotificationHandler) {\n                    starNotificationHandler(message.method, message.params);\n                }\n            }\n            catch (error) {\n                if (error.message) {\n                    logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);\n                }\n                else {\n                    logger.error(`Notification handler '${message.method}' failed unexpectedly.`);\n                }\n            }\n        }\n        else {\n            unhandledNotificationEmitter.fire(message);\n        }\n    }\n    function handleInvalidMessage(message) {\n        if (!message) {\n            logger.error('Received empty message.');\n            return;\n        }\n        logger.error(`Received message which is neither a response nor a notification message:\\n${JSON.stringify(message, null, 4)}`);\n        // Test whether we find an id to reject the promise\n        const responseMessage = message;\n        if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {\n            const key = responseMessage.id;\n            const responseHandler = responsePromises.get(key);\n            if (responseHandler) {\n                responseHandler.reject(new Error('The received response has neither a result nor an error property.'));\n            }\n        }\n    }\n    function stringifyTrace(params) {\n        if (params === undefined || params === null) {\n            return undefined;\n        }\n        switch (trace) {\n            case Trace.Verbose:\n                return JSON.stringify(params, null, 4);\n            case Trace.Compact:\n                return JSON.stringify(params);\n            default:\n                return undefined;\n        }\n    }\n    function traceSendingRequest(message) {\n        if (trace === Trace.Off || !tracer) {\n            return;\n        }\n        if (traceFormat === TraceFormat.Text) {\n            let data = undefined;\n            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {\n                data = `Params: ${stringifyTrace(message.params)}\\n\\n`;\n            }\n            tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);\n        }\n        else {\n            logLSPMessage('send-request', message);\n        }\n    }\n    function traceSendingNotification(message) {\n        if (trace === Trace.Off || !tracer) {\n            return;\n        }\n        if (traceFormat === TraceFormat.Text) {\n            let data = undefined;\n            if (trace === Trace.Verbose || trace === Trace.Compact) {\n                if (message.params) {\n                    data = `Params: ${stringifyTrace(message.params)}\\n\\n`;\n                }\n                else {\n                    data = 'No parameters provided.\\n\\n';\n                }\n            }\n            tracer.log(`Sending notification '${message.method}'.`, data);\n        }\n        else {\n            logLSPMessage('send-notification', message);\n        }\n    }\n    function traceSendingResponse(message, method, startTime) {\n        if (trace === Trace.Off || !tracer) {\n            return;\n        }\n        if (traceFormat === TraceFormat.Text) {\n            let data = undefined;\n            if (trace === Trace.Verbose || trace === Trace.Compact) {\n                if (message.error && message.error.data) {\n                    data = `Error data: ${stringifyTrace(message.error.data)}\\n\\n`;\n                }\n                else {\n                    if (message.result) {\n                        data = `Result: ${stringifyTrace(message.result)}\\n\\n`;\n                    }\n                    else if (message.error === undefined) {\n                        data = 'No result returned.\\n\\n';\n                    }\n                }\n            }\n            tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);\n        }\n        else {\n            logLSPMessage('send-response', message);\n        }\n    }\n    function traceReceivedRequest(message) {\n        if (trace === Trace.Off || !tracer) {\n            return;\n        }\n        if (traceFormat === TraceFormat.Text) {\n            let data = undefined;\n            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {\n                data = `Params: ${stringifyTrace(message.params)}\\n\\n`;\n            }\n            tracer.log(`Received request '${message.method} - (${message.id})'.`, data);\n        }\n        else {\n            logLSPMessage('receive-request', message);\n        }\n    }\n    function traceReceivedNotification(message) {\n        if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {\n            return;\n        }\n        if (traceFormat === TraceFormat.Text) {\n            let data = undefined;\n            if (trace === Trace.Verbose || trace === Trace.Compact) {\n                if (message.params) {\n                    data = `Params: ${stringifyTrace(message.params)}\\n\\n`;\n                }\n                else {\n                    data = 'No parameters provided.\\n\\n';\n                }\n            }\n            tracer.log(`Received notification '${message.method}'.`, data);\n        }\n        else {\n            logLSPMessage('receive-notification', message);\n        }\n    }\n    function traceReceivedResponse(message, responsePromise) {\n        if (trace === Trace.Off || !tracer) {\n            return;\n        }\n        if (traceFormat === TraceFormat.Text) {\n            let data = undefined;\n            if (trace === Trace.Verbose || trace === Trace.Compact) {\n                if (message.error && message.error.data) {\n                    data = `Error data: ${stringifyTrace(message.error.data)}\\n\\n`;\n                }\n                else {\n                    if (message.result) {\n                        data = `Result: ${stringifyTrace(message.result)}\\n\\n`;\n                    }\n                    else if (message.error === undefined) {\n                        data = 'No result returned.\\n\\n';\n                    }\n                }\n            }\n            if (responsePromise) {\n                const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : '';\n                tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);\n            }\n            else {\n                tracer.log(`Received response ${message.id} without active response promise.`, data);\n            }\n        }\n        else {\n            logLSPMessage('receive-response', message);\n        }\n    }\n    function logLSPMessage(type, message) {\n        if (!tracer || trace === Trace.Off) {\n            return;\n        }\n        const lspMessage = {\n            isLSPMessage: true,\n            type,\n            message,\n            timestamp: Date.now()\n        };\n        tracer.log(lspMessage);\n    }\n    function throwIfClosedOrDisposed() {\n        if (isClosed()) {\n            throw new ConnectionError(ConnectionErrors.Closed, 'Connection is closed.');\n        }\n        if (isDisposed()) {\n            throw new ConnectionError(ConnectionErrors.Disposed, 'Connection is disposed.');\n        }\n    }\n    function throwIfListening() {\n        if (isListening()) {\n            throw new ConnectionError(ConnectionErrors.AlreadyListening, 'Connection is already listening');\n        }\n    }\n    function throwIfNotListening() {\n        if (!isListening()) {\n            throw new Error('Call listen() first.');\n        }\n    }\n    function undefinedToNull(param) {\n        if (param === undefined) {\n            return null;\n        }\n        else {\n            return param;\n        }\n    }\n    function nullToUndefined(param) {\n        if (param === null) {\n            return undefined;\n        }\n        else {\n            return param;\n        }\n    }\n    function isNamedParam(param) {\n        return param !== undefined && param !== null && !Array.isArray(param) && typeof param === 'object';\n    }\n    function computeSingleParam(parameterStructures, param) {\n        switch (parameterStructures) {\n            case messages_1.ParameterStructures.auto:\n                if (isNamedParam(param)) {\n                    return nullToUndefined(param);\n                }\n                else {\n                    return [undefinedToNull(param)];\n                }\n            case messages_1.ParameterStructures.byName:\n                if (!isNamedParam(param)) {\n                    throw new Error(`Received parameters by name but param is not an object literal.`);\n                }\n                return nullToUndefined(param);\n            case messages_1.ParameterStructures.byPosition:\n                return [undefinedToNull(param)];\n            default:\n                throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);\n        }\n    }\n    function computeMessageParams(type, params) {\n        let result;\n        const numberOfParams = type.numberOfParams;\n        switch (numberOfParams) {\n            case 0:\n                result = undefined;\n                break;\n            case 1:\n                result = computeSingleParam(type.parameterStructures, params[0]);\n                break;\n            default:\n                result = [];\n                for (let i = 0; i < params.length && i < numberOfParams; i++) {\n                    result.push(undefinedToNull(params[i]));\n                }\n                if (params.length < numberOfParams) {\n                    for (let i = params.length; i < numberOfParams; i++) {\n                        result.push(null);\n                    }\n                }\n                break;\n        }\n        return result;\n    }\n    const connection = {\n        sendNotification: (type, ...args) => {\n            throwIfClosedOrDisposed();\n            let method;\n            let messageParams;\n            if (Is.string(type)) {\n                method = type;\n                const first = args[0];\n                let paramStart = 0;\n                let parameterStructures = messages_1.ParameterStructures.auto;\n                if (messages_1.ParameterStructures.is(first)) {\n                    paramStart = 1;\n                    parameterStructures = first;\n                }\n                let paramEnd = args.length;\n                const numberOfParams = paramEnd - paramStart;\n                switch (numberOfParams) {\n                    case 0:\n                        messageParams = undefined;\n                        break;\n                    case 1:\n                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);\n                        break;\n                    default:\n                        if (parameterStructures === messages_1.ParameterStructures.byName) {\n                            throw new Error(`Received ${numberOfParams} parameters for 'by Name' notification parameter structure.`);\n                        }\n                        messageParams = args.slice(paramStart, paramEnd).map(value => undefinedToNull(value));\n                        break;\n                }\n            }\n            else {\n                const params = args;\n                method = type.method;\n                messageParams = computeMessageParams(type, params);\n            }\n            const notificationMessage = {\n                jsonrpc: version,\n                method: method,\n                params: messageParams\n            };\n            traceSendingNotification(notificationMessage);\n            return messageWriter.write(notificationMessage).catch((error) => {\n                logger.error(`Sending notification failed.`);\n                throw error;\n            });\n        },\n        onNotification: (type, handler) => {\n            throwIfClosedOrDisposed();\n            let method;\n            if (Is.func(type)) {\n                starNotificationHandler = type;\n            }\n            else if (handler) {\n                if (Is.string(type)) {\n                    method = type;\n                    notificationHandlers.set(type, { type: undefined, handler });\n                }\n                else {\n                    method = type.method;\n                    notificationHandlers.set(type.method, { type, handler });\n                }\n            }\n            return {\n                dispose: () => {\n                    if (method !== undefined) {\n                        notificationHandlers.delete(method);\n                    }\n                    else {\n                        starNotificationHandler = undefined;\n                    }\n                }\n            };\n        },\n        onProgress: (_type, token, handler) => {\n            if (progressHandlers.has(token)) {\n                throw new Error(`Progress handler for token ${token} already registered`);\n            }\n            progressHandlers.set(token, handler);\n            return {\n                dispose: () => {\n                    progressHandlers.delete(token);\n                }\n            };\n        },\n        sendProgress: (_type, token, value) => {\n            // This should not await but simple return to ensure that we don't have another\n            // async scheduling. Otherwise one send could overtake another send.\n            return connection.sendNotification(ProgressNotification.type, { token, value });\n        },\n        onUnhandledProgress: unhandledProgressEmitter.event,\n        sendRequest: (type, ...args) => {\n            throwIfClosedOrDisposed();\n            throwIfNotListening();\n            let method;\n            let messageParams;\n            let token = undefined;\n            if (Is.string(type)) {\n                method = type;\n                const first = args[0];\n                const last = args[args.length - 1];\n                let paramStart = 0;\n                let parameterStructures = messages_1.ParameterStructures.auto;\n                if (messages_1.ParameterStructures.is(first)) {\n                    paramStart = 1;\n                    parameterStructures = first;\n                }\n                let paramEnd = args.length;\n                if (cancellation_1.CancellationToken.is(last)) {\n                    paramEnd = paramEnd - 1;\n                    token = last;\n                }\n                const numberOfParams = paramEnd - paramStart;\n                switch (numberOfParams) {\n                    case 0:\n                        messageParams = undefined;\n                        break;\n                    case 1:\n                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);\n                        break;\n                    default:\n                        if (parameterStructures === messages_1.ParameterStructures.byName) {\n                            throw new Error(`Received ${numberOfParams} parameters for 'by Name' request parameter structure.`);\n                        }\n                        messageParams = args.slice(paramStart, paramEnd).map(value => undefinedToNull(value));\n                        break;\n                }\n            }\n            else {\n                const params = args;\n                method = type.method;\n                messageParams = computeMessageParams(type, params);\n                const numberOfParams = type.numberOfParams;\n                token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : undefined;\n            }\n            const id = sequenceNumber++;\n            let disposable;\n            if (token) {\n                disposable = token.onCancellationRequested(() => {\n                    const p = cancellationStrategy.sender.sendCancellation(connection, id);\n                    if (p === undefined) {\n                        logger.log(`Received no promise from cancellation strategy when cancelling id ${id}`);\n                        return Promise.resolve();\n                    }\n                    else {\n                        return p.catch(() => {\n                            logger.log(`Sending cancellation messages for id ${id} failed`);\n                        });\n                    }\n                });\n            }\n            const requestMessage = {\n                jsonrpc: version,\n                id: id,\n                method: method,\n                params: messageParams\n            };\n            traceSendingRequest(requestMessage);\n            if (typeof cancellationStrategy.sender.enableCancellation === 'function') {\n                cancellationStrategy.sender.enableCancellation(requestMessage);\n            }\n            return new Promise(async (resolve, reject) => {\n                const resolveWithCleanup = (r) => {\n                    resolve(r);\n                    cancellationStrategy.sender.cleanup(id);\n                    disposable?.dispose();\n                };\n                const rejectWithCleanup = (r) => {\n                    reject(r);\n                    cancellationStrategy.sender.cleanup(id);\n                    disposable?.dispose();\n                };\n                const responsePromise = { method: method, timerStart: Date.now(), resolve: resolveWithCleanup, reject: rejectWithCleanup };\n                try {\n                    await messageWriter.write(requestMessage);\n                    responsePromises.set(id, responsePromise);\n                }\n                catch (error) {\n                    logger.error(`Sending request failed.`);\n                    // Writing the message failed. So we need to reject the promise.\n                    responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, error.message ? error.message : 'Unknown reason'));\n                    throw error;\n                }\n            });\n        },\n        onRequest: (type, handler) => {\n            throwIfClosedOrDisposed();\n            let method = null;\n            if (StarRequestHandler.is(type)) {\n                method = undefined;\n                starRequestHandler = type;\n            }\n            else if (Is.string(type)) {\n                method = null;\n                if (handler !== undefined) {\n                    method = type;\n                    requestHandlers.set(type, { handler: handler, type: undefined });\n                }\n            }\n            else {\n                if (handler !== undefined) {\n                    method = type.method;\n                    requestHandlers.set(type.method, { type, handler });\n                }\n            }\n            return {\n                dispose: () => {\n                    if (method === null) {\n                        return;\n                    }\n                    if (method !== undefined) {\n                        requestHandlers.delete(method);\n                    }\n                    else {\n                        starRequestHandler = undefined;\n                    }\n                }\n            };\n        },\n        hasPendingResponse: () => {\n            return responsePromises.size > 0;\n        },\n        trace: async (_value, _tracer, sendNotificationOrTraceOptions) => {\n            let _sendNotification = false;\n            let _traceFormat = TraceFormat.Text;\n            if (sendNotificationOrTraceOptions !== undefined) {\n                if (Is.boolean(sendNotificationOrTraceOptions)) {\n                    _sendNotification = sendNotificationOrTraceOptions;\n                }\n                else {\n                    _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;\n                    _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;\n                }\n            }\n            trace = _value;\n            traceFormat = _traceFormat;\n            if (trace === Trace.Off) {\n                tracer = undefined;\n            }\n            else {\n                tracer = _tracer;\n            }\n            if (_sendNotification && !isClosed() && !isDisposed()) {\n                await connection.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });\n            }\n        },\n        onError: errorEmitter.event,\n        onClose: closeEmitter.event,\n        onUnhandledNotification: unhandledNotificationEmitter.event,\n        onDispose: disposeEmitter.event,\n        end: () => {\n            messageWriter.end();\n        },\n        dispose: () => {\n            if (isDisposed()) {\n                return;\n            }\n            state = ConnectionState.Disposed;\n            disposeEmitter.fire(undefined);\n            const error = new messages_1.ResponseError(messages_1.ErrorCodes.PendingResponseRejected, 'Pending response rejected since connection got disposed');\n            for (const promise of responsePromises.values()) {\n                promise.reject(error);\n            }\n            responsePromises = new Map();\n            requestTokens = new Map();\n            knownCanceledRequests = new Set();\n            messageQueue = new linkedMap_1.LinkedMap();\n            // Test for backwards compatibility\n            if (Is.func(messageWriter.dispose)) {\n                messageWriter.dispose();\n            }\n            if (Is.func(messageReader.dispose)) {\n                messageReader.dispose();\n            }\n        },\n        listen: () => {\n            throwIfClosedOrDisposed();\n            throwIfListening();\n            state = ConnectionState.Listening;\n            messageReader.listen(callback);\n        },\n        inspect: () => {\n            // eslint-disable-next-line no-console\n            (0, ral_1.default)().console.log('inspect');\n        }\n    };\n    connection.onNotification(LogTraceNotification.type, (params) => {\n        if (trace === Trace.Off || !tracer) {\n            return;\n        }\n        const verbose = trace === Trace.Verbose || trace === Trace.Compact;\n        tracer.log(params.message, verbose ? params.verbose : undefined);\n    });\n    connection.onNotification(ProgressNotification.type, (params) => {\n        const handler = progressHandlers.get(params.token);\n        if (handler) {\n            handler(params.value);\n        }\n        else {\n            unhandledProgressEmitter.fire(params);\n        }\n    });\n    return connection;\n}\nexports.createMessageConnection = createMessageConnection;\n","module.exports = require(\"path\");","module.exports = require(\"os\");","module.exports = require(\"crypto\");","module.exports = require(\"net\");","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LSPErrorCodes = exports.createProtocolConnection = void 0;\n__exportStar(require(\"vscode-jsonrpc\"), exports);\n__exportStar(require(\"vscode-languageserver-types\"), exports);\n__exportStar(require(\"./messages\"), exports);\n__exportStar(require(\"./protocol\"), exports);\nvar connection_1 = require(\"./connection\");\nObject.defineProperty(exports, \"createProtocolConnection\", { enumerable: true, get: function () { return connection_1.createProtocolConnection; } });\nvar LSPErrorCodes;\n(function (LSPErrorCodes) {\n    /**\n    * This is the start range of LSP reserved error codes.\n    * It doesn't denote a real error code.\n    *\n    * @since 3.16.0\n    */\n    LSPErrorCodes.lspReservedErrorRangeStart = -32899;\n    /**\n     * A request failed but it was syntactically correct, e.g the\n     * method name was known and the parameters were valid. The error\n     * message should contain human readable information about why\n     * the request failed.\n     *\n     * @since 3.17.0\n     */\n    LSPErrorCodes.RequestFailed = -32803;\n    /**\n     * The server cancelled the request. This error code should\n     * only be used for requests that explicitly support being\n     * server cancellable.\n     *\n     * @since 3.17.0\n     */\n    LSPErrorCodes.ServerCancelled = -32802;\n    /**\n     * The server detected that the content of a document got\n     * modified outside normal conditions. A server should\n     * NOT send this error code if it detects a content change\n     * in it unprocessed messages. The result even computed\n     * on an older state might still be useful for the client.\n     *\n     * If a client decides that a result is not of any use anymore\n     * the client should cancel the request.\n     */\n    LSPErrorCodes.ContentModified = -32801;\n    /**\n     * The client has canceled a request and a server as detected\n     * the cancel.\n     */\n    LSPErrorCodes.RequestCancelled = -32800;\n    /**\n    * This is the end range of LSP reserved error codes.\n    * It doesn't denote a real error code.\n    *\n    * @since 3.16.0\n    */\n    LSPErrorCodes.lspReservedErrorRangeEnd = -32800;\n})(LSPErrorCodes || (exports.LSPErrorCodes = LSPErrorCodes = {}));\n","(function (factory) {\n    if (typeof module === \"object\" && typeof module.exports === \"object\") {\n        var v = factory(require, exports);\n        if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === \"function\" && define.amd) {\n        define([\"require\", \"exports\"], factory);\n    }\n})(function (require, exports) {\n    /* --------------------------------------------------------------------------------------------\n     * Copyright (c) Microsoft Corporation. All rights reserved.\n     * Licensed under the MIT License. See License.txt in the project root for license information.\n     * ------------------------------------------------------------------------------------------ */\n    'use strict';\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.TextDocument = exports.EOL = exports.WorkspaceFolder = exports.InlineCompletionContext = exports.SelectedCompletionInfo = exports.InlineCompletionTriggerKind = exports.InlineCompletionList = exports.InlineCompletionItem = exports.StringValue = exports.InlayHint = exports.InlayHintLabelPart = exports.InlayHintKind = exports.InlineValueContext = exports.InlineValueEvaluatableExpression = exports.InlineValueVariableLookup = exports.InlineValueText = exports.SemanticTokens = exports.SemanticTokenModifiers = exports.SemanticTokenTypes = exports.SelectionRange = exports.DocumentLink = exports.FormattingOptions = exports.CodeLens = exports.CodeAction = exports.CodeActionContext = exports.CodeActionTriggerKind = exports.CodeActionKind = exports.DocumentSymbol = exports.WorkspaceSymbol = exports.SymbolInformation = exports.SymbolTag = exports.SymbolKind = exports.DocumentHighlight = exports.DocumentHighlightKind = exports.SignatureInformation = exports.ParameterInformation = exports.Hover = exports.MarkedString = exports.CompletionList = exports.CompletionItem = exports.CompletionItemLabelDetails = exports.InsertTextMode = exports.InsertReplaceEdit = exports.CompletionItemTag = exports.InsertTextFormat = exports.CompletionItemKind = exports.MarkupContent = exports.MarkupKind = exports.TextDocumentItem = exports.OptionalVersionedTextDocumentIdentifier = exports.VersionedTextDocumentIdentifier = exports.TextDocumentIdentifier = exports.WorkspaceChange = exports.WorkspaceEdit = exports.DeleteFile = exports.RenameFile = exports.CreateFile = exports.TextDocumentEdit = exports.AnnotatedTextEdit = exports.ChangeAnnotationIdentifier = exports.ChangeAnnotation = exports.TextEdit = exports.Command = exports.Diagnostic = exports.CodeDescription = exports.DiagnosticTag = exports.DiagnosticSeverity = exports.DiagnosticRelatedInformation = exports.FoldingRange = exports.FoldingRangeKind = exports.ColorPresentation = exports.ColorInformation = exports.Color = exports.LocationLink = exports.Location = exports.Range = exports.Position = exports.uinteger = exports.integer = exports.URI = exports.DocumentUri = void 0;\n    var DocumentUri;\n    (function (DocumentUri) {\n        function is(value) {\n            return typeof value === 'string';\n        }\n        DocumentUri.is = is;\n    })(DocumentUri || (exports.DocumentUri = DocumentUri = {}));\n    var URI;\n    (function (URI) {\n        function is(value) {\n            return typeof value === 'string';\n        }\n        URI.is = is;\n    })(URI || (exports.URI = URI = {}));\n    var integer;\n    (function (integer) {\n        integer.MIN_VALUE = -2147483648;\n        integer.MAX_VALUE = 2147483647;\n        function is(value) {\n            return typeof value === 'number' && integer.MIN_VALUE <= value && value <= integer.MAX_VALUE;\n        }\n        integer.is = is;\n    })(integer || (exports.integer = integer = {}));\n    var uinteger;\n    (function (uinteger) {\n        uinteger.MIN_VALUE = 0;\n        uinteger.MAX_VALUE = 2147483647;\n        function is(value) {\n            return typeof value === 'number' && uinteger.MIN_VALUE <= value && value <= uinteger.MAX_VALUE;\n        }\n        uinteger.is = is;\n    })(uinteger || (exports.uinteger = uinteger = {}));\n    /**\n     * The Position namespace provides helper functions to work with\n     * {@link Position} literals.\n     */\n    var Position;\n    (function (Position) {\n        /**\n         * Creates a new Position literal from the given line and character.\n         * @param line The position's line.\n         * @param character The position's character.\n         */\n        function create(line, character) {\n            if (line === Number.MAX_VALUE) {\n                line = uinteger.MAX_VALUE;\n            }\n            if (character === Number.MAX_VALUE) {\n                character = uinteger.MAX_VALUE;\n            }\n            return { line: line, character: character };\n        }\n        Position.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link Position} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);\n        }\n        Position.is = is;\n    })(Position || (exports.Position = Position = {}));\n    /**\n     * The Range namespace provides helper functions to work with\n     * {@link Range} literals.\n     */\n    var Range;\n    (function (Range) {\n        function create(one, two, three, four) {\n            if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {\n                return { start: Position.create(one, two), end: Position.create(three, four) };\n            }\n            else if (Position.is(one) && Position.is(two)) {\n                return { start: one, end: two };\n            }\n            else {\n                throw new Error(\"Range#create called with invalid arguments[\".concat(one, \", \").concat(two, \", \").concat(three, \", \").concat(four, \"]\"));\n            }\n        }\n        Range.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link Range} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);\n        }\n        Range.is = is;\n    })(Range || (exports.Range = Range = {}));\n    /**\n     * The Location namespace provides helper functions to work with\n     * {@link Location} literals.\n     */\n    var Location;\n    (function (Location) {\n        /**\n         * Creates a Location literal.\n         * @param uri The location's uri.\n         * @param range The location's range.\n         */\n        function create(uri, range) {\n            return { uri: uri, range: range };\n        }\n        Location.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link Location} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));\n        }\n        Location.is = is;\n    })(Location || (exports.Location = Location = {}));\n    /**\n     * The LocationLink namespace provides helper functions to work with\n     * {@link LocationLink} literals.\n     */\n    var LocationLink;\n    (function (LocationLink) {\n        /**\n         * Creates a LocationLink literal.\n         * @param targetUri The definition's uri.\n         * @param targetRange The full range of the definition.\n         * @param targetSelectionRange The span of the symbol definition at the target.\n         * @param originSelectionRange The span of the symbol being defined in the originating source file.\n         */\n        function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {\n            return { targetUri: targetUri, targetRange: targetRange, targetSelectionRange: targetSelectionRange, originSelectionRange: originSelectionRange };\n        }\n        LocationLink.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link LocationLink} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri)\n                && Range.is(candidate.targetSelectionRange)\n                && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));\n        }\n        LocationLink.is = is;\n    })(LocationLink || (exports.LocationLink = LocationLink = {}));\n    /**\n     * The Color namespace provides helper functions to work with\n     * {@link Color} literals.\n     */\n    var Color;\n    (function (Color) {\n        /**\n         * Creates a new Color literal.\n         */\n        function create(red, green, blue, alpha) {\n            return {\n                red: red,\n                green: green,\n                blue: blue,\n                alpha: alpha,\n            };\n        }\n        Color.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link Color} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1)\n                && Is.numberRange(candidate.green, 0, 1)\n                && Is.numberRange(candidate.blue, 0, 1)\n                && Is.numberRange(candidate.alpha, 0, 1);\n        }\n        Color.is = is;\n    })(Color || (exports.Color = Color = {}));\n    /**\n     * The ColorInformation namespace provides helper functions to work with\n     * {@link ColorInformation} literals.\n     */\n    var ColorInformation;\n    (function (ColorInformation) {\n        /**\n         * Creates a new ColorInformation literal.\n         */\n        function create(range, color) {\n            return {\n                range: range,\n                color: color,\n            };\n        }\n        ColorInformation.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link ColorInformation} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Range.is(candidate.range) && Color.is(candidate.color);\n        }\n        ColorInformation.is = is;\n    })(ColorInformation || (exports.ColorInformation = ColorInformation = {}));\n    /**\n     * The Color namespace provides helper functions to work with\n     * {@link ColorPresentation} literals.\n     */\n    var ColorPresentation;\n    (function (ColorPresentation) {\n        /**\n         * Creates a new ColorInformation literal.\n         */\n        function create(label, textEdit, additionalTextEdits) {\n            return {\n                label: label,\n                textEdit: textEdit,\n                additionalTextEdits: additionalTextEdits,\n            };\n        }\n        ColorPresentation.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link ColorInformation} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Is.string(candidate.label)\n                && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate))\n                && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));\n        }\n        ColorPresentation.is = is;\n    })(ColorPresentation || (exports.ColorPresentation = ColorPresentation = {}));\n    /**\n     * A set of predefined range kinds.\n     */\n    var FoldingRangeKind;\n    (function (FoldingRangeKind) {\n        /**\n         * Folding range for a comment\n         */\n        FoldingRangeKind.Comment = 'comment';\n        /**\n         * Folding range for an import or include\n         */\n        FoldingRangeKind.Imports = 'imports';\n        /**\n         * Folding range for a region (e.g. `#region`)\n         */\n        FoldingRangeKind.Region = 'region';\n    })(FoldingRangeKind || (exports.FoldingRangeKind = FoldingRangeKind = {}));\n    /**\n     * The folding range namespace provides helper functions to work with\n     * {@link FoldingRange} literals.\n     */\n    var FoldingRange;\n    (function (FoldingRange) {\n        /**\n         * Creates a new FoldingRange literal.\n         */\n        function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {\n            var result = {\n                startLine: startLine,\n                endLine: endLine\n            };\n            if (Is.defined(startCharacter)) {\n                result.startCharacter = startCharacter;\n            }\n            if (Is.defined(endCharacter)) {\n                result.endCharacter = endCharacter;\n            }\n            if (Is.defined(kind)) {\n                result.kind = kind;\n            }\n            if (Is.defined(collapsedText)) {\n                result.collapsedText = collapsedText;\n            }\n            return result;\n        }\n        FoldingRange.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link FoldingRange} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine)\n                && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter))\n                && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter))\n                && (Is.undefined(candidate.kind) || Is.string(candidate.kind));\n        }\n        FoldingRange.is = is;\n    })(FoldingRange || (exports.FoldingRange = FoldingRange = {}));\n    /**\n     * The DiagnosticRelatedInformation namespace provides helper functions to work with\n     * {@link DiagnosticRelatedInformation} literals.\n     */\n    var DiagnosticRelatedInformation;\n    (function (DiagnosticRelatedInformation) {\n        /**\n         * Creates a new DiagnosticRelatedInformation literal.\n         */\n        function create(location, message) {\n            return {\n                location: location,\n                message: message\n            };\n        }\n        DiagnosticRelatedInformation.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link DiagnosticRelatedInformation} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);\n        }\n        DiagnosticRelatedInformation.is = is;\n    })(DiagnosticRelatedInformation || (exports.DiagnosticRelatedInformation = DiagnosticRelatedInformation = {}));\n    /**\n     * The diagnostic's severity.\n     */\n    var DiagnosticSeverity;\n    (function (DiagnosticSeverity) {\n        /**\n         * Reports an error.\n         */\n        DiagnosticSeverity.Error = 1;\n        /**\n         * Reports a warning.\n         */\n        DiagnosticSeverity.Warning = 2;\n        /**\n         * Reports an information.\n         */\n        DiagnosticSeverity.Information = 3;\n        /**\n         * Reports a hint.\n         */\n        DiagnosticSeverity.Hint = 4;\n    })(DiagnosticSeverity || (exports.DiagnosticSeverity = DiagnosticSeverity = {}));\n    /**\n     * The diagnostic tags.\n     *\n     * @since 3.15.0\n     */\n    var DiagnosticTag;\n    (function (DiagnosticTag) {\n        /**\n         * Unused or unnecessary code.\n         *\n         * Clients are allowed to render diagnostics with this tag faded out instead of having\n         * an error squiggle.\n         */\n        DiagnosticTag.Unnecessary = 1;\n        /**\n         * Deprecated or obsolete code.\n         *\n         * Clients are allowed to rendered diagnostics with this tag strike through.\n         */\n        DiagnosticTag.Deprecated = 2;\n    })(DiagnosticTag || (exports.DiagnosticTag = DiagnosticTag = {}));\n    /**\n     * The CodeDescription namespace provides functions to deal with descriptions for diagnostic codes.\n     *\n     * @since 3.16.0\n     */\n    var CodeDescription;\n    (function (CodeDescription) {\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Is.string(candidate.href);\n        }\n        CodeDescription.is = is;\n    })(CodeDescription || (exports.CodeDescription = CodeDescription = {}));\n    /**\n     * The Diagnostic namespace provides helper functions to work with\n     * {@link Diagnostic} literals.\n     */\n    var Diagnostic;\n    (function (Diagnostic) {\n        /**\n         * Creates a new Diagnostic literal.\n         */\n        function create(range, message, severity, code, source, relatedInformation) {\n            var result = { range: range, message: message };\n            if (Is.defined(severity)) {\n                result.severity = severity;\n            }\n            if (Is.defined(code)) {\n                result.code = code;\n            }\n            if (Is.defined(source)) {\n                result.source = source;\n            }\n            if (Is.defined(relatedInformation)) {\n                result.relatedInformation = relatedInformation;\n            }\n            return result;\n        }\n        Diagnostic.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link Diagnostic} interface.\n         */\n        function is(value) {\n            var _a;\n            var candidate = value;\n            return Is.defined(candidate)\n                && Range.is(candidate.range)\n                && Is.string(candidate.message)\n                && (Is.number(candidate.severity) || Is.undefined(candidate.severity))\n                && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code))\n                && (Is.undefined(candidate.codeDescription) || (Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)))\n                && (Is.string(candidate.source) || Is.undefined(candidate.source))\n                && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));\n        }\n        Diagnostic.is = is;\n    })(Diagnostic || (exports.Diagnostic = Diagnostic = {}));\n    /**\n     * The Command namespace provides helper functions to work with\n     * {@link Command} literals.\n     */\n    var Command;\n    (function (Command) {\n        /**\n         * Creates a new Command literal.\n         */\n        function create(title, command) {\n            var args = [];\n            for (var _i = 2; _i < arguments.length; _i++) {\n                args[_i - 2] = arguments[_i];\n            }\n            var result = { title: title, command: command };\n            if (Is.defined(args) && args.length > 0) {\n                result.arguments = args;\n            }\n            return result;\n        }\n        Command.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link Command} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);\n        }\n        Command.is = is;\n    })(Command || (exports.Command = Command = {}));\n    /**\n     * The TextEdit namespace provides helper function to create replace,\n     * insert and delete edits more easily.\n     */\n    var TextEdit;\n    (function (TextEdit) {\n        /**\n         * Creates a replace text edit.\n         * @param range The range of text to be replaced.\n         * @param newText The new text.\n         */\n        function replace(range, newText) {\n            return { range: range, newText: newText };\n        }\n        TextEdit.replace = replace;\n        /**\n         * Creates an insert text edit.\n         * @param position The position to insert the text at.\n         * @param newText The text to be inserted.\n         */\n        function insert(position, newText) {\n            return { range: { start: position, end: position }, newText: newText };\n        }\n        TextEdit.insert = insert;\n        /**\n         * Creates a delete text edit.\n         * @param range The range of text to be deleted.\n         */\n        function del(range) {\n            return { range: range, newText: '' };\n        }\n        TextEdit.del = del;\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate)\n                && Is.string(candidate.newText)\n                && Range.is(candidate.range);\n        }\n        TextEdit.is = is;\n    })(TextEdit || (exports.TextEdit = TextEdit = {}));\n    var ChangeAnnotation;\n    (function (ChangeAnnotation) {\n        function create(label, needsConfirmation, description) {\n            var result = { label: label };\n            if (needsConfirmation !== undefined) {\n                result.needsConfirmation = needsConfirmation;\n            }\n            if (description !== undefined) {\n                result.description = description;\n            }\n            return result;\n        }\n        ChangeAnnotation.create = create;\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Is.string(candidate.label) &&\n                (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === undefined) &&\n                (Is.string(candidate.description) || candidate.description === undefined);\n        }\n        ChangeAnnotation.is = is;\n    })(ChangeAnnotation || (exports.ChangeAnnotation = ChangeAnnotation = {}));\n    var ChangeAnnotationIdentifier;\n    (function (ChangeAnnotationIdentifier) {\n        function is(value) {\n            var candidate = value;\n            return Is.string(candidate);\n        }\n        ChangeAnnotationIdentifier.is = is;\n    })(ChangeAnnotationIdentifier || (exports.ChangeAnnotationIdentifier = ChangeAnnotationIdentifier = {}));\n    var AnnotatedTextEdit;\n    (function (AnnotatedTextEdit) {\n        /**\n         * Creates an annotated replace text edit.\n         *\n         * @param range The range of text to be replaced.\n         * @param newText The new text.\n         * @param annotation The annotation.\n         */\n        function replace(range, newText, annotation) {\n            return { range: range, newText: newText, annotationId: annotation };\n        }\n        AnnotatedTextEdit.replace = replace;\n        /**\n         * Creates an annotated insert text edit.\n         *\n         * @param position The position to insert the text at.\n         * @param newText The text to be inserted.\n         * @param annotation The annotation.\n         */\n        function insert(position, newText, annotation) {\n            return { range: { start: position, end: position }, newText: newText, annotationId: annotation };\n        }\n        AnnotatedTextEdit.insert = insert;\n        /**\n         * Creates an annotated delete text edit.\n         *\n         * @param range The range of text to be deleted.\n         * @param annotation The annotation.\n         */\n        function del(range, annotation) {\n            return { range: range, newText: '', annotationId: annotation };\n        }\n        AnnotatedTextEdit.del = del;\n        function is(value) {\n            var candidate = value;\n            return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));\n        }\n        AnnotatedTextEdit.is = is;\n    })(AnnotatedTextEdit || (exports.AnnotatedTextEdit = AnnotatedTextEdit = {}));\n    /**\n     * The TextDocumentEdit namespace provides helper function to create\n     * an edit that manipulates a text document.\n     */\n    var TextDocumentEdit;\n    (function (TextDocumentEdit) {\n        /**\n         * Creates a new `TextDocumentEdit`\n         */\n        function create(textDocument, edits) {\n            return { textDocument: textDocument, edits: edits };\n        }\n        TextDocumentEdit.create = create;\n        function is(value) {\n            var candidate = value;\n            return Is.defined(candidate)\n                && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument)\n                && Array.isArray(candidate.edits);\n        }\n        TextDocumentEdit.is = is;\n    })(TextDocumentEdit || (exports.TextDocumentEdit = TextDocumentEdit = {}));\n    var CreateFile;\n    (function (CreateFile) {\n        function create(uri, options, annotation) {\n            var result = {\n                kind: 'create',\n                uri: uri\n            };\n            if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {\n                result.options = options;\n            }\n            if (annotation !== undefined) {\n                result.annotationId = annotation;\n            }\n            return result;\n        }\n        CreateFile.create = create;\n        function is(value) {\n            var candidate = value;\n            return candidate && candidate.kind === 'create' && Is.string(candidate.uri) && (candidate.options === undefined ||\n                ((candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));\n        }\n        CreateFile.is = is;\n    })(CreateFile || (exports.CreateFile = CreateFile = {}));\n    var RenameFile;\n    (function (RenameFile) {\n        function create(oldUri, newUri, options, annotation) {\n            var result = {\n                kind: 'rename',\n                oldUri: oldUri,\n                newUri: newUri\n            };\n            if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {\n                result.options = options;\n            }\n            if (annotation !== undefined) {\n                result.annotationId = annotation;\n            }\n            return result;\n        }\n        RenameFile.create = create;\n        function is(value) {\n            var candidate = value;\n            return candidate && candidate.kind === 'rename' && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === undefined ||\n                ((candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));\n        }\n        RenameFile.is = is;\n    })(RenameFile || (exports.RenameFile = RenameFile = {}));\n    var DeleteFile;\n    (function (DeleteFile) {\n        function create(uri, options, annotation) {\n            var result = {\n                kind: 'delete',\n                uri: uri\n            };\n            if (options !== undefined && (options.recursive !== undefined || options.ignoreIfNotExists !== undefined)) {\n                result.options = options;\n            }\n            if (annotation !== undefined) {\n                result.annotationId = annotation;\n            }\n            return result;\n        }\n        DeleteFile.create = create;\n        function is(value) {\n            var candidate = value;\n            return candidate && candidate.kind === 'delete' && Is.string(candidate.uri) && (candidate.options === undefined ||\n                ((candidate.options.recursive === undefined || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === undefined || Is.boolean(candidate.options.ignoreIfNotExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));\n        }\n        DeleteFile.is = is;\n    })(DeleteFile || (exports.DeleteFile = DeleteFile = {}));\n    var WorkspaceEdit;\n    (function (WorkspaceEdit) {\n        function is(value) {\n            var candidate = value;\n            return candidate &&\n                (candidate.changes !== undefined || candidate.documentChanges !== undefined) &&\n                (candidate.documentChanges === undefined || candidate.documentChanges.every(function (change) {\n                    if (Is.string(change.kind)) {\n                        return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);\n                    }\n                    else {\n                        return TextDocumentEdit.is(change);\n                    }\n                }));\n        }\n        WorkspaceEdit.is = is;\n    })(WorkspaceEdit || (exports.WorkspaceEdit = WorkspaceEdit = {}));\n    var TextEditChangeImpl = /** @class */ (function () {\n        function TextEditChangeImpl(edits, changeAnnotations) {\n            this.edits = edits;\n            this.changeAnnotations = changeAnnotations;\n        }\n        TextEditChangeImpl.prototype.insert = function (position, newText, annotation) {\n            var edit;\n            var id;\n            if (annotation === undefined) {\n                edit = TextEdit.insert(position, newText);\n            }\n            else if (ChangeAnnotationIdentifier.is(annotation)) {\n                id = annotation;\n                edit = AnnotatedTextEdit.insert(position, newText, annotation);\n            }\n            else {\n                this.assertChangeAnnotations(this.changeAnnotations);\n                id = this.changeAnnotations.manage(annotation);\n                edit = AnnotatedTextEdit.insert(position, newText, id);\n            }\n            this.edits.push(edit);\n            if (id !== undefined) {\n                return id;\n            }\n        };\n        TextEditChangeImpl.prototype.replace = function (range, newText, annotation) {\n            var edit;\n            var id;\n            if (annotation === undefined) {\n                edit = TextEdit.replace(range, newText);\n            }\n            else if (ChangeAnnotationIdentifier.is(annotation)) {\n                id = annotation;\n                edit = AnnotatedTextEdit.replace(range, newText, annotation);\n            }\n            else {\n                this.assertChangeAnnotations(this.changeAnnotations);\n                id = this.changeAnnotations.manage(annotation);\n                edit = AnnotatedTextEdit.replace(range, newText, id);\n            }\n            this.edits.push(edit);\n            if (id !== undefined) {\n                return id;\n            }\n        };\n        TextEditChangeImpl.prototype.delete = function (range, annotation) {\n            var edit;\n            var id;\n            if (annotation === undefined) {\n                edit = TextEdit.del(range);\n            }\n            else if (ChangeAnnotationIdentifier.is(annotation)) {\n                id = annotation;\n                edit = AnnotatedTextEdit.del(range, annotation);\n            }\n            else {\n                this.assertChangeAnnotations(this.changeAnnotations);\n                id = this.changeAnnotations.manage(annotation);\n                edit = AnnotatedTextEdit.del(range, id);\n            }\n            this.edits.push(edit);\n            if (id !== undefined) {\n                return id;\n            }\n        };\n        TextEditChangeImpl.prototype.add = function (edit) {\n            this.edits.push(edit);\n        };\n        TextEditChangeImpl.prototype.all = function () {\n            return this.edits;\n        };\n        TextEditChangeImpl.prototype.clear = function () {\n            this.edits.splice(0, this.edits.length);\n        };\n        TextEditChangeImpl.prototype.assertChangeAnnotations = function (value) {\n            if (value === undefined) {\n                throw new Error(\"Text edit change is not configured to manage change annotations.\");\n            }\n        };\n        return TextEditChangeImpl;\n    }());\n    /**\n     * A helper class\n     */\n    var ChangeAnnotations = /** @class */ (function () {\n        function ChangeAnnotations(annotations) {\n            this._annotations = annotations === undefined ? Object.create(null) : annotations;\n            this._counter = 0;\n            this._size = 0;\n        }\n        ChangeAnnotations.prototype.all = function () {\n            return this._annotations;\n        };\n        Object.defineProperty(ChangeAnnotations.prototype, \"size\", {\n            get: function () {\n                return this._size;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        ChangeAnnotations.prototype.manage = function (idOrAnnotation, annotation) {\n            var id;\n            if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {\n                id = idOrAnnotation;\n            }\n            else {\n                id = this.nextId();\n                annotation = idOrAnnotation;\n            }\n            if (this._annotations[id] !== undefined) {\n                throw new Error(\"Id \".concat(id, \" is already in use.\"));\n            }\n            if (annotation === undefined) {\n                throw new Error(\"No annotation provided for id \".concat(id));\n            }\n            this._annotations[id] = annotation;\n            this._size++;\n            return id;\n        };\n        ChangeAnnotations.prototype.nextId = function () {\n            this._counter++;\n            return this._counter.toString();\n        };\n        return ChangeAnnotations;\n    }());\n    /**\n     * A workspace change helps constructing changes to a workspace.\n     */\n    var WorkspaceChange = /** @class */ (function () {\n        function WorkspaceChange(workspaceEdit) {\n            var _this = this;\n            this._textEditChanges = Object.create(null);\n            if (workspaceEdit !== undefined) {\n                this._workspaceEdit = workspaceEdit;\n                if (workspaceEdit.documentChanges) {\n                    this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);\n                    workspaceEdit.changeAnnotations = this._changeAnnotations.all();\n                    workspaceEdit.documentChanges.forEach(function (change) {\n                        if (TextDocumentEdit.is(change)) {\n                            var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);\n                            _this._textEditChanges[change.textDocument.uri] = textEditChange;\n                        }\n                    });\n                }\n                else if (workspaceEdit.changes) {\n                    Object.keys(workspaceEdit.changes).forEach(function (key) {\n                        var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);\n                        _this._textEditChanges[key] = textEditChange;\n                    });\n                }\n            }\n            else {\n                this._workspaceEdit = {};\n            }\n        }\n        Object.defineProperty(WorkspaceChange.prototype, \"edit\", {\n            /**\n             * Returns the underlying {@link WorkspaceEdit} literal\n             * use to be returned from a workspace edit operation like rename.\n             */\n            get: function () {\n                this.initDocumentChanges();\n                if (this._changeAnnotations !== undefined) {\n                    if (this._changeAnnotations.size === 0) {\n                        this._workspaceEdit.changeAnnotations = undefined;\n                    }\n                    else {\n                        this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();\n                    }\n                }\n                return this._workspaceEdit;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        WorkspaceChange.prototype.getTextEditChange = function (key) {\n            if (OptionalVersionedTextDocumentIdentifier.is(key)) {\n                this.initDocumentChanges();\n                if (this._workspaceEdit.documentChanges === undefined) {\n                    throw new Error('Workspace edit is not configured for document changes.');\n                }\n                var textDocument = { uri: key.uri, version: key.version };\n                var result = this._textEditChanges[textDocument.uri];\n                if (!result) {\n                    var edits = [];\n                    var textDocumentEdit = {\n                        textDocument: textDocument,\n                        edits: edits\n                    };\n                    this._workspaceEdit.documentChanges.push(textDocumentEdit);\n                    result = new TextEditChangeImpl(edits, this._changeAnnotations);\n                    this._textEditChanges[textDocument.uri] = result;\n                }\n                return result;\n            }\n            else {\n                this.initChanges();\n                if (this._workspaceEdit.changes === undefined) {\n                    throw new Error('Workspace edit is not configured for normal text edit changes.');\n                }\n                var result = this._textEditChanges[key];\n                if (!result) {\n                    var edits = [];\n                    this._workspaceEdit.changes[key] = edits;\n                    result = new TextEditChangeImpl(edits);\n                    this._textEditChanges[key] = result;\n                }\n                return result;\n            }\n        };\n        WorkspaceChange.prototype.initDocumentChanges = function () {\n            if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {\n                this._changeAnnotations = new ChangeAnnotations();\n                this._workspaceEdit.documentChanges = [];\n                this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();\n            }\n        };\n        WorkspaceChange.prototype.initChanges = function () {\n            if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {\n                this._workspaceEdit.changes = Object.create(null);\n            }\n        };\n        WorkspaceChange.prototype.createFile = function (uri, optionsOrAnnotation, options) {\n            this.initDocumentChanges();\n            if (this._workspaceEdit.documentChanges === undefined) {\n                throw new Error('Workspace edit is not configured for document changes.');\n            }\n            var annotation;\n            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {\n                annotation = optionsOrAnnotation;\n            }\n            else {\n                options = optionsOrAnnotation;\n            }\n            var operation;\n            var id;\n            if (annotation === undefined) {\n                operation = CreateFile.create(uri, options);\n            }\n            else {\n                id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);\n                operation = CreateFile.create(uri, options, id);\n            }\n            this._workspaceEdit.documentChanges.push(operation);\n            if (id !== undefined) {\n                return id;\n            }\n        };\n        WorkspaceChange.prototype.renameFile = function (oldUri, newUri, optionsOrAnnotation, options) {\n            this.initDocumentChanges();\n            if (this._workspaceEdit.documentChanges === undefined) {\n                throw new Error('Workspace edit is not configured for document changes.');\n            }\n            var annotation;\n            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {\n                annotation = optionsOrAnnotation;\n            }\n            else {\n                options = optionsOrAnnotation;\n            }\n            var operation;\n            var id;\n            if (annotation === undefined) {\n                operation = RenameFile.create(oldUri, newUri, options);\n            }\n            else {\n                id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);\n                operation = RenameFile.create(oldUri, newUri, options, id);\n            }\n            this._workspaceEdit.documentChanges.push(operation);\n            if (id !== undefined) {\n                return id;\n            }\n        };\n        WorkspaceChange.prototype.deleteFile = function (uri, optionsOrAnnotation, options) {\n            this.initDocumentChanges();\n            if (this._workspaceEdit.documentChanges === undefined) {\n                throw new Error('Workspace edit is not configured for document changes.');\n            }\n            var annotation;\n            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {\n                annotation = optionsOrAnnotation;\n            }\n            else {\n                options = optionsOrAnnotation;\n            }\n            var operation;\n            var id;\n            if (annotation === undefined) {\n                operation = DeleteFile.create(uri, options);\n            }\n            else {\n                id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);\n                operation = DeleteFile.create(uri, options, id);\n            }\n            this._workspaceEdit.documentChanges.push(operation);\n            if (id !== undefined) {\n                return id;\n            }\n        };\n        return WorkspaceChange;\n    }());\n    exports.WorkspaceChange = WorkspaceChange;\n    /**\n     * The TextDocumentIdentifier namespace provides helper functions to work with\n     * {@link TextDocumentIdentifier} literals.\n     */\n    var TextDocumentIdentifier;\n    (function (TextDocumentIdentifier) {\n        /**\n         * Creates a new TextDocumentIdentifier literal.\n         * @param uri The document's uri.\n         */\n        function create(uri) {\n            return { uri: uri };\n        }\n        TextDocumentIdentifier.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link TextDocumentIdentifier} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Is.string(candidate.uri);\n        }\n        TextDocumentIdentifier.is = is;\n    })(TextDocumentIdentifier || (exports.TextDocumentIdentifier = TextDocumentIdentifier = {}));\n    /**\n     * The VersionedTextDocumentIdentifier namespace provides helper functions to work with\n     * {@link VersionedTextDocumentIdentifier} literals.\n     */\n    var VersionedTextDocumentIdentifier;\n    (function (VersionedTextDocumentIdentifier) {\n        /**\n         * Creates a new VersionedTextDocumentIdentifier literal.\n         * @param uri The document's uri.\n         * @param version The document's version.\n         */\n        function create(uri, version) {\n            return { uri: uri, version: version };\n        }\n        VersionedTextDocumentIdentifier.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link VersionedTextDocumentIdentifier} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);\n        }\n        VersionedTextDocumentIdentifier.is = is;\n    })(VersionedTextDocumentIdentifier || (exports.VersionedTextDocumentIdentifier = VersionedTextDocumentIdentifier = {}));\n    /**\n     * The OptionalVersionedTextDocumentIdentifier namespace provides helper functions to work with\n     * {@link OptionalVersionedTextDocumentIdentifier} literals.\n     */\n    var OptionalVersionedTextDocumentIdentifier;\n    (function (OptionalVersionedTextDocumentIdentifier) {\n        /**\n         * Creates a new OptionalVersionedTextDocumentIdentifier literal.\n         * @param uri The document's uri.\n         * @param version The document's version.\n         */\n        function create(uri, version) {\n            return { uri: uri, version: version };\n        }\n        OptionalVersionedTextDocumentIdentifier.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link OptionalVersionedTextDocumentIdentifier} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));\n        }\n        OptionalVersionedTextDocumentIdentifier.is = is;\n    })(OptionalVersionedTextDocumentIdentifier || (exports.OptionalVersionedTextDocumentIdentifier = OptionalVersionedTextDocumentIdentifier = {}));\n    /**\n     * The TextDocumentItem namespace provides helper functions to work with\n     * {@link TextDocumentItem} literals.\n     */\n    var TextDocumentItem;\n    (function (TextDocumentItem) {\n        /**\n         * Creates a new TextDocumentItem literal.\n         * @param uri The document's uri.\n         * @param languageId The document's language identifier.\n         * @param version The document's version number.\n         * @param text The document's text.\n         */\n        function create(uri, languageId, version, text) {\n            return { uri: uri, languageId: languageId, version: version, text: text };\n        }\n        TextDocumentItem.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link TextDocumentItem} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);\n        }\n        TextDocumentItem.is = is;\n    })(TextDocumentItem || (exports.TextDocumentItem = TextDocumentItem = {}));\n    /**\n     * Describes the content type that a client supports in various\n     * result literals like `Hover`, `ParameterInfo` or `CompletionItem`.\n     *\n     * Please note that `MarkupKinds` must not start with a `$`. This kinds\n     * are reserved for internal usage.\n     */\n    var MarkupKind;\n    (function (MarkupKind) {\n        /**\n         * Plain text is supported as a content format\n         */\n        MarkupKind.PlainText = 'plaintext';\n        /**\n         * Markdown is supported as a content format\n         */\n        MarkupKind.Markdown = 'markdown';\n        /**\n         * Checks whether the given value is a value of the {@link MarkupKind} type.\n         */\n        function is(value) {\n            var candidate = value;\n            return candidate === MarkupKind.PlainText || candidate === MarkupKind.Markdown;\n        }\n        MarkupKind.is = is;\n    })(MarkupKind || (exports.MarkupKind = MarkupKind = {}));\n    var MarkupContent;\n    (function (MarkupContent) {\n        /**\n         * Checks whether the given value conforms to the {@link MarkupContent} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);\n        }\n        MarkupContent.is = is;\n    })(MarkupContent || (exports.MarkupContent = MarkupContent = {}));\n    /**\n     * The kind of a completion entry.\n     */\n    var CompletionItemKind;\n    (function (CompletionItemKind) {\n        CompletionItemKind.Text = 1;\n        CompletionItemKind.Method = 2;\n        CompletionItemKind.Function = 3;\n        CompletionItemKind.Constructor = 4;\n        CompletionItemKind.Field = 5;\n        CompletionItemKind.Variable = 6;\n        CompletionItemKind.Class = 7;\n        CompletionItemKind.Interface = 8;\n        CompletionItemKind.Module = 9;\n        CompletionItemKind.Property = 10;\n        CompletionItemKind.Unit = 11;\n        CompletionItemKind.Value = 12;\n        CompletionItemKind.Enum = 13;\n        CompletionItemKind.Keyword = 14;\n        CompletionItemKind.Snippet = 15;\n        CompletionItemKind.Color = 16;\n        CompletionItemKind.File = 17;\n        CompletionItemKind.Reference = 18;\n        CompletionItemKind.Folder = 19;\n        CompletionItemKind.EnumMember = 20;\n        CompletionItemKind.Constant = 21;\n        CompletionItemKind.Struct = 22;\n        CompletionItemKind.Event = 23;\n        CompletionItemKind.Operator = 24;\n        CompletionItemKind.TypeParameter = 25;\n    })(CompletionItemKind || (exports.CompletionItemKind = CompletionItemKind = {}));\n    /**\n     * Defines whether the insert text in a completion item should be interpreted as\n     * plain text or a snippet.\n     */\n    var InsertTextFormat;\n    (function (InsertTextFormat) {\n        /**\n         * The primary text to be inserted is treated as a plain string.\n         */\n        InsertTextFormat.PlainText = 1;\n        /**\n         * The primary text to be inserted is treated as a snippet.\n         *\n         * A snippet can define tab stops and placeholders with `$1`, `$2`\n         * and `${3:foo}`. `$0` defines the final tab stop, it defaults to\n         * the end of the snippet. Placeholders with equal identifiers are linked,\n         * that is typing in one will update others too.\n         *\n         * See also: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#snippet_syntax\n         */\n        InsertTextFormat.Snippet = 2;\n    })(InsertTextFormat || (exports.InsertTextFormat = InsertTextFormat = {}));\n    /**\n     * Completion item tags are extra annotations that tweak the rendering of a completion\n     * item.\n     *\n     * @since 3.15.0\n     */\n    var CompletionItemTag;\n    (function (CompletionItemTag) {\n        /**\n         * Render a completion as obsolete, usually using a strike-out.\n         */\n        CompletionItemTag.Deprecated = 1;\n    })(CompletionItemTag || (exports.CompletionItemTag = CompletionItemTag = {}));\n    /**\n     * The InsertReplaceEdit namespace provides functions to deal with insert / replace edits.\n     *\n     * @since 3.16.0\n     */\n    var InsertReplaceEdit;\n    (function (InsertReplaceEdit) {\n        /**\n         * Creates a new insert / replace edit\n         */\n        function create(newText, insert, replace) {\n            return { newText: newText, insert: insert, replace: replace };\n        }\n        InsertReplaceEdit.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link InsertReplaceEdit} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);\n        }\n        InsertReplaceEdit.is = is;\n    })(InsertReplaceEdit || (exports.InsertReplaceEdit = InsertReplaceEdit = {}));\n    /**\n     * How whitespace and indentation is handled during completion\n     * item insertion.\n     *\n     * @since 3.16.0\n     */\n    var InsertTextMode;\n    (function (InsertTextMode) {\n        /**\n         * The insertion or replace strings is taken as it is. If the\n         * value is multi line the lines below the cursor will be\n         * inserted using the indentation defined in the string value.\n         * The client will not apply any kind of adjustments to the\n         * string.\n         */\n        InsertTextMode.asIs = 1;\n        /**\n         * The editor adjusts leading whitespace of new lines so that\n         * they match the indentation up to the cursor of the line for\n         * which the item is accepted.\n         *\n         * Consider a line like this: <2tabs><cursor><3tabs>foo. Accepting a\n         * multi line completion item is indented using 2 tabs and all\n         * following lines inserted will be indented using 2 tabs as well.\n         */\n        InsertTextMode.adjustIndentation = 2;\n    })(InsertTextMode || (exports.InsertTextMode = InsertTextMode = {}));\n    var CompletionItemLabelDetails;\n    (function (CompletionItemLabelDetails) {\n        function is(value) {\n            var candidate = value;\n            return candidate && (Is.string(candidate.detail) || candidate.detail === undefined) &&\n                (Is.string(candidate.description) || candidate.description === undefined);\n        }\n        CompletionItemLabelDetails.is = is;\n    })(CompletionItemLabelDetails || (exports.CompletionItemLabelDetails = CompletionItemLabelDetails = {}));\n    /**\n     * The CompletionItem namespace provides functions to deal with\n     * completion items.\n     */\n    var CompletionItem;\n    (function (CompletionItem) {\n        /**\n         * Create a completion item and seed it with a label.\n         * @param label The completion item's label\n         */\n        function create(label) {\n            return { label: label };\n        }\n        CompletionItem.create = create;\n    })(CompletionItem || (exports.CompletionItem = CompletionItem = {}));\n    /**\n     * The CompletionList namespace provides functions to deal with\n     * completion lists.\n     */\n    var CompletionList;\n    (function (CompletionList) {\n        /**\n         * Creates a new completion list.\n         *\n         * @param items The completion items.\n         * @param isIncomplete The list is not complete.\n         */\n        function create(items, isIncomplete) {\n            return { items: items ? items : [], isIncomplete: !!isIncomplete };\n        }\n        CompletionList.create = create;\n    })(CompletionList || (exports.CompletionList = CompletionList = {}));\n    var MarkedString;\n    (function (MarkedString) {\n        /**\n         * Creates a marked string from plain text.\n         *\n         * @param plainText The plain text.\n         */\n        function fromPlainText(plainText) {\n            return plainText.replace(/[\\\\`*_{}[\\]()#+\\-.!]/g, '\\\\$&'); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash\n        }\n        MarkedString.fromPlainText = fromPlainText;\n        /**\n         * Checks whether the given value conforms to the {@link MarkedString} type.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.string(candidate) || (Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value));\n        }\n        MarkedString.is = is;\n    })(MarkedString || (exports.MarkedString = MarkedString = {}));\n    var Hover;\n    (function (Hover) {\n        /**\n         * Checks whether the given value conforms to the {@link Hover} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) ||\n                MarkedString.is(candidate.contents) ||\n                Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === undefined || Range.is(value.range));\n        }\n        Hover.is = is;\n    })(Hover || (exports.Hover = Hover = {}));\n    /**\n     * The ParameterInformation namespace provides helper functions to work with\n     * {@link ParameterInformation} literals.\n     */\n    var ParameterInformation;\n    (function (ParameterInformation) {\n        /**\n         * Creates a new parameter information literal.\n         *\n         * @param label A label string.\n         * @param documentation A doc string.\n         */\n        function create(label, documentation) {\n            return documentation ? { label: label, documentation: documentation } : { label: label };\n        }\n        ParameterInformation.create = create;\n    })(ParameterInformation || (exports.ParameterInformation = ParameterInformation = {}));\n    /**\n     * The SignatureInformation namespace provides helper functions to work with\n     * {@link SignatureInformation} literals.\n     */\n    var SignatureInformation;\n    (function (SignatureInformation) {\n        function create(label, documentation) {\n            var parameters = [];\n            for (var _i = 2; _i < arguments.length; _i++) {\n                parameters[_i - 2] = arguments[_i];\n            }\n            var result = { label: label };\n            if (Is.defined(documentation)) {\n                result.documentation = documentation;\n            }\n            if (Is.defined(parameters)) {\n                result.parameters = parameters;\n            }\n            else {\n                result.parameters = [];\n            }\n            return result;\n        }\n        SignatureInformation.create = create;\n    })(SignatureInformation || (exports.SignatureInformation = SignatureInformation = {}));\n    /**\n     * A document highlight kind.\n     */\n    var DocumentHighlightKind;\n    (function (DocumentHighlightKind) {\n        /**\n         * A textual occurrence.\n         */\n        DocumentHighlightKind.Text = 1;\n        /**\n         * Read-access of a symbol, like reading a variable.\n         */\n        DocumentHighlightKind.Read = 2;\n        /**\n         * Write-access of a symbol, like writing to a variable.\n         */\n        DocumentHighlightKind.Write = 3;\n    })(DocumentHighlightKind || (exports.DocumentHighlightKind = DocumentHighlightKind = {}));\n    /**\n     * DocumentHighlight namespace to provide helper functions to work with\n     * {@link DocumentHighlight} literals.\n     */\n    var DocumentHighlight;\n    (function (DocumentHighlight) {\n        /**\n         * Create a DocumentHighlight object.\n         * @param range The range the highlight applies to.\n         * @param kind The highlight kind\n         */\n        function create(range, kind) {\n            var result = { range: range };\n            if (Is.number(kind)) {\n                result.kind = kind;\n            }\n            return result;\n        }\n        DocumentHighlight.create = create;\n    })(DocumentHighlight || (exports.DocumentHighlight = DocumentHighlight = {}));\n    /**\n     * A symbol kind.\n     */\n    var SymbolKind;\n    (function (SymbolKind) {\n        SymbolKind.File = 1;\n        SymbolKind.Module = 2;\n        SymbolKind.Namespace = 3;\n        SymbolKind.Package = 4;\n        SymbolKind.Class = 5;\n        SymbolKind.Method = 6;\n        SymbolKind.Property = 7;\n        SymbolKind.Field = 8;\n        SymbolKind.Constructor = 9;\n        SymbolKind.Enum = 10;\n        SymbolKind.Interface = 11;\n        SymbolKind.Function = 12;\n        SymbolKind.Variable = 13;\n        SymbolKind.Constant = 14;\n        SymbolKind.String = 15;\n        SymbolKind.Number = 16;\n        SymbolKind.Boolean = 17;\n        SymbolKind.Array = 18;\n        SymbolKind.Object = 19;\n        SymbolKind.Key = 20;\n        SymbolKind.Null = 21;\n        SymbolKind.EnumMember = 22;\n        SymbolKind.Struct = 23;\n        SymbolKind.Event = 24;\n        SymbolKind.Operator = 25;\n        SymbolKind.TypeParameter = 26;\n    })(SymbolKind || (exports.SymbolKind = SymbolKind = {}));\n    /**\n     * Symbol tags are extra annotations that tweak the rendering of a symbol.\n     *\n     * @since 3.16\n     */\n    var SymbolTag;\n    (function (SymbolTag) {\n        /**\n         * Render a symbol as obsolete, usually using a strike-out.\n         */\n        SymbolTag.Deprecated = 1;\n    })(SymbolTag || (exports.SymbolTag = SymbolTag = {}));\n    var SymbolInformation;\n    (function (SymbolInformation) {\n        /**\n         * Creates a new symbol information literal.\n         *\n         * @param name The name of the symbol.\n         * @param kind The kind of the symbol.\n         * @param range The range of the location of the symbol.\n         * @param uri The resource of the location of symbol.\n         * @param containerName The name of the symbol containing the symbol.\n         */\n        function create(name, kind, range, uri, containerName) {\n            var result = {\n                name: name,\n                kind: kind,\n                location: { uri: uri, range: range }\n            };\n            if (containerName) {\n                result.containerName = containerName;\n            }\n            return result;\n        }\n        SymbolInformation.create = create;\n    })(SymbolInformation || (exports.SymbolInformation = SymbolInformation = {}));\n    var WorkspaceSymbol;\n    (function (WorkspaceSymbol) {\n        /**\n         * Create a new workspace symbol.\n         *\n         * @param name The name of the symbol.\n         * @param kind The kind of the symbol.\n         * @param uri The resource of the location of the symbol.\n         * @param range An options range of the location.\n         * @returns A WorkspaceSymbol.\n         */\n        function create(name, kind, uri, range) {\n            return range !== undefined\n                ? { name: name, kind: kind, location: { uri: uri, range: range } }\n                : { name: name, kind: kind, location: { uri: uri } };\n        }\n        WorkspaceSymbol.create = create;\n    })(WorkspaceSymbol || (exports.WorkspaceSymbol = WorkspaceSymbol = {}));\n    var DocumentSymbol;\n    (function (DocumentSymbol) {\n        /**\n         * Creates a new symbol information literal.\n         *\n         * @param name The name of the symbol.\n         * @param detail The detail of the symbol.\n         * @param kind The kind of the symbol.\n         * @param range The range of the symbol.\n         * @param selectionRange The selectionRange of the symbol.\n         * @param children Children of the symbol.\n         */\n        function create(name, detail, kind, range, selectionRange, children) {\n            var result = {\n                name: name,\n                detail: detail,\n                kind: kind,\n                range: range,\n                selectionRange: selectionRange\n            };\n            if (children !== undefined) {\n                result.children = children;\n            }\n            return result;\n        }\n        DocumentSymbol.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link DocumentSymbol} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return candidate &&\n                Is.string(candidate.name) && Is.number(candidate.kind) &&\n                Range.is(candidate.range) && Range.is(candidate.selectionRange) &&\n                (candidate.detail === undefined || Is.string(candidate.detail)) &&\n                (candidate.deprecated === undefined || Is.boolean(candidate.deprecated)) &&\n                (candidate.children === undefined || Array.isArray(candidate.children)) &&\n                (candidate.tags === undefined || Array.isArray(candidate.tags));\n        }\n        DocumentSymbol.is = is;\n    })(DocumentSymbol || (exports.DocumentSymbol = DocumentSymbol = {}));\n    /**\n     * A set of predefined code action kinds\n     */\n    var CodeActionKind;\n    (function (CodeActionKind) {\n        /**\n         * Empty kind.\n         */\n        CodeActionKind.Empty = '';\n        /**\n         * Base kind for quickfix actions: 'quickfix'\n         */\n        CodeActionKind.QuickFix = 'quickfix';\n        /**\n         * Base kind for refactoring actions: 'refactor'\n         */\n        CodeActionKind.Refactor = 'refactor';\n        /**\n         * Base kind for refactoring extraction actions: 'refactor.extract'\n         *\n         * Example extract actions:\n         *\n         * - Extract method\n         * - Extract function\n         * - Extract variable\n         * - Extract interface from class\n         * - ...\n         */\n        CodeActionKind.RefactorExtract = 'refactor.extract';\n        /**\n         * Base kind for refactoring inline actions: 'refactor.inline'\n         *\n         * Example inline actions:\n         *\n         * - Inline function\n         * - Inline variable\n         * - Inline constant\n         * - ...\n         */\n        CodeActionKind.RefactorInline = 'refactor.inline';\n        /**\n         * Base kind for refactoring rewrite actions: 'refactor.rewrite'\n         *\n         * Example rewrite actions:\n         *\n         * - Convert JavaScript function to class\n         * - Add or remove parameter\n         * - Encapsulate field\n         * - Make method static\n         * - Move method to base class\n         * - ...\n         */\n        CodeActionKind.RefactorRewrite = 'refactor.rewrite';\n        /**\n         * Base kind for source actions: `source`\n         *\n         * Source code actions apply to the entire file.\n         */\n        CodeActionKind.Source = 'source';\n        /**\n         * Base kind for an organize imports source action: `source.organizeImports`\n         */\n        CodeActionKind.SourceOrganizeImports = 'source.organizeImports';\n        /**\n         * Base kind for auto-fix source actions: `source.fixAll`.\n         *\n         * Fix all actions automatically fix errors that have a clear fix that do not require user input.\n         * They should not suppress errors or perform unsafe fixes such as generating new types or classes.\n         *\n         * @since 3.15.0\n         */\n        CodeActionKind.SourceFixAll = 'source.fixAll';\n    })(CodeActionKind || (exports.CodeActionKind = CodeActionKind = {}));\n    /**\n     * The reason why code actions were requested.\n     *\n     * @since 3.17.0\n     */\n    var CodeActionTriggerKind;\n    (function (CodeActionTriggerKind) {\n        /**\n         * Code actions were explicitly requested by the user or by an extension.\n         */\n        CodeActionTriggerKind.Invoked = 1;\n        /**\n         * Code actions were requested automatically.\n         *\n         * This typically happens when current selection in a file changes, but can\n         * also be triggered when file content changes.\n         */\n        CodeActionTriggerKind.Automatic = 2;\n    })(CodeActionTriggerKind || (exports.CodeActionTriggerKind = CodeActionTriggerKind = {}));\n    /**\n     * The CodeActionContext namespace provides helper functions to work with\n     * {@link CodeActionContext} literals.\n     */\n    var CodeActionContext;\n    (function (CodeActionContext) {\n        /**\n         * Creates a new CodeActionContext literal.\n         */\n        function create(diagnostics, only, triggerKind) {\n            var result = { diagnostics: diagnostics };\n            if (only !== undefined && only !== null) {\n                result.only = only;\n            }\n            if (triggerKind !== undefined && triggerKind !== null) {\n                result.triggerKind = triggerKind;\n            }\n            return result;\n        }\n        CodeActionContext.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link CodeActionContext} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is)\n                && (candidate.only === undefined || Is.typedArray(candidate.only, Is.string))\n                && (candidate.triggerKind === undefined || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);\n        }\n        CodeActionContext.is = is;\n    })(CodeActionContext || (exports.CodeActionContext = CodeActionContext = {}));\n    var CodeAction;\n    (function (CodeAction) {\n        function create(title, kindOrCommandOrEdit, kind) {\n            var result = { title: title };\n            var checkKind = true;\n            if (typeof kindOrCommandOrEdit === 'string') {\n                checkKind = false;\n                result.kind = kindOrCommandOrEdit;\n            }\n            else if (Command.is(kindOrCommandOrEdit)) {\n                result.command = kindOrCommandOrEdit;\n            }\n            else {\n                result.edit = kindOrCommandOrEdit;\n            }\n            if (checkKind && kind !== undefined) {\n                result.kind = kind;\n            }\n            return result;\n        }\n        CodeAction.create = create;\n        function is(value) {\n            var candidate = value;\n            return candidate && Is.string(candidate.title) &&\n                (candidate.diagnostics === undefined || Is.typedArray(candidate.diagnostics, Diagnostic.is)) &&\n                (candidate.kind === undefined || Is.string(candidate.kind)) &&\n                (candidate.edit !== undefined || candidate.command !== undefined) &&\n                (candidate.command === undefined || Command.is(candidate.command)) &&\n                (candidate.isPreferred === undefined || Is.boolean(candidate.isPreferred)) &&\n                (candidate.edit === undefined || WorkspaceEdit.is(candidate.edit));\n        }\n        CodeAction.is = is;\n    })(CodeAction || (exports.CodeAction = CodeAction = {}));\n    /**\n     * The CodeLens namespace provides helper functions to work with\n     * {@link CodeLens} literals.\n     */\n    var CodeLens;\n    (function (CodeLens) {\n        /**\n         * Creates a new CodeLens literal.\n         */\n        function create(range, data) {\n            var result = { range: range };\n            if (Is.defined(data)) {\n                result.data = data;\n            }\n            return result;\n        }\n        CodeLens.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link CodeLens} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));\n        }\n        CodeLens.is = is;\n    })(CodeLens || (exports.CodeLens = CodeLens = {}));\n    /**\n     * The FormattingOptions namespace provides helper functions to work with\n     * {@link FormattingOptions} literals.\n     */\n    var FormattingOptions;\n    (function (FormattingOptions) {\n        /**\n         * Creates a new FormattingOptions literal.\n         */\n        function create(tabSize, insertSpaces) {\n            return { tabSize: tabSize, insertSpaces: insertSpaces };\n        }\n        FormattingOptions.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link FormattingOptions} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);\n        }\n        FormattingOptions.is = is;\n    })(FormattingOptions || (exports.FormattingOptions = FormattingOptions = {}));\n    /**\n     * The DocumentLink namespace provides helper functions to work with\n     * {@link DocumentLink} literals.\n     */\n    var DocumentLink;\n    (function (DocumentLink) {\n        /**\n         * Creates a new DocumentLink literal.\n         */\n        function create(range, target, data) {\n            return { range: range, target: target, data: data };\n        }\n        DocumentLink.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link DocumentLink} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));\n        }\n        DocumentLink.is = is;\n    })(DocumentLink || (exports.DocumentLink = DocumentLink = {}));\n    /**\n     * The SelectionRange namespace provides helper function to work with\n     * SelectionRange literals.\n     */\n    var SelectionRange;\n    (function (SelectionRange) {\n        /**\n         * Creates a new SelectionRange\n         * @param range the range.\n         * @param parent an optional parent.\n         */\n        function create(range, parent) {\n            return { range: range, parent: parent };\n        }\n        SelectionRange.create = create;\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Range.is(candidate.range) && (candidate.parent === undefined || SelectionRange.is(candidate.parent));\n        }\n        SelectionRange.is = is;\n    })(SelectionRange || (exports.SelectionRange = SelectionRange = {}));\n    /**\n     * A set of predefined token types. This set is not fixed\n     * an clients can specify additional token types via the\n     * corresponding client capabilities.\n     *\n     * @since 3.16.0\n     */\n    var SemanticTokenTypes;\n    (function (SemanticTokenTypes) {\n        SemanticTokenTypes[\"namespace\"] = \"namespace\";\n        /**\n         * Represents a generic type. Acts as a fallback for types which can't be mapped to\n         * a specific type like class or enum.\n         */\n        SemanticTokenTypes[\"type\"] = \"type\";\n        SemanticTokenTypes[\"class\"] = \"class\";\n        SemanticTokenTypes[\"enum\"] = \"enum\";\n        SemanticTokenTypes[\"interface\"] = \"interface\";\n        SemanticTokenTypes[\"struct\"] = \"struct\";\n        SemanticTokenTypes[\"typeParameter\"] = \"typeParameter\";\n        SemanticTokenTypes[\"parameter\"] = \"parameter\";\n        SemanticTokenTypes[\"variable\"] = \"variable\";\n        SemanticTokenTypes[\"property\"] = \"property\";\n        SemanticTokenTypes[\"enumMember\"] = \"enumMember\";\n        SemanticTokenTypes[\"event\"] = \"event\";\n        SemanticTokenTypes[\"function\"] = \"function\";\n        SemanticTokenTypes[\"method\"] = \"method\";\n        SemanticTokenTypes[\"macro\"] = \"macro\";\n        SemanticTokenTypes[\"keyword\"] = \"keyword\";\n        SemanticTokenTypes[\"modifier\"] = \"modifier\";\n        SemanticTokenTypes[\"comment\"] = \"comment\";\n        SemanticTokenTypes[\"string\"] = \"string\";\n        SemanticTokenTypes[\"number\"] = \"number\";\n        SemanticTokenTypes[\"regexp\"] = \"regexp\";\n        SemanticTokenTypes[\"operator\"] = \"operator\";\n        /**\n         * @since 3.17.0\n         */\n        SemanticTokenTypes[\"decorator\"] = \"decorator\";\n    })(SemanticTokenTypes || (exports.SemanticTokenTypes = SemanticTokenTypes = {}));\n    /**\n     * A set of predefined token modifiers. This set is not fixed\n     * an clients can specify additional token types via the\n     * corresponding client capabilities.\n     *\n     * @since 3.16.0\n     */\n    var SemanticTokenModifiers;\n    (function (SemanticTokenModifiers) {\n        SemanticTokenModifiers[\"declaration\"] = \"declaration\";\n        SemanticTokenModifiers[\"definition\"] = \"definition\";\n        SemanticTokenModifiers[\"readonly\"] = \"readonly\";\n        SemanticTokenModifiers[\"static\"] = \"static\";\n        SemanticTokenModifiers[\"deprecated\"] = \"deprecated\";\n        SemanticTokenModifiers[\"abstract\"] = \"abstract\";\n        SemanticTokenModifiers[\"async\"] = \"async\";\n        SemanticTokenModifiers[\"modification\"] = \"modification\";\n        SemanticTokenModifiers[\"documentation\"] = \"documentation\";\n        SemanticTokenModifiers[\"defaultLibrary\"] = \"defaultLibrary\";\n    })(SemanticTokenModifiers || (exports.SemanticTokenModifiers = SemanticTokenModifiers = {}));\n    /**\n     * @since 3.16.0\n     */\n    var SemanticTokens;\n    (function (SemanticTokens) {\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && (candidate.resultId === undefined || typeof candidate.resultId === 'string') &&\n                Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === 'number');\n        }\n        SemanticTokens.is = is;\n    })(SemanticTokens || (exports.SemanticTokens = SemanticTokens = {}));\n    /**\n     * The InlineValueText namespace provides functions to deal with InlineValueTexts.\n     *\n     * @since 3.17.0\n     */\n    var InlineValueText;\n    (function (InlineValueText) {\n        /**\n         * Creates a new InlineValueText literal.\n         */\n        function create(range, text) {\n            return { range: range, text: text };\n        }\n        InlineValueText.create = create;\n        function is(value) {\n            var candidate = value;\n            return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.string(candidate.text);\n        }\n        InlineValueText.is = is;\n    })(InlineValueText || (exports.InlineValueText = InlineValueText = {}));\n    /**\n     * The InlineValueVariableLookup namespace provides functions to deal with InlineValueVariableLookups.\n     *\n     * @since 3.17.0\n     */\n    var InlineValueVariableLookup;\n    (function (InlineValueVariableLookup) {\n        /**\n         * Creates a new InlineValueText literal.\n         */\n        function create(range, variableName, caseSensitiveLookup) {\n            return { range: range, variableName: variableName, caseSensitiveLookup: caseSensitiveLookup };\n        }\n        InlineValueVariableLookup.create = create;\n        function is(value) {\n            var candidate = value;\n            return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup)\n                && (Is.string(candidate.variableName) || candidate.variableName === undefined);\n        }\n        InlineValueVariableLookup.is = is;\n    })(InlineValueVariableLookup || (exports.InlineValueVariableLookup = InlineValueVariableLookup = {}));\n    /**\n     * The InlineValueEvaluatableExpression namespace provides functions to deal with InlineValueEvaluatableExpression.\n     *\n     * @since 3.17.0\n     */\n    var InlineValueEvaluatableExpression;\n    (function (InlineValueEvaluatableExpression) {\n        /**\n         * Creates a new InlineValueEvaluatableExpression literal.\n         */\n        function create(range, expression) {\n            return { range: range, expression: expression };\n        }\n        InlineValueEvaluatableExpression.create = create;\n        function is(value) {\n            var candidate = value;\n            return candidate !== undefined && candidate !== null && Range.is(candidate.range)\n                && (Is.string(candidate.expression) || candidate.expression === undefined);\n        }\n        InlineValueEvaluatableExpression.is = is;\n    })(InlineValueEvaluatableExpression || (exports.InlineValueEvaluatableExpression = InlineValueEvaluatableExpression = {}));\n    /**\n     * The InlineValueContext namespace provides helper functions to work with\n     * {@link InlineValueContext} literals.\n     *\n     * @since 3.17.0\n     */\n    var InlineValueContext;\n    (function (InlineValueContext) {\n        /**\n         * Creates a new InlineValueContext literal.\n         */\n        function create(frameId, stoppedLocation) {\n            return { frameId: frameId, stoppedLocation: stoppedLocation };\n        }\n        InlineValueContext.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link InlineValueContext} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Range.is(value.stoppedLocation);\n        }\n        InlineValueContext.is = is;\n    })(InlineValueContext || (exports.InlineValueContext = InlineValueContext = {}));\n    /**\n     * Inlay hint kinds.\n     *\n     * @since 3.17.0\n     */\n    var InlayHintKind;\n    (function (InlayHintKind) {\n        /**\n         * An inlay hint that for a type annotation.\n         */\n        InlayHintKind.Type = 1;\n        /**\n         * An inlay hint that is for a parameter.\n         */\n        InlayHintKind.Parameter = 2;\n        function is(value) {\n            return value === 1 || value === 2;\n        }\n        InlayHintKind.is = is;\n    })(InlayHintKind || (exports.InlayHintKind = InlayHintKind = {}));\n    var InlayHintLabelPart;\n    (function (InlayHintLabelPart) {\n        function create(value) {\n            return { value: value };\n        }\n        InlayHintLabelPart.create = create;\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate)\n                && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip))\n                && (candidate.location === undefined || Location.is(candidate.location))\n                && (candidate.command === undefined || Command.is(candidate.command));\n        }\n        InlayHintLabelPart.is = is;\n    })(InlayHintLabelPart || (exports.InlayHintLabelPart = InlayHintLabelPart = {}));\n    var InlayHint;\n    (function (InlayHint) {\n        function create(position, label, kind) {\n            var result = { position: position, label: label };\n            if (kind !== undefined) {\n                result.kind = kind;\n            }\n            return result;\n        }\n        InlayHint.create = create;\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && Position.is(candidate.position)\n                && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is))\n                && (candidate.kind === undefined || InlayHintKind.is(candidate.kind))\n                && (candidate.textEdits === undefined) || Is.typedArray(candidate.textEdits, TextEdit.is)\n                && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip))\n                && (candidate.paddingLeft === undefined || Is.boolean(candidate.paddingLeft))\n                && (candidate.paddingRight === undefined || Is.boolean(candidate.paddingRight));\n        }\n        InlayHint.is = is;\n    })(InlayHint || (exports.InlayHint = InlayHint = {}));\n    var StringValue;\n    (function (StringValue) {\n        function createSnippet(value) {\n            return { kind: 'snippet', value: value };\n        }\n        StringValue.createSnippet = createSnippet;\n    })(StringValue || (exports.StringValue = StringValue = {}));\n    var InlineCompletionItem;\n    (function (InlineCompletionItem) {\n        function create(insertText, filterText, range, command) {\n            return { insertText: insertText, filterText: filterText, range: range, command: command };\n        }\n        InlineCompletionItem.create = create;\n    })(InlineCompletionItem || (exports.InlineCompletionItem = InlineCompletionItem = {}));\n    var InlineCompletionList;\n    (function (InlineCompletionList) {\n        function create(items) {\n            return { items: items };\n        }\n        InlineCompletionList.create = create;\n    })(InlineCompletionList || (exports.InlineCompletionList = InlineCompletionList = {}));\n    /**\n     * Describes how an {@link InlineCompletionItemProvider inline completion provider} was triggered.\n     *\n     * @since 3.18.0\n     * @proposed\n     */\n    var InlineCompletionTriggerKind;\n    (function (InlineCompletionTriggerKind) {\n        /**\n         * Completion was triggered explicitly by a user gesture.\n         */\n        InlineCompletionTriggerKind.Invoked = 0;\n        /**\n         * Completion was triggered automatically while editing.\n         */\n        InlineCompletionTriggerKind.Automatic = 1;\n    })(InlineCompletionTriggerKind || (exports.InlineCompletionTriggerKind = InlineCompletionTriggerKind = {}));\n    var SelectedCompletionInfo;\n    (function (SelectedCompletionInfo) {\n        function create(range, text) {\n            return { range: range, text: text };\n        }\n        SelectedCompletionInfo.create = create;\n    })(SelectedCompletionInfo || (exports.SelectedCompletionInfo = SelectedCompletionInfo = {}));\n    var InlineCompletionContext;\n    (function (InlineCompletionContext) {\n        function create(triggerKind, selectedCompletionInfo) {\n            return { triggerKind: triggerKind, selectedCompletionInfo: selectedCompletionInfo };\n        }\n        InlineCompletionContext.create = create;\n    })(InlineCompletionContext || (exports.InlineCompletionContext = InlineCompletionContext = {}));\n    var WorkspaceFolder;\n    (function (WorkspaceFolder) {\n        function is(value) {\n            var candidate = value;\n            return Is.objectLiteral(candidate) && URI.is(candidate.uri) && Is.string(candidate.name);\n        }\n        WorkspaceFolder.is = is;\n    })(WorkspaceFolder || (exports.WorkspaceFolder = WorkspaceFolder = {}));\n    exports.EOL = ['\\n', '\\r\\n', '\\r'];\n    /**\n     * @deprecated Use the text document from the new vscode-languageserver-textdocument package.\n     */\n    var TextDocument;\n    (function (TextDocument) {\n        /**\n         * Creates a new ITextDocument literal from the given uri and content.\n         * @param uri The document's uri.\n         * @param languageId The document's language Id.\n         * @param version The document's version.\n         * @param content The document's content.\n         */\n        function create(uri, languageId, version, content) {\n            return new FullTextDocument(uri, languageId, version, content);\n        }\n        TextDocument.create = create;\n        /**\n         * Checks whether the given literal conforms to the {@link ITextDocument} interface.\n         */\n        function is(value) {\n            var candidate = value;\n            return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount)\n                && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;\n        }\n        TextDocument.is = is;\n        function applyEdits(document, edits) {\n            var text = document.getText();\n            var sortedEdits = mergeSort(edits, function (a, b) {\n                var diff = a.range.start.line - b.range.start.line;\n                if (diff === 0) {\n                    return a.range.start.character - b.range.start.character;\n                }\n                return diff;\n            });\n            var lastModifiedOffset = text.length;\n            for (var i = sortedEdits.length - 1; i >= 0; i--) {\n                var e = sortedEdits[i];\n                var startOffset = document.offsetAt(e.range.start);\n                var endOffset = document.offsetAt(e.range.end);\n                if (endOffset <= lastModifiedOffset) {\n                    text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);\n                }\n                else {\n                    throw new Error('Overlapping edit');\n                }\n                lastModifiedOffset = startOffset;\n            }\n            return text;\n        }\n        TextDocument.applyEdits = applyEdits;\n        function mergeSort(data, compare) {\n            if (data.length <= 1) {\n                // sorted\n                return data;\n            }\n            var p = (data.length / 2) | 0;\n            var left = data.slice(0, p);\n            var right = data.slice(p);\n            mergeSort(left, compare);\n            mergeSort(right, compare);\n            var leftIdx = 0;\n            var rightIdx = 0;\n            var i = 0;\n            while (leftIdx < left.length && rightIdx < right.length) {\n                var ret = compare(left[leftIdx], right[rightIdx]);\n                if (ret <= 0) {\n                    // smaller_equal -> take left to preserve order\n                    data[i++] = left[leftIdx++];\n                }\n                else {\n                    // greater -> take right\n                    data[i++] = right[rightIdx++];\n                }\n            }\n            while (leftIdx < left.length) {\n                data[i++] = left[leftIdx++];\n            }\n            while (rightIdx < right.length) {\n                data[i++] = right[rightIdx++];\n            }\n            return data;\n        }\n    })(TextDocument || (exports.TextDocument = TextDocument = {}));\n    /**\n     * @deprecated Use the text document from the new vscode-languageserver-textdocument package.\n     */\n    var FullTextDocument = /** @class */ (function () {\n        function FullTextDocument(uri, languageId, version, content) {\n            this._uri = uri;\n            this._languageId = languageId;\n            this._version = version;\n            this._content = content;\n            this._lineOffsets = undefined;\n        }\n        Object.defineProperty(FullTextDocument.prototype, \"uri\", {\n            get: function () {\n                return this._uri;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(FullTextDocument.prototype, \"languageId\", {\n            get: function () {\n                return this._languageId;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(FullTextDocument.prototype, \"version\", {\n            get: function () {\n                return this._version;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        FullTextDocument.prototype.getText = function (range) {\n            if (range) {\n                var start = this.offsetAt(range.start);\n                var end = this.offsetAt(range.end);\n                return this._content.substring(start, end);\n            }\n            return this._content;\n        };\n        FullTextDocument.prototype.update = function (event, version) {\n            this._content = event.text;\n            this._version = version;\n            this._lineOffsets = undefined;\n        };\n        FullTextDocument.prototype.getLineOffsets = function () {\n            if (this._lineOffsets === undefined) {\n                var lineOffsets = [];\n                var text = this._content;\n                var isLineStart = true;\n                for (var i = 0; i < text.length; i++) {\n                    if (isLineStart) {\n                        lineOffsets.push(i);\n                        isLineStart = false;\n                    }\n                    var ch = text.charAt(i);\n                    isLineStart = (ch === '\\r' || ch === '\\n');\n                    if (ch === '\\r' && i + 1 < text.length && text.charAt(i + 1) === '\\n') {\n                        i++;\n                    }\n                }\n                if (isLineStart && text.length > 0) {\n                    lineOffsets.push(text.length);\n                }\n                this._lineOffsets = lineOffsets;\n            }\n            return this._lineOffsets;\n        };\n        FullTextDocument.prototype.positionAt = function (offset) {\n            offset = Math.max(Math.min(offset, this._content.length), 0);\n            var lineOffsets = this.getLineOffsets();\n            var low = 0, high = lineOffsets.length;\n            if (high === 0) {\n                return Position.create(0, offset);\n            }\n            while (low < high) {\n                var mid = Math.floor((low + high) / 2);\n                if (lineOffsets[mid] > offset) {\n                    high = mid;\n                }\n                else {\n                    low = mid + 1;\n                }\n            }\n            // low is the least x for which the line offset is larger than the current offset\n            // or array.length if no line offset is larger than the current offset\n            var line = low - 1;\n            return Position.create(line, offset - lineOffsets[line]);\n        };\n        FullTextDocument.prototype.offsetAt = function (position) {\n            var lineOffsets = this.getLineOffsets();\n            if (position.line >= lineOffsets.length) {\n                return this._content.length;\n            }\n            else if (position.line < 0) {\n                return 0;\n            }\n            var lineOffset = lineOffsets[position.line];\n            var nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;\n            return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);\n        };\n        Object.defineProperty(FullTextDocument.prototype, \"lineCount\", {\n            get: function () {\n                return this.getLineOffsets().length;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        return FullTextDocument;\n    }());\n    var Is;\n    (function (Is) {\n        var toString = Object.prototype.toString;\n        function defined(value) {\n            return typeof value !== 'undefined';\n        }\n        Is.defined = defined;\n        function undefined(value) {\n            return typeof value === 'undefined';\n        }\n        Is.undefined = undefined;\n        function boolean(value) {\n            return value === true || value === false;\n        }\n        Is.boolean = boolean;\n        function string(value) {\n            return toString.call(value) === '[object String]';\n        }\n        Is.string = string;\n        function number(value) {\n            return toString.call(value) === '[object Number]';\n        }\n        Is.number = number;\n        function numberRange(value, min, max) {\n            return toString.call(value) === '[object Number]' && min <= value && value <= max;\n        }\n        Is.numberRange = numberRange;\n        function integer(value) {\n            return toString.call(value) === '[object Number]' && -2147483648 <= value && value <= 2147483647;\n        }\n        Is.integer = integer;\n        function uinteger(value) {\n            return toString.call(value) === '[object Number]' && 0 <= value && value <= 2147483647;\n        }\n        Is.uinteger = uinteger;\n        function func(value) {\n            return toString.call(value) === '[object Function]';\n        }\n        Is.func = func;\n        function objectLiteral(value) {\n            // Strictly speaking class instances pass this check as well. Since the LSP\n            // doesn't use classes we ignore this for now. If we do we need to add something\n            // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`\n            return value !== null && typeof value === 'object';\n        }\n        Is.objectLiteral = objectLiteral;\n        function typedArray(value, check) {\n            return Array.isArray(value) && value.every(check);\n        }\n        Is.typedArray = typedArray;\n    })(Is || (Is = {}));\n});\n","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = () => ([]);\nwebpackEmptyContext.resolve = webpackEmptyContext;\nwebpackEmptyContext.id = 31;\nmodule.exports = webpackEmptyContext;","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ProtocolNotificationType = exports.ProtocolNotificationType0 = exports.ProtocolRequestType = exports.ProtocolRequestType0 = exports.RegistrationType = exports.MessageDirection = void 0;\nconst vscode_jsonrpc_1 = require(\"vscode-jsonrpc\");\nvar MessageDirection;\n(function (MessageDirection) {\n    MessageDirection[\"clientToServer\"] = \"clientToServer\";\n    MessageDirection[\"serverToClient\"] = \"serverToClient\";\n    MessageDirection[\"both\"] = \"both\";\n})(MessageDirection || (exports.MessageDirection = MessageDirection = {}));\nclass RegistrationType {\n    constructor(method) {\n        this.method = method;\n    }\n}\nexports.RegistrationType = RegistrationType;\nclass ProtocolRequestType0 extends vscode_jsonrpc_1.RequestType0 {\n    constructor(method) {\n        super(method);\n    }\n}\nexports.ProtocolRequestType0 = ProtocolRequestType0;\nclass ProtocolRequestType extends vscode_jsonrpc_1.RequestType {\n    constructor(method) {\n        super(method, vscode_jsonrpc_1.ParameterStructures.byName);\n    }\n}\nexports.ProtocolRequestType = ProtocolRequestType;\nclass ProtocolNotificationType0 extends vscode_jsonrpc_1.NotificationType0 {\n    constructor(method) {\n        super(method);\n    }\n}\nexports.ProtocolNotificationType0 = ProtocolNotificationType0;\nclass ProtocolNotificationType extends vscode_jsonrpc_1.NotificationType {\n    constructor(method) {\n        super(method, vscode_jsonrpc_1.ParameterStructures.byName);\n    }\n}\nexports.ProtocolNotificationType = ProtocolNotificationType;\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WorkspaceSymbolRequest = exports.CodeActionResolveRequest = exports.CodeActionRequest = exports.DocumentSymbolRequest = exports.DocumentHighlightRequest = exports.ReferencesRequest = exports.DefinitionRequest = exports.SignatureHelpRequest = exports.SignatureHelpTriggerKind = exports.HoverRequest = exports.CompletionResolveRequest = exports.CompletionRequest = exports.CompletionTriggerKind = exports.PublishDiagnosticsNotification = exports.WatchKind = exports.RelativePattern = exports.FileChangeType = exports.DidChangeWatchedFilesNotification = exports.WillSaveTextDocumentWaitUntilRequest = exports.WillSaveTextDocumentNotification = exports.TextDocumentSaveReason = exports.DidSaveTextDocumentNotification = exports.DidCloseTextDocumentNotification = exports.DidChangeTextDocumentNotification = exports.TextDocumentContentChangeEvent = exports.DidOpenTextDocumentNotification = exports.TextDocumentSyncKind = exports.TelemetryEventNotification = exports.LogMessageNotification = exports.ShowMessageRequest = exports.ShowMessageNotification = exports.MessageType = exports.DidChangeConfigurationNotification = exports.ExitNotification = exports.ShutdownRequest = exports.InitializedNotification = exports.InitializeErrorCodes = exports.InitializeRequest = exports.WorkDoneProgressOptions = exports.TextDocumentRegistrationOptions = exports.StaticRegistrationOptions = exports.PositionEncodingKind = exports.FailureHandlingKind = exports.ResourceOperationKind = exports.UnregistrationRequest = exports.RegistrationRequest = exports.DocumentSelector = exports.NotebookCellTextDocumentFilter = exports.NotebookDocumentFilter = exports.TextDocumentFilter = void 0;\nexports.MonikerRequest = exports.MonikerKind = exports.UniquenessLevel = exports.WillDeleteFilesRequest = exports.DidDeleteFilesNotification = exports.WillRenameFilesRequest = exports.DidRenameFilesNotification = exports.WillCreateFilesRequest = exports.DidCreateFilesNotification = exports.FileOperationPatternKind = exports.LinkedEditingRangeRequest = exports.ShowDocumentRequest = exports.SemanticTokensRegistrationType = exports.SemanticTokensRefreshRequest = exports.SemanticTokensRangeRequest = exports.SemanticTokensDeltaRequest = exports.SemanticTokensRequest = exports.TokenFormat = exports.CallHierarchyPrepareRequest = exports.CallHierarchyOutgoingCallsRequest = exports.CallHierarchyIncomingCallsRequest = exports.WorkDoneProgressCancelNotification = exports.WorkDoneProgressCreateRequest = exports.WorkDoneProgress = exports.SelectionRangeRequest = exports.DeclarationRequest = exports.FoldingRangeRefreshRequest = exports.FoldingRangeRequest = exports.ColorPresentationRequest = exports.DocumentColorRequest = exports.ConfigurationRequest = exports.DidChangeWorkspaceFoldersNotification = exports.WorkspaceFoldersRequest = exports.TypeDefinitionRequest = exports.ImplementationRequest = exports.ApplyWorkspaceEditRequest = exports.ExecuteCommandRequest = exports.PrepareRenameRequest = exports.RenameRequest = exports.PrepareSupportDefaultBehavior = exports.DocumentOnTypeFormattingRequest = exports.DocumentRangesFormattingRequest = exports.DocumentRangeFormattingRequest = exports.DocumentFormattingRequest = exports.DocumentLinkResolveRequest = exports.DocumentLinkRequest = exports.CodeLensRefreshRequest = exports.CodeLensResolveRequest = exports.CodeLensRequest = exports.WorkspaceSymbolResolveRequest = void 0;\nexports.InlineCompletionRequest = exports.DidCloseNotebookDocumentNotification = exports.DidSaveNotebookDocumentNotification = exports.DidChangeNotebookDocumentNotification = exports.NotebookCellArrayChange = exports.DidOpenNotebookDocumentNotification = exports.NotebookDocumentSyncRegistrationType = exports.NotebookDocument = exports.NotebookCell = exports.ExecutionSummary = exports.NotebookCellKind = exports.DiagnosticRefreshRequest = exports.WorkspaceDiagnosticRequest = exports.DocumentDiagnosticRequest = exports.DocumentDiagnosticReportKind = exports.DiagnosticServerCancellationData = exports.InlayHintRefreshRequest = exports.InlayHintResolveRequest = exports.InlayHintRequest = exports.InlineValueRefreshRequest = exports.InlineValueRequest = exports.TypeHierarchySupertypesRequest = exports.TypeHierarchySubtypesRequest = exports.TypeHierarchyPrepareRequest = void 0;\nconst messages_1 = require(\"./messages\");\nconst vscode_languageserver_types_1 = require(\"vscode-languageserver-types\");\nconst Is = require(\"./utils/is\");\nconst protocol_implementation_1 = require(\"./protocol.implementation\");\nObject.defineProperty(exports, \"ImplementationRequest\", { enumerable: true, get: function () { return protocol_implementation_1.ImplementationRequest; } });\nconst protocol_typeDefinition_1 = require(\"./protocol.typeDefinition\");\nObject.defineProperty(exports, \"TypeDefinitionRequest\", { enumerable: true, get: function () { return protocol_typeDefinition_1.TypeDefinitionRequest; } });\nconst protocol_workspaceFolder_1 = require(\"./protocol.workspaceFolder\");\nObject.defineProperty(exports, \"WorkspaceFoldersRequest\", { enumerable: true, get: function () { return protocol_workspaceFolder_1.WorkspaceFoldersRequest; } });\nObject.defineProperty(exports, \"DidChangeWorkspaceFoldersNotification\", { enumerable: true, get: function () { return protocol_workspaceFolder_1.DidChangeWorkspaceFoldersNotification; } });\nconst protocol_configuration_1 = require(\"./protocol.configuration\");\nObject.defineProperty(exports, \"ConfigurationRequest\", { enumerable: true, get: function () { return protocol_configuration_1.ConfigurationRequest; } });\nconst protocol_colorProvider_1 = require(\"./protocol.colorProvider\");\nObject.defineProperty(exports, \"DocumentColorRequest\", { enumerable: true, get: function () { return protocol_colorProvider_1.DocumentColorRequest; } });\nObject.defineProperty(exports, \"ColorPresentationRequest\", { enumerable: true, get: function () { return protocol_colorProvider_1.ColorPresentationRequest; } });\nconst protocol_foldingRange_1 = require(\"./protocol.foldingRange\");\nObject.defineProperty(exports, \"FoldingRangeRequest\", { enumerable: true, get: function () { return protocol_foldingRange_1.FoldingRangeRequest; } });\nObject.defineProperty(exports, \"FoldingRangeRefreshRequest\", { enumerable: true, get: function () { return protocol_foldingRange_1.FoldingRangeRefreshRequest; } });\nconst protocol_declaration_1 = require(\"./protocol.declaration\");\nObject.defineProperty(exports, \"DeclarationRequest\", { enumerable: true, get: function () { return protocol_declaration_1.DeclarationRequest; } });\nconst protocol_selectionRange_1 = require(\"./protocol.selectionRange\");\nObject.defineProperty(exports, \"SelectionRangeRequest\", { enumerable: true, get: function () { return protocol_selectionRange_1.SelectionRangeRequest; } });\nconst protocol_progress_1 = require(\"./protocol.progress\");\nObject.defineProperty(exports, \"WorkDoneProgress\", { enumerable: true, get: function () { return protocol_progress_1.WorkDoneProgress; } });\nObject.defineProperty(exports, \"WorkDoneProgressCreateRequest\", { enumerable: true, get: function () { return protocol_progress_1.WorkDoneProgressCreateRequest; } });\nObject.defineProperty(exports, \"WorkDoneProgressCancelNotification\", { enumerable: true, get: function () { return protocol_progress_1.WorkDoneProgressCancelNotification; } });\nconst protocol_callHierarchy_1 = require(\"./protocol.callHierarchy\");\nObject.defineProperty(exports, \"CallHierarchyIncomingCallsRequest\", { enumerable: true, get: function () { return protocol_callHierarchy_1.CallHierarchyIncomingCallsRequest; } });\nObject.defineProperty(exports, \"CallHierarchyOutgoingCallsRequest\", { enumerable: true, get: function () { return protocol_callHierarchy_1.CallHierarchyOutgoingCallsRequest; } });\nObject.defineProperty(exports, \"CallHierarchyPrepareRequest\", { enumerable: true, get: function () { return protocol_callHierarchy_1.CallHierarchyPrepareRequest; } });\nconst protocol_semanticTokens_1 = require(\"./protocol.semanticTokens\");\nObject.defineProperty(exports, \"TokenFormat\", { enumerable: true, get: function () { return protocol_semanticTokens_1.TokenFormat; } });\nObject.defineProperty(exports, \"SemanticTokensRequest\", { enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRequest; } });\nObject.defineProperty(exports, \"SemanticTokensDeltaRequest\", { enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensDeltaRequest; } });\nObject.defineProperty(exports, \"SemanticTokensRangeRequest\", { enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRangeRequest; } });\nObject.defineProperty(exports, \"SemanticTokensRefreshRequest\", { enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRefreshRequest; } });\nObject.defineProperty(exports, \"SemanticTokensRegistrationType\", { enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRegistrationType; } });\nconst protocol_showDocument_1 = require(\"./protocol.showDocument\");\nObject.defineProperty(exports, \"ShowDocumentRequest\", { enumerable: true, get: function () { return protocol_showDocument_1.ShowDocumentRequest; } });\nconst protocol_linkedEditingRange_1 = require(\"./protocol.linkedEditingRange\");\nObject.defineProperty(exports, \"LinkedEditingRangeRequest\", { enumerable: true, get: function () { return protocol_linkedEditingRange_1.LinkedEditingRangeRequest; } });\nconst protocol_fileOperations_1 = require(\"./protocol.fileOperations\");\nObject.defineProperty(exports, \"FileOperationPatternKind\", { enumerable: true, get: function () { return protocol_fileOperations_1.FileOperationPatternKind; } });\nObject.defineProperty(exports, \"DidCreateFilesNotification\", { enumerable: true, get: function () { return protocol_fileOperations_1.DidCreateFilesNotification; } });\nObject.defineProperty(exports, \"WillCreateFilesRequest\", { enumerable: true, get: function () { return protocol_fileOperations_1.WillCreateFilesRequest; } });\nObject.defineProperty(exports, \"DidRenameFilesNotification\", { enumerable: true, get: function () { return protocol_fileOperations_1.DidRenameFilesNotification; } });\nObject.defineProperty(exports, \"WillRenameFilesRequest\", { enumerable: true, get: function () { return protocol_fileOperations_1.WillRenameFilesRequest; } });\nObject.defineProperty(exports, \"DidDeleteFilesNotification\", { enumerable: true, get: function () { return protocol_fileOperations_1.DidDeleteFilesNotification; } });\nObject.defineProperty(exports, \"WillDeleteFilesRequest\", { enumerable: true, get: function () { return protocol_fileOperations_1.WillDeleteFilesRequest; } });\nconst protocol_moniker_1 = require(\"./protocol.moniker\");\nObject.defineProperty(exports, \"UniquenessLevel\", { enumerable: true, get: function () { return protocol_moniker_1.UniquenessLevel; } });\nObject.defineProperty(exports, \"MonikerKind\", { enumerable: true, get: function () { return protocol_moniker_1.MonikerKind; } });\nObject.defineProperty(exports, \"MonikerRequest\", { enumerable: true, get: function () { return protocol_moniker_1.MonikerRequest; } });\nconst protocol_typeHierarchy_1 = require(\"./protocol.typeHierarchy\");\nObject.defineProperty(exports, \"TypeHierarchyPrepareRequest\", { enumerable: true, get: function () { return protocol_typeHierarchy_1.TypeHierarchyPrepareRequest; } });\nObject.defineProperty(exports, \"TypeHierarchySubtypesRequest\", { enumerable: true, get: function () { return protocol_typeHierarchy_1.TypeHierarchySubtypesRequest; } });\nObject.defineProperty(exports, \"TypeHierarchySupertypesRequest\", { enumerable: true, get: function () { return protocol_typeHierarchy_1.TypeHierarchySupertypesRequest; } });\nconst protocol_inlineValue_1 = require(\"./protocol.inlineValue\");\nObject.defineProperty(exports, \"InlineValueRequest\", { enumerable: true, get: function () { return protocol_inlineValue_1.InlineValueRequest; } });\nObject.defineProperty(exports, \"InlineValueRefreshRequest\", { enumerable: true, get: function () { return protocol_inlineValue_1.InlineValueRefreshRequest; } });\nconst protocol_inlayHint_1 = require(\"./protocol.inlayHint\");\nObject.defineProperty(exports, \"InlayHintRequest\", { enumerable: true, get: function () { return protocol_inlayHint_1.InlayHintRequest; } });\nObject.defineProperty(exports, \"InlayHintResolveRequest\", { enumerable: true, get: function () { return protocol_inlayHint_1.InlayHintResolveRequest; } });\nObject.defineProperty(exports, \"InlayHintRefreshRequest\", { enumerable: true, get: function () { return protocol_inlayHint_1.InlayHintRefreshRequest; } });\nconst protocol_diagnostic_1 = require(\"./protocol.diagnostic\");\nObject.defineProperty(exports, \"DiagnosticServerCancellationData\", { enumerable: true, get: function () { return protocol_diagnostic_1.DiagnosticServerCancellationData; } });\nObject.defineProperty(exports, \"DocumentDiagnosticReportKind\", { enumerable: true, get: function () { return protocol_diagnostic_1.DocumentDiagnosticReportKind; } });\nObject.defineProperty(exports, \"DocumentDiagnosticRequest\", { enumerable: true, get: function () { return protocol_diagnostic_1.DocumentDiagnosticRequest; } });\nObject.defineProperty(exports, \"WorkspaceDiagnosticRequest\", { enumerable: true, get: function () { return protocol_diagnostic_1.WorkspaceDiagnosticRequest; } });\nObject.defineProperty(exports, \"DiagnosticRefreshRequest\", { enumerable: true, get: function () { return protocol_diagnostic_1.DiagnosticRefreshRequest; } });\nconst protocol_notebook_1 = require(\"./protocol.notebook\");\nObject.defineProperty(exports, \"NotebookCellKind\", { enumerable: true, get: function () { return protocol_notebook_1.NotebookCellKind; } });\nObject.defineProperty(exports, \"ExecutionSummary\", { enumerable: true, get: function () { return protocol_notebook_1.ExecutionSummary; } });\nObject.defineProperty(exports, \"NotebookCell\", { enumerable: true, get: function () { return protocol_notebook_1.NotebookCell; } });\nObject.defineProperty(exports, \"NotebookDocument\", { enumerable: true, get: function () { return protocol_notebook_1.NotebookDocument; } });\nObject.defineProperty(exports, \"NotebookDocumentSyncRegistrationType\", { enumerable: true, get: function () { return protocol_notebook_1.NotebookDocumentSyncRegistrationType; } });\nObject.defineProperty(exports, \"DidOpenNotebookDocumentNotification\", { enumerable: true, get: function () { return protocol_notebook_1.DidOpenNotebookDocumentNotification; } });\nObject.defineProperty(exports, \"NotebookCellArrayChange\", { enumerable: true, get: function () { return protocol_notebook_1.NotebookCellArrayChange; } });\nObject.defineProperty(exports, \"DidChangeNotebookDocumentNotification\", { enumerable: true, get: function () { return protocol_notebook_1.DidChangeNotebookDocumentNotification; } });\nObject.defineProperty(exports, \"DidSaveNotebookDocumentNotification\", { enumerable: true, get: function () { return protocol_notebook_1.DidSaveNotebookDocumentNotification; } });\nObject.defineProperty(exports, \"DidCloseNotebookDocumentNotification\", { enumerable: true, get: function () { return protocol_notebook_1.DidCloseNotebookDocumentNotification; } });\nconst protocol_inlineCompletion_1 = require(\"./protocol.inlineCompletion\");\nObject.defineProperty(exports, \"InlineCompletionRequest\", { enumerable: true, get: function () { return protocol_inlineCompletion_1.InlineCompletionRequest; } });\n// @ts-ignore: to avoid inlining LocationLink as dynamic import\nlet __noDynamicImport;\n/**\n * The TextDocumentFilter namespace provides helper functions to work with\n * {@link TextDocumentFilter} literals.\n *\n * @since 3.17.0\n */\nvar TextDocumentFilter;\n(function (TextDocumentFilter) {\n    function is(value) {\n        const candidate = value;\n        return Is.string(candidate) || (Is.string(candidate.language) || Is.string(candidate.scheme) || Is.string(candidate.pattern));\n    }\n    TextDocumentFilter.is = is;\n})(TextDocumentFilter || (exports.TextDocumentFilter = TextDocumentFilter = {}));\n/**\n * The NotebookDocumentFilter namespace provides helper functions to work with\n * {@link NotebookDocumentFilter} literals.\n *\n * @since 3.17.0\n */\nvar NotebookDocumentFilter;\n(function (NotebookDocumentFilter) {\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && (Is.string(candidate.notebookType) || Is.string(candidate.scheme) || Is.string(candidate.pattern));\n    }\n    NotebookDocumentFilter.is = is;\n})(NotebookDocumentFilter || (exports.NotebookDocumentFilter = NotebookDocumentFilter = {}));\n/**\n * The NotebookCellTextDocumentFilter namespace provides helper functions to work with\n * {@link NotebookCellTextDocumentFilter} literals.\n *\n * @since 3.17.0\n */\nvar NotebookCellTextDocumentFilter;\n(function (NotebookCellTextDocumentFilter) {\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate)\n            && (Is.string(candidate.notebook) || NotebookDocumentFilter.is(candidate.notebook))\n            && (candidate.language === undefined || Is.string(candidate.language));\n    }\n    NotebookCellTextDocumentFilter.is = is;\n})(NotebookCellTextDocumentFilter || (exports.NotebookCellTextDocumentFilter = NotebookCellTextDocumentFilter = {}));\n/**\n * The DocumentSelector namespace provides helper functions to work with\n * {@link DocumentSelector}s.\n */\nvar DocumentSelector;\n(function (DocumentSelector) {\n    function is(value) {\n        if (!Array.isArray(value)) {\n            return false;\n        }\n        for (let elem of value) {\n            if (!Is.string(elem) && !TextDocumentFilter.is(elem) && !NotebookCellTextDocumentFilter.is(elem)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    DocumentSelector.is = is;\n})(DocumentSelector || (exports.DocumentSelector = DocumentSelector = {}));\n/**\n * The `client/registerCapability` request is sent from the server to the client to register a new capability\n * handler on the client side.\n */\nvar RegistrationRequest;\n(function (RegistrationRequest) {\n    RegistrationRequest.method = 'client/registerCapability';\n    RegistrationRequest.messageDirection = messages_1.MessageDirection.serverToClient;\n    RegistrationRequest.type = new messages_1.ProtocolRequestType(RegistrationRequest.method);\n})(RegistrationRequest || (exports.RegistrationRequest = RegistrationRequest = {}));\n/**\n * The `client/unregisterCapability` request is sent from the server to the client to unregister a previously registered capability\n * handler on the client side.\n */\nvar UnregistrationRequest;\n(function (UnregistrationRequest) {\n    UnregistrationRequest.method = 'client/unregisterCapability';\n    UnregistrationRequest.messageDirection = messages_1.MessageDirection.serverToClient;\n    UnregistrationRequest.type = new messages_1.ProtocolRequestType(UnregistrationRequest.method);\n})(UnregistrationRequest || (exports.UnregistrationRequest = UnregistrationRequest = {}));\nvar ResourceOperationKind;\n(function (ResourceOperationKind) {\n    /**\n     * Supports creating new files and folders.\n     */\n    ResourceOperationKind.Create = 'create';\n    /**\n     * Supports renaming existing files and folders.\n     */\n    ResourceOperationKind.Rename = 'rename';\n    /**\n     * Supports deleting existing files and folders.\n     */\n    ResourceOperationKind.Delete = 'delete';\n})(ResourceOperationKind || (exports.ResourceOperationKind = ResourceOperationKind = {}));\nvar FailureHandlingKind;\n(function (FailureHandlingKind) {\n    /**\n     * Applying the workspace change is simply aborted if one of the changes provided\n     * fails. All operations executed before the failing operation stay executed.\n     */\n    FailureHandlingKind.Abort = 'abort';\n    /**\n     * All operations are executed transactional. That means they either all\n     * succeed or no changes at all are applied to the workspace.\n     */\n    FailureHandlingKind.Transactional = 'transactional';\n    /**\n     * If the workspace edit contains only textual file changes they are executed transactional.\n     * If resource changes (create, rename or delete file) are part of the change the failure\n     * handling strategy is abort.\n     */\n    FailureHandlingKind.TextOnlyTransactional = 'textOnlyTransactional';\n    /**\n     * The client tries to undo the operations already executed. But there is no\n     * guarantee that this is succeeding.\n     */\n    FailureHandlingKind.Undo = 'undo';\n})(FailureHandlingKind || (exports.FailureHandlingKind = FailureHandlingKind = {}));\n/**\n * A set of predefined position encoding kinds.\n *\n * @since 3.17.0\n */\nvar PositionEncodingKind;\n(function (PositionEncodingKind) {\n    /**\n     * Character offsets count UTF-8 code units (e.g. bytes).\n     */\n    PositionEncodingKind.UTF8 = 'utf-8';\n    /**\n     * Character offsets count UTF-16 code units.\n     *\n     * This is the default and must always be supported\n     * by servers\n     */\n    PositionEncodingKind.UTF16 = 'utf-16';\n    /**\n     * Character offsets count UTF-32 code units.\n     *\n     * Implementation note: these are the same as Unicode codepoints,\n     * so this `PositionEncodingKind` may also be used for an\n     * encoding-agnostic representation of character offsets.\n     */\n    PositionEncodingKind.UTF32 = 'utf-32';\n})(PositionEncodingKind || (exports.PositionEncodingKind = PositionEncodingKind = {}));\n/**\n * The StaticRegistrationOptions namespace provides helper functions to work with\n * {@link StaticRegistrationOptions} literals.\n */\nvar StaticRegistrationOptions;\n(function (StaticRegistrationOptions) {\n    function hasId(value) {\n        const candidate = value;\n        return candidate && Is.string(candidate.id) && candidate.id.length > 0;\n    }\n    StaticRegistrationOptions.hasId = hasId;\n})(StaticRegistrationOptions || (exports.StaticRegistrationOptions = StaticRegistrationOptions = {}));\n/**\n * The TextDocumentRegistrationOptions namespace provides helper functions to work with\n * {@link TextDocumentRegistrationOptions} literals.\n */\nvar TextDocumentRegistrationOptions;\n(function (TextDocumentRegistrationOptions) {\n    function is(value) {\n        const candidate = value;\n        return candidate && (candidate.documentSelector === null || DocumentSelector.is(candidate.documentSelector));\n    }\n    TextDocumentRegistrationOptions.is = is;\n})(TextDocumentRegistrationOptions || (exports.TextDocumentRegistrationOptions = TextDocumentRegistrationOptions = {}));\n/**\n * The WorkDoneProgressOptions namespace provides helper functions to work with\n * {@link WorkDoneProgressOptions} literals.\n */\nvar WorkDoneProgressOptions;\n(function (WorkDoneProgressOptions) {\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && (candidate.workDoneProgress === undefined || Is.boolean(candidate.workDoneProgress));\n    }\n    WorkDoneProgressOptions.is = is;\n    function hasWorkDoneProgress(value) {\n        const candidate = value;\n        return candidate && Is.boolean(candidate.workDoneProgress);\n    }\n    WorkDoneProgressOptions.hasWorkDoneProgress = hasWorkDoneProgress;\n})(WorkDoneProgressOptions || (exports.WorkDoneProgressOptions = WorkDoneProgressOptions = {}));\n/**\n * The initialize request is sent from the client to the server.\n * It is sent once as the request after starting up the server.\n * The requests parameter is of type {@link InitializeParams}\n * the response if of type {@link InitializeResult} of a Thenable that\n * resolves to such.\n */\nvar InitializeRequest;\n(function (InitializeRequest) {\n    InitializeRequest.method = 'initialize';\n    InitializeRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    InitializeRequest.type = new messages_1.ProtocolRequestType(InitializeRequest.method);\n})(InitializeRequest || (exports.InitializeRequest = InitializeRequest = {}));\n/**\n * Known error codes for an `InitializeErrorCodes`;\n */\nvar InitializeErrorCodes;\n(function (InitializeErrorCodes) {\n    /**\n     * If the protocol version provided by the client can't be handled by the server.\n     *\n     * @deprecated This initialize error got replaced by client capabilities. There is\n     * no version handshake in version 3.0x\n     */\n    InitializeErrorCodes.unknownProtocolVersion = 1;\n})(InitializeErrorCodes || (exports.InitializeErrorCodes = InitializeErrorCodes = {}));\n/**\n * The initialized notification is sent from the client to the\n * server after the client is fully initialized and the server\n * is allowed to send requests from the server to the client.\n */\nvar InitializedNotification;\n(function (InitializedNotification) {\n    InitializedNotification.method = 'initialized';\n    InitializedNotification.messageDirection = messages_1.MessageDirection.clientToServer;\n    InitializedNotification.type = new messages_1.ProtocolNotificationType(InitializedNotification.method);\n})(InitializedNotification || (exports.InitializedNotification = InitializedNotification = {}));\n//---- Shutdown Method ----\n/**\n * A shutdown request is sent from the client to the server.\n * It is sent once when the client decides to shutdown the\n * server. The only notification that is sent after a shutdown request\n * is the exit event.\n */\nvar ShutdownRequest;\n(function (ShutdownRequest) {\n    ShutdownRequest.method = 'shutdown';\n    ShutdownRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    ShutdownRequest.type = new messages_1.ProtocolRequestType0(ShutdownRequest.method);\n})(ShutdownRequest || (exports.ShutdownRequest = ShutdownRequest = {}));\n//---- Exit Notification ----\n/**\n * The exit event is sent from the client to the server to\n * ask the server to exit its process.\n */\nvar ExitNotification;\n(function (ExitNotification) {\n    ExitNotification.method = 'exit';\n    ExitNotification.messageDirection = messages_1.MessageDirection.clientToServer;\n    ExitNotification.type = new messages_1.ProtocolNotificationType0(ExitNotification.method);\n})(ExitNotification || (exports.ExitNotification = ExitNotification = {}));\n/**\n * The configuration change notification is sent from the client to the server\n * when the client's configuration has changed. The notification contains\n * the changed configuration as defined by the language client.\n */\nvar DidChangeConfigurationNotification;\n(function (DidChangeConfigurationNotification) {\n    DidChangeConfigurationNotification.method = 'workspace/didChangeConfiguration';\n    DidChangeConfigurationNotification.messageDirection = messages_1.MessageDirection.clientToServer;\n    DidChangeConfigurationNotification.type = new messages_1.ProtocolNotificationType(DidChangeConfigurationNotification.method);\n})(DidChangeConfigurationNotification || (exports.DidChangeConfigurationNotification = DidChangeConfigurationNotification = {}));\n//---- Message show and log notifications ----\n/**\n * The message type\n */\nvar MessageType;\n(function (MessageType) {\n    /**\n     * An error message.\n     */\n    MessageType.Error = 1;\n    /**\n     * A warning message.\n     */\n    MessageType.Warning = 2;\n    /**\n     * An information message.\n     */\n    MessageType.Info = 3;\n    /**\n     * A log message.\n     */\n    MessageType.Log = 4;\n    /**\n     * A debug message.\n     *\n     * @since 3.18.0\n     */\n    MessageType.Debug = 5;\n})(MessageType || (exports.MessageType = MessageType = {}));\n/**\n * The show message notification is sent from a server to a client to ask\n * the client to display a particular message in the user interface.\n */\nvar ShowMessageNotification;\n(function (ShowMessageNotification) {\n    ShowMessageNotification.method = 'window/showMessage';\n    ShowMessageNotification.messageDirection = messages_1.MessageDirection.serverToClient;\n    ShowMessageNotification.type = new messages_1.ProtocolNotificationType(ShowMessageNotification.method);\n})(ShowMessageNotification || (exports.ShowMessageNotification = ShowMessageNotification = {}));\n/**\n * The show message request is sent from the server to the client to show a message\n * and a set of options actions to the user.\n */\nvar ShowMessageRequest;\n(function (ShowMessageRequest) {\n    ShowMessageRequest.method = 'window/showMessageRequest';\n    ShowMessageRequest.messageDirection = messages_1.MessageDirection.serverToClient;\n    ShowMessageRequest.type = new messages_1.ProtocolRequestType(ShowMessageRequest.method);\n})(ShowMessageRequest || (exports.ShowMessageRequest = ShowMessageRequest = {}));\n/**\n * The log message notification is sent from the server to the client to ask\n * the client to log a particular message.\n */\nvar LogMessageNotification;\n(function (LogMessageNotification) {\n    LogMessageNotification.method = 'window/logMessage';\n    LogMessageNotification.messageDirection = messages_1.MessageDirection.serverToClient;\n    LogMessageNotification.type = new messages_1.ProtocolNotificationType(LogMessageNotification.method);\n})(LogMessageNotification || (exports.LogMessageNotification = LogMessageNotification = {}));\n//---- Telemetry notification\n/**\n * The telemetry event notification is sent from the server to the client to ask\n * the client to log telemetry data.\n */\nvar TelemetryEventNotification;\n(function (TelemetryEventNotification) {\n    TelemetryEventNotification.method = 'telemetry/event';\n    TelemetryEventNotification.messageDirection = messages_1.MessageDirection.serverToClient;\n    TelemetryEventNotification.type = new messages_1.ProtocolNotificationType(TelemetryEventNotification.method);\n})(TelemetryEventNotification || (exports.TelemetryEventNotification = TelemetryEventNotification = {}));\n/**\n * Defines how the host (editor) should sync\n * document changes to the language server.\n */\nvar TextDocumentSyncKind;\n(function (TextDocumentSyncKind) {\n    /**\n     * Documents should not be synced at all.\n     */\n    TextDocumentSyncKind.None = 0;\n    /**\n     * Documents are synced by always sending the full content\n     * of the document.\n     */\n    TextDocumentSyncKind.Full = 1;\n    /**\n     * Documents are synced by sending the full content on open.\n     * After that only incremental updates to the document are\n     * send.\n     */\n    TextDocumentSyncKind.Incremental = 2;\n})(TextDocumentSyncKind || (exports.TextDocumentSyncKind = TextDocumentSyncKind = {}));\n/**\n * The document open notification is sent from the client to the server to signal\n * newly opened text documents. The document's truth is now managed by the client\n * and the server must not try to read the document's truth using the document's\n * uri. Open in this sense means it is managed by the client. It doesn't necessarily\n * mean that its content is presented in an editor. An open notification must not\n * be sent more than once without a corresponding close notification send before.\n * This means open and close notification must be balanced and the max open count\n * is one.\n */\nvar DidOpenTextDocumentNotification;\n(function (DidOpenTextDocumentNotification) {\n    DidOpenTextDocumentNotification.method = 'textDocument/didOpen';\n    DidOpenTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;\n    DidOpenTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification.method);\n})(DidOpenTextDocumentNotification || (exports.DidOpenTextDocumentNotification = DidOpenTextDocumentNotification = {}));\nvar TextDocumentContentChangeEvent;\n(function (TextDocumentContentChangeEvent) {\n    /**\n     * Checks whether the information describes a delta event.\n     */\n    function isIncremental(event) {\n        let candidate = event;\n        return candidate !== undefined && candidate !== null &&\n            typeof candidate.text === 'string' && candidate.range !== undefined &&\n            (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');\n    }\n    TextDocumentContentChangeEvent.isIncremental = isIncremental;\n    /**\n     * Checks whether the information describes a full replacement event.\n     */\n    function isFull(event) {\n        let candidate = event;\n        return candidate !== undefined && candidate !== null &&\n            typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;\n    }\n    TextDocumentContentChangeEvent.isFull = isFull;\n})(TextDocumentContentChangeEvent || (exports.TextDocumentContentChangeEvent = TextDocumentContentChangeEvent = {}));\n/**\n * The document change notification is sent from the client to the server to signal\n * changes to a text document.\n */\nvar DidChangeTextDocumentNotification;\n(function (DidChangeTextDocumentNotification) {\n    DidChangeTextDocumentNotification.method = 'textDocument/didChange';\n    DidChangeTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;\n    DidChangeTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification.method);\n})(DidChangeTextDocumentNotification || (exports.DidChangeTextDocumentNotification = DidChangeTextDocumentNotification = {}));\n/**\n * The document close notification is sent from the client to the server when\n * the document got closed in the client. The document's truth now exists where\n * the document's uri points to (e.g. if the document's uri is a file uri the\n * truth now exists on disk). As with the open notification the close notification\n * is about managing the document's content. Receiving a close notification\n * doesn't mean that the document was open in an editor before. A close\n * notification requires a previous open notification to be sent.\n */\nvar DidCloseTextDocumentNotification;\n(function (DidCloseTextDocumentNotification) {\n    DidCloseTextDocumentNotification.method = 'textDocument/didClose';\n    DidCloseTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;\n    DidCloseTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification.method);\n})(DidCloseTextDocumentNotification || (exports.DidCloseTextDocumentNotification = DidCloseTextDocumentNotification = {}));\n/**\n * The document save notification is sent from the client to the server when\n * the document got saved in the client.\n */\nvar DidSaveTextDocumentNotification;\n(function (DidSaveTextDocumentNotification) {\n    DidSaveTextDocumentNotification.method = 'textDocument/didSave';\n    DidSaveTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;\n    DidSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification.method);\n})(DidSaveTextDocumentNotification || (exports.DidSaveTextDocumentNotification = DidSaveTextDocumentNotification = {}));\n/**\n * Represents reasons why a text document is saved.\n */\nvar TextDocumentSaveReason;\n(function (TextDocumentSaveReason) {\n    /**\n     * Manually triggered, e.g. by the user pressing save, by starting debugging,\n     * or by an API call.\n     */\n    TextDocumentSaveReason.Manual = 1;\n    /**\n     * Automatic after a delay.\n     */\n    TextDocumentSaveReason.AfterDelay = 2;\n    /**\n     * When the editor lost focus.\n     */\n    TextDocumentSaveReason.FocusOut = 3;\n})(TextDocumentSaveReason || (exports.TextDocumentSaveReason = TextDocumentSaveReason = {}));\n/**\n * A document will save notification is sent from the client to the server before\n * the document is actually saved.\n */\nvar WillSaveTextDocumentNotification;\n(function (WillSaveTextDocumentNotification) {\n    WillSaveTextDocumentNotification.method = 'textDocument/willSave';\n    WillSaveTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;\n    WillSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification.method);\n})(WillSaveTextDocumentNotification || (exports.WillSaveTextDocumentNotification = WillSaveTextDocumentNotification = {}));\n/**\n * A document will save request is sent from the client to the server before\n * the document is actually saved. The request can return an array of TextEdits\n * which will be applied to the text document before it is saved. Please note that\n * clients might drop results if computing the text edits took too long or if a\n * server constantly fails on this request. This is done to keep the save fast and\n * reliable.\n */\nvar WillSaveTextDocumentWaitUntilRequest;\n(function (WillSaveTextDocumentWaitUntilRequest) {\n    WillSaveTextDocumentWaitUntilRequest.method = 'textDocument/willSaveWaitUntil';\n    WillSaveTextDocumentWaitUntilRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    WillSaveTextDocumentWaitUntilRequest.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest.method);\n})(WillSaveTextDocumentWaitUntilRequest || (exports.WillSaveTextDocumentWaitUntilRequest = WillSaveTextDocumentWaitUntilRequest = {}));\n/**\n * The watched files notification is sent from the client to the server when\n * the client detects changes to file watched by the language client.\n */\nvar DidChangeWatchedFilesNotification;\n(function (DidChangeWatchedFilesNotification) {\n    DidChangeWatchedFilesNotification.method = 'workspace/didChangeWatchedFiles';\n    DidChangeWatchedFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;\n    DidChangeWatchedFilesNotification.type = new messages_1.ProtocolNotificationType(DidChangeWatchedFilesNotification.method);\n})(DidChangeWatchedFilesNotification || (exports.DidChangeWatchedFilesNotification = DidChangeWatchedFilesNotification = {}));\n/**\n * The file event type\n */\nvar FileChangeType;\n(function (FileChangeType) {\n    /**\n     * The file got created.\n     */\n    FileChangeType.Created = 1;\n    /**\n     * The file got changed.\n     */\n    FileChangeType.Changed = 2;\n    /**\n     * The file got deleted.\n     */\n    FileChangeType.Deleted = 3;\n})(FileChangeType || (exports.FileChangeType = FileChangeType = {}));\nvar RelativePattern;\n(function (RelativePattern) {\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && (vscode_languageserver_types_1.URI.is(candidate.baseUri) || vscode_languageserver_types_1.WorkspaceFolder.is(candidate.baseUri)) && Is.string(candidate.pattern);\n    }\n    RelativePattern.is = is;\n})(RelativePattern || (exports.RelativePattern = RelativePattern = {}));\nvar WatchKind;\n(function (WatchKind) {\n    /**\n     * Interested in create events.\n     */\n    WatchKind.Create = 1;\n    /**\n     * Interested in change events\n     */\n    WatchKind.Change = 2;\n    /**\n     * Interested in delete events\n     */\n    WatchKind.Delete = 4;\n})(WatchKind || (exports.WatchKind = WatchKind = {}));\n/**\n * Diagnostics notification are sent from the server to the client to signal\n * results of validation runs.\n */\nvar PublishDiagnosticsNotification;\n(function (PublishDiagnosticsNotification) {\n    PublishDiagnosticsNotification.method = 'textDocument/publishDiagnostics';\n    PublishDiagnosticsNotification.messageDirection = messages_1.MessageDirection.serverToClient;\n    PublishDiagnosticsNotification.type = new messages_1.ProtocolNotificationType(PublishDiagnosticsNotification.method);\n})(PublishDiagnosticsNotification || (exports.PublishDiagnosticsNotification = PublishDiagnosticsNotification = {}));\n/**\n * How a completion was triggered\n */\nvar CompletionTriggerKind;\n(function (CompletionTriggerKind) {\n    /**\n     * Completion was triggered by typing an identifier (24x7 code\n     * complete), manual invocation (e.g Ctrl+Space) or via API.\n     */\n    CompletionTriggerKind.Invoked = 1;\n    /**\n     * Completion was triggered by a trigger character specified by\n     * the `triggerCharacters` properties of the `CompletionRegistrationOptions`.\n     */\n    CompletionTriggerKind.TriggerCharacter = 2;\n    /**\n     * Completion was re-triggered as current completion list is incomplete\n     */\n    CompletionTriggerKind.TriggerForIncompleteCompletions = 3;\n})(CompletionTriggerKind || (exports.CompletionTriggerKind = CompletionTriggerKind = {}));\n/**\n * Request to request completion at a given text document position. The request's\n * parameter is of type {@link TextDocumentPosition} the response\n * is of type {@link CompletionItem CompletionItem[]} or {@link CompletionList}\n * or a Thenable that resolves to such.\n *\n * The request can delay the computation of the {@link CompletionItem.detail `detail`}\n * and {@link CompletionItem.documentation `documentation`} properties to the `completionItem/resolve`\n * request. However, properties that are needed for the initial sorting and filtering, like `sortText`,\n * `filterText`, `insertText`, and `textEdit`, must not be changed during resolve.\n */\nvar CompletionRequest;\n(function (CompletionRequest) {\n    CompletionRequest.method = 'textDocument/completion';\n    CompletionRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    CompletionRequest.type = new messages_1.ProtocolRequestType(CompletionRequest.method);\n})(CompletionRequest || (exports.CompletionRequest = CompletionRequest = {}));\n/**\n * Request to resolve additional information for a given completion item.The request's\n * parameter is of type {@link CompletionItem} the response\n * is of type {@link CompletionItem} or a Thenable that resolves to such.\n */\nvar CompletionResolveRequest;\n(function (CompletionResolveRequest) {\n    CompletionResolveRequest.method = 'completionItem/resolve';\n    CompletionResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    CompletionResolveRequest.type = new messages_1.ProtocolRequestType(CompletionResolveRequest.method);\n})(CompletionResolveRequest || (exports.CompletionResolveRequest = CompletionResolveRequest = {}));\n/**\n * Request to request hover information at a given text document position. The request's\n * parameter is of type {@link TextDocumentPosition} the response is of\n * type {@link Hover} or a Thenable that resolves to such.\n */\nvar HoverRequest;\n(function (HoverRequest) {\n    HoverRequest.method = 'textDocument/hover';\n    HoverRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    HoverRequest.type = new messages_1.ProtocolRequestType(HoverRequest.method);\n})(HoverRequest || (exports.HoverRequest = HoverRequest = {}));\n/**\n * How a signature help was triggered.\n *\n * @since 3.15.0\n */\nvar SignatureHelpTriggerKind;\n(function (SignatureHelpTriggerKind) {\n    /**\n     * Signature help was invoked manually by the user or by a command.\n     */\n    SignatureHelpTriggerKind.Invoked = 1;\n    /**\n     * Signature help was triggered by a trigger character.\n     */\n    SignatureHelpTriggerKind.TriggerCharacter = 2;\n    /**\n     * Signature help was triggered by the cursor moving or by the document content changing.\n     */\n    SignatureHelpTriggerKind.ContentChange = 3;\n})(SignatureHelpTriggerKind || (exports.SignatureHelpTriggerKind = SignatureHelpTriggerKind = {}));\nvar SignatureHelpRequest;\n(function (SignatureHelpRequest) {\n    SignatureHelpRequest.method = 'textDocument/signatureHelp';\n    SignatureHelpRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    SignatureHelpRequest.type = new messages_1.ProtocolRequestType(SignatureHelpRequest.method);\n})(SignatureHelpRequest || (exports.SignatureHelpRequest = SignatureHelpRequest = {}));\n/**\n * A request to resolve the definition location of a symbol at a given text\n * document position. The request's parameter is of type {@link TextDocumentPosition}\n * the response is of either type {@link Definition} or a typed array of\n * {@link DefinitionLink} or a Thenable that resolves to such.\n */\nvar DefinitionRequest;\n(function (DefinitionRequest) {\n    DefinitionRequest.method = 'textDocument/definition';\n    DefinitionRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    DefinitionRequest.type = new messages_1.ProtocolRequestType(DefinitionRequest.method);\n})(DefinitionRequest || (exports.DefinitionRequest = DefinitionRequest = {}));\n/**\n * A request to resolve project-wide references for the symbol denoted\n * by the given text document position. The request's parameter is of\n * type {@link ReferenceParams} the response is of type\n * {@link Location Location[]} or a Thenable that resolves to such.\n */\nvar ReferencesRequest;\n(function (ReferencesRequest) {\n    ReferencesRequest.method = 'textDocument/references';\n    ReferencesRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    ReferencesRequest.type = new messages_1.ProtocolRequestType(ReferencesRequest.method);\n})(ReferencesRequest || (exports.ReferencesRequest = ReferencesRequest = {}));\n/**\n * Request to resolve a {@link DocumentHighlight} for a given\n * text document position. The request's parameter is of type {@link TextDocumentPosition}\n * the request response is an array of type {@link DocumentHighlight}\n * or a Thenable that resolves to such.\n */\nvar DocumentHighlightRequest;\n(function (DocumentHighlightRequest) {\n    DocumentHighlightRequest.method = 'textDocument/documentHighlight';\n    DocumentHighlightRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    DocumentHighlightRequest.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest.method);\n})(DocumentHighlightRequest || (exports.DocumentHighlightRequest = DocumentHighlightRequest = {}));\n/**\n * A request to list all symbols found in a given text document. The request's\n * parameter is of type {@link TextDocumentIdentifier} the\n * response is of type {@link SymbolInformation SymbolInformation[]} or a Thenable\n * that resolves to such.\n */\nvar DocumentSymbolRequest;\n(function (DocumentSymbolRequest) {\n    DocumentSymbolRequest.method = 'textDocument/documentSymbol';\n    DocumentSymbolRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    DocumentSymbolRequest.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest.method);\n})(DocumentSymbolRequest || (exports.DocumentSymbolRequest = DocumentSymbolRequest = {}));\n/**\n * A request to provide commands for the given text document and range.\n */\nvar CodeActionRequest;\n(function (CodeActionRequest) {\n    CodeActionRequest.method = 'textDocument/codeAction';\n    CodeActionRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    CodeActionRequest.type = new messages_1.ProtocolRequestType(CodeActionRequest.method);\n})(CodeActionRequest || (exports.CodeActionRequest = CodeActionRequest = {}));\n/**\n * Request to resolve additional information for a given code action.The request's\n * parameter is of type {@link CodeAction} the response\n * is of type {@link CodeAction} or a Thenable that resolves to such.\n */\nvar CodeActionResolveRequest;\n(function (CodeActionResolveRequest) {\n    CodeActionResolveRequest.method = 'codeAction/resolve';\n    CodeActionResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    CodeActionResolveRequest.type = new messages_1.ProtocolRequestType(CodeActionResolveRequest.method);\n})(CodeActionResolveRequest || (exports.CodeActionResolveRequest = CodeActionResolveRequest = {}));\n/**\n * A request to list project-wide symbols matching the query string given\n * by the {@link WorkspaceSymbolParams}. The response is\n * of type {@link SymbolInformation SymbolInformation[]} or a Thenable that\n * resolves to such.\n *\n * @since 3.17.0 - support for WorkspaceSymbol in the returned data. Clients\n *  need to advertise support for WorkspaceSymbols via the client capability\n *  `workspace.symbol.resolveSupport`.\n *\n */\nvar WorkspaceSymbolRequest;\n(function (WorkspaceSymbolRequest) {\n    WorkspaceSymbolRequest.method = 'workspace/symbol';\n    WorkspaceSymbolRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    WorkspaceSymbolRequest.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest.method);\n})(WorkspaceSymbolRequest || (exports.WorkspaceSymbolRequest = WorkspaceSymbolRequest = {}));\n/**\n * A request to resolve the range inside the workspace\n * symbol's location.\n *\n * @since 3.17.0\n */\nvar WorkspaceSymbolResolveRequest;\n(function (WorkspaceSymbolResolveRequest) {\n    WorkspaceSymbolResolveRequest.method = 'workspaceSymbol/resolve';\n    WorkspaceSymbolResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    WorkspaceSymbolResolveRequest.type = new messages_1.ProtocolRequestType(WorkspaceSymbolResolveRequest.method);\n})(WorkspaceSymbolResolveRequest || (exports.WorkspaceSymbolResolveRequest = WorkspaceSymbolResolveRequest = {}));\n/**\n * A request to provide code lens for the given text document.\n */\nvar CodeLensRequest;\n(function (CodeLensRequest) {\n    CodeLensRequest.method = 'textDocument/codeLens';\n    CodeLensRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    CodeLensRequest.type = new messages_1.ProtocolRequestType(CodeLensRequest.method);\n})(CodeLensRequest || (exports.CodeLensRequest = CodeLensRequest = {}));\n/**\n * A request to resolve a command for a given code lens.\n */\nvar CodeLensResolveRequest;\n(function (CodeLensResolveRequest) {\n    CodeLensResolveRequest.method = 'codeLens/resolve';\n    CodeLensResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    CodeLensResolveRequest.type = new messages_1.ProtocolRequestType(CodeLensResolveRequest.method);\n})(CodeLensResolveRequest || (exports.CodeLensResolveRequest = CodeLensResolveRequest = {}));\n/**\n * A request to refresh all code actions\n *\n * @since 3.16.0\n */\nvar CodeLensRefreshRequest;\n(function (CodeLensRefreshRequest) {\n    CodeLensRefreshRequest.method = `workspace/codeLens/refresh`;\n    CodeLensRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;\n    CodeLensRefreshRequest.type = new messages_1.ProtocolRequestType0(CodeLensRefreshRequest.method);\n})(CodeLensRefreshRequest || (exports.CodeLensRefreshRequest = CodeLensRefreshRequest = {}));\n/**\n * A request to provide document links\n */\nvar DocumentLinkRequest;\n(function (DocumentLinkRequest) {\n    DocumentLinkRequest.method = 'textDocument/documentLink';\n    DocumentLinkRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    DocumentLinkRequest.type = new messages_1.ProtocolRequestType(DocumentLinkRequest.method);\n})(DocumentLinkRequest || (exports.DocumentLinkRequest = DocumentLinkRequest = {}));\n/**\n * Request to resolve additional information for a given document link. The request's\n * parameter is of type {@link DocumentLink} the response\n * is of type {@link DocumentLink} or a Thenable that resolves to such.\n */\nvar DocumentLinkResolveRequest;\n(function (DocumentLinkResolveRequest) {\n    DocumentLinkResolveRequest.method = 'documentLink/resolve';\n    DocumentLinkResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    DocumentLinkResolveRequest.type = new messages_1.ProtocolRequestType(DocumentLinkResolveRequest.method);\n})(DocumentLinkResolveRequest || (exports.DocumentLinkResolveRequest = DocumentLinkResolveRequest = {}));\n/**\n * A request to format a whole document.\n */\nvar DocumentFormattingRequest;\n(function (DocumentFormattingRequest) {\n    DocumentFormattingRequest.method = 'textDocument/formatting';\n    DocumentFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    DocumentFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest.method);\n})(DocumentFormattingRequest || (exports.DocumentFormattingRequest = DocumentFormattingRequest = {}));\n/**\n * A request to format a range in a document.\n */\nvar DocumentRangeFormattingRequest;\n(function (DocumentRangeFormattingRequest) {\n    DocumentRangeFormattingRequest.method = 'textDocument/rangeFormatting';\n    DocumentRangeFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    DocumentRangeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest.method);\n})(DocumentRangeFormattingRequest || (exports.DocumentRangeFormattingRequest = DocumentRangeFormattingRequest = {}));\n/**\n * A request to format ranges in a document.\n *\n * @since 3.18.0\n * @proposed\n */\nvar DocumentRangesFormattingRequest;\n(function (DocumentRangesFormattingRequest) {\n    DocumentRangesFormattingRequest.method = 'textDocument/rangesFormatting';\n    DocumentRangesFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    DocumentRangesFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentRangesFormattingRequest.method);\n})(DocumentRangesFormattingRequest || (exports.DocumentRangesFormattingRequest = DocumentRangesFormattingRequest = {}));\n/**\n * A request to format a document on type.\n */\nvar DocumentOnTypeFormattingRequest;\n(function (DocumentOnTypeFormattingRequest) {\n    DocumentOnTypeFormattingRequest.method = 'textDocument/onTypeFormatting';\n    DocumentOnTypeFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    DocumentOnTypeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest.method);\n})(DocumentOnTypeFormattingRequest || (exports.DocumentOnTypeFormattingRequest = DocumentOnTypeFormattingRequest = {}));\n//---- Rename ----------------------------------------------\nvar PrepareSupportDefaultBehavior;\n(function (PrepareSupportDefaultBehavior) {\n    /**\n     * The client's default behavior is to select the identifier\n     * according the to language's syntax rule.\n     */\n    PrepareSupportDefaultBehavior.Identifier = 1;\n})(PrepareSupportDefaultBehavior || (exports.PrepareSupportDefaultBehavior = PrepareSupportDefaultBehavior = {}));\n/**\n * A request to rename a symbol.\n */\nvar RenameRequest;\n(function (RenameRequest) {\n    RenameRequest.method = 'textDocument/rename';\n    RenameRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    RenameRequest.type = new messages_1.ProtocolRequestType(RenameRequest.method);\n})(RenameRequest || (exports.RenameRequest = RenameRequest = {}));\n/**\n * A request to test and perform the setup necessary for a rename.\n *\n * @since 3.16 - support for default behavior\n */\nvar PrepareRenameRequest;\n(function (PrepareRenameRequest) {\n    PrepareRenameRequest.method = 'textDocument/prepareRename';\n    PrepareRenameRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    PrepareRenameRequest.type = new messages_1.ProtocolRequestType(PrepareRenameRequest.method);\n})(PrepareRenameRequest || (exports.PrepareRenameRequest = PrepareRenameRequest = {}));\n/**\n * A request send from the client to the server to execute a command. The request might return\n * a workspace edit which the client will apply to the workspace.\n */\nvar ExecuteCommandRequest;\n(function (ExecuteCommandRequest) {\n    ExecuteCommandRequest.method = 'workspace/executeCommand';\n    ExecuteCommandRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    ExecuteCommandRequest.type = new messages_1.ProtocolRequestType(ExecuteCommandRequest.method);\n})(ExecuteCommandRequest || (exports.ExecuteCommandRequest = ExecuteCommandRequest = {}));\n/**\n * A request sent from the server to the client to modified certain resources.\n */\nvar ApplyWorkspaceEditRequest;\n(function (ApplyWorkspaceEditRequest) {\n    ApplyWorkspaceEditRequest.method = 'workspace/applyEdit';\n    ApplyWorkspaceEditRequest.messageDirection = messages_1.MessageDirection.serverToClient;\n    ApplyWorkspaceEditRequest.type = new messages_1.ProtocolRequestType('workspace/applyEdit');\n})(ApplyWorkspaceEditRequest || (exports.ApplyWorkspaceEditRequest = ApplyWorkspaceEditRequest = {}));\n","/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.objectLiteral = exports.typedArray = exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;\nfunction boolean(value) {\n    return value === true || value === false;\n}\nexports.boolean = boolean;\nfunction string(value) {\n    return typeof value === 'string' || value instanceof String;\n}\nexports.string = string;\nfunction number(value) {\n    return typeof value === 'number' || value instanceof Number;\n}\nexports.number = number;\nfunction error(value) {\n    return value instanceof Error;\n}\nexports.error = error;\nfunction func(value) {\n    return typeof value === 'function';\n}\nexports.func = func;\nfunction array(value) {\n    return Array.isArray(value);\n}\nexports.array = array;\nfunction stringArray(value) {\n    return array(value) && value.every(elem => string(elem));\n}\nexports.stringArray = stringArray;\nfunction typedArray(value, check) {\n    return Array.isArray(value) && value.every(check);\n}\nexports.typedArray = typedArray;\nfunction objectLiteral(value) {\n    // Strictly speaking class instances pass this check as well. Since the LSP\n    // doesn't use classes we ignore this for now. If we do we need to add something\n    // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`\n    return value !== null && typeof value === 'object';\n}\nexports.objectLiteral = objectLiteral;\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ImplementationRequest = void 0;\nconst messages_1 = require(\"./messages\");\n// @ts-ignore: to avoid inlining LocationLink as dynamic import\nlet __noDynamicImport;\n/**\n * A request to resolve the implementation locations of a symbol at a given text\n * document position. The request's parameter is of type {@link TextDocumentPositionParams}\n * the response is of type {@link Definition} or a Thenable that resolves to such.\n */\nvar ImplementationRequest;\n(function (ImplementationRequest) {\n    ImplementationRequest.method = 'textDocument/implementation';\n    ImplementationRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    ImplementationRequest.type = new messages_1.ProtocolRequestType(ImplementationRequest.method);\n})(ImplementationRequest || (exports.ImplementationRequest = ImplementationRequest = {}));\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TypeDefinitionRequest = void 0;\nconst messages_1 = require(\"./messages\");\n// @ts-ignore: to avoid inlining LocatioLink as dynamic import\nlet __noDynamicImport;\n/**\n * A request to resolve the type definition locations of a symbol at a given text\n * document position. The request's parameter is of type {@link TextDocumentPositionParams}\n * the response is of type {@link Definition} or a Thenable that resolves to such.\n */\nvar TypeDefinitionRequest;\n(function (TypeDefinitionRequest) {\n    TypeDefinitionRequest.method = 'textDocument/typeDefinition';\n    TypeDefinitionRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    TypeDefinitionRequest.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest.method);\n})(TypeDefinitionRequest || (exports.TypeDefinitionRequest = TypeDefinitionRequest = {}));\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DidChangeWorkspaceFoldersNotification = exports.WorkspaceFoldersRequest = void 0;\nconst messages_1 = require(\"./messages\");\n/**\n * The `workspace/workspaceFolders` is sent from the server to the client to fetch the open workspace folders.\n */\nvar WorkspaceFoldersRequest;\n(function (WorkspaceFoldersRequest) {\n    WorkspaceFoldersRequest.method = 'workspace/workspaceFolders';\n    WorkspaceFoldersRequest.messageDirection = messages_1.MessageDirection.serverToClient;\n    WorkspaceFoldersRequest.type = new messages_1.ProtocolRequestType0(WorkspaceFoldersRequest.method);\n})(WorkspaceFoldersRequest || (exports.WorkspaceFoldersRequest = WorkspaceFoldersRequest = {}));\n/**\n * The `workspace/didChangeWorkspaceFolders` notification is sent from the client to the server when the workspace\n * folder configuration changes.\n */\nvar DidChangeWorkspaceFoldersNotification;\n(function (DidChangeWorkspaceFoldersNotification) {\n    DidChangeWorkspaceFoldersNotification.method = 'workspace/didChangeWorkspaceFolders';\n    DidChangeWorkspaceFoldersNotification.messageDirection = messages_1.MessageDirection.clientToServer;\n    DidChangeWorkspaceFoldersNotification.type = new messages_1.ProtocolNotificationType(DidChangeWorkspaceFoldersNotification.method);\n})(DidChangeWorkspaceFoldersNotification || (exports.DidChangeWorkspaceFoldersNotification = DidChangeWorkspaceFoldersNotification = {}));\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ConfigurationRequest = void 0;\nconst messages_1 = require(\"./messages\");\n//---- Get Configuration request ----\n/**\n * The 'workspace/configuration' request is sent from the server to the client to fetch a certain\n * configuration setting.\n *\n * This pull model replaces the old push model were the client signaled configuration change via an\n * event. If the server still needs to react to configuration changes (since the server caches the\n * result of `workspace/configuration` requests) the server should register for an empty configuration\n * change event and empty the cache if such an event is received.\n */\nvar ConfigurationRequest;\n(function (ConfigurationRequest) {\n    ConfigurationRequest.method = 'workspace/configuration';\n    ConfigurationRequest.messageDirection = messages_1.MessageDirection.serverToClient;\n    ConfigurationRequest.type = new messages_1.ProtocolRequestType(ConfigurationRequest.method);\n})(ConfigurationRequest || (exports.ConfigurationRequest = ConfigurationRequest = {}));\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ColorPresentationRequest = exports.DocumentColorRequest = void 0;\nconst messages_1 = require(\"./messages\");\n/**\n * A request to list all color symbols found in a given text document. The request's\n * parameter is of type {@link DocumentColorParams} the\n * response is of type {@link ColorInformation ColorInformation[]} or a Thenable\n * that resolves to such.\n */\nvar DocumentColorRequest;\n(function (DocumentColorRequest) {\n    DocumentColorRequest.method = 'textDocument/documentColor';\n    DocumentColorRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    DocumentColorRequest.type = new messages_1.ProtocolRequestType(DocumentColorRequest.method);\n})(DocumentColorRequest || (exports.DocumentColorRequest = DocumentColorRequest = {}));\n/**\n * A request to list all presentation for a color. The request's\n * parameter is of type {@link ColorPresentationParams} the\n * response is of type {@link ColorInformation ColorInformation[]} or a Thenable\n * that resolves to such.\n */\nvar ColorPresentationRequest;\n(function (ColorPresentationRequest) {\n    ColorPresentationRequest.method = 'textDocument/colorPresentation';\n    ColorPresentationRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    ColorPresentationRequest.type = new messages_1.ProtocolRequestType(ColorPresentationRequest.method);\n})(ColorPresentationRequest || (exports.ColorPresentationRequest = ColorPresentationRequest = {}));\n","\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FoldingRangeRefreshRequest = exports.FoldingRangeRequest = void 0;\nconst messages_1 = require(\"./messages\");\n/**\n * A request to provide folding ranges in a document. The request's\n * parameter is of type {@link FoldingRangeParams}, the\n * response is of type {@link FoldingRangeList} or a Thenable\n * that resolves to such.\n */\nvar FoldingRangeRequest;\n(function (FoldingRangeRequest) {\n    FoldingRangeRequest.method = 'textDocument/foldingRange';\n    FoldingRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    FoldingRangeRequest.type = new messages_1.ProtocolRequestType(FoldingRangeRequest.method);\n})(FoldingRangeRequest || (exports.FoldingRangeRequest = FoldingRangeRequest = {}));\n/**\n * @since 3.18.0\n * @proposed\n */\nvar FoldingRangeRefreshRequest;\n(function (FoldingRangeRefreshRequest) {\n    FoldingRangeRefreshRequest.method = `workspace/foldingRange/refresh`;\n    FoldingRangeRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;\n    FoldingRangeRefreshRequest.type = new messages_1.ProtocolRequestType0(FoldingRangeRefreshRequest.method);\n})(FoldingRangeRefreshRequest || (exports.FoldingRangeRefreshRequest = FoldingRangeRefreshRequest = {}));\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DeclarationRequest = void 0;\nconst messages_1 = require(\"./messages\");\n// @ts-ignore: to avoid inlining LocationLink as dynamic import\nlet __noDynamicImport;\n/**\n * A request to resolve the type definition locations of a symbol at a given text\n * document position. The request's parameter is of type {@link TextDocumentPositionParams}\n * the response is of type {@link Declaration} or a typed array of {@link DeclarationLink}\n * or a Thenable that resolves to such.\n */\nvar DeclarationRequest;\n(function (DeclarationRequest) {\n    DeclarationRequest.method = 'textDocument/declaration';\n    DeclarationRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    DeclarationRequest.type = new messages_1.ProtocolRequestType(DeclarationRequest.method);\n})(DeclarationRequest || (exports.DeclarationRequest = DeclarationRequest = {}));\n","\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SelectionRangeRequest = void 0;\nconst messages_1 = require(\"./messages\");\n/**\n * A request to provide selection ranges in a document. The request's\n * parameter is of type {@link SelectionRangeParams}, the\n * response is of type {@link SelectionRange SelectionRange[]} or a Thenable\n * that resolves to such.\n */\nvar SelectionRangeRequest;\n(function (SelectionRangeRequest) {\n    SelectionRangeRequest.method = 'textDocument/selectionRange';\n    SelectionRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    SelectionRangeRequest.type = new messages_1.ProtocolRequestType(SelectionRangeRequest.method);\n})(SelectionRangeRequest || (exports.SelectionRangeRequest = SelectionRangeRequest = {}));\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WorkDoneProgressCancelNotification = exports.WorkDoneProgressCreateRequest = exports.WorkDoneProgress = void 0;\nconst vscode_jsonrpc_1 = require(\"vscode-jsonrpc\");\nconst messages_1 = require(\"./messages\");\nvar WorkDoneProgress;\n(function (WorkDoneProgress) {\n    WorkDoneProgress.type = new vscode_jsonrpc_1.ProgressType();\n    function is(value) {\n        return value === WorkDoneProgress.type;\n    }\n    WorkDoneProgress.is = is;\n})(WorkDoneProgress || (exports.WorkDoneProgress = WorkDoneProgress = {}));\n/**\n * The `window/workDoneProgress/create` request is sent from the server to the client to initiate progress\n * reporting from the server.\n */\nvar WorkDoneProgressCreateRequest;\n(function (WorkDoneProgressCreateRequest) {\n    WorkDoneProgressCreateRequest.method = 'window/workDoneProgress/create';\n    WorkDoneProgressCreateRequest.messageDirection = messages_1.MessageDirection.serverToClient;\n    WorkDoneProgressCreateRequest.type = new messages_1.ProtocolRequestType(WorkDoneProgressCreateRequest.method);\n})(WorkDoneProgressCreateRequest || (exports.WorkDoneProgressCreateRequest = WorkDoneProgressCreateRequest = {}));\n/**\n * The `window/workDoneProgress/cancel` notification is sent from  the client to the server to cancel a progress\n * initiated on the server side.\n */\nvar WorkDoneProgressCancelNotification;\n(function (WorkDoneProgressCancelNotification) {\n    WorkDoneProgressCancelNotification.method = 'window/workDoneProgress/cancel';\n    WorkDoneProgressCancelNotification.messageDirection = messages_1.MessageDirection.clientToServer;\n    WorkDoneProgressCancelNotification.type = new messages_1.ProtocolNotificationType(WorkDoneProgressCancelNotification.method);\n})(WorkDoneProgressCancelNotification || (exports.WorkDoneProgressCancelNotification = WorkDoneProgressCancelNotification = {}));\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) TypeFox, Microsoft and others. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CallHierarchyOutgoingCallsRequest = exports.CallHierarchyIncomingCallsRequest = exports.CallHierarchyPrepareRequest = void 0;\nconst messages_1 = require(\"./messages\");\n/**\n * A request to result a `CallHierarchyItem` in a document at a given position.\n * Can be used as an input to an incoming or outgoing call hierarchy.\n *\n * @since 3.16.0\n */\nvar CallHierarchyPrepareRequest;\n(function (CallHierarchyPrepareRequest) {\n    CallHierarchyPrepareRequest.method = 'textDocument/prepareCallHierarchy';\n    CallHierarchyPrepareRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    CallHierarchyPrepareRequest.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest.method);\n})(CallHierarchyPrepareRequest || (exports.CallHierarchyPrepareRequest = CallHierarchyPrepareRequest = {}));\n/**\n * A request to resolve the incoming calls for a given `CallHierarchyItem`.\n *\n * @since 3.16.0\n */\nvar CallHierarchyIncomingCallsRequest;\n(function (CallHierarchyIncomingCallsRequest) {\n    CallHierarchyIncomingCallsRequest.method = 'callHierarchy/incomingCalls';\n    CallHierarchyIncomingCallsRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    CallHierarchyIncomingCallsRequest.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest.method);\n})(CallHierarchyIncomingCallsRequest || (exports.CallHierarchyIncomingCallsRequest = CallHierarchyIncomingCallsRequest = {}));\n/**\n * A request to resolve the outgoing calls for a given `CallHierarchyItem`.\n *\n * @since 3.16.0\n */\nvar CallHierarchyOutgoingCallsRequest;\n(function (CallHierarchyOutgoingCallsRequest) {\n    CallHierarchyOutgoingCallsRequest.method = 'callHierarchy/outgoingCalls';\n    CallHierarchyOutgoingCallsRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    CallHierarchyOutgoingCallsRequest.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest.method);\n})(CallHierarchyOutgoingCallsRequest || (exports.CallHierarchyOutgoingCallsRequest = CallHierarchyOutgoingCallsRequest = {}));\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SemanticTokensRefreshRequest = exports.SemanticTokensRangeRequest = exports.SemanticTokensDeltaRequest = exports.SemanticTokensRequest = exports.SemanticTokensRegistrationType = exports.TokenFormat = void 0;\nconst messages_1 = require(\"./messages\");\n//------- 'textDocument/semanticTokens' -----\nvar TokenFormat;\n(function (TokenFormat) {\n    TokenFormat.Relative = 'relative';\n})(TokenFormat || (exports.TokenFormat = TokenFormat = {}));\nvar SemanticTokensRegistrationType;\n(function (SemanticTokensRegistrationType) {\n    SemanticTokensRegistrationType.method = 'textDocument/semanticTokens';\n    SemanticTokensRegistrationType.type = new messages_1.RegistrationType(SemanticTokensRegistrationType.method);\n})(SemanticTokensRegistrationType || (exports.SemanticTokensRegistrationType = SemanticTokensRegistrationType = {}));\n/**\n * @since 3.16.0\n */\nvar SemanticTokensRequest;\n(function (SemanticTokensRequest) {\n    SemanticTokensRequest.method = 'textDocument/semanticTokens/full';\n    SemanticTokensRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    SemanticTokensRequest.type = new messages_1.ProtocolRequestType(SemanticTokensRequest.method);\n    SemanticTokensRequest.registrationMethod = SemanticTokensRegistrationType.method;\n})(SemanticTokensRequest || (exports.SemanticTokensRequest = SemanticTokensRequest = {}));\n/**\n * @since 3.16.0\n */\nvar SemanticTokensDeltaRequest;\n(function (SemanticTokensDeltaRequest) {\n    SemanticTokensDeltaRequest.method = 'textDocument/semanticTokens/full/delta';\n    SemanticTokensDeltaRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    SemanticTokensDeltaRequest.type = new messages_1.ProtocolRequestType(SemanticTokensDeltaRequest.method);\n    SemanticTokensDeltaRequest.registrationMethod = SemanticTokensRegistrationType.method;\n})(SemanticTokensDeltaRequest || (exports.SemanticTokensDeltaRequest = SemanticTokensDeltaRequest = {}));\n/**\n * @since 3.16.0\n */\nvar SemanticTokensRangeRequest;\n(function (SemanticTokensRangeRequest) {\n    SemanticTokensRangeRequest.method = 'textDocument/semanticTokens/range';\n    SemanticTokensRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    SemanticTokensRangeRequest.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest.method);\n    SemanticTokensRangeRequest.registrationMethod = SemanticTokensRegistrationType.method;\n})(SemanticTokensRangeRequest || (exports.SemanticTokensRangeRequest = SemanticTokensRangeRequest = {}));\n/**\n * @since 3.16.0\n */\nvar SemanticTokensRefreshRequest;\n(function (SemanticTokensRefreshRequest) {\n    SemanticTokensRefreshRequest.method = `workspace/semanticTokens/refresh`;\n    SemanticTokensRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;\n    SemanticTokensRefreshRequest.type = new messages_1.ProtocolRequestType0(SemanticTokensRefreshRequest.method);\n})(SemanticTokensRefreshRequest || (exports.SemanticTokensRefreshRequest = SemanticTokensRefreshRequest = {}));\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ShowDocumentRequest = void 0;\nconst messages_1 = require(\"./messages\");\n/**\n * A request to show a document. This request might open an\n * external program depending on the value of the URI to open.\n * For example a request to open `https://code.visualstudio.com/`\n * will very likely open the URI in a WEB browser.\n *\n * @since 3.16.0\n*/\nvar ShowDocumentRequest;\n(function (ShowDocumentRequest) {\n    ShowDocumentRequest.method = 'window/showDocument';\n    ShowDocumentRequest.messageDirection = messages_1.MessageDirection.serverToClient;\n    ShowDocumentRequest.type = new messages_1.ProtocolRequestType(ShowDocumentRequest.method);\n})(ShowDocumentRequest || (exports.ShowDocumentRequest = ShowDocumentRequest = {}));\n","\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LinkedEditingRangeRequest = void 0;\nconst messages_1 = require(\"./messages\");\n/**\n * A request to provide ranges that can be edited together.\n *\n * @since 3.16.0\n */\nvar LinkedEditingRangeRequest;\n(function (LinkedEditingRangeRequest) {\n    LinkedEditingRangeRequest.method = 'textDocument/linkedEditingRange';\n    LinkedEditingRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    LinkedEditingRangeRequest.type = new messages_1.ProtocolRequestType(LinkedEditingRangeRequest.method);\n})(LinkedEditingRangeRequest || (exports.LinkedEditingRangeRequest = LinkedEditingRangeRequest = {}));\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WillDeleteFilesRequest = exports.DidDeleteFilesNotification = exports.DidRenameFilesNotification = exports.WillRenameFilesRequest = exports.DidCreateFilesNotification = exports.WillCreateFilesRequest = exports.FileOperationPatternKind = void 0;\nconst messages_1 = require(\"./messages\");\n/**\n * A pattern kind describing if a glob pattern matches a file a folder or\n * both.\n *\n * @since 3.16.0\n */\nvar FileOperationPatternKind;\n(function (FileOperationPatternKind) {\n    /**\n     * The pattern matches a file only.\n     */\n    FileOperationPatternKind.file = 'file';\n    /**\n     * The pattern matches a folder only.\n     */\n    FileOperationPatternKind.folder = 'folder';\n})(FileOperationPatternKind || (exports.FileOperationPatternKind = FileOperationPatternKind = {}));\n/**\n * The will create files request is sent from the client to the server before files are actually\n * created as long as the creation is triggered from within the client.\n *\n * The request can return a `WorkspaceEdit` which will be applied to workspace before the\n * files are created. Hence the `WorkspaceEdit` can not manipulate the content of the file\n * to be created.\n *\n * @since 3.16.0\n */\nvar WillCreateFilesRequest;\n(function (WillCreateFilesRequest) {\n    WillCreateFilesRequest.method = 'workspace/willCreateFiles';\n    WillCreateFilesRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    WillCreateFilesRequest.type = new messages_1.ProtocolRequestType(WillCreateFilesRequest.method);\n})(WillCreateFilesRequest || (exports.WillCreateFilesRequest = WillCreateFilesRequest = {}));\n/**\n * The did create files notification is sent from the client to the server when\n * files were created from within the client.\n *\n * @since 3.16.0\n */\nvar DidCreateFilesNotification;\n(function (DidCreateFilesNotification) {\n    DidCreateFilesNotification.method = 'workspace/didCreateFiles';\n    DidCreateFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;\n    DidCreateFilesNotification.type = new messages_1.ProtocolNotificationType(DidCreateFilesNotification.method);\n})(DidCreateFilesNotification || (exports.DidCreateFilesNotification = DidCreateFilesNotification = {}));\n/**\n * The will rename files request is sent from the client to the server before files are actually\n * renamed as long as the rename is triggered from within the client.\n *\n * @since 3.16.0\n */\nvar WillRenameFilesRequest;\n(function (WillRenameFilesRequest) {\n    WillRenameFilesRequest.method = 'workspace/willRenameFiles';\n    WillRenameFilesRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    WillRenameFilesRequest.type = new messages_1.ProtocolRequestType(WillRenameFilesRequest.method);\n})(WillRenameFilesRequest || (exports.WillRenameFilesRequest = WillRenameFilesRequest = {}));\n/**\n * The did rename files notification is sent from the client to the server when\n * files were renamed from within the client.\n *\n * @since 3.16.0\n */\nvar DidRenameFilesNotification;\n(function (DidRenameFilesNotification) {\n    DidRenameFilesNotification.method = 'workspace/didRenameFiles';\n    DidRenameFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;\n    DidRenameFilesNotification.type = new messages_1.ProtocolNotificationType(DidRenameFilesNotification.method);\n})(DidRenameFilesNotification || (exports.DidRenameFilesNotification = DidRenameFilesNotification = {}));\n/**\n * The will delete files request is sent from the client to the server before files are actually\n * deleted as long as the deletion is triggered from within the client.\n *\n * @since 3.16.0\n */\nvar DidDeleteFilesNotification;\n(function (DidDeleteFilesNotification) {\n    DidDeleteFilesNotification.method = 'workspace/didDeleteFiles';\n    DidDeleteFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;\n    DidDeleteFilesNotification.type = new messages_1.ProtocolNotificationType(DidDeleteFilesNotification.method);\n})(DidDeleteFilesNotification || (exports.DidDeleteFilesNotification = DidDeleteFilesNotification = {}));\n/**\n * The did delete files notification is sent from the client to the server when\n * files were deleted from within the client.\n *\n * @since 3.16.0\n */\nvar WillDeleteFilesRequest;\n(function (WillDeleteFilesRequest) {\n    WillDeleteFilesRequest.method = 'workspace/willDeleteFiles';\n    WillDeleteFilesRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    WillDeleteFilesRequest.type = new messages_1.ProtocolRequestType(WillDeleteFilesRequest.method);\n})(WillDeleteFilesRequest || (exports.WillDeleteFilesRequest = WillDeleteFilesRequest = {}));\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MonikerRequest = exports.MonikerKind = exports.UniquenessLevel = void 0;\nconst messages_1 = require(\"./messages\");\n/**\n * Moniker uniqueness level to define scope of the moniker.\n *\n * @since 3.16.0\n */\nvar UniquenessLevel;\n(function (UniquenessLevel) {\n    /**\n     * The moniker is only unique inside a document\n     */\n    UniquenessLevel.document = 'document';\n    /**\n     * The moniker is unique inside a project for which a dump got created\n     */\n    UniquenessLevel.project = 'project';\n    /**\n     * The moniker is unique inside the group to which a project belongs\n     */\n    UniquenessLevel.group = 'group';\n    /**\n     * The moniker is unique inside the moniker scheme.\n     */\n    UniquenessLevel.scheme = 'scheme';\n    /**\n     * The moniker is globally unique\n     */\n    UniquenessLevel.global = 'global';\n})(UniquenessLevel || (exports.UniquenessLevel = UniquenessLevel = {}));\n/**\n * The moniker kind.\n *\n * @since 3.16.0\n */\nvar MonikerKind;\n(function (MonikerKind) {\n    /**\n     * The moniker represent a symbol that is imported into a project\n     */\n    MonikerKind.$import = 'import';\n    /**\n     * The moniker represents a symbol that is exported from a project\n     */\n    MonikerKind.$export = 'export';\n    /**\n     * The moniker represents a symbol that is local to a project (e.g. a local\n     * variable of a function, a class not visible outside the project, ...)\n     */\n    MonikerKind.local = 'local';\n})(MonikerKind || (exports.MonikerKind = MonikerKind = {}));\n/**\n * A request to get the moniker of a symbol at a given text document position.\n * The request parameter is of type {@link TextDocumentPositionParams}.\n * The response is of type {@link Moniker Moniker[]} or `null`.\n */\nvar MonikerRequest;\n(function (MonikerRequest) {\n    MonikerRequest.method = 'textDocument/moniker';\n    MonikerRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    MonikerRequest.type = new messages_1.ProtocolRequestType(MonikerRequest.method);\n})(MonikerRequest || (exports.MonikerRequest = MonikerRequest = {}));\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) TypeFox, Microsoft and others. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TypeHierarchySubtypesRequest = exports.TypeHierarchySupertypesRequest = exports.TypeHierarchyPrepareRequest = void 0;\nconst messages_1 = require(\"./messages\");\n/**\n * A request to result a `TypeHierarchyItem` in a document at a given position.\n * Can be used as an input to a subtypes or supertypes type hierarchy.\n *\n * @since 3.17.0\n */\nvar TypeHierarchyPrepareRequest;\n(function (TypeHierarchyPrepareRequest) {\n    TypeHierarchyPrepareRequest.method = 'textDocument/prepareTypeHierarchy';\n    TypeHierarchyPrepareRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    TypeHierarchyPrepareRequest.type = new messages_1.ProtocolRequestType(TypeHierarchyPrepareRequest.method);\n})(TypeHierarchyPrepareRequest || (exports.TypeHierarchyPrepareRequest = TypeHierarchyPrepareRequest = {}));\n/**\n * A request to resolve the supertypes for a given `TypeHierarchyItem`.\n *\n * @since 3.17.0\n */\nvar TypeHierarchySupertypesRequest;\n(function (TypeHierarchySupertypesRequest) {\n    TypeHierarchySupertypesRequest.method = 'typeHierarchy/supertypes';\n    TypeHierarchySupertypesRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    TypeHierarchySupertypesRequest.type = new messages_1.ProtocolRequestType(TypeHierarchySupertypesRequest.method);\n})(TypeHierarchySupertypesRequest || (exports.TypeHierarchySupertypesRequest = TypeHierarchySupertypesRequest = {}));\n/**\n * A request to resolve the subtypes for a given `TypeHierarchyItem`.\n *\n * @since 3.17.0\n */\nvar TypeHierarchySubtypesRequest;\n(function (TypeHierarchySubtypesRequest) {\n    TypeHierarchySubtypesRequest.method = 'typeHierarchy/subtypes';\n    TypeHierarchySubtypesRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    TypeHierarchySubtypesRequest.type = new messages_1.ProtocolRequestType(TypeHierarchySubtypesRequest.method);\n})(TypeHierarchySubtypesRequest || (exports.TypeHierarchySubtypesRequest = TypeHierarchySubtypesRequest = {}));\n","\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.InlineValueRefreshRequest = exports.InlineValueRequest = void 0;\nconst messages_1 = require(\"./messages\");\n/**\n * A request to provide inline values in a document. The request's parameter is of\n * type {@link InlineValueParams}, the response is of type\n * {@link InlineValue InlineValue[]} or a Thenable that resolves to such.\n *\n * @since 3.17.0\n */\nvar InlineValueRequest;\n(function (InlineValueRequest) {\n    InlineValueRequest.method = 'textDocument/inlineValue';\n    InlineValueRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    InlineValueRequest.type = new messages_1.ProtocolRequestType(InlineValueRequest.method);\n})(InlineValueRequest || (exports.InlineValueRequest = InlineValueRequest = {}));\n/**\n * @since 3.17.0\n */\nvar InlineValueRefreshRequest;\n(function (InlineValueRefreshRequest) {\n    InlineValueRefreshRequest.method = `workspace/inlineValue/refresh`;\n    InlineValueRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;\n    InlineValueRefreshRequest.type = new messages_1.ProtocolRequestType0(InlineValueRefreshRequest.method);\n})(InlineValueRefreshRequest || (exports.InlineValueRefreshRequest = InlineValueRefreshRequest = {}));\n","\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.InlayHintRefreshRequest = exports.InlayHintResolveRequest = exports.InlayHintRequest = void 0;\nconst messages_1 = require(\"./messages\");\n/**\n * A request to provide inlay hints in a document. The request's parameter is of\n * type {@link InlayHintsParams}, the response is of type\n * {@link InlayHint InlayHint[]} or a Thenable that resolves to such.\n *\n * @since 3.17.0\n */\nvar InlayHintRequest;\n(function (InlayHintRequest) {\n    InlayHintRequest.method = 'textDocument/inlayHint';\n    InlayHintRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    InlayHintRequest.type = new messages_1.ProtocolRequestType(InlayHintRequest.method);\n})(InlayHintRequest || (exports.InlayHintRequest = InlayHintRequest = {}));\n/**\n * A request to resolve additional properties for an inlay hint.\n * The request's parameter is of type {@link InlayHint}, the response is\n * of type {@link InlayHint} or a Thenable that resolves to such.\n *\n * @since 3.17.0\n */\nvar InlayHintResolveRequest;\n(function (InlayHintResolveRequest) {\n    InlayHintResolveRequest.method = 'inlayHint/resolve';\n    InlayHintResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    InlayHintResolveRequest.type = new messages_1.ProtocolRequestType(InlayHintResolveRequest.method);\n})(InlayHintResolveRequest || (exports.InlayHintResolveRequest = InlayHintResolveRequest = {}));\n/**\n * @since 3.17.0\n */\nvar InlayHintRefreshRequest;\n(function (InlayHintRefreshRequest) {\n    InlayHintRefreshRequest.method = `workspace/inlayHint/refresh`;\n    InlayHintRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;\n    InlayHintRefreshRequest.type = new messages_1.ProtocolRequestType0(InlayHintRefreshRequest.method);\n})(InlayHintRefreshRequest || (exports.InlayHintRefreshRequest = InlayHintRefreshRequest = {}));\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DiagnosticRefreshRequest = exports.WorkspaceDiagnosticRequest = exports.DocumentDiagnosticRequest = exports.DocumentDiagnosticReportKind = exports.DiagnosticServerCancellationData = void 0;\nconst vscode_jsonrpc_1 = require(\"vscode-jsonrpc\");\nconst Is = require(\"./utils/is\");\nconst messages_1 = require(\"./messages\");\n/**\n * @since 3.17.0\n */\nvar DiagnosticServerCancellationData;\n(function (DiagnosticServerCancellationData) {\n    function is(value) {\n        const candidate = value;\n        return candidate && Is.boolean(candidate.retriggerRequest);\n    }\n    DiagnosticServerCancellationData.is = is;\n})(DiagnosticServerCancellationData || (exports.DiagnosticServerCancellationData = DiagnosticServerCancellationData = {}));\n/**\n * The document diagnostic report kinds.\n *\n * @since 3.17.0\n */\nvar DocumentDiagnosticReportKind;\n(function (DocumentDiagnosticReportKind) {\n    /**\n     * A diagnostic report with a full\n     * set of problems.\n     */\n    DocumentDiagnosticReportKind.Full = 'full';\n    /**\n     * A report indicating that the last\n     * returned report is still accurate.\n     */\n    DocumentDiagnosticReportKind.Unchanged = 'unchanged';\n})(DocumentDiagnosticReportKind || (exports.DocumentDiagnosticReportKind = DocumentDiagnosticReportKind = {}));\n/**\n * The document diagnostic request definition.\n *\n * @since 3.17.0\n */\nvar DocumentDiagnosticRequest;\n(function (DocumentDiagnosticRequest) {\n    DocumentDiagnosticRequest.method = 'textDocument/diagnostic';\n    DocumentDiagnosticRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    DocumentDiagnosticRequest.type = new messages_1.ProtocolRequestType(DocumentDiagnosticRequest.method);\n    DocumentDiagnosticRequest.partialResult = new vscode_jsonrpc_1.ProgressType();\n})(DocumentDiagnosticRequest || (exports.DocumentDiagnosticRequest = DocumentDiagnosticRequest = {}));\n/**\n * The workspace diagnostic request definition.\n *\n * @since 3.17.0\n */\nvar WorkspaceDiagnosticRequest;\n(function (WorkspaceDiagnosticRequest) {\n    WorkspaceDiagnosticRequest.method = 'workspace/diagnostic';\n    WorkspaceDiagnosticRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    WorkspaceDiagnosticRequest.type = new messages_1.ProtocolRequestType(WorkspaceDiagnosticRequest.method);\n    WorkspaceDiagnosticRequest.partialResult = new vscode_jsonrpc_1.ProgressType();\n})(WorkspaceDiagnosticRequest || (exports.WorkspaceDiagnosticRequest = WorkspaceDiagnosticRequest = {}));\n/**\n * The diagnostic refresh request definition.\n *\n * @since 3.17.0\n */\nvar DiagnosticRefreshRequest;\n(function (DiagnosticRefreshRequest) {\n    DiagnosticRefreshRequest.method = `workspace/diagnostic/refresh`;\n    DiagnosticRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;\n    DiagnosticRefreshRequest.type = new messages_1.ProtocolRequestType0(DiagnosticRefreshRequest.method);\n})(DiagnosticRefreshRequest || (exports.DiagnosticRefreshRequest = DiagnosticRefreshRequest = {}));\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DidCloseNotebookDocumentNotification = exports.DidSaveNotebookDocumentNotification = exports.DidChangeNotebookDocumentNotification = exports.NotebookCellArrayChange = exports.DidOpenNotebookDocumentNotification = exports.NotebookDocumentSyncRegistrationType = exports.NotebookDocument = exports.NotebookCell = exports.ExecutionSummary = exports.NotebookCellKind = void 0;\nconst vscode_languageserver_types_1 = require(\"vscode-languageserver-types\");\nconst Is = require(\"./utils/is\");\nconst messages_1 = require(\"./messages\");\n/**\n * A notebook cell kind.\n *\n * @since 3.17.0\n */\nvar NotebookCellKind;\n(function (NotebookCellKind) {\n    /**\n     * A markup-cell is formatted source that is used for display.\n     */\n    NotebookCellKind.Markup = 1;\n    /**\n     * A code-cell is source code.\n     */\n    NotebookCellKind.Code = 2;\n    function is(value) {\n        return value === 1 || value === 2;\n    }\n    NotebookCellKind.is = is;\n})(NotebookCellKind || (exports.NotebookCellKind = NotebookCellKind = {}));\nvar ExecutionSummary;\n(function (ExecutionSummary) {\n    function create(executionOrder, success) {\n        const result = { executionOrder };\n        if (success === true || success === false) {\n            result.success = success;\n        }\n        return result;\n    }\n    ExecutionSummary.create = create;\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.executionOrder) && (candidate.success === undefined || Is.boolean(candidate.success));\n    }\n    ExecutionSummary.is = is;\n    function equals(one, other) {\n        if (one === other) {\n            return true;\n        }\n        if (one === null || one === undefined || other === null || other === undefined) {\n            return false;\n        }\n        return one.executionOrder === other.executionOrder && one.success === other.success;\n    }\n    ExecutionSummary.equals = equals;\n})(ExecutionSummary || (exports.ExecutionSummary = ExecutionSummary = {}));\nvar NotebookCell;\n(function (NotebookCell) {\n    function create(kind, document) {\n        return { kind, document };\n    }\n    NotebookCell.create = create;\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && NotebookCellKind.is(candidate.kind) && vscode_languageserver_types_1.DocumentUri.is(candidate.document) &&\n            (candidate.metadata === undefined || Is.objectLiteral(candidate.metadata));\n    }\n    NotebookCell.is = is;\n    function diff(one, two) {\n        const result = new Set();\n        if (one.document !== two.document) {\n            result.add('document');\n        }\n        if (one.kind !== two.kind) {\n            result.add('kind');\n        }\n        if (one.executionSummary !== two.executionSummary) {\n            result.add('executionSummary');\n        }\n        if ((one.metadata !== undefined || two.metadata !== undefined) && !equalsMetadata(one.metadata, two.metadata)) {\n            result.add('metadata');\n        }\n        if ((one.executionSummary !== undefined || two.executionSummary !== undefined) && !ExecutionSummary.equals(one.executionSummary, two.executionSummary)) {\n            result.add('executionSummary');\n        }\n        return result;\n    }\n    NotebookCell.diff = diff;\n    function equalsMetadata(one, other) {\n        if (one === other) {\n            return true;\n        }\n        if (one === null || one === undefined || other === null || other === undefined) {\n            return false;\n        }\n        if (typeof one !== typeof other) {\n            return false;\n        }\n        if (typeof one !== 'object') {\n            return false;\n        }\n        const oneArray = Array.isArray(one);\n        const otherArray = Array.isArray(other);\n        if (oneArray !== otherArray) {\n            return false;\n        }\n        if (oneArray && otherArray) {\n            if (one.length !== other.length) {\n                return false;\n            }\n            for (let i = 0; i < one.length; i++) {\n                if (!equalsMetadata(one[i], other[i])) {\n                    return false;\n                }\n            }\n        }\n        if (Is.objectLiteral(one) && Is.objectLiteral(other)) {\n            const oneKeys = Object.keys(one);\n            const otherKeys = Object.keys(other);\n            if (oneKeys.length !== otherKeys.length) {\n                return false;\n            }\n            oneKeys.sort();\n            otherKeys.sort();\n            if (!equalsMetadata(oneKeys, otherKeys)) {\n                return false;\n            }\n            for (let i = 0; i < oneKeys.length; i++) {\n                const prop = oneKeys[i];\n                if (!equalsMetadata(one[prop], other[prop])) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n})(NotebookCell || (exports.NotebookCell = NotebookCell = {}));\nvar NotebookDocument;\n(function (NotebookDocument) {\n    function create(uri, notebookType, version, cells) {\n        return { uri, notebookType, version, cells };\n    }\n    NotebookDocument.create = create;\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && Is.string(candidate.uri) && vscode_languageserver_types_1.integer.is(candidate.version) && Is.typedArray(candidate.cells, NotebookCell.is);\n    }\n    NotebookDocument.is = is;\n})(NotebookDocument || (exports.NotebookDocument = NotebookDocument = {}));\nvar NotebookDocumentSyncRegistrationType;\n(function (NotebookDocumentSyncRegistrationType) {\n    NotebookDocumentSyncRegistrationType.method = 'notebookDocument/sync';\n    NotebookDocumentSyncRegistrationType.messageDirection = messages_1.MessageDirection.clientToServer;\n    NotebookDocumentSyncRegistrationType.type = new messages_1.RegistrationType(NotebookDocumentSyncRegistrationType.method);\n})(NotebookDocumentSyncRegistrationType || (exports.NotebookDocumentSyncRegistrationType = NotebookDocumentSyncRegistrationType = {}));\n/**\n * A notification sent when a notebook opens.\n *\n * @since 3.17.0\n */\nvar DidOpenNotebookDocumentNotification;\n(function (DidOpenNotebookDocumentNotification) {\n    DidOpenNotebookDocumentNotification.method = 'notebookDocument/didOpen';\n    DidOpenNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;\n    DidOpenNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidOpenNotebookDocumentNotification.method);\n    DidOpenNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;\n})(DidOpenNotebookDocumentNotification || (exports.DidOpenNotebookDocumentNotification = DidOpenNotebookDocumentNotification = {}));\nvar NotebookCellArrayChange;\n(function (NotebookCellArrayChange) {\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.start) && vscode_languageserver_types_1.uinteger.is(candidate.deleteCount) && (candidate.cells === undefined || Is.typedArray(candidate.cells, NotebookCell.is));\n    }\n    NotebookCellArrayChange.is = is;\n    function create(start, deleteCount, cells) {\n        const result = { start, deleteCount };\n        if (cells !== undefined) {\n            result.cells = cells;\n        }\n        return result;\n    }\n    NotebookCellArrayChange.create = create;\n})(NotebookCellArrayChange || (exports.NotebookCellArrayChange = NotebookCellArrayChange = {}));\nvar DidChangeNotebookDocumentNotification;\n(function (DidChangeNotebookDocumentNotification) {\n    DidChangeNotebookDocumentNotification.method = 'notebookDocument/didChange';\n    DidChangeNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;\n    DidChangeNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidChangeNotebookDocumentNotification.method);\n    DidChangeNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;\n})(DidChangeNotebookDocumentNotification || (exports.DidChangeNotebookDocumentNotification = DidChangeNotebookDocumentNotification = {}));\n/**\n * A notification sent when a notebook document is saved.\n *\n * @since 3.17.0\n */\nvar DidSaveNotebookDocumentNotification;\n(function (DidSaveNotebookDocumentNotification) {\n    DidSaveNotebookDocumentNotification.method = 'notebookDocument/didSave';\n    DidSaveNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;\n    DidSaveNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidSaveNotebookDocumentNotification.method);\n    DidSaveNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;\n})(DidSaveNotebookDocumentNotification || (exports.DidSaveNotebookDocumentNotification = DidSaveNotebookDocumentNotification = {}));\n/**\n * A notification sent when a notebook closes.\n *\n * @since 3.17.0\n */\nvar DidCloseNotebookDocumentNotification;\n(function (DidCloseNotebookDocumentNotification) {\n    DidCloseNotebookDocumentNotification.method = 'notebookDocument/didClose';\n    DidCloseNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;\n    DidCloseNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidCloseNotebookDocumentNotification.method);\n    DidCloseNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;\n})(DidCloseNotebookDocumentNotification || (exports.DidCloseNotebookDocumentNotification = DidCloseNotebookDocumentNotification = {}));\n","\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.InlineCompletionRequest = void 0;\nconst messages_1 = require(\"./messages\");\n/**\n * A request to provide inline completions in a document. The request's parameter is of\n * type {@link InlineCompletionParams}, the response is of type\n * {@link InlineCompletion InlineCompletion[]} or a Thenable that resolves to such.\n *\n * @since 3.18.0\n * @proposed\n */\nvar InlineCompletionRequest;\n(function (InlineCompletionRequest) {\n    InlineCompletionRequest.method = 'textDocument/inlineCompletion';\n    InlineCompletionRequest.messageDirection = messages_1.MessageDirection.clientToServer;\n    InlineCompletionRequest.type = new messages_1.ProtocolRequestType(InlineCompletionRequest.method);\n})(InlineCompletionRequest || (exports.InlineCompletionRequest = InlineCompletionRequest = {}));\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createProtocolConnection = void 0;\nconst vscode_jsonrpc_1 = require(\"vscode-jsonrpc\");\nfunction createProtocolConnection(input, output, logger, options) {\n    if (vscode_jsonrpc_1.ConnectionStrategy.is(options)) {\n        options = { connectionStrategy: options };\n    }\n    return (0, vscode_jsonrpc_1.createMessageConnection)(input, output, logger, options);\n}\nexports.createProtocolConnection = createProtocolConnection;\n","\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.generateUuid = exports.parse = exports.isUUID = exports.v4 = exports.empty = void 0;\nclass ValueUUID {\n    constructor(_value) {\n        this._value = _value;\n        // empty\n    }\n    asHex() {\n        return this._value;\n    }\n    equals(other) {\n        return this.asHex() === other.asHex();\n    }\n}\nclass V4UUID extends ValueUUID {\n    static _oneOf(array) {\n        return array[Math.floor(array.length * Math.random())];\n    }\n    static _randomHex() {\n        return V4UUID._oneOf(V4UUID._chars);\n    }\n    constructor() {\n        super([\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            '-',\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            '-',\n            '4',\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            '-',\n            V4UUID._oneOf(V4UUID._timeHighBits),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            '-',\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n        ].join(''));\n    }\n}\nV4UUID._chars = ['0', '1', '2', '3', '4', '5', '6', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];\nV4UUID._timeHighBits = ['8', '9', 'a', 'b'];\n/**\n * An empty UUID that contains only zeros.\n */\nexports.empty = new ValueUUID('00000000-0000-0000-0000-000000000000');\nfunction v4() {\n    return new V4UUID();\n}\nexports.v4 = v4;\nconst _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;\nfunction isUUID(value) {\n    return _UUIDPattern.test(value);\n}\nexports.isUUID = isUUID;\n/**\n * Parses a UUID that is of the format xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx.\n * @param value A uuid string.\n */\nfunction parse(value) {\n    if (!isUUID(value)) {\n        throw new Error('invalid uuid');\n    }\n    return new ValueUUID(value);\n}\nexports.parse = parse;\nfunction generateUuid() {\n    return v4().asHex();\n}\nexports.generateUuid = generateUuid;\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.attachPartialResult = exports.ProgressFeature = exports.attachWorkDone = void 0;\nconst vscode_languageserver_protocol_1 = require(\"vscode-languageserver-protocol\");\nconst uuid_1 = require(\"./utils/uuid\");\nclass WorkDoneProgressReporterImpl {\n    constructor(_connection, _token) {\n        this._connection = _connection;\n        this._token = _token;\n        WorkDoneProgressReporterImpl.Instances.set(this._token, this);\n    }\n    begin(title, percentage, message, cancellable) {\n        let param = {\n            kind: 'begin',\n            title,\n            percentage,\n            message,\n            cancellable\n        };\n        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, param);\n    }\n    report(arg0, arg1) {\n        let param = {\n            kind: 'report'\n        };\n        if (typeof arg0 === 'number') {\n            param.percentage = arg0;\n            if (arg1 !== undefined) {\n                param.message = arg1;\n            }\n        }\n        else {\n            param.message = arg0;\n        }\n        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, param);\n    }\n    done() {\n        WorkDoneProgressReporterImpl.Instances.delete(this._token);\n        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, { kind: 'end' });\n    }\n}\nWorkDoneProgressReporterImpl.Instances = new Map();\nclass WorkDoneProgressServerReporterImpl extends WorkDoneProgressReporterImpl {\n    constructor(connection, token) {\n        super(connection, token);\n        this._source = new vscode_languageserver_protocol_1.CancellationTokenSource();\n    }\n    get token() {\n        return this._source.token;\n    }\n    done() {\n        this._source.dispose();\n        super.done();\n    }\n    cancel() {\n        this._source.cancel();\n    }\n}\nclass NullProgressReporter {\n    constructor() {\n    }\n    begin() {\n    }\n    report() {\n    }\n    done() {\n    }\n}\nclass NullProgressServerReporter extends NullProgressReporter {\n    constructor() {\n        super();\n        this._source = new vscode_languageserver_protocol_1.CancellationTokenSource();\n    }\n    get token() {\n        return this._source.token;\n    }\n    done() {\n        this._source.dispose();\n    }\n    cancel() {\n        this._source.cancel();\n    }\n}\nfunction attachWorkDone(connection, params) {\n    if (params === undefined || params.workDoneToken === undefined) {\n        return new NullProgressReporter();\n    }\n    const token = params.workDoneToken;\n    delete params.workDoneToken;\n    return new WorkDoneProgressReporterImpl(connection, token);\n}\nexports.attachWorkDone = attachWorkDone;\nconst ProgressFeature = (Base) => {\n    return class extends Base {\n        constructor() {\n            super();\n            this._progressSupported = false;\n        }\n        initialize(capabilities) {\n            super.initialize(capabilities);\n            if (capabilities?.window?.workDoneProgress === true) {\n                this._progressSupported = true;\n                this.connection.onNotification(vscode_languageserver_protocol_1.WorkDoneProgressCancelNotification.type, (params) => {\n                    let progress = WorkDoneProgressReporterImpl.Instances.get(params.token);\n                    if (progress instanceof WorkDoneProgressServerReporterImpl || progress instanceof NullProgressServerReporter) {\n                        progress.cancel();\n                    }\n                });\n            }\n        }\n        attachWorkDoneProgress(token) {\n            if (token === undefined) {\n                return new NullProgressReporter();\n            }\n            else {\n                return new WorkDoneProgressReporterImpl(this.connection, token);\n            }\n        }\n        createWorkDoneProgress() {\n            if (this._progressSupported) {\n                const token = (0, uuid_1.generateUuid)();\n                return this.connection.sendRequest(vscode_languageserver_protocol_1.WorkDoneProgressCreateRequest.type, { token }).then(() => {\n                    const result = new WorkDoneProgressServerReporterImpl(this.connection, token);\n                    return result;\n                });\n            }\n            else {\n                return Promise.resolve(new NullProgressServerReporter());\n            }\n        }\n    };\n};\nexports.ProgressFeature = ProgressFeature;\nvar ResultProgress;\n(function (ResultProgress) {\n    ResultProgress.type = new vscode_languageserver_protocol_1.ProgressType();\n})(ResultProgress || (ResultProgress = {}));\nclass ResultProgressReporterImpl {\n    constructor(_connection, _token) {\n        this._connection = _connection;\n        this._token = _token;\n    }\n    report(data) {\n        this._connection.sendProgress(ResultProgress.type, this._token, data);\n    }\n}\nfunction attachPartialResult(connection, params) {\n    if (params === undefined || params.partialResultToken === undefined) {\n        return undefined;\n    }\n    const token = params.partialResultToken;\n    delete params.partialResultToken;\n    return new ResultProgressReporterImpl(connection, token);\n}\nexports.attachPartialResult = attachPartialResult;\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ConfigurationFeature = void 0;\nconst vscode_languageserver_protocol_1 = require(\"vscode-languageserver-protocol\");\nconst Is = require(\"./utils/is\");\nconst ConfigurationFeature = (Base) => {\n    return class extends Base {\n        getConfiguration(arg) {\n            if (!arg) {\n                return this._getConfiguration({});\n            }\n            else if (Is.string(arg)) {\n                return this._getConfiguration({ section: arg });\n            }\n            else {\n                return this._getConfiguration(arg);\n            }\n        }\n        _getConfiguration(arg) {\n            let params = {\n                items: Array.isArray(arg) ? arg : [arg]\n            };\n            return this.connection.sendRequest(vscode_languageserver_protocol_1.ConfigurationRequest.type, params).then((result) => {\n                if (Array.isArray(result)) {\n                    return Array.isArray(arg) ? result : result[0];\n                }\n                else {\n                    return Array.isArray(arg) ? [] : null;\n                }\n            });\n        }\n    };\n};\nexports.ConfigurationFeature = ConfigurationFeature;\n","/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WorkspaceFoldersFeature = void 0;\nconst vscode_languageserver_protocol_1 = require(\"vscode-languageserver-protocol\");\nconst WorkspaceFoldersFeature = (Base) => {\n    return class extends Base {\n        constructor() {\n            super();\n            this._notificationIsAutoRegistered = false;\n        }\n        initialize(capabilities) {\n            super.initialize(capabilities);\n            let workspaceCapabilities = capabilities.workspace;\n            if (workspaceCapabilities && workspaceCapabilities.workspaceFolders) {\n                this._onDidChangeWorkspaceFolders = new vscode_languageserver_protocol_1.Emitter();\n                this.connection.onNotification(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type, (params) => {\n                    this._onDidChangeWorkspaceFolders.fire(params.event);\n                });\n            }\n        }\n        fillServerCapabilities(capabilities) {\n            super.fillServerCapabilities(capabilities);\n            const changeNotifications = capabilities.workspace?.workspaceFolders?.changeNotifications;\n            this._notificationIsAutoRegistered = changeNotifications === true || typeof changeNotifications === 'string';\n        }\n        getWorkspaceFolders() {\n            return this.connection.sendRequest(vscode_languageserver_protocol_1.WorkspaceFoldersRequest.type);\n        }\n        get onDidChangeWorkspaceFolders() {\n            if (!this._onDidChangeWorkspaceFolders) {\n                throw new Error('Client doesn\\'t support sending workspace folder change events.');\n            }\n            if (!this._notificationIsAutoRegistered && !this._unregistration) {\n                this._unregistration = this.connection.client.register(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type);\n            }\n            return this._onDidChangeWorkspaceFolders.event;\n        }\n    };\n};\nexports.WorkspaceFoldersFeature = WorkspaceFoldersFeature;\n","/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CallHierarchyFeature = void 0;\nconst vscode_languageserver_protocol_1 = require(\"vscode-languageserver-protocol\");\nconst CallHierarchyFeature = (Base) => {\n    return class extends Base {\n        get callHierarchy() {\n            return {\n                onPrepare: (handler) => {\n                    return this.connection.onRequest(vscode_languageserver_protocol_1.CallHierarchyPrepareRequest.type, (params, cancel) => {\n                        return handler(params, cancel, this.attachWorkDoneProgress(params), undefined);\n                    });\n                },\n                onIncomingCalls: (handler) => {\n                    const type = vscode_languageserver_protocol_1.CallHierarchyIncomingCallsRequest.type;\n                    return this.connection.onRequest(type, (params, cancel) => {\n                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));\n                    });\n                },\n                onOutgoingCalls: (handler) => {\n                    const type = vscode_languageserver_protocol_1.CallHierarchyOutgoingCallsRequest.type;\n                    return this.connection.onRequest(type, (params, cancel) => {\n                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));\n                    });\n                }\n            };\n        }\n    };\n};\nexports.CallHierarchyFeature = CallHierarchyFeature;\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SemanticTokensBuilder = exports.SemanticTokensDiff = exports.SemanticTokensFeature = void 0;\nconst vscode_languageserver_protocol_1 = require(\"vscode-languageserver-protocol\");\nconst SemanticTokensFeature = (Base) => {\n    return class extends Base {\n        get semanticTokens() {\n            return {\n                refresh: () => {\n                    return this.connection.sendRequest(vscode_languageserver_protocol_1.SemanticTokensRefreshRequest.type);\n                },\n                on: (handler) => {\n                    const type = vscode_languageserver_protocol_1.SemanticTokensRequest.type;\n                    return this.connection.onRequest(type, (params, cancel) => {\n                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));\n                    });\n                },\n                onDelta: (handler) => {\n                    const type = vscode_languageserver_protocol_1.SemanticTokensDeltaRequest.type;\n                    return this.connection.onRequest(type, (params, cancel) => {\n                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));\n                    });\n                },\n                onRange: (handler) => {\n                    const type = vscode_languageserver_protocol_1.SemanticTokensRangeRequest.type;\n                    return this.connection.onRequest(type, (params, cancel) => {\n                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));\n                    });\n                }\n            };\n        }\n    };\n};\nexports.SemanticTokensFeature = SemanticTokensFeature;\nclass SemanticTokensDiff {\n    constructor(originalSequence, modifiedSequence) {\n        this.originalSequence = originalSequence;\n        this.modifiedSequence = modifiedSequence;\n    }\n    computeDiff() {\n        const originalLength = this.originalSequence.length;\n        const modifiedLength = this.modifiedSequence.length;\n        let startIndex = 0;\n        while (startIndex < modifiedLength && startIndex < originalLength && this.originalSequence[startIndex] === this.modifiedSequence[startIndex]) {\n            startIndex++;\n        }\n        if (startIndex < modifiedLength && startIndex < originalLength) {\n            let originalEndIndex = originalLength - 1;\n            let modifiedEndIndex = modifiedLength - 1;\n            while (originalEndIndex >= startIndex && modifiedEndIndex >= startIndex && this.originalSequence[originalEndIndex] === this.modifiedSequence[modifiedEndIndex]) {\n                originalEndIndex--;\n                modifiedEndIndex--;\n            }\n            // if one moved behind the start index move them forward again\n            if (originalEndIndex < startIndex || modifiedEndIndex < startIndex) {\n                originalEndIndex++;\n                modifiedEndIndex++;\n            }\n            const deleteCount = originalEndIndex - startIndex + 1;\n            const newData = this.modifiedSequence.slice(startIndex, modifiedEndIndex + 1);\n            // If we moved behind the start index we could have missed a simple delete.\n            if (newData.length === 1 && newData[0] === this.originalSequence[originalEndIndex]) {\n                return [\n                    { start: startIndex, deleteCount: deleteCount - 1 }\n                ];\n            }\n            else {\n                return [\n                    { start: startIndex, deleteCount, data: newData }\n                ];\n            }\n        }\n        else if (startIndex < modifiedLength) {\n            return [\n                { start: startIndex, deleteCount: 0, data: this.modifiedSequence.slice(startIndex) }\n            ];\n        }\n        else if (startIndex < originalLength) {\n            return [\n                { start: startIndex, deleteCount: originalLength - startIndex }\n            ];\n        }\n        else {\n            // The two arrays are the same.\n            return [];\n        }\n    }\n}\nexports.SemanticTokensDiff = SemanticTokensDiff;\nclass SemanticTokensBuilder {\n    constructor() {\n        this._prevData = undefined;\n        this.initialize();\n    }\n    initialize() {\n        this._id = Date.now();\n        this._prevLine = 0;\n        this._prevChar = 0;\n        this._data = [];\n        this._dataLen = 0;\n    }\n    push(line, char, length, tokenType, tokenModifiers) {\n        let pushLine = line;\n        let pushChar = char;\n        if (this._dataLen > 0) {\n            pushLine -= this._prevLine;\n            if (pushLine === 0) {\n                pushChar -= this._prevChar;\n            }\n        }\n        this._data[this._dataLen++] = pushLine;\n        this._data[this._dataLen++] = pushChar;\n        this._data[this._dataLen++] = length;\n        this._data[this._dataLen++] = tokenType;\n        this._data[this._dataLen++] = tokenModifiers;\n        this._prevLine = line;\n        this._prevChar = char;\n    }\n    get id() {\n        return this._id.toString();\n    }\n    previousResult(id) {\n        if (this.id === id) {\n            this._prevData = this._data;\n        }\n        this.initialize();\n    }\n    build() {\n        this._prevData = undefined;\n        return {\n            resultId: this.id,\n            data: this._data\n        };\n    }\n    canBuildEdits() {\n        return this._prevData !== undefined;\n    }\n    buildEdits() {\n        if (this._prevData !== undefined) {\n            return {\n                resultId: this.id,\n                edits: (new SemanticTokensDiff(this._prevData, this._data)).computeDiff()\n            };\n        }\n        else {\n            return this.build();\n        }\n    }\n}\nexports.SemanticTokensBuilder = SemanticTokensBuilder;\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ShowDocumentFeature = void 0;\nconst vscode_languageserver_protocol_1 = require(\"vscode-languageserver-protocol\");\nconst ShowDocumentFeature = (Base) => {\n    return class extends Base {\n        showDocument(params) {\n            return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowDocumentRequest.type, params);\n        }\n    };\n};\nexports.ShowDocumentFeature = ShowDocumentFeature;\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FileOperationsFeature = void 0;\nconst vscode_languageserver_protocol_1 = require(\"vscode-languageserver-protocol\");\nconst FileOperationsFeature = (Base) => {\n    return class extends Base {\n        onDidCreateFiles(handler) {\n            return this.connection.onNotification(vscode_languageserver_protocol_1.DidCreateFilesNotification.type, (params) => {\n                handler(params);\n            });\n        }\n        onDidRenameFiles(handler) {\n            return this.connection.onNotification(vscode_languageserver_protocol_1.DidRenameFilesNotification.type, (params) => {\n                handler(params);\n            });\n        }\n        onDidDeleteFiles(handler) {\n            return this.connection.onNotification(vscode_languageserver_protocol_1.DidDeleteFilesNotification.type, (params) => {\n                handler(params);\n            });\n        }\n        onWillCreateFiles(handler) {\n            return this.connection.onRequest(vscode_languageserver_protocol_1.WillCreateFilesRequest.type, (params, cancel) => {\n                return handler(params, cancel);\n            });\n        }\n        onWillRenameFiles(handler) {\n            return this.connection.onRequest(vscode_languageserver_protocol_1.WillRenameFilesRequest.type, (params, cancel) => {\n                return handler(params, cancel);\n            });\n        }\n        onWillDeleteFiles(handler) {\n            return this.connection.onRequest(vscode_languageserver_protocol_1.WillDeleteFilesRequest.type, (params, cancel) => {\n                return handler(params, cancel);\n            });\n        }\n    };\n};\nexports.FileOperationsFeature = FileOperationsFeature;\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LinkedEditingRangeFeature = void 0;\nconst vscode_languageserver_protocol_1 = require(\"vscode-languageserver-protocol\");\nconst LinkedEditingRangeFeature = (Base) => {\n    return class extends Base {\n        onLinkedEditingRange(handler) {\n            return this.connection.onRequest(vscode_languageserver_protocol_1.LinkedEditingRangeRequest.type, (params, cancel) => {\n                return handler(params, cancel, this.attachWorkDoneProgress(params), undefined);\n            });\n        }\n    };\n};\nexports.LinkedEditingRangeFeature = LinkedEditingRangeFeature;\n","/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TypeHierarchyFeature = void 0;\nconst vscode_languageserver_protocol_1 = require(\"vscode-languageserver-protocol\");\nconst TypeHierarchyFeature = (Base) => {\n    return class extends Base {\n        get typeHierarchy() {\n            return {\n                onPrepare: (handler) => {\n                    return this.connection.onRequest(vscode_languageserver_protocol_1.TypeHierarchyPrepareRequest.type, (params, cancel) => {\n                        return handler(params, cancel, this.attachWorkDoneProgress(params), undefined);\n                    });\n                },\n                onSupertypes: (handler) => {\n                    const type = vscode_languageserver_protocol_1.TypeHierarchySupertypesRequest.type;\n                    return this.connection.onRequest(type, (params, cancel) => {\n                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));\n                    });\n                },\n                onSubtypes: (handler) => {\n                    const type = vscode_languageserver_protocol_1.TypeHierarchySubtypesRequest.type;\n                    return this.connection.onRequest(type, (params, cancel) => {\n                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));\n                    });\n                }\n            };\n        }\n    };\n};\nexports.TypeHierarchyFeature = TypeHierarchyFeature;\n","/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.InlineValueFeature = void 0;\nconst vscode_languageserver_protocol_1 = require(\"vscode-languageserver-protocol\");\nconst InlineValueFeature = (Base) => {\n    return class extends Base {\n        get inlineValue() {\n            return {\n                refresh: () => {\n                    return this.connection.sendRequest(vscode_languageserver_protocol_1.InlineValueRefreshRequest.type);\n                },\n                on: (handler) => {\n                    return this.connection.onRequest(vscode_languageserver_protocol_1.InlineValueRequest.type, (params, cancel) => {\n                        return handler(params, cancel, this.attachWorkDoneProgress(params));\n                    });\n                }\n            };\n        }\n    };\n};\nexports.InlineValueFeature = InlineValueFeature;\n","/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FoldingRangeFeature = void 0;\nconst vscode_languageserver_protocol_1 = require(\"vscode-languageserver-protocol\");\nconst FoldingRangeFeature = (Base) => {\n    return class extends Base {\n        get foldingRange() {\n            return {\n                refresh: () => {\n                    return this.connection.sendRequest(vscode_languageserver_protocol_1.FoldingRangeRefreshRequest.type);\n                },\n                on: (handler) => {\n                    const type = vscode_languageserver_protocol_1.FoldingRangeRequest.type;\n                    return this.connection.onRequest(type, (params, cancel) => {\n                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));\n                    });\n                }\n            };\n        }\n    };\n};\nexports.FoldingRangeFeature = FoldingRangeFeature;\n","/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.InlayHintFeature = void 0;\nconst vscode_languageserver_protocol_1 = require(\"vscode-languageserver-protocol\");\nconst InlayHintFeature = (Base) => {\n    return class extends Base {\n        get inlayHint() {\n            return {\n                refresh: () => {\n                    return this.connection.sendRequest(vscode_languageserver_protocol_1.InlayHintRefreshRequest.type);\n                },\n                on: (handler) => {\n                    return this.connection.onRequest(vscode_languageserver_protocol_1.InlayHintRequest.type, (params, cancel) => {\n                        return handler(params, cancel, this.attachWorkDoneProgress(params));\n                    });\n                },\n                resolve: (handler) => {\n                    return this.connection.onRequest(vscode_languageserver_protocol_1.InlayHintResolveRequest.type, (params, cancel) => {\n                        return handler(params, cancel);\n                    });\n                }\n            };\n        }\n    };\n};\nexports.InlayHintFeature = InlayHintFeature;\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DiagnosticFeature = void 0;\nconst vscode_languageserver_protocol_1 = require(\"vscode-languageserver-protocol\");\nconst DiagnosticFeature = (Base) => {\n    return class extends Base {\n        get diagnostics() {\n            return {\n                refresh: () => {\n                    return this.connection.sendRequest(vscode_languageserver_protocol_1.DiagnosticRefreshRequest.type);\n                },\n                on: (handler) => {\n                    return this.connection.onRequest(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.type, (params, cancel) => {\n                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.partialResult, params));\n                    });\n                },\n                onWorkspace: (handler) => {\n                    return this.connection.onRequest(vscode_languageserver_protocol_1.WorkspaceDiagnosticRequest.type, (params, cancel) => {\n                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(vscode_languageserver_protocol_1.WorkspaceDiagnosticRequest.partialResult, params));\n                    });\n                }\n            };\n        }\n    };\n};\nexports.DiagnosticFeature = DiagnosticFeature;\n","/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NotebookDocuments = exports.NotebookSyncFeature = void 0;\nconst vscode_languageserver_protocol_1 = require(\"vscode-languageserver-protocol\");\nconst textDocuments_1 = require(\"./textDocuments\");\nconst NotebookSyncFeature = (Base) => {\n    return class extends Base {\n        get synchronization() {\n            return {\n                onDidOpenNotebookDocument: (handler) => {\n                    return this.connection.onNotification(vscode_languageserver_protocol_1.DidOpenNotebookDocumentNotification.type, (params) => {\n                        handler(params);\n                    });\n                },\n                onDidChangeNotebookDocument: (handler) => {\n                    return this.connection.onNotification(vscode_languageserver_protocol_1.DidChangeNotebookDocumentNotification.type, (params) => {\n                        handler(params);\n                    });\n                },\n                onDidSaveNotebookDocument: (handler) => {\n                    return this.connection.onNotification(vscode_languageserver_protocol_1.DidSaveNotebookDocumentNotification.type, (params) => {\n                        handler(params);\n                    });\n                },\n                onDidCloseNotebookDocument: (handler) => {\n                    return this.connection.onNotification(vscode_languageserver_protocol_1.DidCloseNotebookDocumentNotification.type, (params) => {\n                        handler(params);\n                    });\n                }\n            };\n        }\n    };\n};\nexports.NotebookSyncFeature = NotebookSyncFeature;\nclass CellTextDocumentConnection {\n    onDidOpenTextDocument(handler) {\n        this.openHandler = handler;\n        return vscode_languageserver_protocol_1.Disposable.create(() => { this.openHandler = undefined; });\n    }\n    openTextDocument(params) {\n        this.openHandler && this.openHandler(params);\n    }\n    onDidChangeTextDocument(handler) {\n        this.changeHandler = handler;\n        return vscode_languageserver_protocol_1.Disposable.create(() => { this.changeHandler = handler; });\n    }\n    changeTextDocument(params) {\n        this.changeHandler && this.changeHandler(params);\n    }\n    onDidCloseTextDocument(handler) {\n        this.closeHandler = handler;\n        return vscode_languageserver_protocol_1.Disposable.create(() => { this.closeHandler = undefined; });\n    }\n    closeTextDocument(params) {\n        this.closeHandler && this.closeHandler(params);\n    }\n    onWillSaveTextDocument() {\n        return CellTextDocumentConnection.NULL_DISPOSE;\n    }\n    onWillSaveTextDocumentWaitUntil() {\n        return CellTextDocumentConnection.NULL_DISPOSE;\n    }\n    onDidSaveTextDocument() {\n        return CellTextDocumentConnection.NULL_DISPOSE;\n    }\n}\nCellTextDocumentConnection.NULL_DISPOSE = Object.freeze({ dispose: () => { } });\nclass NotebookDocuments {\n    constructor(configurationOrTextDocuments) {\n        if (configurationOrTextDocuments instanceof textDocuments_1.TextDocuments) {\n            this._cellTextDocuments = configurationOrTextDocuments;\n        }\n        else {\n            this._cellTextDocuments = new textDocuments_1.TextDocuments(configurationOrTextDocuments);\n        }\n        this.notebookDocuments = new Map();\n        this.notebookCellMap = new Map();\n        this._onDidOpen = new vscode_languageserver_protocol_1.Emitter();\n        this._onDidChange = new vscode_languageserver_protocol_1.Emitter();\n        this._onDidSave = new vscode_languageserver_protocol_1.Emitter();\n        this._onDidClose = new vscode_languageserver_protocol_1.Emitter();\n    }\n    get cellTextDocuments() {\n        return this._cellTextDocuments;\n    }\n    getCellTextDocument(cell) {\n        return this._cellTextDocuments.get(cell.document);\n    }\n    getNotebookDocument(uri) {\n        return this.notebookDocuments.get(uri);\n    }\n    getNotebookCell(uri) {\n        const value = this.notebookCellMap.get(uri);\n        return value && value[0];\n    }\n    findNotebookDocumentForCell(cell) {\n        const key = typeof cell === 'string' ? cell : cell.document;\n        const value = this.notebookCellMap.get(key);\n        return value && value[1];\n    }\n    get onDidOpen() {\n        return this._onDidOpen.event;\n    }\n    get onDidSave() {\n        return this._onDidSave.event;\n    }\n    get onDidChange() {\n        return this._onDidChange.event;\n    }\n    get onDidClose() {\n        return this._onDidClose.event;\n    }\n    /**\n     * Listens for `low level` notification on the given connection to\n     * update the notebook documents managed by this instance.\n     *\n     * Please note that the connection only provides handlers not an event model. Therefore\n     * listening on a connection will overwrite the following handlers on a connection:\n     * `onDidOpenNotebookDocument`, `onDidChangeNotebookDocument`, `onDidSaveNotebookDocument`,\n     *  and `onDidCloseNotebookDocument`.\n     *\n     * @param connection The connection to listen on.\n     */\n    listen(connection) {\n        const cellTextDocumentConnection = new CellTextDocumentConnection();\n        const disposables = [];\n        disposables.push(this.cellTextDocuments.listen(cellTextDocumentConnection));\n        disposables.push(connection.notebooks.synchronization.onDidOpenNotebookDocument((params) => {\n            this.notebookDocuments.set(params.notebookDocument.uri, params.notebookDocument);\n            for (const cellTextDocument of params.cellTextDocuments) {\n                cellTextDocumentConnection.openTextDocument({ textDocument: cellTextDocument });\n            }\n            this.updateCellMap(params.notebookDocument);\n            this._onDidOpen.fire(params.notebookDocument);\n        }));\n        disposables.push(connection.notebooks.synchronization.onDidChangeNotebookDocument((params) => {\n            const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);\n            if (notebookDocument === undefined) {\n                return;\n            }\n            notebookDocument.version = params.notebookDocument.version;\n            const oldMetadata = notebookDocument.metadata;\n            let metadataChanged = false;\n            const change = params.change;\n            if (change.metadata !== undefined) {\n                metadataChanged = true;\n                notebookDocument.metadata = change.metadata;\n            }\n            const opened = [];\n            const closed = [];\n            const data = [];\n            const text = [];\n            if (change.cells !== undefined) {\n                const changedCells = change.cells;\n                if (changedCells.structure !== undefined) {\n                    const array = changedCells.structure.array;\n                    notebookDocument.cells.splice(array.start, array.deleteCount, ...(array.cells !== undefined ? array.cells : []));\n                    // Additional open cell text documents.\n                    if (changedCells.structure.didOpen !== undefined) {\n                        for (const open of changedCells.structure.didOpen) {\n                            cellTextDocumentConnection.openTextDocument({ textDocument: open });\n                            opened.push(open.uri);\n                        }\n                    }\n                    // Additional closed cell test documents.\n                    if (changedCells.structure.didClose) {\n                        for (const close of changedCells.structure.didClose) {\n                            cellTextDocumentConnection.closeTextDocument({ textDocument: close });\n                            closed.push(close.uri);\n                        }\n                    }\n                }\n                if (changedCells.data !== undefined) {\n                    const cellUpdates = new Map(changedCells.data.map(cell => [cell.document, cell]));\n                    for (let i = 0; i <= notebookDocument.cells.length; i++) {\n                        const change = cellUpdates.get(notebookDocument.cells[i].document);\n                        if (change !== undefined) {\n                            const old = notebookDocument.cells.splice(i, 1, change);\n                            data.push({ old: old[0], new: change });\n                            cellUpdates.delete(change.document);\n                            if (cellUpdates.size === 0) {\n                                break;\n                            }\n                        }\n                    }\n                }\n                if (changedCells.textContent !== undefined) {\n                    for (const cellTextDocument of changedCells.textContent) {\n                        cellTextDocumentConnection.changeTextDocument({ textDocument: cellTextDocument.document, contentChanges: cellTextDocument.changes });\n                        text.push(cellTextDocument.document.uri);\n                    }\n                }\n            }\n            // Update internal data structure.\n            this.updateCellMap(notebookDocument);\n            const changeEvent = { notebookDocument };\n            if (metadataChanged) {\n                changeEvent.metadata = { old: oldMetadata, new: notebookDocument.metadata };\n            }\n            const added = [];\n            for (const open of opened) {\n                added.push(this.getNotebookCell(open));\n            }\n            const removed = [];\n            for (const close of closed) {\n                removed.push(this.getNotebookCell(close));\n            }\n            const textContent = [];\n            for (const change of text) {\n                textContent.push(this.getNotebookCell(change));\n            }\n            if (added.length > 0 || removed.length > 0 || data.length > 0 || textContent.length > 0) {\n                changeEvent.cells = { added, removed, changed: { data, textContent } };\n            }\n            if (changeEvent.metadata !== undefined || changeEvent.cells !== undefined) {\n                this._onDidChange.fire(changeEvent);\n            }\n        }));\n        disposables.push(connection.notebooks.synchronization.onDidSaveNotebookDocument((params) => {\n            const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);\n            if (notebookDocument === undefined) {\n                return;\n            }\n            this._onDidSave.fire(notebookDocument);\n        }));\n        disposables.push(connection.notebooks.synchronization.onDidCloseNotebookDocument((params) => {\n            const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);\n            if (notebookDocument === undefined) {\n                return;\n            }\n            this._onDidClose.fire(notebookDocument);\n            for (const cellTextDocument of params.cellTextDocuments) {\n                cellTextDocumentConnection.closeTextDocument({ textDocument: cellTextDocument });\n            }\n            this.notebookDocuments.delete(params.notebookDocument.uri);\n            for (const cell of notebookDocument.cells) {\n                this.notebookCellMap.delete(cell.document);\n            }\n        }));\n        return vscode_languageserver_protocol_1.Disposable.create(() => { disposables.forEach(disposable => disposable.dispose()); });\n    }\n    updateCellMap(notebookDocument) {\n        for (const cell of notebookDocument.cells) {\n            this.notebookCellMap.set(cell.document, [cell, notebookDocument]);\n        }\n    }\n}\nexports.NotebookDocuments = NotebookDocuments;\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TextDocuments = void 0;\nconst vscode_languageserver_protocol_1 = require(\"vscode-languageserver-protocol\");\n/**\n * A manager for simple text documents. The manager requires at a minimum that\n * the server registered for the following text document sync events in the\n * initialize handler or via dynamic registration:\n *\n * - open and close events.\n * - change events.\n *\n * Registering for save and will save events is optional.\n */\nclass TextDocuments {\n    /**\n     * Create a new text document manager.\n     */\n    constructor(configuration) {\n        this._configuration = configuration;\n        this._syncedDocuments = new Map();\n        this._onDidChangeContent = new vscode_languageserver_protocol_1.Emitter();\n        this._onDidOpen = new vscode_languageserver_protocol_1.Emitter();\n        this._onDidClose = new vscode_languageserver_protocol_1.Emitter();\n        this._onDidSave = new vscode_languageserver_protocol_1.Emitter();\n        this._onWillSave = new vscode_languageserver_protocol_1.Emitter();\n    }\n    /**\n     * An event that fires when a text document managed by this manager\n     * has been opened.\n     */\n    get onDidOpen() {\n        return this._onDidOpen.event;\n    }\n    /**\n     * An event that fires when a text document managed by this manager\n     * has been opened or the content changes.\n     */\n    get onDidChangeContent() {\n        return this._onDidChangeContent.event;\n    }\n    /**\n     * An event that fires when a text document managed by this manager\n     * will be saved.\n     */\n    get onWillSave() {\n        return this._onWillSave.event;\n    }\n    /**\n     * Sets a handler that will be called if a participant wants to provide\n     * edits during a text document save.\n     */\n    onWillSaveWaitUntil(handler) {\n        this._willSaveWaitUntil = handler;\n    }\n    /**\n     * An event that fires when a text document managed by this manager\n     * has been saved.\n     */\n    get onDidSave() {\n        return this._onDidSave.event;\n    }\n    /**\n     * An event that fires when a text document managed by this manager\n     * has been closed.\n     */\n    get onDidClose() {\n        return this._onDidClose.event;\n    }\n    /**\n     * Returns the document for the given URI. Returns undefined if\n     * the document is not managed by this instance.\n     *\n     * @param uri The text document's URI to retrieve.\n     * @return the text document or `undefined`.\n     */\n    get(uri) {\n        return this._syncedDocuments.get(uri);\n    }\n    /**\n     * Returns all text documents managed by this instance.\n     *\n     * @return all text documents.\n     */\n    all() {\n        return Array.from(this._syncedDocuments.values());\n    }\n    /**\n     * Returns the URIs of all text documents managed by this instance.\n     *\n     * @return the URI's of all text documents.\n     */\n    keys() {\n        return Array.from(this._syncedDocuments.keys());\n    }\n    /**\n     * Listens for `low level` notification on the given connection to\n     * update the text documents managed by this instance.\n     *\n     * Please note that the connection only provides handlers not an event model. Therefore\n     * listening on a connection will overwrite the following handlers on a connection:\n     * `onDidOpenTextDocument`, `onDidChangeTextDocument`, `onDidCloseTextDocument`,\n     * `onWillSaveTextDocument`, `onWillSaveTextDocumentWaitUntil` and `onDidSaveTextDocument`.\n     *\n     * Use the corresponding events on the TextDocuments instance instead.\n     *\n     * @param connection The connection to listen on.\n     */\n    listen(connection) {\n        connection.__textDocumentSync = vscode_languageserver_protocol_1.TextDocumentSyncKind.Incremental;\n        const disposables = [];\n        disposables.push(connection.onDidOpenTextDocument((event) => {\n            const td = event.textDocument;\n            const document = this._configuration.create(td.uri, td.languageId, td.version, td.text);\n            this._syncedDocuments.set(td.uri, document);\n            const toFire = Object.freeze({ document });\n            this._onDidOpen.fire(toFire);\n            this._onDidChangeContent.fire(toFire);\n        }));\n        disposables.push(connection.onDidChangeTextDocument((event) => {\n            const td = event.textDocument;\n            const changes = event.contentChanges;\n            if (changes.length === 0) {\n                return;\n            }\n            const { version } = td;\n            if (version === null || version === undefined) {\n                throw new Error(`Received document change event for ${td.uri} without valid version identifier`);\n            }\n            let syncedDocument = this._syncedDocuments.get(td.uri);\n            if (syncedDocument !== undefined) {\n                syncedDocument = this._configuration.update(syncedDocument, changes, version);\n                this._syncedDocuments.set(td.uri, syncedDocument);\n                this._onDidChangeContent.fire(Object.freeze({ document: syncedDocument }));\n            }\n        }));\n        disposables.push(connection.onDidCloseTextDocument((event) => {\n            let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);\n            if (syncedDocument !== undefined) {\n                this._syncedDocuments.delete(event.textDocument.uri);\n                this._onDidClose.fire(Object.freeze({ document: syncedDocument }));\n            }\n        }));\n        disposables.push(connection.onWillSaveTextDocument((event) => {\n            let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);\n            if (syncedDocument !== undefined) {\n                this._onWillSave.fire(Object.freeze({ document: syncedDocument, reason: event.reason }));\n            }\n        }));\n        disposables.push(connection.onWillSaveTextDocumentWaitUntil((event, token) => {\n            let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);\n            if (syncedDocument !== undefined && this._willSaveWaitUntil) {\n                return this._willSaveWaitUntil(Object.freeze({ document: syncedDocument, reason: event.reason }), token);\n            }\n            else {\n                return [];\n            }\n        }));\n        disposables.push(connection.onDidSaveTextDocument((event) => {\n            let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);\n            if (syncedDocument !== undefined) {\n                this._onDidSave.fire(Object.freeze({ document: syncedDocument }));\n            }\n        }));\n        return vscode_languageserver_protocol_1.Disposable.create(() => { disposables.forEach(disposable => disposable.dispose()); });\n    }\n}\nexports.TextDocuments = TextDocuments;\n","/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MonikerFeature = void 0;\nconst vscode_languageserver_protocol_1 = require(\"vscode-languageserver-protocol\");\nconst MonikerFeature = (Base) => {\n    return class extends Base {\n        get moniker() {\n            return {\n                on: (handler) => {\n                    const type = vscode_languageserver_protocol_1.MonikerRequest.type;\n                    return this.connection.onRequest(type, (params, cancel) => {\n                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));\n                    });\n                },\n            };\n        }\n    };\n};\nexports.MonikerFeature = MonikerFeature;\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.resolveModulePath = exports.FileSystem = exports.resolveGlobalYarnPath = exports.resolveGlobalNodePath = exports.resolve = exports.uriToFilePath = void 0;\nconst url = require(\"url\");\nconst path = require(\"path\");\nconst fs = require(\"fs\");\nconst child_process_1 = require(\"child_process\");\n/**\n * @deprecated Use the `vscode-uri` npm module which provides a more\n * complete implementation of handling VS Code URIs.\n */\nfunction uriToFilePath(uri) {\n    let parsed = url.parse(uri);\n    if (parsed.protocol !== 'file:' || !parsed.path) {\n        return undefined;\n    }\n    let segments = parsed.path.split('/');\n    for (var i = 0, len = segments.length; i < len; i++) {\n        segments[i] = decodeURIComponent(segments[i]);\n    }\n    if (process.platform === 'win32' && segments.length > 1) {\n        let first = segments[0];\n        let second = segments[1];\n        // Do we have a drive letter and we started with a / which is the\n        // case if the first segement is empty (see split above)\n        if (first.length === 0 && second.length > 1 && second[1] === ':') {\n            // Remove first slash\n            segments.shift();\n        }\n    }\n    return path.normalize(segments.join('/'));\n}\nexports.uriToFilePath = uriToFilePath;\nfunction isWindows() {\n    return process.platform === 'win32';\n}\nfunction resolve(moduleName, nodePath, cwd, tracer) {\n    const nodePathKey = 'NODE_PATH';\n    const app = [\n        'var p = process;',\n        'p.on(\\'message\\',function(m){',\n        'if(m.c===\\'e\\'){',\n        'p.exit(0);',\n        '}',\n        'else if(m.c===\\'rs\\'){',\n        'try{',\n        'var r=require.resolve(m.a);',\n        'p.send({c:\\'r\\',s:true,r:r});',\n        '}',\n        'catch(err){',\n        'p.send({c:\\'r\\',s:false});',\n        '}',\n        '}',\n        '});'\n    ].join('');\n    return new Promise((resolve, reject) => {\n        let env = process.env;\n        let newEnv = Object.create(null);\n        Object.keys(env).forEach(key => newEnv[key] = env[key]);\n        if (nodePath && fs.existsSync(nodePath) /* see issue 545 */) {\n            if (newEnv[nodePathKey]) {\n                newEnv[nodePathKey] = nodePath + path.delimiter + newEnv[nodePathKey];\n            }\n            else {\n                newEnv[nodePathKey] = nodePath;\n            }\n            if (tracer) {\n                tracer(`NODE_PATH value is: ${newEnv[nodePathKey]}`);\n            }\n        }\n        newEnv['ELECTRON_RUN_AS_NODE'] = '1';\n        try {\n            let cp = (0, child_process_1.fork)('', [], {\n                cwd: cwd,\n                env: newEnv,\n                execArgv: ['-e', app]\n            });\n            if (cp.pid === void 0) {\n                reject(new Error(`Starting process to resolve node module  ${moduleName} failed`));\n                return;\n            }\n            cp.on('error', (error) => {\n                reject(error);\n            });\n            cp.on('message', (message) => {\n                if (message.c === 'r') {\n                    cp.send({ c: 'e' });\n                    if (message.s) {\n                        resolve(message.r);\n                    }\n                    else {\n                        reject(new Error(`Failed to resolve module: ${moduleName}`));\n                    }\n                }\n            });\n            let message = {\n                c: 'rs',\n                a: moduleName\n            };\n            cp.send(message);\n        }\n        catch (error) {\n            reject(error);\n        }\n    });\n}\nexports.resolve = resolve;\n/**\n * Resolve the global npm package path.\n * @deprecated Since this depends on the used package manager and their version the best is that servers\n * implement this themselves since they know best what kind of package managers to support.\n * @param tracer the tracer to use\n */\nfunction resolveGlobalNodePath(tracer) {\n    let npmCommand = 'npm';\n    const env = Object.create(null);\n    Object.keys(process.env).forEach(key => env[key] = process.env[key]);\n    env['NO_UPDATE_NOTIFIER'] = 'true';\n    const options = {\n        encoding: 'utf8',\n        env\n    };\n    if (isWindows()) {\n        npmCommand = 'npm.cmd';\n        options.shell = true;\n    }\n    let handler = () => { };\n    try {\n        process.on('SIGPIPE', handler);\n        let stdout = (0, child_process_1.spawnSync)(npmCommand, ['config', 'get', 'prefix'], options).stdout;\n        if (!stdout) {\n            if (tracer) {\n                tracer(`'npm config get prefix' didn't return a value.`);\n            }\n            return undefined;\n        }\n        let prefix = stdout.trim();\n        if (tracer) {\n            tracer(`'npm config get prefix' value is: ${prefix}`);\n        }\n        if (prefix.length > 0) {\n            if (isWindows()) {\n                return path.join(prefix, 'node_modules');\n            }\n            else {\n                return path.join(prefix, 'lib', 'node_modules');\n            }\n        }\n        return undefined;\n    }\n    catch (err) {\n        return undefined;\n    }\n    finally {\n        process.removeListener('SIGPIPE', handler);\n    }\n}\nexports.resolveGlobalNodePath = resolveGlobalNodePath;\n/*\n * Resolve the global yarn pakage path.\n * @deprecated Since this depends on the used package manager and their version the best is that servers\n * implement this themselves since they know best what kind of package managers to support.\n * @param tracer the tracer to use\n */\nfunction resolveGlobalYarnPath(tracer) {\n    let yarnCommand = 'yarn';\n    let options = {\n        encoding: 'utf8'\n    };\n    if (isWindows()) {\n        yarnCommand = 'yarn.cmd';\n        options.shell = true;\n    }\n    let handler = () => { };\n    try {\n        process.on('SIGPIPE', handler);\n        let results = (0, child_process_1.spawnSync)(yarnCommand, ['global', 'dir', '--json'], options);\n        let stdout = results.stdout;\n        if (!stdout) {\n            if (tracer) {\n                tracer(`'yarn global dir' didn't return a value.`);\n                if (results.stderr) {\n                    tracer(results.stderr);\n                }\n            }\n            return undefined;\n        }\n        let lines = stdout.trim().split(/\\r?\\n/);\n        for (let line of lines) {\n            try {\n                let yarn = JSON.parse(line);\n                if (yarn.type === 'log') {\n                    return path.join(yarn.data, 'node_modules');\n                }\n            }\n            catch (e) {\n                // Do nothing. Ignore the line\n            }\n        }\n        return undefined;\n    }\n    catch (err) {\n        return undefined;\n    }\n    finally {\n        process.removeListener('SIGPIPE', handler);\n    }\n}\nexports.resolveGlobalYarnPath = resolveGlobalYarnPath;\nvar FileSystem;\n(function (FileSystem) {\n    let _isCaseSensitive = undefined;\n    function isCaseSensitive() {\n        if (_isCaseSensitive !== void 0) {\n            return _isCaseSensitive;\n        }\n        if (process.platform === 'win32') {\n            _isCaseSensitive = false;\n        }\n        else {\n            // convert current file name to upper case / lower case and check if file exists\n            // (guards against cases when name is already all uppercase or lowercase)\n            _isCaseSensitive = !fs.existsSync(__filename.toUpperCase()) || !fs.existsSync(__filename.toLowerCase());\n        }\n        return _isCaseSensitive;\n    }\n    FileSystem.isCaseSensitive = isCaseSensitive;\n    function isParent(parent, child) {\n        if (isCaseSensitive()) {\n            return path.normalize(child).indexOf(path.normalize(parent)) === 0;\n        }\n        else {\n            return path.normalize(child).toLowerCase().indexOf(path.normalize(parent).toLowerCase()) === 0;\n        }\n    }\n    FileSystem.isParent = isParent;\n})(FileSystem || (exports.FileSystem = FileSystem = {}));\nfunction resolveModulePath(workspaceRoot, moduleName, nodePath, tracer) {\n    if (nodePath) {\n        if (!path.isAbsolute(nodePath)) {\n            nodePath = path.join(workspaceRoot, nodePath);\n        }\n        return resolve(moduleName, nodePath, nodePath, tracer).then((value) => {\n            if (FileSystem.isParent(nodePath, value)) {\n                return value;\n            }\n            else {\n                return Promise.reject(new Error(`Failed to load ${moduleName} from node path location.`));\n            }\n        }).then(undefined, (_error) => {\n            return resolve(moduleName, resolveGlobalNodePath(tracer), workspaceRoot, tracer);\n        });\n    }\n    else {\n        return resolve(moduleName, resolveGlobalNodePath(tracer), workspaceRoot, tracer);\n    }\n}\nexports.resolveModulePath = resolveModulePath;\n","module.exports = require(\"url\");","module.exports = require(\"fs\");","module.exports = require(\"child_process\");","/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ----------------------------------------------------------------------------------------- */\n'use strict';\n\nmodule.exports = require('./lib/node/main');","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ProposedFeatures = exports.NotebookDocuments = exports.TextDocuments = exports.SemanticTokensBuilder = void 0;\nconst semanticTokens_1 = require(\"./semanticTokens\");\nObject.defineProperty(exports, \"SemanticTokensBuilder\", { enumerable: true, get: function () { return semanticTokens_1.SemanticTokensBuilder; } });\nconst ic = require(\"./inlineCompletion.proposed\");\n__exportStar(require(\"vscode-languageserver-protocol/\"), exports);\nconst textDocuments_1 = require(\"./textDocuments\");\nObject.defineProperty(exports, \"TextDocuments\", { enumerable: true, get: function () { return textDocuments_1.TextDocuments; } });\nconst notebook_1 = require(\"./notebook\");\nObject.defineProperty(exports, \"NotebookDocuments\", { enumerable: true, get: function () { return notebook_1.NotebookDocuments; } });\n__exportStar(require(\"./server\"), exports);\nvar ProposedFeatures;\n(function (ProposedFeatures) {\n    ProposedFeatures.all = {\n        __brand: 'features',\n        languages: ic.InlineCompletionFeature\n    };\n})(ProposedFeatures || (exports.ProposedFeatures = ProposedFeatures = {}));\n","/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.InlineCompletionFeature = void 0;\nconst vscode_languageserver_protocol_1 = require(\"vscode-languageserver-protocol\");\nconst InlineCompletionFeature = (Base) => {\n    return class extends Base {\n        get inlineCompletion() {\n            return {\n                on: (handler) => {\n                    return this.connection.onRequest(vscode_languageserver_protocol_1.InlineCompletionRequest.type, (params, cancel) => {\n                        return handler(params, cancel, this.attachWorkDoneProgress(params));\n                    });\n                }\n            };\n        }\n    };\n};\nexports.InlineCompletionFeature = InlineCompletionFeature;\n","/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n'use strict';\nclass FullTextDocument {\n    constructor(uri, languageId, version, content) {\n        this._uri = uri;\n        this._languageId = languageId;\n        this._version = version;\n        this._content = content;\n        this._lineOffsets = undefined;\n    }\n    get uri() {\n        return this._uri;\n    }\n    get languageId() {\n        return this._languageId;\n    }\n    get version() {\n        return this._version;\n    }\n    getText(range) {\n        if (range) {\n            const start = this.offsetAt(range.start);\n            const end = this.offsetAt(range.end);\n            return this._content.substring(start, end);\n        }\n        return this._content;\n    }\n    update(changes, version) {\n        for (const change of changes) {\n            if (FullTextDocument.isIncremental(change)) {\n                // makes sure start is before end\n                const range = getWellformedRange(change.range);\n                // update content\n                const startOffset = this.offsetAt(range.start);\n                const endOffset = this.offsetAt(range.end);\n                this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);\n                // update the offsets\n                const startLine = Math.max(range.start.line, 0);\n                const endLine = Math.max(range.end.line, 0);\n                let lineOffsets = this._lineOffsets;\n                const addedLineOffsets = computeLineOffsets(change.text, false, startOffset);\n                if (endLine - startLine === addedLineOffsets.length) {\n                    for (let i = 0, len = addedLineOffsets.length; i < len; i++) {\n                        lineOffsets[i + startLine + 1] = addedLineOffsets[i];\n                    }\n                }\n                else {\n                    if (addedLineOffsets.length < 10000) {\n                        lineOffsets.splice(startLine + 1, endLine - startLine, ...addedLineOffsets);\n                    }\n                    else { // avoid too many arguments for splice\n                        this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));\n                    }\n                }\n                const diff = change.text.length - (endOffset - startOffset);\n                if (diff !== 0) {\n                    for (let i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++) {\n                        lineOffsets[i] = lineOffsets[i] + diff;\n                    }\n                }\n            }\n            else if (FullTextDocument.isFull(change)) {\n                this._content = change.text;\n                this._lineOffsets = undefined;\n            }\n            else {\n                throw new Error('Unknown change event received');\n            }\n        }\n        this._version = version;\n    }\n    getLineOffsets() {\n        if (this._lineOffsets === undefined) {\n            this._lineOffsets = computeLineOffsets(this._content, true);\n        }\n        return this._lineOffsets;\n    }\n    positionAt(offset) {\n        offset = Math.max(Math.min(offset, this._content.length), 0);\n        const lineOffsets = this.getLineOffsets();\n        let low = 0, high = lineOffsets.length;\n        if (high === 0) {\n            return { line: 0, character: offset };\n        }\n        while (low < high) {\n            const mid = Math.floor((low + high) / 2);\n            if (lineOffsets[mid] > offset) {\n                high = mid;\n            }\n            else {\n                low = mid + 1;\n            }\n        }\n        // low is the least x for which the line offset is larger than the current offset\n        // or array.length if no line offset is larger than the current offset\n        const line = low - 1;\n        offset = this.ensureBeforeEOL(offset, lineOffsets[line]);\n        return { line, character: offset - lineOffsets[line] };\n    }\n    offsetAt(position) {\n        const lineOffsets = this.getLineOffsets();\n        if (position.line >= lineOffsets.length) {\n            return this._content.length;\n        }\n        else if (position.line < 0) {\n            return 0;\n        }\n        const lineOffset = lineOffsets[position.line];\n        if (position.character <= 0) {\n            return lineOffset;\n        }\n        const nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;\n        const offset = Math.min(lineOffset + position.character, nextLineOffset);\n        return this.ensureBeforeEOL(offset, lineOffset);\n    }\n    ensureBeforeEOL(offset, lineOffset) {\n        while (offset > lineOffset && isEOL(this._content.charCodeAt(offset - 1))) {\n            offset--;\n        }\n        return offset;\n    }\n    get lineCount() {\n        return this.getLineOffsets().length;\n    }\n    static isIncremental(event) {\n        const candidate = event;\n        return candidate !== undefined && candidate !== null &&\n            typeof candidate.text === 'string' && candidate.range !== undefined &&\n            (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');\n    }\n    static isFull(event) {\n        const candidate = event;\n        return candidate !== undefined && candidate !== null &&\n            typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;\n    }\n}\nexport var TextDocument;\n(function (TextDocument) {\n    /**\n     * Creates a new text document.\n     *\n     * @param uri The document's uri.\n     * @param languageId  The document's language Id.\n     * @param version The document's initial version number.\n     * @param content The document's content.\n     */\n    function create(uri, languageId, version, content) {\n        return new FullTextDocument(uri, languageId, version, content);\n    }\n    TextDocument.create = create;\n    /**\n     * Updates a TextDocument by modifying its content.\n     *\n     * @param document the document to update. Only documents created by TextDocument.create are valid inputs.\n     * @param changes the changes to apply to the document.\n     * @param version the changes version for the document.\n     * @returns The updated TextDocument. Note: That's the same document instance passed in as first parameter.\n     *\n     */\n    function update(document, changes, version) {\n        if (document instanceof FullTextDocument) {\n            document.update(changes, version);\n            return document;\n        }\n        else {\n            throw new Error('TextDocument.update: document must be created by TextDocument.create');\n        }\n    }\n    TextDocument.update = update;\n    function applyEdits(document, edits) {\n        const text = document.getText();\n        const sortedEdits = mergeSort(edits.map(getWellformedEdit), (a, b) => {\n            const diff = a.range.start.line - b.range.start.line;\n            if (diff === 0) {\n                return a.range.start.character - b.range.start.character;\n            }\n            return diff;\n        });\n        let lastModifiedOffset = 0;\n        const spans = [];\n        for (const e of sortedEdits) {\n            const startOffset = document.offsetAt(e.range.start);\n            if (startOffset < lastModifiedOffset) {\n                throw new Error('Overlapping edit');\n            }\n            else if (startOffset > lastModifiedOffset) {\n                spans.push(text.substring(lastModifiedOffset, startOffset));\n            }\n            if (e.newText.length) {\n                spans.push(e.newText);\n            }\n            lastModifiedOffset = document.offsetAt(e.range.end);\n        }\n        spans.push(text.substr(lastModifiedOffset));\n        return spans.join('');\n    }\n    TextDocument.applyEdits = applyEdits;\n})(TextDocument || (TextDocument = {}));\nfunction mergeSort(data, compare) {\n    if (data.length <= 1) {\n        // sorted\n        return data;\n    }\n    const p = (data.length / 2) | 0;\n    const left = data.slice(0, p);\n    const right = data.slice(p);\n    mergeSort(left, compare);\n    mergeSort(right, compare);\n    let leftIdx = 0;\n    let rightIdx = 0;\n    let i = 0;\n    while (leftIdx < left.length && rightIdx < right.length) {\n        const ret = compare(left[leftIdx], right[rightIdx]);\n        if (ret <= 0) {\n            // smaller_equal -> take left to preserve order\n            data[i++] = left[leftIdx++];\n        }\n        else {\n            // greater -> take right\n            data[i++] = right[rightIdx++];\n        }\n    }\n    while (leftIdx < left.length) {\n        data[i++] = left[leftIdx++];\n    }\n    while (rightIdx < right.length) {\n        data[i++] = right[rightIdx++];\n    }\n    return data;\n}\nfunction computeLineOffsets(text, isAtLineStart, textOffset = 0) {\n    const result = isAtLineStart ? [textOffset] : [];\n    for (let i = 0; i < text.length; i++) {\n        const ch = text.charCodeAt(i);\n        if (isEOL(ch)) {\n            if (ch === 13 /* CharCode.CarriageReturn */ && i + 1 < text.length && text.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */) {\n                i++;\n            }\n            result.push(textOffset + i + 1);\n        }\n    }\n    return result;\n}\nfunction isEOL(char) {\n    return char === 13 /* CharCode.CarriageReturn */ || char === 10 /* CharCode.LineFeed */;\n}\nfunction getWellformedRange(range) {\n    const start = range.start;\n    const end = range.end;\n    if (start.line > end.line || (start.line === end.line && start.character > end.character)) {\n        return { start: end, end: start };\n    }\n    return range;\n}\nfunction getWellformedEdit(textEdit) {\n    const range = getWellformedRange(textEdit.range);\n    if (range !== textEdit.range) {\n        return { newText: textEdit.newText, range };\n    }\n    return textEdit;\n}\n","import { Diagnostic, Range } from \"vscode-languageserver-protocol\";\nimport { TextDocumentChangeEvent } from \"vscode-languageserver\";\nimport { DocumentUri, TextDocument } from \"vscode-languageserver-textdocument\";\nimport { ESPHomeConnection } from \"./connection\";\nimport {\n  MessageTypes,\n  MESSAGE_FILE_RESPONSE,\n  MESSAGE_READ_FILE,\n  MESSAGE_RESULT,\n  ValidationError as ESPHomeValidationError,\n  YamlValidationError,\n} from \"./types\";\nimport { FileAccessor } from \"./file-accessor\";\nimport * as vscodeUri from \"vscode-uri\";\nimport path = require(\"path\");\n\nexport class Validation {\n  lastRequest!: Date;\n  constructor(\n    private fileAccessor: FileAccessor,\n    private connection: ESPHomeConnection,\n    private sendDiagnostics: (\n      fileUri: string,\n      diagnostics: Diagnostic[],\n    ) => void,\n  ) {\n    connection.onResponse((m) => this.handleESPHomeMessage(m));\n  }\n\n  private diagnosticCollection: Map<string, Diagnostic[]> = new Map<\n    string,\n    Diagnostic[]\n  >();\n\n  private addError(uri: DocumentUri, range: Range, message: string) {\n    //console.log(`diag error: ${message} to ${uri}`);\n    let diagnostics = this.diagnosticCollection.get(uri) || [];\n    const diagnostic = Diagnostic.create(range, message);\n    diagnostics = [...diagnostics, diagnostic];\n    this.diagnosticCollection.set(uri, diagnostics);\n  }\n\n  private addIncludeFile(file: string, included: string) {\n    var includes = this.includedFiles[file] || [];\n    if (includes.indexOf(included) === -1) {\n      includes.push(included);\n      this.includedFiles[file] = includes;\n    }\n  }\n\n  private handleEsphomeError(error: ESPHomeValidationError) {\n    const message = error.message;\n\n    if (error.range !== null) {\n      this.addError(\n        this.getUriStringForValidationPath(error.range.document),\n        Range.create(\n          error.range.start_line,\n          error.range.start_col,\n          error.range.end_line,\n          error.range.end_col,\n        ),\n        message,\n      );\n    } else {\n      this.addError(this.validating_uri!, Range.create(1, 0, 1, 2), message);\n    }\n  }\n\n  private handleYamlError(error: YamlValidationError) {\n    // expect pair of lines with\n    // - error message\n    // - location\n    let message = \"\";\n    const error_lines = error.message.split(\"\\n\");\n    if (error_lines.length % 2 != 0) {\n      if (this.validating_uri)\n        this.addError(\n          this.validating_uri,\n          Range.create(1, 0, 1, 1),\n          error.message,\n        );\n      else console.error(\"unknown: \" + error.message);\n      return;\n    }\n\n    error_lines.forEach((line: string) => {\n      if (message === \"\") {\n        message = line;\n      } else {\n        let location = line\n          .trimStart()\n          .match(/in \"([^\"]*)\", line (\\d*), column (\\d*)/);\n        if (location) {\n          const uri = this.getUriStringForValidationPath(location[1]);\n          const line_number = parseInt(location[2]) - 1;\n          const col_number = parseInt(location[3]) - 1;\n          const range = Range.create(\n            line_number,\n            col_number,\n            line_number,\n            col_number + 1,\n          );\n\n          this.addError(uri, range, message);\n        } else {\n          if (this.validating_uri)\n            this.addError(\n              this.validating_uri,\n              Range.create(1, 0, 1, 1),\n              message + \" \" + line,\n            );\n          else console.error(\"unknown: \" + error.message);\n        }\n        message = \"\";\n      }\n    });\n  }\n\n  private getUriStringForValidationPath(file_path: string) {\n    const absolute_path = path.isAbsolute(file_path)\n      ? file_path\n      : this.fileAccessor.getRelativePath(\n          vscodeUri.URI.parse(this.validating_uri!).fsPath,\n          file_path,\n        );\n    const uri_string = vscodeUri.URI.file(absolute_path).toString();\n    return uri_string;\n  }\n\n  private async handleESPHomeMessage(msg: MessageTypes): Promise<void> {\n    try {\n      switch (msg.type) {\n        case MESSAGE_READ_FILE: {\n          const uri = this.getUriStringForValidationPath(msg.path);\n\n          if (uri !== this.validating_uri) {\n            // Track this as an included file, so when the user edits this file\n            // we know it's and included file and a validation on the master yaml should be executed instead\n            this.addIncludeFile(this.validating_uri!, uri);\n            // This file is validated indirectly, if it had errors then they must be cleared\n            this.diagnosticCollection.set(uri, []);\n          }\n          try {\n            const docText = await this.fileAccessor.getFileContents(uri);\n            this.connection.sendMessage({\n              type: MESSAGE_FILE_RESPONSE,\n              content: docText,\n            });\n          } catch (e) {\n            // if this is trying to get secrets.yaml from a directory other than validating_uri directory,\n            // it is expected that when the file does not exists it will try to load a secrets.yaml from\n            // the same folder where validating_uri is. See https://github.com/esphome/esphome/pull/5604\n            if (\n              vscodeUri.Utils.basename(vscodeUri.URI.parse(uri)) ==\n                \"secrets.yaml\" &&\n              this.validating_uri &&\n              vscodeUri.Utils.dirname(vscodeUri.URI.parse(uri)) !=\n                vscodeUri.Utils.dirname(\n                  vscodeUri.URI.parse(this.validating_uri),\n                )\n            )\n              return this.handleESPHomeMessage({\n                type: MESSAGE_READ_FILE,\n                path: vscodeUri.Utils.joinPath(\n                  vscodeUri.Utils.dirname(\n                    vscodeUri.URI.parse(this.validating_uri),\n                  ),\n                  \"secrets.yaml\",\n                ).fsPath,\n              });\n\n            // general case: won't validate as an include file is missing\n            this.addError(\n              this.validating_uri!,\n              Range.create(0, 0, 1, 0),\n              `Could not open '${msg.path}': ${e}`,\n            );\n            this.connection.sendMessage({\n              type: MESSAGE_FILE_RESPONSE,\n              content: \"\",\n            });\n          }\n\n          break;\n        }\n        case MESSAGE_RESULT: {\n          msg.validation_errors.forEach((e) => this.handleEsphomeError(e));\n          msg.yaml_errors.forEach((e) => this.handleYamlError(e));\n\n          this.diagnosticCollection.forEach((diagnostics, uri) =>\n            this.sendDiagnostics(uri, diagnostics),\n          );\n\n          this.validating_uri = null;\n          //this.validateNext();\n          break;\n        }\n        case \"check_directory_exists\": {\n          const uri = vscodeUri.URI.file(msg.path).toString();\n          const pathExists = await this.fileAccessor.checkPathExists(uri);\n\n          this.connection.sendMessage({\n            type: \"directory_exists_response\",\n            content: pathExists,\n          });\n          break;\n        }\n        case \"check_file_exists\": {\n          const uri = vscodeUri.URI.file(msg.path).toString();\n          const fileExists = await this.fileAccessor.checkPathExists(uri);\n\n          this.connection.sendMessage({\n            type: \"file_exists_response\",\n            content: fileExists,\n          });\n          break;\n        }\n        default: {\n          console.log(`Got unknown message type`, msg);\n          break;\n        }\n      }\n    } catch (e) {\n      console.log(\"Income message error: \" + e);\n      this.validating_uri = null;\n    }\n  }\n\n  private validating_uri: string | null = null;\n  private includedFiles: { [id: string]: string[] } = {};\n\n  onDocumentChange(e: TextDocumentChangeEvent<TextDocument>): void {\n    try {\n      if (vscodeUri.URI.parse(e.document.uri).path.endsWith(\"secrets.yaml\")) {\n        // don't validate secrets\n        return;\n      }\n      if (this.validating_uri !== null) {\n        const lastRequestElapsedTime =\n          new Date().getTime() - this.lastRequest.getTime();\n        // 10 seconds without response\n        if (lastRequestElapsedTime < 10000) {\n          return;\n        }\n        console.log(\n          \"Timeout waiting for previous validation to complete. Discarding.\",\n        );\n      }\n      this.validating_uri = e.document.uri;\n      this.diagnosticCollection.clear();\n      this.diagnosticCollection.set(this.validating_uri, []);\n      const uri = this.validating_uri;\n      // Check if this is an included file\n      // console.log(`this file path: ${uri}`);\n      for (let key in this.includedFiles) {\n        // TODO: When an included file is in turn included, this should call the top most file, not the next one.\n        // console.log(`testing included files in: ${key} files: ${this.includedFiles[key]}`);\n        if (this.includedFiles[key].indexOf(uri) >= 0) {\n          this.validating_uri = key;\n          // console.log(`Not validating ${uri} as is listed as included file. Validating containing document ${key} instead`);\n        }\n      }\n\n      console.log(`Validating ${this.validating_uri}`);\n      this.lastRequest = new Date();\n      this.connection.sendMessage({\n        type: \"validate\",\n        file: vscodeUri.URI.parse(this.validating_uri).fsPath,\n      });\n    } catch (e) {\n      console.log(e);\n      this.validating_uri = null;\n    }\n  }\n}\n","export const MESSAGE_READ_FILE = \"read_file\";\nexport const MESSAGE_FILE_RESPONSE = \"file_response\";\nexport const MESSAGE_RESULT = \"result\";\nexport const MESSAGE_CHECK_FILE = \"check_file_exists\";\nexport const MESSAGE_CHECK_DIRECTORY = \"check_directory_exists\";\nexport const MESSAGE_VERSION = \"version\";\nexport const MESSAGE_STD_ERR_OUT = \"std_err_out\";\n\nexport interface EsphomeRange {\n  document: string;\n  start_line: number;\n  start_col: number;\n  end_line: number;\n  end_col: number;\n}\n\nexport interface ValidationError {\n  range: EsphomeRange | null;\n  message: string;\n}\n\nexport interface MessageReadFile {\n  type: typeof MESSAGE_READ_FILE;\n  path: string;\n}\n\nexport interface YamlValidationError {\n  message: string;\n}\n\nexport interface MessageResult {\n  type: typeof MESSAGE_RESULT;\n  validation_errors: ValidationError[];\n  yaml_errors: YamlValidationError[];\n}\nexport interface MessageStdErrOut {\n  type: typeof MESSAGE_STD_ERR_OUT;\n  std_err: string;\n}\n\nexport interface MessageCheckFileExists {\n  type: typeof MESSAGE_CHECK_FILE;\n  path: string;\n}\n\nexport interface MessageCheckDirectoryExists {\n  type: typeof MESSAGE_CHECK_DIRECTORY;\n  path: string;\n}\n\nexport interface MessageVersion {\n  type: typeof MESSAGE_VERSION;\n  value: string;\n}\n\nexport type MessageTypes =\n  | MessageReadFile\n  | MessageResult\n  | MessageCheckFileExists\n  | MessageCheckDirectoryExists\n  | MessageVersion\n  | MessageStdErrOut;\n","!function(t,e){if(\"object\"==typeof exports&&\"object\"==typeof module)module.exports=e();else if(\"function\"==typeof define&&define.amd)define([],e);else{var r=e();for(var n in r)(\"object\"==typeof exports?exports:t)[n]=r[n]}}(this,(()=>(()=>{\"use strict\";var t={975:t=>{function e(t){if(\"string\"!=typeof t)throw new TypeError(\"Path must be a string. Received \"+JSON.stringify(t))}function r(t,e){for(var r,n=\"\",i=0,o=-1,s=0,a=0;a<=t.length;++a){if(a<t.length)r=t.charCodeAt(a);else{if(47===r)break;r=47}if(47===r){if(o===a-1||1===s);else if(o!==a-1&&2===s){if(n.length<2||2!==i||46!==n.charCodeAt(n.length-1)||46!==n.charCodeAt(n.length-2))if(n.length>2){var h=n.lastIndexOf(\"/\");if(h!==n.length-1){-1===h?(n=\"\",i=0):i=(n=n.slice(0,h)).length-1-n.lastIndexOf(\"/\"),o=a,s=0;continue}}else if(2===n.length||1===n.length){n=\"\",i=0,o=a,s=0;continue}e&&(n.length>0?n+=\"/..\":n=\"..\",i=2)}else n.length>0?n+=\"/\"+t.slice(o+1,a):n=t.slice(o+1,a),i=a-o-1;o=a,s=0}else 46===r&&-1!==s?++s:s=-1}return n}var n={resolve:function(){for(var t,n=\"\",i=!1,o=arguments.length-1;o>=-1&&!i;o--){var s;o>=0?s=arguments[o]:(void 0===t&&(t=process.cwd()),s=t),e(s),0!==s.length&&(n=s+\"/\"+n,i=47===s.charCodeAt(0))}return n=r(n,!i),i?n.length>0?\"/\"+n:\"/\":n.length>0?n:\".\"},normalize:function(t){if(e(t),0===t.length)return\".\";var n=47===t.charCodeAt(0),i=47===t.charCodeAt(t.length-1);return 0!==(t=r(t,!n)).length||n||(t=\".\"),t.length>0&&i&&(t+=\"/\"),n?\"/\"+t:t},isAbsolute:function(t){return e(t),t.length>0&&47===t.charCodeAt(0)},join:function(){if(0===arguments.length)return\".\";for(var t,r=0;r<arguments.length;++r){var i=arguments[r];e(i),i.length>0&&(void 0===t?t=i:t+=\"/\"+i)}return void 0===t?\".\":n.normalize(t)},relative:function(t,r){if(e(t),e(r),t===r)return\"\";if((t=n.resolve(t))===(r=n.resolve(r)))return\"\";for(var i=1;i<t.length&&47===t.charCodeAt(i);++i);for(var o=t.length,s=o-i,a=1;a<r.length&&47===r.charCodeAt(a);++a);for(var h=r.length-a,c=s<h?s:h,f=-1,u=0;u<=c;++u){if(u===c){if(h>c){if(47===r.charCodeAt(a+u))return r.slice(a+u+1);if(0===u)return r.slice(a+u)}else s>c&&(47===t.charCodeAt(i+u)?f=u:0===u&&(f=0));break}var l=t.charCodeAt(i+u);if(l!==r.charCodeAt(a+u))break;47===l&&(f=u)}var d=\"\";for(u=i+f+1;u<=o;++u)u!==o&&47!==t.charCodeAt(u)||(0===d.length?d+=\"..\":d+=\"/..\");return d.length>0?d+r.slice(a+f):(a+=f,47===r.charCodeAt(a)&&++a,r.slice(a))},_makeLong:function(t){return t},dirname:function(t){if(e(t),0===t.length)return\".\";for(var r=t.charCodeAt(0),n=47===r,i=-1,o=!0,s=t.length-1;s>=1;--s)if(47===(r=t.charCodeAt(s))){if(!o){i=s;break}}else o=!1;return-1===i?n?\"/\":\".\":n&&1===i?\"//\":t.slice(0,i)},basename:function(t,r){if(void 0!==r&&\"string\"!=typeof r)throw new TypeError('\"ext\" argument must be a string');e(t);var n,i=0,o=-1,s=!0;if(void 0!==r&&r.length>0&&r.length<=t.length){if(r.length===t.length&&r===t)return\"\";var a=r.length-1,h=-1;for(n=t.length-1;n>=0;--n){var c=t.charCodeAt(n);if(47===c){if(!s){i=n+1;break}}else-1===h&&(s=!1,h=n+1),a>=0&&(c===r.charCodeAt(a)?-1==--a&&(o=n):(a=-1,o=h))}return i===o?o=h:-1===o&&(o=t.length),t.slice(i,o)}for(n=t.length-1;n>=0;--n)if(47===t.charCodeAt(n)){if(!s){i=n+1;break}}else-1===o&&(s=!1,o=n+1);return-1===o?\"\":t.slice(i,o)},extname:function(t){e(t);for(var r=-1,n=0,i=-1,o=!0,s=0,a=t.length-1;a>=0;--a){var h=t.charCodeAt(a);if(47!==h)-1===i&&(o=!1,i=a+1),46===h?-1===r?r=a:1!==s&&(s=1):-1!==r&&(s=-1);else if(!o){n=a+1;break}}return-1===r||-1===i||0===s||1===s&&r===i-1&&r===n+1?\"\":t.slice(r,i)},format:function(t){if(null===t||\"object\"!=typeof t)throw new TypeError('The \"pathObject\" argument must be of type Object. Received type '+typeof t);return function(t,e){var r=e.dir||e.root,n=e.base||(e.name||\"\")+(e.ext||\"\");return r?r===e.root?r+n:r+\"/\"+n:n}(0,t)},parse:function(t){e(t);var r={root:\"\",dir:\"\",base:\"\",ext:\"\",name:\"\"};if(0===t.length)return r;var n,i=t.charCodeAt(0),o=47===i;o?(r.root=\"/\",n=1):n=0;for(var s=-1,a=0,h=-1,c=!0,f=t.length-1,u=0;f>=n;--f)if(47!==(i=t.charCodeAt(f)))-1===h&&(c=!1,h=f+1),46===i?-1===s?s=f:1!==u&&(u=1):-1!==s&&(u=-1);else if(!c){a=f+1;break}return-1===s||-1===h||0===u||1===u&&s===h-1&&s===a+1?-1!==h&&(r.base=r.name=0===a&&o?t.slice(1,h):t.slice(a,h)):(0===a&&o?(r.name=t.slice(1,s),r.base=t.slice(1,h)):(r.name=t.slice(a,s),r.base=t.slice(a,h)),r.ext=t.slice(s,h)),a>0?r.dir=t.slice(0,a-1):o&&(r.dir=\"/\"),r},sep:\"/\",delimiter:\":\",win32:null,posix:null};n.posix=n,t.exports=n},70:(t,e)=>{if(Object.defineProperty(e,\"__esModule\",{value:!0}),e.isWindows=void 0,\"object\"==typeof process)e.isWindows=\"win32\"===process.platform;else if(\"object\"==typeof navigator){let t=navigator.userAgent;e.isWindows=t.indexOf(\"Windows\")>=0}},231:(t,e,r)=>{Object.defineProperty(e,\"__esModule\",{value:!0}),e.uriToFsPath=e.URI=void 0;const n=r(70),i=/^\\w[\\w\\d+.-]*$/,o=/^\\//,s=/^\\/\\//;function a(t,e){if(!t.scheme&&e)throw new Error(`[UriError]: Scheme is missing: {scheme: \"\", authority: \"${t.authority}\", path: \"${t.path}\", query: \"${t.query}\", fragment: \"${t.fragment}\"}`);if(t.scheme&&!i.test(t.scheme))throw new Error(\"[UriError]: Scheme contains illegal characters.\");if(t.path)if(t.authority){if(!o.test(t.path))throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash (\"/\") character')}else if(s.test(t.path))throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters (\"//\")')}const h=\"\",c=\"/\",f=/^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;class u{static isUri(t){return t instanceof u||!!t&&\"string\"==typeof t.authority&&\"string\"==typeof t.fragment&&\"string\"==typeof t.path&&\"string\"==typeof t.query&&\"string\"==typeof t.scheme&&\"string\"==typeof t.fsPath&&\"function\"==typeof t.with&&\"function\"==typeof t.toString}scheme;authority;path;query;fragment;constructor(t,e,r,n,i,o=!1){\"object\"==typeof t?(this.scheme=t.scheme||h,this.authority=t.authority||h,this.path=t.path||h,this.query=t.query||h,this.fragment=t.fragment||h):(this.scheme=function(t,e){return t||e?t:\"file\"}(t,o),this.authority=e||h,this.path=function(t,e){switch(t){case\"https\":case\"http\":case\"file\":e?e[0]!==c&&(e=c+e):e=c}return e}(this.scheme,r||h),this.query=n||h,this.fragment=i||h,a(this,o))}get fsPath(){return v(this,!1)}with(t){if(!t)return this;let{scheme:e,authority:r,path:n,query:i,fragment:o}=t;return void 0===e?e=this.scheme:null===e&&(e=h),void 0===r?r=this.authority:null===r&&(r=h),void 0===n?n=this.path:null===n&&(n=h),void 0===i?i=this.query:null===i&&(i=h),void 0===o?o=this.fragment:null===o&&(o=h),e===this.scheme&&r===this.authority&&n===this.path&&i===this.query&&o===this.fragment?this:new d(e,r,n,i,o)}static parse(t,e=!1){const r=f.exec(t);return r?new d(r[2]||h,w(r[4]||h),w(r[5]||h),w(r[7]||h),w(r[9]||h),e):new d(h,h,h,h,h)}static file(t){let e=h;if(n.isWindows&&(t=t.replace(/\\\\/g,c)),t[0]===c&&t[1]===c){const r=t.indexOf(c,2);-1===r?(e=t.substring(2),t=c):(e=t.substring(2,r),t=t.substring(r)||c)}return new d(\"file\",e,t,h,h)}static from(t){const e=new d(t.scheme,t.authority,t.path,t.query,t.fragment);return a(e,!0),e}toString(t=!1){return y(this,t)}toJSON(){return this}static revive(t){if(t){if(t instanceof u)return t;{const e=new d(t);return e._formatted=t.external,e._fsPath=t._sep===l?t.fsPath:null,e}}return t}}e.URI=u;const l=n.isWindows?1:void 0;class d extends u{_formatted=null;_fsPath=null;get fsPath(){return this._fsPath||(this._fsPath=v(this,!1)),this._fsPath}toString(t=!1){return t?y(this,!0):(this._formatted||(this._formatted=y(this,!1)),this._formatted)}toJSON(){const t={$mid:1};return this._fsPath&&(t.fsPath=this._fsPath,t._sep=l),this._formatted&&(t.external=this._formatted),this.path&&(t.path=this.path),this.scheme&&(t.scheme=this.scheme),this.authority&&(t.authority=this.authority),this.query&&(t.query=this.query),this.fragment&&(t.fragment=this.fragment),t}}const p={58:\"%3A\",47:\"%2F\",63:\"%3F\",35:\"%23\",91:\"%5B\",93:\"%5D\",64:\"%40\",33:\"%21\",36:\"%24\",38:\"%26\",39:\"%27\",40:\"%28\",41:\"%29\",42:\"%2A\",43:\"%2B\",44:\"%2C\",59:\"%3B\",61:\"%3D\",32:\"%20\"};function g(t,e,r){let n,i=-1;for(let o=0;o<t.length;o++){const s=t.charCodeAt(o);if(s>=97&&s<=122||s>=65&&s<=90||s>=48&&s<=57||45===s||46===s||95===s||126===s||e&&47===s||r&&91===s||r&&93===s||r&&58===s)-1!==i&&(n+=encodeURIComponent(t.substring(i,o)),i=-1),void 0!==n&&(n+=t.charAt(o));else{void 0===n&&(n=t.substr(0,o));const e=p[s];void 0!==e?(-1!==i&&(n+=encodeURIComponent(t.substring(i,o)),i=-1),n+=e):-1===i&&(i=o)}}return-1!==i&&(n+=encodeURIComponent(t.substring(i))),void 0!==n?n:t}function m(t){let e;for(let r=0;r<t.length;r++){const n=t.charCodeAt(r);35===n||63===n?(void 0===e&&(e=t.substr(0,r)),e+=p[n]):void 0!==e&&(e+=t[r])}return void 0!==e?e:t}function v(t,e){let r;return r=t.authority&&t.path.length>1&&\"file\"===t.scheme?`//${t.authority}${t.path}`:47===t.path.charCodeAt(0)&&(t.path.charCodeAt(1)>=65&&t.path.charCodeAt(1)<=90||t.path.charCodeAt(1)>=97&&t.path.charCodeAt(1)<=122)&&58===t.path.charCodeAt(2)?e?t.path.substr(1):t.path[1].toLowerCase()+t.path.substr(2):t.path,n.isWindows&&(r=r.replace(/\\//g,\"\\\\\")),r}function y(t,e){const r=e?m:g;let n=\"\",{scheme:i,authority:o,path:s,query:a,fragment:h}=t;if(i&&(n+=i,n+=\":\"),(o||\"file\"===i)&&(n+=c,n+=c),o){let t=o.indexOf(\"@\");if(-1!==t){const e=o.substr(0,t);o=o.substr(t+1),t=e.lastIndexOf(\":\"),-1===t?n+=r(e,!1,!1):(n+=r(e.substr(0,t),!1,!1),n+=\":\",n+=r(e.substr(t+1),!1,!0)),n+=\"@\"}o=o.toLowerCase(),t=o.lastIndexOf(\":\"),-1===t?n+=r(o,!1,!0):(n+=r(o.substr(0,t),!1,!0),n+=o.substr(t))}if(s){if(s.length>=3&&47===s.charCodeAt(0)&&58===s.charCodeAt(2)){const t=s.charCodeAt(1);t>=65&&t<=90&&(s=`/${String.fromCharCode(t+32)}:${s.substr(3)}`)}else if(s.length>=2&&58===s.charCodeAt(1)){const t=s.charCodeAt(0);t>=65&&t<=90&&(s=`${String.fromCharCode(t+32)}:${s.substr(2)}`)}n+=r(s,!0,!1)}return a&&(n+=\"?\",n+=r(a,!1,!1)),h&&(n+=\"#\",n+=e?h:g(h,!1,!1)),n}function b(t){try{return decodeURIComponent(t)}catch{return t.length>3?t.substr(0,3)+b(t.substr(3)):t}}e.uriToFsPath=v;const C=/(%[0-9A-Za-z][0-9A-Za-z])+/g;function w(t){return t.match(C)?t.replace(C,(t=>b(t))):t}},552:function(t,e,r){var n=this&&this.__createBinding||(Object.create?function(t,e,r,n){void 0===n&&(n=r);var i=Object.getOwnPropertyDescriptor(e,r);i&&!(\"get\"in i?!e.__esModule:i.writable||i.configurable)||(i={enumerable:!0,get:function(){return e[r]}}),Object.defineProperty(t,n,i)}:function(t,e,r,n){void 0===n&&(n=r),t[n]=e[r]}),i=this&&this.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,\"default\",{enumerable:!0,value:e})}:function(t,e){t.default=e}),o=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var r in t)\"default\"!==r&&Object.prototype.hasOwnProperty.call(t,r)&&n(e,t,r);return i(e,t),e};Object.defineProperty(e,\"__esModule\",{value:!0}),e.Utils=void 0;const s=o(r(975)),a=s.posix||s,h=\"/\";var c;!function(t){t.joinPath=function(t,...e){return t.with({path:a.join(t.path,...e)})},t.resolvePath=function(t,...e){let r=t.path,n=!1;r[0]!==h&&(r=h+r,n=!0);let i=a.resolve(r,...e);return n&&i[0]===h&&!t.authority&&(i=i.substring(1)),t.with({path:i})},t.dirname=function(t){if(0===t.path.length||t.path===h)return t;let e=a.dirname(t.path);return 1===e.length&&46===e.charCodeAt(0)&&(e=\"\"),t.with({path:e})},t.basename=function(t){return a.basename(t.path)},t.extname=function(t){return a.extname(t.path)}}(c||(e.Utils=c={}))}},e={};function r(n){var i=e[n];if(void 0!==i)return i.exports;var o=e[n]={exports:{}};return t[n].call(o.exports,o,o.exports,r),o.exports}var n={};return(()=>{var t=n;Object.defineProperty(t,\"__esModule\",{value:!0}),t.Utils=t.URI=void 0;const e=r(231);Object.defineProperty(t,\"URI\",{enumerable:!0,get:function(){return e.URI}});const i=r(552);Object.defineProperty(t,\"Utils\",{enumerable:!0,get:function(){return i.Utils}})})(),n})()));\n//# sourceMappingURL=index.js.map","import { TextDocuments } from \"vscode-languageserver\";\nimport { TextDocument } from \"vscode-languageserver-textdocument\";\nimport * as fs from \"fs\";\nimport * as path from \"path\";\nimport * as vscodeUri from \"vscode-uri\";\n\nexport interface FileAccessor {\n  checkPathExists(uri: string): Promise<boolean>;\n  getFileContents(fileName: string): Promise<string>;\n  getFilesInFolder(subFolder: string): string[];\n  getFilesInFolderRelativeFrom(\n    subFolder: string,\n    relativeFrom: string,\n  ): string[];\n  getFilesInFolderRelativeFromAsFileUri(\n    subFolder: string,\n    relativeFrom: string,\n  ): string[];\n  getRelativePath(relativeFrom: string, filename: string): string;\n  getRelativePathAsFileUri(relativeFrom: string, filename: string): string;\n}\n\nexport class VsCodeFileAccessor implements FileAccessor {\n  private ourRoot: string;\n\n  constructor(private documents: TextDocuments<TextDocument>) {\n    this.ourRoot = path.resolve();\n  }\n  async checkPathExists(uri: string): Promise<boolean> {\n    const fsPath = vscodeUri.URI.parse(uri).fsPath;\n    return new Promise<boolean>((c) => {\n      fs.exists(fsPath, (exists) => {\n        c(exists);\n      });\n    });\n  }\n\n  public async getFileContents(uri: string): Promise<string> {\n    const textDocument = this.documents.get(uri);\n    if (textDocument) {\n      // open file in editor, might not be saved yet\n      return textDocument.getText();\n    }\n    const fsPath = vscodeUri.URI.parse(uri).fsPath;\n    return new Promise<string>((c, e) => {\n      fs.exists(fsPath, (exists) => {\n        if (!exists) {\n          e(\"File does not exist\");\n        }\n        fs.readFile(fsPath, { encoding: \"utf-8\" }, (err, result) => {\n          if (err) {\n            e(err);\n          } else {\n            c(result);\n          }\n        });\n      });\n    });\n  }\n\n  public getFilesInFolder(\n    subFolder: string,\n    file_list: string[] = [],\n  ): string[] {\n    subFolder = path.normalize(subFolder);\n\n    try {\n      fs.readdirSync(subFolder).forEach((file) => {\n        file_list = fs.statSync(path.join(subFolder, file)).isDirectory()\n          ? this.getFilesInFolder(path.join(subFolder, file), file_list)\n          : file_list.concat(path.join(subFolder, file));\n      });\n    } catch (err) {\n      console.log(`Cannot find the files in folder ${subFolder}`);\n    }\n    return file_list;\n  }\n\n  private dealtWithRelativeFrom = (relativeFrom: string): string => {\n    if (relativeFrom.startsWith(\"file://\")) {\n      relativeFrom = vscodeUri.URI.parse(relativeFrom).fsPath;\n    } else {\n      if (!relativeFrom.startsWith(this.ourRoot)) {\n        relativeFrom = path.resolve(relativeFrom);\n      }\n      relativeFrom = vscodeUri.URI.file(relativeFrom).fsPath;\n    }\n    return relativeFrom;\n  };\n\n  public getFilesInFolderRelativeFrom(\n    subFolder: string,\n    relativeFrom: string,\n  ): string[] {\n    relativeFrom = this.dealtWithRelativeFrom(relativeFrom);\n\n    const dirOfFile = path.dirname(relativeFrom);\n    subFolder = path.join(dirOfFile, subFolder);\n    return this.getFilesInFolder(subFolder);\n  }\n\n  public getFilesInFolderRelativeFromAsFileUri(\n    subFolder: string,\n    relativeFrom: string,\n  ): string[] {\n    const files = this.getFilesInFolderRelativeFrom(subFolder, relativeFrom);\n    return files.map((f) => vscodeUri.URI.file(f).toString());\n  }\n\n  public getRelativePath = (relativeFrom: string, filename: string): string => {\n    relativeFrom = this.dealtWithRelativeFrom(relativeFrom);\n\n    const dirOfFile = path.dirname(relativeFrom);\n    const joinedPath = path.join(dirOfFile, filename);\n\n    return joinedPath;\n  };\n\n  public getRelativePathAsFileUri = (\n    relativeFrom: string,\n    filename: string,\n  ): string => {\n    return vscodeUri.URI.file(\n      this.getRelativePath(relativeFrom, filename),\n    ).toString();\n  };\n}\n","import { ESPHomeDashboardConnection } from \"./connection-dashboard\";\nimport { ESPHomeLocalConnection } from \"./connection-local\";\nimport { ESPHomeSettings } from \"./settings\";\nimport { MESSAGE_VERSION, MessageTypes } from \"./types\";\nimport { ESPHomeConnection } from \"./connection\";\n\n// This class checks configuration settings and decides which connection to use\n// The same base ESPHomeConnection is used for this.\nconst DEFAULT_VERSION = \"2025.4.0\";\nexport class ESPHomeConnectionSource extends ESPHomeConnection {\n  // The real connection\n  private relay!: ESPHomeConnection;\n  private handleMessageSource_!: (msg: MessageTypes) => void;\n  private relayType: string | undefined;\n\n  async connect(): Promise<void> {\n    throw new Error(\"Method not implemented.\");\n  }\n  disconnect(): void {\n    throw new Error(\"Method not implemented.\");\n  }\n  sendMessageInternal(msg: any): void {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  async configure(config: ESPHomeSettings) {\n    const newRelayType = config.validator;\n    if (this.relayType !== undefined) {\n      if (this.relayType != newRelayType) this.relay.disconnect();\n      else {\n        if (this.relayType === \"local\") {\n          // nothing to do\n          return;\n        }\n      }\n    }\n    this.relayType = newRelayType;\n    if (config.validator === \"local\") {\n      console.log(\"Configuring ESPHome with local validation...\");\n      this.relay = new ESPHomeLocalConnection(config.pythonPath);\n    } else {\n      if (config.dashboardUri === undefined) {\n        console.error(\"Invalid dashboard uri. Check the configuration\");\n        return;\n      }\n      console.log(\n        `Configuring ESPHome with dashboard validation at ${config.dashboardUri}...`,\n      );\n\n      this.relay = new ESPHomeDashboardConnection(config.dashboardUri);\n    }\n    this.relay.onResponse(this.handleRelayResponse.bind(this));\n    await this.relay.connect();\n  }\n\n  sendMessage(msg: any): void {\n    if (this.relay !== undefined) {\n      this.relay.sendMessage(msg);\n    }\n  }\n\n  onResponse(handleMessage: (msg: MessageTypes) => void) {\n    this.handleMessageSource_ = handleMessage;\n  }\n\n  private handleRelayResponse(m: MessageTypes): void {\n    // newer versions of esphome push version on connection established\n    if (m.type == MESSAGE_VERSION) {\n      setVersion(m.value);\n      return;\n    } else {\n      if (_version == undefined) {\n        console.log(\n          `First message is not version. Default to ${DEFAULT_VERSION}`,\n        );\n        setVersion(DEFAULT_VERSION);\n      }\n    }\n    if (this.handleMessageSource_) this.handleMessageSource_(m);\n  }\n}\n\nlet _version: string | undefined;\nlet _version_promise: Promise<string> | undefined;\nlet _version_resolve: ((value: string) => void) | undefined;\nlet _version_timeout: NodeJS.Timeout | undefined;\n\nexport function setVersion(newVersion: string) {\n  _version = newVersion;\n  if (_version_resolve) {\n    clearTimeout(_version_timeout);\n    _version_resolve(_version);\n    _version_resolve = undefined;\n  }\n}\n\nexport async function version(): Promise<string> {\n  if (!_version_promise) {\n    _version_promise = new Promise<string>((resolve) => {\n      if (_version) {\n        resolve(_version);\n        return;\n      }\n      _version_resolve = resolve;\n      _version_timeout = setTimeout(() => {\n        console.log(\"Version default given by timeout\");\n        _version = DEFAULT_VERSION; // Default version\n        resolve(_version); // fallback to current _version\n      }, 10000);\n    });\n  }\n  return _version_promise;\n}\n","import * as WebSocket from \"ws\";\nimport { ESPHomeConnection } from \"./connection\";\n\nexport class ESPHomeDashboardConnection extends ESPHomeConnection {\n  private ws!: WebSocket;\n  constructor(readonly endPoint: string) {\n    super();\n  }\n\n  sendMessageInternal(msg: any): void {\n    // Check if WS is open, otherwise ignore\n    if (this.ws.readyState !== 1) {\n      return;\n    }\n    let send = JSON.stringify({\n      type: \"stdin\",\n      data: JSON.stringify(msg) + \"\\n\",\n    });\n    this.ws.send(send);\n  }\n\n  async connect(): Promise<void> {\n    const regex = /^(([^:/?#]+):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\n    let uri = this.endPoint;\n    if (uri.indexOf(\"//\") === -1) {\n      uri = \"http://\" + uri;\n    }\n    const match = uri.match(regex);\n\n    if (match === null) {\n      console.error(`Could not understand end point '${this.endPoint}'`);\n      return;\n    }\n\n    const httpUri = `${match[2]}://${match[4]}/`;\n    const wsUri = `ws${match[2] === \"https\" ? \"s\" : \"\"}://${match[4]}/vscode`;\n\n    console.log(`Using ESPHome dashboard at: ${wsUri} server: ${httpUri}`);\n    this.ws = new WebSocket(wsUri.toString());\n\n    // TODO: Open dynamically, re - open when connection lost etc.\n    this.ws.on(\"open\", () => {\n      console.log(\"Connection established.\");\n      const msg = JSON.stringify({ type: \"spawn\" });\n      this.ws.send(msg);\n    });\n    this.ws.on(\"error\", (err: Error) => {\n      console.log(\"Cannot connect to ESPHome dashboard\" + err);\n      console.error(\n        `Cannot connect to ESPHome dashboard. Make sure you can access '${httpUri}' and have set the option 'leave_front_door_open': true`,\n      );\n    });\n    this.ws.on(\"message\", (data) => {\n      const raw = JSON.parse(data.toString());\n      const msg = JSON.parse(raw.data);\n      this.handleMessage(msg);\n    });\n  }\n\n  public disconnect(): void {}\n}\n","'use strict';\n\nconst WebSocket = require('./lib/websocket');\n\nWebSocket.createWebSocketStream = require('./lib/stream');\nWebSocket.Server = require('./lib/websocket-server');\nWebSocket.Receiver = require('./lib/receiver');\nWebSocket.Sender = require('./lib/sender');\n\nWebSocket.WebSocket = WebSocket;\nWebSocket.WebSocketServer = WebSocket.Server;\n\nmodule.exports = WebSocket;\n","/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Duplex|Readable$\", \"caughtErrors\": \"none\" }] */\n\n'use strict';\n\nconst EventEmitter = require('events');\nconst https = require('https');\nconst http = require('http');\nconst net = require('net');\nconst tls = require('tls');\nconst { randomBytes, createHash } = require('crypto');\nconst { Duplex, Readable } = require('stream');\nconst { URL } = require('url');\n\nconst PerMessageDeflate = require('./permessage-deflate');\nconst Receiver = require('./receiver');\nconst Sender = require('./sender');\nconst { isBlob } = require('./validation');\n\nconst {\n  BINARY_TYPES,\n  EMPTY_BUFFER,\n  GUID,\n  kForOnEventAttribute,\n  kListener,\n  kStatusCode,\n  kWebSocket,\n  NOOP\n} = require('./constants');\nconst {\n  EventTarget: { addEventListener, removeEventListener }\n} = require('./event-target');\nconst { format, parse } = require('./extension');\nconst { toBuffer } = require('./buffer-util');\n\nconst closeTimeout = 30 * 1000;\nconst kAborted = Symbol('kAborted');\nconst protocolVersions = [8, 13];\nconst readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];\nconst subprotocolRegex = /^[!#$%&'*+\\-.0-9A-Z^_`|a-z~]+$/;\n\n/**\n * Class representing a WebSocket.\n *\n * @extends EventEmitter\n */\nclass WebSocket extends EventEmitter {\n  /**\n   * Create a new `WebSocket`.\n   *\n   * @param {(String|URL)} address The URL to which to connect\n   * @param {(String|String[])} [protocols] The subprotocols\n   * @param {Object} [options] Connection options\n   */\n  constructor(address, protocols, options) {\n    super();\n\n    this._binaryType = BINARY_TYPES[0];\n    this._closeCode = 1006;\n    this._closeFrameReceived = false;\n    this._closeFrameSent = false;\n    this._closeMessage = EMPTY_BUFFER;\n    this._closeTimer = null;\n    this._errorEmitted = false;\n    this._extensions = {};\n    this._paused = false;\n    this._protocol = '';\n    this._readyState = WebSocket.CONNECTING;\n    this._receiver = null;\n    this._sender = null;\n    this._socket = null;\n\n    if (address !== null) {\n      this._bufferedAmount = 0;\n      this._isServer = false;\n      this._redirects = 0;\n\n      if (protocols === undefined) {\n        protocols = [];\n      } else if (!Array.isArray(protocols)) {\n        if (typeof protocols === 'object' && protocols !== null) {\n          options = protocols;\n          protocols = [];\n        } else {\n          protocols = [protocols];\n        }\n      }\n\n      initAsClient(this, address, protocols, options);\n    } else {\n      this._autoPong = options.autoPong;\n      this._isServer = true;\n    }\n  }\n\n  /**\n   * For historical reasons, the custom \"nodebuffer\" type is used by the default\n   * instead of \"blob\".\n   *\n   * @type {String}\n   */\n  get binaryType() {\n    return this._binaryType;\n  }\n\n  set binaryType(type) {\n    if (!BINARY_TYPES.includes(type)) return;\n\n    this._binaryType = type;\n\n    //\n    // Allow to change `binaryType` on the fly.\n    //\n    if (this._receiver) this._receiver._binaryType = type;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get bufferedAmount() {\n    if (!this._socket) return this._bufferedAmount;\n\n    return this._socket._writableState.length + this._sender._bufferedBytes;\n  }\n\n  /**\n   * @type {String}\n   */\n  get extensions() {\n    return Object.keys(this._extensions).join();\n  }\n\n  /**\n   * @type {Boolean}\n   */\n  get isPaused() {\n    return this._paused;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onclose() {\n    return null;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onerror() {\n    return null;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onopen() {\n    return null;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onmessage() {\n    return null;\n  }\n\n  /**\n   * @type {String}\n   */\n  get protocol() {\n    return this._protocol;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get readyState() {\n    return this._readyState;\n  }\n\n  /**\n   * @type {String}\n   */\n  get url() {\n    return this._url;\n  }\n\n  /**\n   * Set up the socket and the internal resources.\n   *\n   * @param {Duplex} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Object} options Options object\n   * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether\n   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted\n   *     multiple times in the same tick\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Number} [options.maxPayload=0] The maximum allowed message size\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   * @private\n   */\n  setSocket(socket, head, options) {\n    const receiver = new Receiver({\n      allowSynchronousEvents: options.allowSynchronousEvents,\n      binaryType: this.binaryType,\n      extensions: this._extensions,\n      isServer: this._isServer,\n      maxPayload: options.maxPayload,\n      skipUTF8Validation: options.skipUTF8Validation\n    });\n\n    const sender = new Sender(socket, this._extensions, options.generateMask);\n\n    this._receiver = receiver;\n    this._sender = sender;\n    this._socket = socket;\n\n    receiver[kWebSocket] = this;\n    sender[kWebSocket] = this;\n    socket[kWebSocket] = this;\n\n    receiver.on('conclude', receiverOnConclude);\n    receiver.on('drain', receiverOnDrain);\n    receiver.on('error', receiverOnError);\n    receiver.on('message', receiverOnMessage);\n    receiver.on('ping', receiverOnPing);\n    receiver.on('pong', receiverOnPong);\n\n    sender.onerror = senderOnError;\n\n    //\n    // These methods may not be available if `socket` is just a `Duplex`.\n    //\n    if (socket.setTimeout) socket.setTimeout(0);\n    if (socket.setNoDelay) socket.setNoDelay();\n\n    if (head.length > 0) socket.unshift(head);\n\n    socket.on('close', socketOnClose);\n    socket.on('data', socketOnData);\n    socket.on('end', socketOnEnd);\n    socket.on('error', socketOnError);\n\n    this._readyState = WebSocket.OPEN;\n    this.emit('open');\n  }\n\n  /**\n   * Emit the `'close'` event.\n   *\n   * @private\n   */\n  emitClose() {\n    if (!this._socket) {\n      this._readyState = WebSocket.CLOSED;\n      this.emit('close', this._closeCode, this._closeMessage);\n      return;\n    }\n\n    if (this._extensions[PerMessageDeflate.extensionName]) {\n      this._extensions[PerMessageDeflate.extensionName].cleanup();\n    }\n\n    this._receiver.removeAllListeners();\n    this._readyState = WebSocket.CLOSED;\n    this.emit('close', this._closeCode, this._closeMessage);\n  }\n\n  /**\n   * Start a closing handshake.\n   *\n   *          +----------+   +-----------+   +----------+\n   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -\n   *    |     +----------+   +-----------+   +----------+     |\n   *          +----------+   +-----------+         |\n   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING\n   *          +----------+   +-----------+   |\n   *    |           |                        |   +---+        |\n   *                +------------------------+-->|fin| - - - -\n   *    |         +---+                      |   +---+\n   *     - - - - -|fin|<---------------------+\n   *              +---+\n   *\n   * @param {Number} [code] Status code explaining why the connection is closing\n   * @param {(String|Buffer)} [data] The reason why the connection is\n   *     closing\n   * @public\n   */\n  close(code, data) {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      abortHandshake(this, this._req, msg);\n      return;\n    }\n\n    if (this.readyState === WebSocket.CLOSING) {\n      if (\n        this._closeFrameSent &&\n        (this._closeFrameReceived || this._receiver._writableState.errorEmitted)\n      ) {\n        this._socket.end();\n      }\n\n      return;\n    }\n\n    this._readyState = WebSocket.CLOSING;\n    this._sender.close(code, data, !this._isServer, (err) => {\n      //\n      // This error is handled by the `'error'` listener on the socket. We only\n      // want to know if the close frame has been sent here.\n      //\n      if (err) return;\n\n      this._closeFrameSent = true;\n\n      if (\n        this._closeFrameReceived ||\n        this._receiver._writableState.errorEmitted\n      ) {\n        this._socket.end();\n      }\n    });\n\n    setCloseTimer(this);\n  }\n\n  /**\n   * Pause the socket.\n   *\n   * @public\n   */\n  pause() {\n    if (\n      this.readyState === WebSocket.CONNECTING ||\n      this.readyState === WebSocket.CLOSED\n    ) {\n      return;\n    }\n\n    this._paused = true;\n    this._socket.pause();\n  }\n\n  /**\n   * Send a ping.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the ping is sent\n   * @public\n   */\n  ping(data, mask, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    if (mask === undefined) mask = !this._isServer;\n    this._sender.ping(data || EMPTY_BUFFER, mask, cb);\n  }\n\n  /**\n   * Send a pong.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the pong is sent\n   * @public\n   */\n  pong(data, mask, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    if (mask === undefined) mask = !this._isServer;\n    this._sender.pong(data || EMPTY_BUFFER, mask, cb);\n  }\n\n  /**\n   * Resume the socket.\n   *\n   * @public\n   */\n  resume() {\n    if (\n      this.readyState === WebSocket.CONNECTING ||\n      this.readyState === WebSocket.CLOSED\n    ) {\n      return;\n    }\n\n    this._paused = false;\n    if (!this._receiver._writableState.needDrain) this._socket.resume();\n  }\n\n  /**\n   * Send a data message.\n   *\n   * @param {*} data The message to send\n   * @param {Object} [options] Options object\n   * @param {Boolean} [options.binary] Specifies whether `data` is binary or\n   *     text\n   * @param {Boolean} [options.compress] Specifies whether or not to compress\n   *     `data`\n   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when data is written out\n   * @public\n   */\n  send(data, options, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    const opts = {\n      binary: typeof data !== 'string',\n      mask: !this._isServer,\n      compress: true,\n      fin: true,\n      ...options\n    };\n\n    if (!this._extensions[PerMessageDeflate.extensionName]) {\n      opts.compress = false;\n    }\n\n    this._sender.send(data || EMPTY_BUFFER, opts, cb);\n  }\n\n  /**\n   * Forcibly close the connection.\n   *\n   * @public\n   */\n  terminate() {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      abortHandshake(this, this._req, msg);\n      return;\n    }\n\n    if (this._socket) {\n      this._readyState = WebSocket.CLOSING;\n      this._socket.destroy();\n    }\n  }\n}\n\n/**\n * @constant {Number} CONNECTING\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'CONNECTING', {\n  enumerable: true,\n  value: readyStates.indexOf('CONNECTING')\n});\n\n/**\n * @constant {Number} CONNECTING\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'CONNECTING', {\n  enumerable: true,\n  value: readyStates.indexOf('CONNECTING')\n});\n\n/**\n * @constant {Number} OPEN\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'OPEN', {\n  enumerable: true,\n  value: readyStates.indexOf('OPEN')\n});\n\n/**\n * @constant {Number} OPEN\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'OPEN', {\n  enumerable: true,\n  value: readyStates.indexOf('OPEN')\n});\n\n/**\n * @constant {Number} CLOSING\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'CLOSING', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSING')\n});\n\n/**\n * @constant {Number} CLOSING\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'CLOSING', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSING')\n});\n\n/**\n * @constant {Number} CLOSED\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'CLOSED', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSED')\n});\n\n/**\n * @constant {Number} CLOSED\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'CLOSED', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSED')\n});\n\n[\n  'binaryType',\n  'bufferedAmount',\n  'extensions',\n  'isPaused',\n  'protocol',\n  'readyState',\n  'url'\n].forEach((property) => {\n  Object.defineProperty(WebSocket.prototype, property, { enumerable: true });\n});\n\n//\n// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.\n// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface\n//\n['open', 'error', 'close', 'message'].forEach((method) => {\n  Object.defineProperty(WebSocket.prototype, `on${method}`, {\n    enumerable: true,\n    get() {\n      for (const listener of this.listeners(method)) {\n        if (listener[kForOnEventAttribute]) return listener[kListener];\n      }\n\n      return null;\n    },\n    set(handler) {\n      for (const listener of this.listeners(method)) {\n        if (listener[kForOnEventAttribute]) {\n          this.removeListener(method, listener);\n          break;\n        }\n      }\n\n      if (typeof handler !== 'function') return;\n\n      this.addEventListener(method, handler, {\n        [kForOnEventAttribute]: true\n      });\n    }\n  });\n});\n\nWebSocket.prototype.addEventListener = addEventListener;\nWebSocket.prototype.removeEventListener = removeEventListener;\n\nmodule.exports = WebSocket;\n\n/**\n * Initialize a WebSocket client.\n *\n * @param {WebSocket} websocket The client to initialize\n * @param {(String|URL)} address The URL to which to connect\n * @param {Array} protocols The subprotocols\n * @param {Object} [options] Connection options\n * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether any\n *     of the `'message'`, `'ping'`, and `'pong'` events can be emitted multiple\n *     times in the same tick\n * @param {Boolean} [options.autoPong=true] Specifies whether or not to\n *     automatically send a pong in response to a ping\n * @param {Function} [options.finishRequest] A function which can be used to\n *     customize the headers of each http request before it is sent\n * @param {Boolean} [options.followRedirects=false] Whether or not to follow\n *     redirects\n * @param {Function} [options.generateMask] The function used to generate the\n *     masking key\n * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the\n *     handshake request\n * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n *     size\n * @param {Number} [options.maxRedirects=10] The maximum number of redirects\n *     allowed\n * @param {String} [options.origin] Value of the `Origin` or\n *     `Sec-WebSocket-Origin` header\n * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable\n *     permessage-deflate\n * @param {Number} [options.protocolVersion=13] Value of the\n *     `Sec-WebSocket-Version` header\n * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n *     not to skip UTF-8 validation for text and close messages\n * @private\n */\nfunction initAsClient(websocket, address, protocols, options) {\n  const opts = {\n    allowSynchronousEvents: true,\n    autoPong: true,\n    protocolVersion: protocolVersions[1],\n    maxPayload: 100 * 1024 * 1024,\n    skipUTF8Validation: false,\n    perMessageDeflate: true,\n    followRedirects: false,\n    maxRedirects: 10,\n    ...options,\n    socketPath: undefined,\n    hostname: undefined,\n    protocol: undefined,\n    timeout: undefined,\n    method: 'GET',\n    host: undefined,\n    path: undefined,\n    port: undefined\n  };\n\n  websocket._autoPong = opts.autoPong;\n\n  if (!protocolVersions.includes(opts.protocolVersion)) {\n    throw new RangeError(\n      `Unsupported protocol version: ${opts.protocolVersion} ` +\n        `(supported versions: ${protocolVersions.join(', ')})`\n    );\n  }\n\n  let parsedUrl;\n\n  if (address instanceof URL) {\n    parsedUrl = address;\n  } else {\n    try {\n      parsedUrl = new URL(address);\n    } catch (e) {\n      throw new SyntaxError(`Invalid URL: ${address}`);\n    }\n  }\n\n  if (parsedUrl.protocol === 'http:') {\n    parsedUrl.protocol = 'ws:';\n  } else if (parsedUrl.protocol === 'https:') {\n    parsedUrl.protocol = 'wss:';\n  }\n\n  websocket._url = parsedUrl.href;\n\n  const isSecure = parsedUrl.protocol === 'wss:';\n  const isIpcUrl = parsedUrl.protocol === 'ws+unix:';\n  let invalidUrlMessage;\n\n  if (parsedUrl.protocol !== 'ws:' && !isSecure && !isIpcUrl) {\n    invalidUrlMessage =\n      'The URL\\'s protocol must be one of \"ws:\", \"wss:\", ' +\n      '\"http:\", \"https:\", or \"ws+unix:\"';\n  } else if (isIpcUrl && !parsedUrl.pathname) {\n    invalidUrlMessage = \"The URL's pathname is empty\";\n  } else if (parsedUrl.hash) {\n    invalidUrlMessage = 'The URL contains a fragment identifier';\n  }\n\n  if (invalidUrlMessage) {\n    const err = new SyntaxError(invalidUrlMessage);\n\n    if (websocket._redirects === 0) {\n      throw err;\n    } else {\n      emitErrorAndClose(websocket, err);\n      return;\n    }\n  }\n\n  const defaultPort = isSecure ? 443 : 80;\n  const key = randomBytes(16).toString('base64');\n  const request = isSecure ? https.request : http.request;\n  const protocolSet = new Set();\n  let perMessageDeflate;\n\n  opts.createConnection =\n    opts.createConnection || (isSecure ? tlsConnect : netConnect);\n  opts.defaultPort = opts.defaultPort || defaultPort;\n  opts.port = parsedUrl.port || defaultPort;\n  opts.host = parsedUrl.hostname.startsWith('[')\n    ? parsedUrl.hostname.slice(1, -1)\n    : parsedUrl.hostname;\n  opts.headers = {\n    ...opts.headers,\n    'Sec-WebSocket-Version': opts.protocolVersion,\n    'Sec-WebSocket-Key': key,\n    Connection: 'Upgrade',\n    Upgrade: 'websocket'\n  };\n  opts.path = parsedUrl.pathname + parsedUrl.search;\n  opts.timeout = opts.handshakeTimeout;\n\n  if (opts.perMessageDeflate) {\n    perMessageDeflate = new PerMessageDeflate(\n      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},\n      false,\n      opts.maxPayload\n    );\n    opts.headers['Sec-WebSocket-Extensions'] = format({\n      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()\n    });\n  }\n  if (protocols.length) {\n    for (const protocol of protocols) {\n      if (\n        typeof protocol !== 'string' ||\n        !subprotocolRegex.test(protocol) ||\n        protocolSet.has(protocol)\n      ) {\n        throw new SyntaxError(\n          'An invalid or duplicated subprotocol was specified'\n        );\n      }\n\n      protocolSet.add(protocol);\n    }\n\n    opts.headers['Sec-WebSocket-Protocol'] = protocols.join(',');\n  }\n  if (opts.origin) {\n    if (opts.protocolVersion < 13) {\n      opts.headers['Sec-WebSocket-Origin'] = opts.origin;\n    } else {\n      opts.headers.Origin = opts.origin;\n    }\n  }\n  if (parsedUrl.username || parsedUrl.password) {\n    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;\n  }\n\n  if (isIpcUrl) {\n    const parts = opts.path.split(':');\n\n    opts.socketPath = parts[0];\n    opts.path = parts[1];\n  }\n\n  let req;\n\n  if (opts.followRedirects) {\n    if (websocket._redirects === 0) {\n      websocket._originalIpc = isIpcUrl;\n      websocket._originalSecure = isSecure;\n      websocket._originalHostOrSocketPath = isIpcUrl\n        ? opts.socketPath\n        : parsedUrl.host;\n\n      const headers = options && options.headers;\n\n      //\n      // Shallow copy the user provided options so that headers can be changed\n      // without mutating the original object.\n      //\n      options = { ...options, headers: {} };\n\n      if (headers) {\n        for (const [key, value] of Object.entries(headers)) {\n          options.headers[key.toLowerCase()] = value;\n        }\n      }\n    } else if (websocket.listenerCount('redirect') === 0) {\n      const isSameHost = isIpcUrl\n        ? websocket._originalIpc\n          ? opts.socketPath === websocket._originalHostOrSocketPath\n          : false\n        : websocket._originalIpc\n          ? false\n          : parsedUrl.host === websocket._originalHostOrSocketPath;\n\n      if (!isSameHost || (websocket._originalSecure && !isSecure)) {\n        //\n        // Match curl 7.77.0 behavior and drop the following headers. These\n        // headers are also dropped when following a redirect to a subdomain.\n        //\n        delete opts.headers.authorization;\n        delete opts.headers.cookie;\n\n        if (!isSameHost) delete opts.headers.host;\n\n        opts.auth = undefined;\n      }\n    }\n\n    //\n    // Match curl 7.77.0 behavior and make the first `Authorization` header win.\n    // If the `Authorization` header is set, then there is nothing to do as it\n    // will take precedence.\n    //\n    if (opts.auth && !options.headers.authorization) {\n      options.headers.authorization =\n        'Basic ' + Buffer.from(opts.auth).toString('base64');\n    }\n\n    req = websocket._req = request(opts);\n\n    if (websocket._redirects) {\n      //\n      // Unlike what is done for the `'upgrade'` event, no early exit is\n      // triggered here if the user calls `websocket.close()` or\n      // `websocket.terminate()` from a listener of the `'redirect'` event. This\n      // is because the user can also call `request.destroy()` with an error\n      // before calling `websocket.close()` or `websocket.terminate()` and this\n      // would result in an error being emitted on the `request` object with no\n      // `'error'` event listeners attached.\n      //\n      websocket.emit('redirect', websocket.url, req);\n    }\n  } else {\n    req = websocket._req = request(opts);\n  }\n\n  if (opts.timeout) {\n    req.on('timeout', () => {\n      abortHandshake(websocket, req, 'Opening handshake has timed out');\n    });\n  }\n\n  req.on('error', (err) => {\n    if (req === null || req[kAborted]) return;\n\n    req = websocket._req = null;\n    emitErrorAndClose(websocket, err);\n  });\n\n  req.on('response', (res) => {\n    const location = res.headers.location;\n    const statusCode = res.statusCode;\n\n    if (\n      location &&\n      opts.followRedirects &&\n      statusCode >= 300 &&\n      statusCode < 400\n    ) {\n      if (++websocket._redirects > opts.maxRedirects) {\n        abortHandshake(websocket, req, 'Maximum redirects exceeded');\n        return;\n      }\n\n      req.abort();\n\n      let addr;\n\n      try {\n        addr = new URL(location, address);\n      } catch (e) {\n        const err = new SyntaxError(`Invalid URL: ${location}`);\n        emitErrorAndClose(websocket, err);\n        return;\n      }\n\n      initAsClient(websocket, addr, protocols, options);\n    } else if (!websocket.emit('unexpected-response', req, res)) {\n      abortHandshake(\n        websocket,\n        req,\n        `Unexpected server response: ${res.statusCode}`\n      );\n    }\n  });\n\n  req.on('upgrade', (res, socket, head) => {\n    websocket.emit('upgrade', res);\n\n    //\n    // The user may have closed the connection from a listener of the\n    // `'upgrade'` event.\n    //\n    if (websocket.readyState !== WebSocket.CONNECTING) return;\n\n    req = websocket._req = null;\n\n    const upgrade = res.headers.upgrade;\n\n    if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {\n      abortHandshake(websocket, socket, 'Invalid Upgrade header');\n      return;\n    }\n\n    const digest = createHash('sha1')\n      .update(key + GUID)\n      .digest('base64');\n\n    if (res.headers['sec-websocket-accept'] !== digest) {\n      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');\n      return;\n    }\n\n    const serverProt = res.headers['sec-websocket-protocol'];\n    let protError;\n\n    if (serverProt !== undefined) {\n      if (!protocolSet.size) {\n        protError = 'Server sent a subprotocol but none was requested';\n      } else if (!protocolSet.has(serverProt)) {\n        protError = 'Server sent an invalid subprotocol';\n      }\n    } else if (protocolSet.size) {\n      protError = 'Server sent no subprotocol';\n    }\n\n    if (protError) {\n      abortHandshake(websocket, socket, protError);\n      return;\n    }\n\n    if (serverProt) websocket._protocol = serverProt;\n\n    const secWebSocketExtensions = res.headers['sec-websocket-extensions'];\n\n    if (secWebSocketExtensions !== undefined) {\n      if (!perMessageDeflate) {\n        const message =\n          'Server sent a Sec-WebSocket-Extensions header but no extension ' +\n          'was requested';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      let extensions;\n\n      try {\n        extensions = parse(secWebSocketExtensions);\n      } catch (err) {\n        const message = 'Invalid Sec-WebSocket-Extensions header';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      const extensionNames = Object.keys(extensions);\n\n      if (\n        extensionNames.length !== 1 ||\n        extensionNames[0] !== PerMessageDeflate.extensionName\n      ) {\n        const message = 'Server indicated an extension that was not requested';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      try {\n        perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);\n      } catch (err) {\n        const message = 'Invalid Sec-WebSocket-Extensions header';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      websocket._extensions[PerMessageDeflate.extensionName] =\n        perMessageDeflate;\n    }\n\n    websocket.setSocket(socket, head, {\n      allowSynchronousEvents: opts.allowSynchronousEvents,\n      generateMask: opts.generateMask,\n      maxPayload: opts.maxPayload,\n      skipUTF8Validation: opts.skipUTF8Validation\n    });\n  });\n\n  if (opts.finishRequest) {\n    opts.finishRequest(req, websocket);\n  } else {\n    req.end();\n  }\n}\n\n/**\n * Emit the `'error'` and `'close'` events.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {Error} The error to emit\n * @private\n */\nfunction emitErrorAndClose(websocket, err) {\n  websocket._readyState = WebSocket.CLOSING;\n  //\n  // The following assignment is practically useless and is done only for\n  // consistency.\n  //\n  websocket._errorEmitted = true;\n  websocket.emit('error', err);\n  websocket.emitClose();\n}\n\n/**\n * Create a `net.Socket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {net.Socket} The newly created socket used to start the connection\n * @private\n */\nfunction netConnect(options) {\n  options.path = options.socketPath;\n  return net.connect(options);\n}\n\n/**\n * Create a `tls.TLSSocket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {tls.TLSSocket} The newly created socket used to start the connection\n * @private\n */\nfunction tlsConnect(options) {\n  options.path = undefined;\n\n  if (!options.servername && options.servername !== '') {\n    options.servername = net.isIP(options.host) ? '' : options.host;\n  }\n\n  return tls.connect(options);\n}\n\n/**\n * Abort the handshake and emit an error.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to\n *     abort or the socket to destroy\n * @param {String} message The error message\n * @private\n */\nfunction abortHandshake(websocket, stream, message) {\n  websocket._readyState = WebSocket.CLOSING;\n\n  const err = new Error(message);\n  Error.captureStackTrace(err, abortHandshake);\n\n  if (stream.setHeader) {\n    stream[kAborted] = true;\n    stream.abort();\n\n    if (stream.socket && !stream.socket.destroyed) {\n      //\n      // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if\n      // called after the request completed. See\n      // https://github.com/websockets/ws/issues/1869.\n      //\n      stream.socket.destroy();\n    }\n\n    process.nextTick(emitErrorAndClose, websocket, err);\n  } else {\n    stream.destroy(err);\n    stream.once('error', websocket.emit.bind(websocket, 'error'));\n    stream.once('close', websocket.emitClose.bind(websocket));\n  }\n}\n\n/**\n * Handle cases where the `ping()`, `pong()`, or `send()` methods are called\n * when the `readyState` attribute is `CLOSING` or `CLOSED`.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {*} [data] The data to send\n * @param {Function} [cb] Callback\n * @private\n */\nfunction sendAfterClose(websocket, data, cb) {\n  if (data) {\n    const length = isBlob(data) ? data.size : toBuffer(data).length;\n\n    //\n    // The `_bufferedAmount` property is used only when the peer is a client and\n    // the opening handshake fails. Under these circumstances, in fact, the\n    // `setSocket()` method is not called, so the `_socket` and `_sender`\n    // properties are set to `null`.\n    //\n    if (websocket._socket) websocket._sender._bufferedBytes += length;\n    else websocket._bufferedAmount += length;\n  }\n\n  if (cb) {\n    const err = new Error(\n      `WebSocket is not open: readyState ${websocket.readyState} ` +\n        `(${readyStates[websocket.readyState]})`\n    );\n    process.nextTick(cb, err);\n  }\n}\n\n/**\n * The listener of the `Receiver` `'conclude'` event.\n *\n * @param {Number} code The status code\n * @param {Buffer} reason The reason for closing\n * @private\n */\nfunction receiverOnConclude(code, reason) {\n  const websocket = this[kWebSocket];\n\n  websocket._closeFrameReceived = true;\n  websocket._closeMessage = reason;\n  websocket._closeCode = code;\n\n  if (websocket._socket[kWebSocket] === undefined) return;\n\n  websocket._socket.removeListener('data', socketOnData);\n  process.nextTick(resume, websocket._socket);\n\n  if (code === 1005) websocket.close();\n  else websocket.close(code, reason);\n}\n\n/**\n * The listener of the `Receiver` `'drain'` event.\n *\n * @private\n */\nfunction receiverOnDrain() {\n  const websocket = this[kWebSocket];\n\n  if (!websocket.isPaused) websocket._socket.resume();\n}\n\n/**\n * The listener of the `Receiver` `'error'` event.\n *\n * @param {(RangeError|Error)} err The emitted error\n * @private\n */\nfunction receiverOnError(err) {\n  const websocket = this[kWebSocket];\n\n  if (websocket._socket[kWebSocket] !== undefined) {\n    websocket._socket.removeListener('data', socketOnData);\n\n    //\n    // On Node.js < 14.0.0 the `'error'` event is emitted synchronously. See\n    // https://github.com/websockets/ws/issues/1940.\n    //\n    process.nextTick(resume, websocket._socket);\n\n    websocket.close(err[kStatusCode]);\n  }\n\n  if (!websocket._errorEmitted) {\n    websocket._errorEmitted = true;\n    websocket.emit('error', err);\n  }\n}\n\n/**\n * The listener of the `Receiver` `'finish'` event.\n *\n * @private\n */\nfunction receiverOnFinish() {\n  this[kWebSocket].emitClose();\n}\n\n/**\n * The listener of the `Receiver` `'message'` event.\n *\n * @param {Buffer|ArrayBuffer|Buffer[])} data The message\n * @param {Boolean} isBinary Specifies whether the message is binary or not\n * @private\n */\nfunction receiverOnMessage(data, isBinary) {\n  this[kWebSocket].emit('message', data, isBinary);\n}\n\n/**\n * The listener of the `Receiver` `'ping'` event.\n *\n * @param {Buffer} data The data included in the ping frame\n * @private\n */\nfunction receiverOnPing(data) {\n  const websocket = this[kWebSocket];\n\n  if (websocket._autoPong) websocket.pong(data, !this._isServer, NOOP);\n  websocket.emit('ping', data);\n}\n\n/**\n * The listener of the `Receiver` `'pong'` event.\n *\n * @param {Buffer} data The data included in the pong frame\n * @private\n */\nfunction receiverOnPong(data) {\n  this[kWebSocket].emit('pong', data);\n}\n\n/**\n * Resume a readable stream\n *\n * @param {Readable} stream The readable stream\n * @private\n */\nfunction resume(stream) {\n  stream.resume();\n}\n\n/**\n * The `Sender` error event handler.\n *\n * @param {Error} The error\n * @private\n */\nfunction senderOnError(err) {\n  const websocket = this[kWebSocket];\n\n  if (websocket.readyState === WebSocket.CLOSED) return;\n  if (websocket.readyState === WebSocket.OPEN) {\n    websocket._readyState = WebSocket.CLOSING;\n    setCloseTimer(websocket);\n  }\n\n  //\n  // `socket.end()` is used instead of `socket.destroy()` to allow the other\n  // peer to finish sending queued data. There is no need to set a timer here\n  // because `CLOSING` means that it is already set or not needed.\n  //\n  this._socket.end();\n\n  if (!websocket._errorEmitted) {\n    websocket._errorEmitted = true;\n    websocket.emit('error', err);\n  }\n}\n\n/**\n * Set a timer to destroy the underlying raw socket of a WebSocket.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @private\n */\nfunction setCloseTimer(websocket) {\n  websocket._closeTimer = setTimeout(\n    websocket._socket.destroy.bind(websocket._socket),\n    closeTimeout\n  );\n}\n\n/**\n * The listener of the socket `'close'` event.\n *\n * @private\n */\nfunction socketOnClose() {\n  const websocket = this[kWebSocket];\n\n  this.removeListener('close', socketOnClose);\n  this.removeListener('data', socketOnData);\n  this.removeListener('end', socketOnEnd);\n\n  websocket._readyState = WebSocket.CLOSING;\n\n  let chunk;\n\n  //\n  // The close frame might not have been received or the `'end'` event emitted,\n  // for example, if the socket was destroyed due to an error. Ensure that the\n  // `receiver` stream is closed after writing any remaining buffered data to\n  // it. If the readable side of the socket is in flowing mode then there is no\n  // buffered data as everything has been already written and `readable.read()`\n  // will return `null`. If instead, the socket is paused, any possible buffered\n  // data will be read as a single chunk.\n  //\n  if (\n    !this._readableState.endEmitted &&\n    !websocket._closeFrameReceived &&\n    !websocket._receiver._writableState.errorEmitted &&\n    (chunk = websocket._socket.read()) !== null\n  ) {\n    websocket._receiver.write(chunk);\n  }\n\n  websocket._receiver.end();\n\n  this[kWebSocket] = undefined;\n\n  clearTimeout(websocket._closeTimer);\n\n  if (\n    websocket._receiver._writableState.finished ||\n    websocket._receiver._writableState.errorEmitted\n  ) {\n    websocket.emitClose();\n  } else {\n    websocket._receiver.on('error', receiverOnFinish);\n    websocket._receiver.on('finish', receiverOnFinish);\n  }\n}\n\n/**\n * The listener of the socket `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction socketOnData(chunk) {\n  if (!this[kWebSocket]._receiver.write(chunk)) {\n    this.pause();\n  }\n}\n\n/**\n * The listener of the socket `'end'` event.\n *\n * @private\n */\nfunction socketOnEnd() {\n  const websocket = this[kWebSocket];\n\n  websocket._readyState = WebSocket.CLOSING;\n  websocket._receiver.end();\n  this.end();\n}\n\n/**\n * The listener of the socket `'error'` event.\n *\n * @private\n */\nfunction socketOnError() {\n  const websocket = this[kWebSocket];\n\n  this.removeListener('error', socketOnError);\n  this.on('error', NOOP);\n\n  if (websocket) {\n    websocket._readyState = WebSocket.CLOSING;\n    this.destroy();\n  }\n}\n","module.exports = require(\"events\");","module.exports = require(\"https\");","module.exports = require(\"http\");","module.exports = require(\"tls\");","module.exports = require(\"stream\");","'use strict';\n\nconst zlib = require('zlib');\n\nconst bufferUtil = require('./buffer-util');\nconst Limiter = require('./limiter');\nconst { kStatusCode } = require('./constants');\n\nconst FastBuffer = Buffer[Symbol.species];\nconst TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);\nconst kPerMessageDeflate = Symbol('permessage-deflate');\nconst kTotalLength = Symbol('total-length');\nconst kCallback = Symbol('callback');\nconst kBuffers = Symbol('buffers');\nconst kError = Symbol('error');\n\n//\n// We limit zlib concurrency, which prevents severe memory fragmentation\n// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913\n// and https://github.com/websockets/ws/issues/1202\n//\n// Intentionally global; it's the global thread pool that's an issue.\n//\nlet zlibLimiter;\n\n/**\n * permessage-deflate implementation.\n */\nclass PerMessageDeflate {\n  /**\n   * Creates a PerMessageDeflate instance.\n   *\n   * @param {Object} [options] Configuration options\n   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support\n   *     for, or request, a custom client window size\n   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/\n   *     acknowledge disabling of client context takeover\n   * @param {Number} [options.concurrencyLimit=10] The number of concurrent\n   *     calls to zlib\n   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the\n   *     use of a custom server window size\n   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept\n   *     disabling of server context takeover\n   * @param {Number} [options.threshold=1024] Size (in bytes) below which\n   *     messages should not be compressed if context takeover is disabled\n   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on\n   *     deflate\n   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on\n   *     inflate\n   * @param {Boolean} [isServer=false] Create the instance in either server or\n   *     client mode\n   * @param {Number} [maxPayload=0] The maximum allowed message length\n   */\n  constructor(options, isServer, maxPayload) {\n    this._maxPayload = maxPayload | 0;\n    this._options = options || {};\n    this._threshold =\n      this._options.threshold !== undefined ? this._options.threshold : 1024;\n    this._isServer = !!isServer;\n    this._deflate = null;\n    this._inflate = null;\n\n    this.params = null;\n\n    if (!zlibLimiter) {\n      const concurrency =\n        this._options.concurrencyLimit !== undefined\n          ? this._options.concurrencyLimit\n          : 10;\n      zlibLimiter = new Limiter(concurrency);\n    }\n  }\n\n  /**\n   * @type {String}\n   */\n  static get extensionName() {\n    return 'permessage-deflate';\n  }\n\n  /**\n   * Create an extension negotiation offer.\n   *\n   * @return {Object} Extension parameters\n   * @public\n   */\n  offer() {\n    const params = {};\n\n    if (this._options.serverNoContextTakeover) {\n      params.server_no_context_takeover = true;\n    }\n    if (this._options.clientNoContextTakeover) {\n      params.client_no_context_takeover = true;\n    }\n    if (this._options.serverMaxWindowBits) {\n      params.server_max_window_bits = this._options.serverMaxWindowBits;\n    }\n    if (this._options.clientMaxWindowBits) {\n      params.client_max_window_bits = this._options.clientMaxWindowBits;\n    } else if (this._options.clientMaxWindowBits == null) {\n      params.client_max_window_bits = true;\n    }\n\n    return params;\n  }\n\n  /**\n   * Accept an extension negotiation offer/response.\n   *\n   * @param {Array} configurations The extension negotiation offers/reponse\n   * @return {Object} Accepted configuration\n   * @public\n   */\n  accept(configurations) {\n    configurations = this.normalizeParams(configurations);\n\n    this.params = this._isServer\n      ? this.acceptAsServer(configurations)\n      : this.acceptAsClient(configurations);\n\n    return this.params;\n  }\n\n  /**\n   * Releases all resources used by the extension.\n   *\n   * @public\n   */\n  cleanup() {\n    if (this._inflate) {\n      this._inflate.close();\n      this._inflate = null;\n    }\n\n    if (this._deflate) {\n      const callback = this._deflate[kCallback];\n\n      this._deflate.close();\n      this._deflate = null;\n\n      if (callback) {\n        callback(\n          new Error(\n            'The deflate stream was closed while data was being processed'\n          )\n        );\n      }\n    }\n  }\n\n  /**\n   *  Accept an extension negotiation offer.\n   *\n   * @param {Array} offers The extension negotiation offers\n   * @return {Object} Accepted configuration\n   * @private\n   */\n  acceptAsServer(offers) {\n    const opts = this._options;\n    const accepted = offers.find((params) => {\n      if (\n        (opts.serverNoContextTakeover === false &&\n          params.server_no_context_takeover) ||\n        (params.server_max_window_bits &&\n          (opts.serverMaxWindowBits === false ||\n            (typeof opts.serverMaxWindowBits === 'number' &&\n              opts.serverMaxWindowBits > params.server_max_window_bits))) ||\n        (typeof opts.clientMaxWindowBits === 'number' &&\n          !params.client_max_window_bits)\n      ) {\n        return false;\n      }\n\n      return true;\n    });\n\n    if (!accepted) {\n      throw new Error('None of the extension offers can be accepted');\n    }\n\n    if (opts.serverNoContextTakeover) {\n      accepted.server_no_context_takeover = true;\n    }\n    if (opts.clientNoContextTakeover) {\n      accepted.client_no_context_takeover = true;\n    }\n    if (typeof opts.serverMaxWindowBits === 'number') {\n      accepted.server_max_window_bits = opts.serverMaxWindowBits;\n    }\n    if (typeof opts.clientMaxWindowBits === 'number') {\n      accepted.client_max_window_bits = opts.clientMaxWindowBits;\n    } else if (\n      accepted.client_max_window_bits === true ||\n      opts.clientMaxWindowBits === false\n    ) {\n      delete accepted.client_max_window_bits;\n    }\n\n    return accepted;\n  }\n\n  /**\n   * Accept the extension negotiation response.\n   *\n   * @param {Array} response The extension negotiation response\n   * @return {Object} Accepted configuration\n   * @private\n   */\n  acceptAsClient(response) {\n    const params = response[0];\n\n    if (\n      this._options.clientNoContextTakeover === false &&\n      params.client_no_context_takeover\n    ) {\n      throw new Error('Unexpected parameter \"client_no_context_takeover\"');\n    }\n\n    if (!params.client_max_window_bits) {\n      if (typeof this._options.clientMaxWindowBits === 'number') {\n        params.client_max_window_bits = this._options.clientMaxWindowBits;\n      }\n    } else if (\n      this._options.clientMaxWindowBits === false ||\n      (typeof this._options.clientMaxWindowBits === 'number' &&\n        params.client_max_window_bits > this._options.clientMaxWindowBits)\n    ) {\n      throw new Error(\n        'Unexpected or invalid parameter \"client_max_window_bits\"'\n      );\n    }\n\n    return params;\n  }\n\n  /**\n   * Normalize parameters.\n   *\n   * @param {Array} configurations The extension negotiation offers/reponse\n   * @return {Array} The offers/response with normalized parameters\n   * @private\n   */\n  normalizeParams(configurations) {\n    configurations.forEach((params) => {\n      Object.keys(params).forEach((key) => {\n        let value = params[key];\n\n        if (value.length > 1) {\n          throw new Error(`Parameter \"${key}\" must have only a single value`);\n        }\n\n        value = value[0];\n\n        if (key === 'client_max_window_bits') {\n          if (value !== true) {\n            const num = +value;\n            if (!Number.isInteger(num) || num < 8 || num > 15) {\n              throw new TypeError(\n                `Invalid value for parameter \"${key}\": ${value}`\n              );\n            }\n            value = num;\n          } else if (!this._isServer) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n        } else if (key === 'server_max_window_bits') {\n          const num = +value;\n          if (!Number.isInteger(num) || num < 8 || num > 15) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n          value = num;\n        } else if (\n          key === 'client_no_context_takeover' ||\n          key === 'server_no_context_takeover'\n        ) {\n          if (value !== true) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n        } else {\n          throw new Error(`Unknown parameter \"${key}\"`);\n        }\n\n        params[key] = value;\n      });\n    });\n\n    return configurations;\n  }\n\n  /**\n   * Decompress data. Concurrency limited.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */\n  decompress(data, fin, callback) {\n    zlibLimiter.add((done) => {\n      this._decompress(data, fin, (err, result) => {\n        done();\n        callback(err, result);\n      });\n    });\n  }\n\n  /**\n   * Compress data. Concurrency limited.\n   *\n   * @param {(Buffer|String)} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */\n  compress(data, fin, callback) {\n    zlibLimiter.add((done) => {\n      this._compress(data, fin, (err, result) => {\n        done();\n        callback(err, result);\n      });\n    });\n  }\n\n  /**\n   * Decompress data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */\n  _decompress(data, fin, callback) {\n    const endpoint = this._isServer ? 'client' : 'server';\n\n    if (!this._inflate) {\n      const key = `${endpoint}_max_window_bits`;\n      const windowBits =\n        typeof this.params[key] !== 'number'\n          ? zlib.Z_DEFAULT_WINDOWBITS\n          : this.params[key];\n\n      this._inflate = zlib.createInflateRaw({\n        ...this._options.zlibInflateOptions,\n        windowBits\n      });\n      this._inflate[kPerMessageDeflate] = this;\n      this._inflate[kTotalLength] = 0;\n      this._inflate[kBuffers] = [];\n      this._inflate.on('error', inflateOnError);\n      this._inflate.on('data', inflateOnData);\n    }\n\n    this._inflate[kCallback] = callback;\n\n    this._inflate.write(data);\n    if (fin) this._inflate.write(TRAILER);\n\n    this._inflate.flush(() => {\n      const err = this._inflate[kError];\n\n      if (err) {\n        this._inflate.close();\n        this._inflate = null;\n        callback(err);\n        return;\n      }\n\n      const data = bufferUtil.concat(\n        this._inflate[kBuffers],\n        this._inflate[kTotalLength]\n      );\n\n      if (this._inflate._readableState.endEmitted) {\n        this._inflate.close();\n        this._inflate = null;\n      } else {\n        this._inflate[kTotalLength] = 0;\n        this._inflate[kBuffers] = [];\n\n        if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n          this._inflate.reset();\n        }\n      }\n\n      callback(null, data);\n    });\n  }\n\n  /**\n   * Compress data.\n   *\n   * @param {(Buffer|String)} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */\n  _compress(data, fin, callback) {\n    const endpoint = this._isServer ? 'server' : 'client';\n\n    if (!this._deflate) {\n      const key = `${endpoint}_max_window_bits`;\n      const windowBits =\n        typeof this.params[key] !== 'number'\n          ? zlib.Z_DEFAULT_WINDOWBITS\n          : this.params[key];\n\n      this._deflate = zlib.createDeflateRaw({\n        ...this._options.zlibDeflateOptions,\n        windowBits\n      });\n\n      this._deflate[kTotalLength] = 0;\n      this._deflate[kBuffers] = [];\n\n      this._deflate.on('data', deflateOnData);\n    }\n\n    this._deflate[kCallback] = callback;\n\n    this._deflate.write(data);\n    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {\n      if (!this._deflate) {\n        //\n        // The deflate stream was closed while data was being processed.\n        //\n        return;\n      }\n\n      let data = bufferUtil.concat(\n        this._deflate[kBuffers],\n        this._deflate[kTotalLength]\n      );\n\n      if (fin) {\n        data = new FastBuffer(data.buffer, data.byteOffset, data.length - 4);\n      }\n\n      //\n      // Ensure that the callback will not be called again in\n      // `PerMessageDeflate#cleanup()`.\n      //\n      this._deflate[kCallback] = null;\n\n      this._deflate[kTotalLength] = 0;\n      this._deflate[kBuffers] = [];\n\n      if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n        this._deflate.reset();\n      }\n\n      callback(null, data);\n    });\n  }\n}\n\nmodule.exports = PerMessageDeflate;\n\n/**\n * The listener of the `zlib.DeflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction deflateOnData(chunk) {\n  this[kBuffers].push(chunk);\n  this[kTotalLength] += chunk.length;\n}\n\n/**\n * The listener of the `zlib.InflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction inflateOnData(chunk) {\n  this[kTotalLength] += chunk.length;\n\n  if (\n    this[kPerMessageDeflate]._maxPayload < 1 ||\n    this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload\n  ) {\n    this[kBuffers].push(chunk);\n    return;\n  }\n\n  this[kError] = new RangeError('Max payload size exceeded');\n  this[kError].code = 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH';\n  this[kError][kStatusCode] = 1009;\n  this.removeListener('data', inflateOnData);\n\n  //\n  // The choice to employ `zlib.reset()` over `zlib.close()` is dictated by the\n  // fact that in Node.js versions prior to 13.10.0, the callback for\n  // `zlib.flush()` is not called if `zlib.close()` is used. Utilizing\n  // `zlib.reset()` ensures that either the callback is invoked or an error is\n  // emitted.\n  //\n  this.reset();\n}\n\n/**\n * The listener of the `zlib.InflateRaw` stream `'error'` event.\n *\n * @param {Error} err The emitted error\n * @private\n */\nfunction inflateOnError(err) {\n  //\n  // There is no need to call `Zlib#close()` as the handle is automatically\n  // closed when an error is emitted.\n  //\n  this[kPerMessageDeflate]._inflate = null;\n\n  if (this[kError]) {\n    this[kCallback](this[kError]);\n    return;\n  }\n\n  err[kStatusCode] = 1007;\n  this[kCallback](err);\n}\n","module.exports = require(\"zlib\");","'use strict';\n\nconst { EMPTY_BUFFER } = require('./constants');\n\nconst FastBuffer = Buffer[Symbol.species];\n\n/**\n * Merges an array of buffers into a new buffer.\n *\n * @param {Buffer[]} list The array of buffers to concat\n * @param {Number} totalLength The total length of buffers in the list\n * @return {Buffer} The resulting buffer\n * @public\n */\nfunction concat(list, totalLength) {\n  if (list.length === 0) return EMPTY_BUFFER;\n  if (list.length === 1) return list[0];\n\n  const target = Buffer.allocUnsafe(totalLength);\n  let offset = 0;\n\n  for (let i = 0; i < list.length; i++) {\n    const buf = list[i];\n    target.set(buf, offset);\n    offset += buf.length;\n  }\n\n  if (offset < totalLength) {\n    return new FastBuffer(target.buffer, target.byteOffset, offset);\n  }\n\n  return target;\n}\n\n/**\n * Masks a buffer using the given mask.\n *\n * @param {Buffer} source The buffer to mask\n * @param {Buffer} mask The mask to use\n * @param {Buffer} output The buffer where to store the result\n * @param {Number} offset The offset at which to start writing\n * @param {Number} length The number of bytes to mask.\n * @public\n */\nfunction _mask(source, mask, output, offset, length) {\n  for (let i = 0; i < length; i++) {\n    output[offset + i] = source[i] ^ mask[i & 3];\n  }\n}\n\n/**\n * Unmasks a buffer using the given mask.\n *\n * @param {Buffer} buffer The buffer to unmask\n * @param {Buffer} mask The mask to use\n * @public\n */\nfunction _unmask(buffer, mask) {\n  for (let i = 0; i < buffer.length; i++) {\n    buffer[i] ^= mask[i & 3];\n  }\n}\n\n/**\n * Converts a buffer to an `ArrayBuffer`.\n *\n * @param {Buffer} buf The buffer to convert\n * @return {ArrayBuffer} Converted buffer\n * @public\n */\nfunction toArrayBuffer(buf) {\n  if (buf.length === buf.buffer.byteLength) {\n    return buf.buffer;\n  }\n\n  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);\n}\n\n/**\n * Converts `data` to a `Buffer`.\n *\n * @param {*} data The data to convert\n * @return {Buffer} The buffer\n * @throws {TypeError}\n * @public\n */\nfunction toBuffer(data) {\n  toBuffer.readOnly = true;\n\n  if (Buffer.isBuffer(data)) return data;\n\n  let buf;\n\n  if (data instanceof ArrayBuffer) {\n    buf = new FastBuffer(data);\n  } else if (ArrayBuffer.isView(data)) {\n    buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);\n  } else {\n    buf = Buffer.from(data);\n    toBuffer.readOnly = false;\n  }\n\n  return buf;\n}\n\nmodule.exports = {\n  concat,\n  mask: _mask,\n  toArrayBuffer,\n  toBuffer,\n  unmask: _unmask\n};\n\n/* istanbul ignore else  */\nif (!process.env.WS_NO_BUFFER_UTIL) {\n  try {\n    const bufferUtil = require('bufferutil');\n\n    module.exports.mask = function (source, mask, output, offset, length) {\n      if (length < 48) _mask(source, mask, output, offset, length);\n      else bufferUtil.mask(source, mask, output, offset, length);\n    };\n\n    module.exports.unmask = function (buffer, mask) {\n      if (buffer.length < 32) _unmask(buffer, mask);\n      else bufferUtil.unmask(buffer, mask);\n    };\n  } catch (e) {\n    // Continue regardless of the error.\n  }\n}\n","'use strict';\n\nconst BINARY_TYPES = ['nodebuffer', 'arraybuffer', 'fragments'];\nconst hasBlob = typeof Blob !== 'undefined';\n\nif (hasBlob) BINARY_TYPES.push('blob');\n\nmodule.exports = {\n  BINARY_TYPES,\n  EMPTY_BUFFER: Buffer.alloc(0),\n  GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',\n  hasBlob,\n  kForOnEventAttribute: Symbol('kIsForOnEventAttribute'),\n  kListener: Symbol('kListener'),\n  kStatusCode: Symbol('status-code'),\n  kWebSocket: Symbol('websocket'),\n  NOOP: () => {}\n};\n","module.exports = require(\"bufferutil\");","'use strict';\n\nconst kDone = Symbol('kDone');\nconst kRun = Symbol('kRun');\n\n/**\n * A very simple job queue with adjustable concurrency. Adapted from\n * https://github.com/STRML/async-limiter\n */\nclass Limiter {\n  /**\n   * Creates a new `Limiter`.\n   *\n   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed\n   *     to run concurrently\n   */\n  constructor(concurrency) {\n    this[kDone] = () => {\n      this.pending--;\n      this[kRun]();\n    };\n    this.concurrency = concurrency || Infinity;\n    this.jobs = [];\n    this.pending = 0;\n  }\n\n  /**\n   * Adds a job to the queue.\n   *\n   * @param {Function} job The job to run\n   * @public\n   */\n  add(job) {\n    this.jobs.push(job);\n    this[kRun]();\n  }\n\n  /**\n   * Removes a job from the queue and runs it if possible.\n   *\n   * @private\n   */\n  [kRun]() {\n    if (this.pending === this.concurrency) return;\n\n    if (this.jobs.length) {\n      const job = this.jobs.shift();\n\n      this.pending++;\n      job(this[kDone]);\n    }\n  }\n}\n\nmodule.exports = Limiter;\n","'use strict';\n\nconst { Writable } = require('stream');\n\nconst PerMessageDeflate = require('./permessage-deflate');\nconst {\n  BINARY_TYPES,\n  EMPTY_BUFFER,\n  kStatusCode,\n  kWebSocket\n} = require('./constants');\nconst { concat, toArrayBuffer, unmask } = require('./buffer-util');\nconst { isValidStatusCode, isValidUTF8 } = require('./validation');\n\nconst FastBuffer = Buffer[Symbol.species];\n\nconst GET_INFO = 0;\nconst GET_PAYLOAD_LENGTH_16 = 1;\nconst GET_PAYLOAD_LENGTH_64 = 2;\nconst GET_MASK = 3;\nconst GET_DATA = 4;\nconst INFLATING = 5;\nconst DEFER_EVENT = 6;\n\n/**\n * HyBi Receiver implementation.\n *\n * @extends Writable\n */\nclass Receiver extends Writable {\n  /**\n   * Creates a Receiver instance.\n   *\n   * @param {Object} [options] Options object\n   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether\n   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted\n   *     multiple times in the same tick\n   * @param {String} [options.binaryType=nodebuffer] The type for binary data\n   * @param {Object} [options.extensions] An object containing the negotiated\n   *     extensions\n   * @param {Boolean} [options.isServer=false] Specifies whether to operate in\n   *     client or server mode\n   * @param {Number} [options.maxPayload=0] The maximum allowed message length\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   */\n  constructor(options = {}) {\n    super();\n\n    this._allowSynchronousEvents =\n      options.allowSynchronousEvents !== undefined\n        ? options.allowSynchronousEvents\n        : true;\n    this._binaryType = options.binaryType || BINARY_TYPES[0];\n    this._extensions = options.extensions || {};\n    this._isServer = !!options.isServer;\n    this._maxPayload = options.maxPayload | 0;\n    this._skipUTF8Validation = !!options.skipUTF8Validation;\n    this[kWebSocket] = undefined;\n\n    this._bufferedBytes = 0;\n    this._buffers = [];\n\n    this._compressed = false;\n    this._payloadLength = 0;\n    this._mask = undefined;\n    this._fragmented = 0;\n    this._masked = false;\n    this._fin = false;\n    this._opcode = 0;\n\n    this._totalPayloadLength = 0;\n    this._messageLength = 0;\n    this._fragments = [];\n\n    this._errored = false;\n    this._loop = false;\n    this._state = GET_INFO;\n  }\n\n  /**\n   * Implements `Writable.prototype._write()`.\n   *\n   * @param {Buffer} chunk The chunk of data to write\n   * @param {String} encoding The character encoding of `chunk`\n   * @param {Function} cb Callback\n   * @private\n   */\n  _write(chunk, encoding, cb) {\n    if (this._opcode === 0x08 && this._state == GET_INFO) return cb();\n\n    this._bufferedBytes += chunk.length;\n    this._buffers.push(chunk);\n    this.startLoop(cb);\n  }\n\n  /**\n   * Consumes `n` bytes from the buffered data.\n   *\n   * @param {Number} n The number of bytes to consume\n   * @return {Buffer} The consumed bytes\n   * @private\n   */\n  consume(n) {\n    this._bufferedBytes -= n;\n\n    if (n === this._buffers[0].length) return this._buffers.shift();\n\n    if (n < this._buffers[0].length) {\n      const buf = this._buffers[0];\n      this._buffers[0] = new FastBuffer(\n        buf.buffer,\n        buf.byteOffset + n,\n        buf.length - n\n      );\n\n      return new FastBuffer(buf.buffer, buf.byteOffset, n);\n    }\n\n    const dst = Buffer.allocUnsafe(n);\n\n    do {\n      const buf = this._buffers[0];\n      const offset = dst.length - n;\n\n      if (n >= buf.length) {\n        dst.set(this._buffers.shift(), offset);\n      } else {\n        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);\n        this._buffers[0] = new FastBuffer(\n          buf.buffer,\n          buf.byteOffset + n,\n          buf.length - n\n        );\n      }\n\n      n -= buf.length;\n    } while (n > 0);\n\n    return dst;\n  }\n\n  /**\n   * Starts the parsing loop.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  startLoop(cb) {\n    this._loop = true;\n\n    do {\n      switch (this._state) {\n        case GET_INFO:\n          this.getInfo(cb);\n          break;\n        case GET_PAYLOAD_LENGTH_16:\n          this.getPayloadLength16(cb);\n          break;\n        case GET_PAYLOAD_LENGTH_64:\n          this.getPayloadLength64(cb);\n          break;\n        case GET_MASK:\n          this.getMask();\n          break;\n        case GET_DATA:\n          this.getData(cb);\n          break;\n        case INFLATING:\n        case DEFER_EVENT:\n          this._loop = false;\n          return;\n      }\n    } while (this._loop);\n\n    if (!this._errored) cb();\n  }\n\n  /**\n   * Reads the first two bytes of a frame.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  getInfo(cb) {\n    if (this._bufferedBytes < 2) {\n      this._loop = false;\n      return;\n    }\n\n    const buf = this.consume(2);\n\n    if ((buf[0] & 0x30) !== 0x00) {\n      const error = this.createError(\n        RangeError,\n        'RSV2 and RSV3 must be clear',\n        true,\n        1002,\n        'WS_ERR_UNEXPECTED_RSV_2_3'\n      );\n\n      cb(error);\n      return;\n    }\n\n    const compressed = (buf[0] & 0x40) === 0x40;\n\n    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {\n      const error = this.createError(\n        RangeError,\n        'RSV1 must be clear',\n        true,\n        1002,\n        'WS_ERR_UNEXPECTED_RSV_1'\n      );\n\n      cb(error);\n      return;\n    }\n\n    this._fin = (buf[0] & 0x80) === 0x80;\n    this._opcode = buf[0] & 0x0f;\n    this._payloadLength = buf[1] & 0x7f;\n\n    if (this._opcode === 0x00) {\n      if (compressed) {\n        const error = this.createError(\n          RangeError,\n          'RSV1 must be clear',\n          true,\n          1002,\n          'WS_ERR_UNEXPECTED_RSV_1'\n        );\n\n        cb(error);\n        return;\n      }\n\n      if (!this._fragmented) {\n        const error = this.createError(\n          RangeError,\n          'invalid opcode 0',\n          true,\n          1002,\n          'WS_ERR_INVALID_OPCODE'\n        );\n\n        cb(error);\n        return;\n      }\n\n      this._opcode = this._fragmented;\n    } else if (this._opcode === 0x01 || this._opcode === 0x02) {\n      if (this._fragmented) {\n        const error = this.createError(\n          RangeError,\n          `invalid opcode ${this._opcode}`,\n          true,\n          1002,\n          'WS_ERR_INVALID_OPCODE'\n        );\n\n        cb(error);\n        return;\n      }\n\n      this._compressed = compressed;\n    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {\n      if (!this._fin) {\n        const error = this.createError(\n          RangeError,\n          'FIN must be set',\n          true,\n          1002,\n          'WS_ERR_EXPECTED_FIN'\n        );\n\n        cb(error);\n        return;\n      }\n\n      if (compressed) {\n        const error = this.createError(\n          RangeError,\n          'RSV1 must be clear',\n          true,\n          1002,\n          'WS_ERR_UNEXPECTED_RSV_1'\n        );\n\n        cb(error);\n        return;\n      }\n\n      if (\n        this._payloadLength > 0x7d ||\n        (this._opcode === 0x08 && this._payloadLength === 1)\n      ) {\n        const error = this.createError(\n          RangeError,\n          `invalid payload length ${this._payloadLength}`,\n          true,\n          1002,\n          'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH'\n        );\n\n        cb(error);\n        return;\n      }\n    } else {\n      const error = this.createError(\n        RangeError,\n        `invalid opcode ${this._opcode}`,\n        true,\n        1002,\n        'WS_ERR_INVALID_OPCODE'\n      );\n\n      cb(error);\n      return;\n    }\n\n    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;\n    this._masked = (buf[1] & 0x80) === 0x80;\n\n    if (this._isServer) {\n      if (!this._masked) {\n        const error = this.createError(\n          RangeError,\n          'MASK must be set',\n          true,\n          1002,\n          'WS_ERR_EXPECTED_MASK'\n        );\n\n        cb(error);\n        return;\n      }\n    } else if (this._masked) {\n      const error = this.createError(\n        RangeError,\n        'MASK must be clear',\n        true,\n        1002,\n        'WS_ERR_UNEXPECTED_MASK'\n      );\n\n      cb(error);\n      return;\n    }\n\n    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;\n    else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;\n    else this.haveLength(cb);\n  }\n\n  /**\n   * Gets extended payload length (7+16).\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  getPayloadLength16(cb) {\n    if (this._bufferedBytes < 2) {\n      this._loop = false;\n      return;\n    }\n\n    this._payloadLength = this.consume(2).readUInt16BE(0);\n    this.haveLength(cb);\n  }\n\n  /**\n   * Gets extended payload length (7+64).\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  getPayloadLength64(cb) {\n    if (this._bufferedBytes < 8) {\n      this._loop = false;\n      return;\n    }\n\n    const buf = this.consume(8);\n    const num = buf.readUInt32BE(0);\n\n    //\n    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned\n    // if payload length is greater than this number.\n    //\n    if (num > Math.pow(2, 53 - 32) - 1) {\n      const error = this.createError(\n        RangeError,\n        'Unsupported WebSocket frame: payload length > 2^53 - 1',\n        false,\n        1009,\n        'WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH'\n      );\n\n      cb(error);\n      return;\n    }\n\n    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);\n    this.haveLength(cb);\n  }\n\n  /**\n   * Payload length has been read.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  haveLength(cb) {\n    if (this._payloadLength && this._opcode < 0x08) {\n      this._totalPayloadLength += this._payloadLength;\n      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {\n        const error = this.createError(\n          RangeError,\n          'Max payload size exceeded',\n          false,\n          1009,\n          'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'\n        );\n\n        cb(error);\n        return;\n      }\n    }\n\n    if (this._masked) this._state = GET_MASK;\n    else this._state = GET_DATA;\n  }\n\n  /**\n   * Reads mask bytes.\n   *\n   * @private\n   */\n  getMask() {\n    if (this._bufferedBytes < 4) {\n      this._loop = false;\n      return;\n    }\n\n    this._mask = this.consume(4);\n    this._state = GET_DATA;\n  }\n\n  /**\n   * Reads data bytes.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  getData(cb) {\n    let data = EMPTY_BUFFER;\n\n    if (this._payloadLength) {\n      if (this._bufferedBytes < this._payloadLength) {\n        this._loop = false;\n        return;\n      }\n\n      data = this.consume(this._payloadLength);\n\n      if (\n        this._masked &&\n        (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0\n      ) {\n        unmask(data, this._mask);\n      }\n    }\n\n    if (this._opcode > 0x07) {\n      this.controlMessage(data, cb);\n      return;\n    }\n\n    if (this._compressed) {\n      this._state = INFLATING;\n      this.decompress(data, cb);\n      return;\n    }\n\n    if (data.length) {\n      //\n      // This message is not compressed so its length is the sum of the payload\n      // length of all fragments.\n      //\n      this._messageLength = this._totalPayloadLength;\n      this._fragments.push(data);\n    }\n\n    this.dataMessage(cb);\n  }\n\n  /**\n   * Decompresses data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Function} cb Callback\n   * @private\n   */\n  decompress(data, cb) {\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n\n    perMessageDeflate.decompress(data, this._fin, (err, buf) => {\n      if (err) return cb(err);\n\n      if (buf.length) {\n        this._messageLength += buf.length;\n        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {\n          const error = this.createError(\n            RangeError,\n            'Max payload size exceeded',\n            false,\n            1009,\n            'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'\n          );\n\n          cb(error);\n          return;\n        }\n\n        this._fragments.push(buf);\n      }\n\n      this.dataMessage(cb);\n      if (this._state === GET_INFO) this.startLoop(cb);\n    });\n  }\n\n  /**\n   * Handles a data message.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  dataMessage(cb) {\n    if (!this._fin) {\n      this._state = GET_INFO;\n      return;\n    }\n\n    const messageLength = this._messageLength;\n    const fragments = this._fragments;\n\n    this._totalPayloadLength = 0;\n    this._messageLength = 0;\n    this._fragmented = 0;\n    this._fragments = [];\n\n    if (this._opcode === 2) {\n      let data;\n\n      if (this._binaryType === 'nodebuffer') {\n        data = concat(fragments, messageLength);\n      } else if (this._binaryType === 'arraybuffer') {\n        data = toArrayBuffer(concat(fragments, messageLength));\n      } else if (this._binaryType === 'blob') {\n        data = new Blob(fragments);\n      } else {\n        data = fragments;\n      }\n\n      if (this._allowSynchronousEvents) {\n        this.emit('message', data, true);\n        this._state = GET_INFO;\n      } else {\n        this._state = DEFER_EVENT;\n        setImmediate(() => {\n          this.emit('message', data, true);\n          this._state = GET_INFO;\n          this.startLoop(cb);\n        });\n      }\n    } else {\n      const buf = concat(fragments, messageLength);\n\n      if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\n        const error = this.createError(\n          Error,\n          'invalid UTF-8 sequence',\n          true,\n          1007,\n          'WS_ERR_INVALID_UTF8'\n        );\n\n        cb(error);\n        return;\n      }\n\n      if (this._state === INFLATING || this._allowSynchronousEvents) {\n        this.emit('message', buf, false);\n        this._state = GET_INFO;\n      } else {\n        this._state = DEFER_EVENT;\n        setImmediate(() => {\n          this.emit('message', buf, false);\n          this._state = GET_INFO;\n          this.startLoop(cb);\n        });\n      }\n    }\n  }\n\n  /**\n   * Handles a control message.\n   *\n   * @param {Buffer} data Data to handle\n   * @return {(Error|RangeError|undefined)} A possible error\n   * @private\n   */\n  controlMessage(data, cb) {\n    if (this._opcode === 0x08) {\n      if (data.length === 0) {\n        this._loop = false;\n        this.emit('conclude', 1005, EMPTY_BUFFER);\n        this.end();\n      } else {\n        const code = data.readUInt16BE(0);\n\n        if (!isValidStatusCode(code)) {\n          const error = this.createError(\n            RangeError,\n            `invalid status code ${code}`,\n            true,\n            1002,\n            'WS_ERR_INVALID_CLOSE_CODE'\n          );\n\n          cb(error);\n          return;\n        }\n\n        const buf = new FastBuffer(\n          data.buffer,\n          data.byteOffset + 2,\n          data.length - 2\n        );\n\n        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\n          const error = this.createError(\n            Error,\n            'invalid UTF-8 sequence',\n            true,\n            1007,\n            'WS_ERR_INVALID_UTF8'\n          );\n\n          cb(error);\n          return;\n        }\n\n        this._loop = false;\n        this.emit('conclude', code, buf);\n        this.end();\n      }\n\n      this._state = GET_INFO;\n      return;\n    }\n\n    if (this._allowSynchronousEvents) {\n      this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);\n      this._state = GET_INFO;\n    } else {\n      this._state = DEFER_EVENT;\n      setImmediate(() => {\n        this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);\n        this._state = GET_INFO;\n        this.startLoop(cb);\n      });\n    }\n  }\n\n  /**\n   * Builds an error object.\n   *\n   * @param {function(new:Error|RangeError)} ErrorCtor The error constructor\n   * @param {String} message The error message\n   * @param {Boolean} prefix Specifies whether or not to add a default prefix to\n   *     `message`\n   * @param {Number} statusCode The status code\n   * @param {String} errorCode The exposed error code\n   * @return {(Error|RangeError)} The error\n   * @private\n   */\n  createError(ErrorCtor, message, prefix, statusCode, errorCode) {\n    this._loop = false;\n    this._errored = true;\n\n    const err = new ErrorCtor(\n      prefix ? `Invalid WebSocket frame: ${message}` : message\n    );\n\n    Error.captureStackTrace(err, this.createError);\n    err.code = errorCode;\n    err[kStatusCode] = statusCode;\n    return err;\n  }\n}\n\nmodule.exports = Receiver;\n","'use strict';\n\nconst { isUtf8 } = require('buffer');\n\nconst { hasBlob } = require('./constants');\n\n//\n// Allowed token characters:\n//\n// '!', '#', '$', '%', '&', ''', '*', '+', '-',\n// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'\n//\n// tokenChars[32] === 0 // ' '\n// tokenChars[33] === 1 // '!'\n// tokenChars[34] === 0 // '\"'\n// ...\n//\n// prettier-ignore\nconst tokenChars = [\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31\n  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127\n];\n\n/**\n * Checks if a status code is allowed in a close frame.\n *\n * @param {Number} code The status code\n * @return {Boolean} `true` if the status code is valid, else `false`\n * @public\n */\nfunction isValidStatusCode(code) {\n  return (\n    (code >= 1000 &&\n      code <= 1014 &&\n      code !== 1004 &&\n      code !== 1005 &&\n      code !== 1006) ||\n    (code >= 3000 && code <= 4999)\n  );\n}\n\n/**\n * Checks if a given buffer contains only correct UTF-8.\n * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by\n * Markus Kuhn.\n *\n * @param {Buffer} buf The buffer to check\n * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`\n * @public\n */\nfunction _isValidUTF8(buf) {\n  const len = buf.length;\n  let i = 0;\n\n  while (i < len) {\n    if ((buf[i] & 0x80) === 0) {\n      // 0xxxxxxx\n      i++;\n    } else if ((buf[i] & 0xe0) === 0xc0) {\n      // 110xxxxx 10xxxxxx\n      if (\n        i + 1 === len ||\n        (buf[i + 1] & 0xc0) !== 0x80 ||\n        (buf[i] & 0xfe) === 0xc0 // Overlong\n      ) {\n        return false;\n      }\n\n      i += 2;\n    } else if ((buf[i] & 0xf0) === 0xe0) {\n      // 1110xxxx 10xxxxxx 10xxxxxx\n      if (\n        i + 2 >= len ||\n        (buf[i + 1] & 0xc0) !== 0x80 ||\n        (buf[i + 2] & 0xc0) !== 0x80 ||\n        (buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80) || // Overlong\n        (buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0) // Surrogate (U+D800 - U+DFFF)\n      ) {\n        return false;\n      }\n\n      i += 3;\n    } else if ((buf[i] & 0xf8) === 0xf0) {\n      // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n      if (\n        i + 3 >= len ||\n        (buf[i + 1] & 0xc0) !== 0x80 ||\n        (buf[i + 2] & 0xc0) !== 0x80 ||\n        (buf[i + 3] & 0xc0) !== 0x80 ||\n        (buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80) || // Overlong\n        (buf[i] === 0xf4 && buf[i + 1] > 0x8f) ||\n        buf[i] > 0xf4 // > U+10FFFF\n      ) {\n        return false;\n      }\n\n      i += 4;\n    } else {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Determines whether a value is a `Blob`.\n *\n * @param {*} value The value to be tested\n * @return {Boolean} `true` if `value` is a `Blob`, else `false`\n * @private\n */\nfunction isBlob(value) {\n  return (\n    hasBlob &&\n    typeof value === 'object' &&\n    typeof value.arrayBuffer === 'function' &&\n    typeof value.type === 'string' &&\n    typeof value.stream === 'function' &&\n    (value[Symbol.toStringTag] === 'Blob' ||\n      value[Symbol.toStringTag] === 'File')\n  );\n}\n\nmodule.exports = {\n  isBlob,\n  isValidStatusCode,\n  isValidUTF8: _isValidUTF8,\n  tokenChars\n};\n\nif (isUtf8) {\n  module.exports.isValidUTF8 = function (buf) {\n    return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);\n  };\n} /* istanbul ignore else  */ else if (!process.env.WS_NO_UTF_8_VALIDATE) {\n  try {\n    const isValidUTF8 = require('utf-8-validate');\n\n    module.exports.isValidUTF8 = function (buf) {\n      return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);\n    };\n  } catch (e) {\n    // Continue regardless of the error.\n  }\n}\n","module.exports = require(\"buffer\");","module.exports = require(\"utf-8-validate\");","/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Duplex\" }] */\n\n'use strict';\n\nconst { Duplex } = require('stream');\nconst { randomFillSync } = require('crypto');\n\nconst PerMessageDeflate = require('./permessage-deflate');\nconst { EMPTY_BUFFER, kWebSocket, NOOP } = require('./constants');\nconst { isBlob, isValidStatusCode } = require('./validation');\nconst { mask: applyMask, toBuffer } = require('./buffer-util');\n\nconst kByteLength = Symbol('kByteLength');\nconst maskBuffer = Buffer.alloc(4);\nconst RANDOM_POOL_SIZE = 8 * 1024;\nlet randomPool;\nlet randomPoolPointer = RANDOM_POOL_SIZE;\n\nconst DEFAULT = 0;\nconst DEFLATING = 1;\nconst GET_BLOB_DATA = 2;\n\n/**\n * HyBi Sender implementation.\n */\nclass Sender {\n  /**\n   * Creates a Sender instance.\n   *\n   * @param {Duplex} socket The connection socket\n   * @param {Object} [extensions] An object containing the negotiated extensions\n   * @param {Function} [generateMask] The function used to generate the masking\n   *     key\n   */\n  constructor(socket, extensions, generateMask) {\n    this._extensions = extensions || {};\n\n    if (generateMask) {\n      this._generateMask = generateMask;\n      this._maskBuffer = Buffer.alloc(4);\n    }\n\n    this._socket = socket;\n\n    this._firstFragment = true;\n    this._compress = false;\n\n    this._bufferedBytes = 0;\n    this._queue = [];\n    this._state = DEFAULT;\n    this.onerror = NOOP;\n    this[kWebSocket] = undefined;\n  }\n\n  /**\n   * Frames a piece of data according to the HyBi WebSocket protocol.\n   *\n   * @param {(Buffer|String)} data The data to frame\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @return {(Buffer|String)[]} The framed data\n   * @public\n   */\n  static frame(data, options) {\n    let mask;\n    let merge = false;\n    let offset = 2;\n    let skipMasking = false;\n\n    if (options.mask) {\n      mask = options.maskBuffer || maskBuffer;\n\n      if (options.generateMask) {\n        options.generateMask(mask);\n      } else {\n        if (randomPoolPointer === RANDOM_POOL_SIZE) {\n          /* istanbul ignore else  */\n          if (randomPool === undefined) {\n            //\n            // This is lazily initialized because server-sent frames must not\n            // be masked so it may never be used.\n            //\n            randomPool = Buffer.alloc(RANDOM_POOL_SIZE);\n          }\n\n          randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);\n          randomPoolPointer = 0;\n        }\n\n        mask[0] = randomPool[randomPoolPointer++];\n        mask[1] = randomPool[randomPoolPointer++];\n        mask[2] = randomPool[randomPoolPointer++];\n        mask[3] = randomPool[randomPoolPointer++];\n      }\n\n      skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;\n      offset = 6;\n    }\n\n    let dataLength;\n\n    if (typeof data === 'string') {\n      if (\n        (!options.mask || skipMasking) &&\n        options[kByteLength] !== undefined\n      ) {\n        dataLength = options[kByteLength];\n      } else {\n        data = Buffer.from(data);\n        dataLength = data.length;\n      }\n    } else {\n      dataLength = data.length;\n      merge = options.mask && options.readOnly && !skipMasking;\n    }\n\n    let payloadLength = dataLength;\n\n    if (dataLength >= 65536) {\n      offset += 8;\n      payloadLength = 127;\n    } else if (dataLength > 125) {\n      offset += 2;\n      payloadLength = 126;\n    }\n\n    const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);\n\n    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;\n    if (options.rsv1) target[0] |= 0x40;\n\n    target[1] = payloadLength;\n\n    if (payloadLength === 126) {\n      target.writeUInt16BE(dataLength, 2);\n    } else if (payloadLength === 127) {\n      target[2] = target[3] = 0;\n      target.writeUIntBE(dataLength, 4, 6);\n    }\n\n    if (!options.mask) return [target, data];\n\n    target[1] |= 0x80;\n    target[offset - 4] = mask[0];\n    target[offset - 3] = mask[1];\n    target[offset - 2] = mask[2];\n    target[offset - 1] = mask[3];\n\n    if (skipMasking) return [target, data];\n\n    if (merge) {\n      applyMask(data, mask, target, offset, dataLength);\n      return [target];\n    }\n\n    applyMask(data, mask, data, 0, dataLength);\n    return [target, data];\n  }\n\n  /**\n   * Sends a close message to the other peer.\n   *\n   * @param {Number} [code] The status code component of the body\n   * @param {(String|Buffer)} [data] The message component of the body\n   * @param {Boolean} [mask=false] Specifies whether or not to mask the message\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  close(code, data, mask, cb) {\n    let buf;\n\n    if (code === undefined) {\n      buf = EMPTY_BUFFER;\n    } else if (typeof code !== 'number' || !isValidStatusCode(code)) {\n      throw new TypeError('First argument must be a valid error code number');\n    } else if (data === undefined || !data.length) {\n      buf = Buffer.allocUnsafe(2);\n      buf.writeUInt16BE(code, 0);\n    } else {\n      const length = Buffer.byteLength(data);\n\n      if (length > 123) {\n        throw new RangeError('The message must not be greater than 123 bytes');\n      }\n\n      buf = Buffer.allocUnsafe(2 + length);\n      buf.writeUInt16BE(code, 0);\n\n      if (typeof data === 'string') {\n        buf.write(data, 2);\n      } else {\n        buf.set(data, 2);\n      }\n    }\n\n    const options = {\n      [kByteLength]: buf.length,\n      fin: true,\n      generateMask: this._generateMask,\n      mask,\n      maskBuffer: this._maskBuffer,\n      opcode: 0x08,\n      readOnly: false,\n      rsv1: false\n    };\n\n    if (this._state !== DEFAULT) {\n      this.enqueue([this.dispatch, buf, false, options, cb]);\n    } else {\n      this.sendFrame(Sender.frame(buf, options), cb);\n    }\n  }\n\n  /**\n   * Sends a ping message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  ping(data, mask, cb) {\n    let byteLength;\n    let readOnly;\n\n    if (typeof data === 'string') {\n      byteLength = Buffer.byteLength(data);\n      readOnly = false;\n    } else if (isBlob(data)) {\n      byteLength = data.size;\n      readOnly = false;\n    } else {\n      data = toBuffer(data);\n      byteLength = data.length;\n      readOnly = toBuffer.readOnly;\n    }\n\n    if (byteLength > 125) {\n      throw new RangeError('The data size must not be greater than 125 bytes');\n    }\n\n    const options = {\n      [kByteLength]: byteLength,\n      fin: true,\n      generateMask: this._generateMask,\n      mask,\n      maskBuffer: this._maskBuffer,\n      opcode: 0x09,\n      readOnly,\n      rsv1: false\n    };\n\n    if (isBlob(data)) {\n      if (this._state !== DEFAULT) {\n        this.enqueue([this.getBlobData, data, false, options, cb]);\n      } else {\n        this.getBlobData(data, false, options, cb);\n      }\n    } else if (this._state !== DEFAULT) {\n      this.enqueue([this.dispatch, data, false, options, cb]);\n    } else {\n      this.sendFrame(Sender.frame(data, options), cb);\n    }\n  }\n\n  /**\n   * Sends a pong message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  pong(data, mask, cb) {\n    let byteLength;\n    let readOnly;\n\n    if (typeof data === 'string') {\n      byteLength = Buffer.byteLength(data);\n      readOnly = false;\n    } else if (isBlob(data)) {\n      byteLength = data.size;\n      readOnly = false;\n    } else {\n      data = toBuffer(data);\n      byteLength = data.length;\n      readOnly = toBuffer.readOnly;\n    }\n\n    if (byteLength > 125) {\n      throw new RangeError('The data size must not be greater than 125 bytes');\n    }\n\n    const options = {\n      [kByteLength]: byteLength,\n      fin: true,\n      generateMask: this._generateMask,\n      mask,\n      maskBuffer: this._maskBuffer,\n      opcode: 0x0a,\n      readOnly,\n      rsv1: false\n    };\n\n    if (isBlob(data)) {\n      if (this._state !== DEFAULT) {\n        this.enqueue([this.getBlobData, data, false, options, cb]);\n      } else {\n        this.getBlobData(data, false, options, cb);\n      }\n    } else if (this._state !== DEFAULT) {\n      this.enqueue([this.dispatch, data, false, options, cb]);\n    } else {\n      this.sendFrame(Sender.frame(data, options), cb);\n    }\n  }\n\n  /**\n   * Sends a data message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Object} options Options object\n   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary\n   *     or text\n   * @param {Boolean} [options.compress=false] Specifies whether or not to\n   *     compress `data`\n   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  send(data, options, cb) {\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n    let opcode = options.binary ? 2 : 1;\n    let rsv1 = options.compress;\n\n    let byteLength;\n    let readOnly;\n\n    if (typeof data === 'string') {\n      byteLength = Buffer.byteLength(data);\n      readOnly = false;\n    } else if (isBlob(data)) {\n      byteLength = data.size;\n      readOnly = false;\n    } else {\n      data = toBuffer(data);\n      byteLength = data.length;\n      readOnly = toBuffer.readOnly;\n    }\n\n    if (this._firstFragment) {\n      this._firstFragment = false;\n      if (\n        rsv1 &&\n        perMessageDeflate &&\n        perMessageDeflate.params[\n          perMessageDeflate._isServer\n            ? 'server_no_context_takeover'\n            : 'client_no_context_takeover'\n        ]\n      ) {\n        rsv1 = byteLength >= perMessageDeflate._threshold;\n      }\n      this._compress = rsv1;\n    } else {\n      rsv1 = false;\n      opcode = 0;\n    }\n\n    if (options.fin) this._firstFragment = true;\n\n    const opts = {\n      [kByteLength]: byteLength,\n      fin: options.fin,\n      generateMask: this._generateMask,\n      mask: options.mask,\n      maskBuffer: this._maskBuffer,\n      opcode,\n      readOnly,\n      rsv1\n    };\n\n    if (isBlob(data)) {\n      if (this._state !== DEFAULT) {\n        this.enqueue([this.getBlobData, data, this._compress, opts, cb]);\n      } else {\n        this.getBlobData(data, this._compress, opts, cb);\n      }\n    } else if (this._state !== DEFAULT) {\n      this.enqueue([this.dispatch, data, this._compress, opts, cb]);\n    } else {\n      this.dispatch(data, this._compress, opts, cb);\n    }\n  }\n\n  /**\n   * Gets the contents of a blob as binary data.\n   *\n   * @param {Blob} blob The blob\n   * @param {Boolean} [compress=false] Specifies whether or not to compress\n   *     the data\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @param {Function} [cb] Callback\n   * @private\n   */\n  getBlobData(blob, compress, options, cb) {\n    this._bufferedBytes += options[kByteLength];\n    this._state = GET_BLOB_DATA;\n\n    blob\n      .arrayBuffer()\n      .then((arrayBuffer) => {\n        if (this._socket.destroyed) {\n          const err = new Error(\n            'The socket was closed while the blob was being read'\n          );\n\n          //\n          // `callCallbacks` is called in the next tick to ensure that errors\n          // that might be thrown in the callbacks behave like errors thrown\n          // outside the promise chain.\n          //\n          process.nextTick(callCallbacks, this, err, cb);\n          return;\n        }\n\n        this._bufferedBytes -= options[kByteLength];\n        const data = toBuffer(arrayBuffer);\n\n        if (!compress) {\n          this._state = DEFAULT;\n          this.sendFrame(Sender.frame(data, options), cb);\n          this.dequeue();\n        } else {\n          this.dispatch(data, compress, options, cb);\n        }\n      })\n      .catch((err) => {\n        //\n        // `onError` is called in the next tick for the same reason that\n        // `callCallbacks` above is.\n        //\n        process.nextTick(onError, this, err, cb);\n      });\n  }\n\n  /**\n   * Dispatches a message.\n   *\n   * @param {(Buffer|String)} data The message to send\n   * @param {Boolean} [compress=false] Specifies whether or not to compress\n   *     `data`\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @param {Function} [cb] Callback\n   * @private\n   */\n  dispatch(data, compress, options, cb) {\n    if (!compress) {\n      this.sendFrame(Sender.frame(data, options), cb);\n      return;\n    }\n\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n\n    this._bufferedBytes += options[kByteLength];\n    this._state = DEFLATING;\n    perMessageDeflate.compress(data, options.fin, (_, buf) => {\n      if (this._socket.destroyed) {\n        const err = new Error(\n          'The socket was closed while data was being compressed'\n        );\n\n        callCallbacks(this, err, cb);\n        return;\n      }\n\n      this._bufferedBytes -= options[kByteLength];\n      this._state = DEFAULT;\n      options.readOnly = false;\n      this.sendFrame(Sender.frame(buf, options), cb);\n      this.dequeue();\n    });\n  }\n\n  /**\n   * Executes queued send operations.\n   *\n   * @private\n   */\n  dequeue() {\n    while (this._state === DEFAULT && this._queue.length) {\n      const params = this._queue.shift();\n\n      this._bufferedBytes -= params[3][kByteLength];\n      Reflect.apply(params[0], this, params.slice(1));\n    }\n  }\n\n  /**\n   * Enqueues a send operation.\n   *\n   * @param {Array} params Send operation parameters.\n   * @private\n   */\n  enqueue(params) {\n    this._bufferedBytes += params[3][kByteLength];\n    this._queue.push(params);\n  }\n\n  /**\n   * Sends a frame.\n   *\n   * @param {(Buffer | String)[]} list The frame to send\n   * @param {Function} [cb] Callback\n   * @private\n   */\n  sendFrame(list, cb) {\n    if (list.length === 2) {\n      this._socket.cork();\n      this._socket.write(list[0]);\n      this._socket.write(list[1], cb);\n      this._socket.uncork();\n    } else {\n      this._socket.write(list[0], cb);\n    }\n  }\n}\n\nmodule.exports = Sender;\n\n/**\n * Calls queued callbacks with an error.\n *\n * @param {Sender} sender The `Sender` instance\n * @param {Error} err The error to call the callbacks with\n * @param {Function} [cb] The first callback\n * @private\n */\nfunction callCallbacks(sender, err, cb) {\n  if (typeof cb === 'function') cb(err);\n\n  for (let i = 0; i < sender._queue.length; i++) {\n    const params = sender._queue[i];\n    const callback = params[params.length - 1];\n\n    if (typeof callback === 'function') callback(err);\n  }\n}\n\n/**\n * Handles a `Sender` error.\n *\n * @param {Sender} sender The `Sender` instance\n * @param {Error} err The error\n * @param {Function} [cb] The first pending callback\n * @private\n */\nfunction onError(sender, err, cb) {\n  callCallbacks(sender, err, cb);\n  sender.onerror(err);\n}\n","'use strict';\n\nconst { kForOnEventAttribute, kListener } = require('./constants');\n\nconst kCode = Symbol('kCode');\nconst kData = Symbol('kData');\nconst kError = Symbol('kError');\nconst kMessage = Symbol('kMessage');\nconst kReason = Symbol('kReason');\nconst kTarget = Symbol('kTarget');\nconst kType = Symbol('kType');\nconst kWasClean = Symbol('kWasClean');\n\n/**\n * Class representing an event.\n */\nclass Event {\n  /**\n   * Create a new `Event`.\n   *\n   * @param {String} type The name of the event\n   * @throws {TypeError} If the `type` argument is not specified\n   */\n  constructor(type) {\n    this[kTarget] = null;\n    this[kType] = type;\n  }\n\n  /**\n   * @type {*}\n   */\n  get target() {\n    return this[kTarget];\n  }\n\n  /**\n   * @type {String}\n   */\n  get type() {\n    return this[kType];\n  }\n}\n\nObject.defineProperty(Event.prototype, 'target', { enumerable: true });\nObject.defineProperty(Event.prototype, 'type', { enumerable: true });\n\n/**\n * Class representing a close event.\n *\n * @extends Event\n */\nclass CloseEvent extends Event {\n  /**\n   * Create a new `CloseEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {Number} [options.code=0] The status code explaining why the\n   *     connection was closed\n   * @param {String} [options.reason=''] A human-readable string explaining why\n   *     the connection was closed\n   * @param {Boolean} [options.wasClean=false] Indicates whether or not the\n   *     connection was cleanly closed\n   */\n  constructor(type, options = {}) {\n    super(type);\n\n    this[kCode] = options.code === undefined ? 0 : options.code;\n    this[kReason] = options.reason === undefined ? '' : options.reason;\n    this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get code() {\n    return this[kCode];\n  }\n\n  /**\n   * @type {String}\n   */\n  get reason() {\n    return this[kReason];\n  }\n\n  /**\n   * @type {Boolean}\n   */\n  get wasClean() {\n    return this[kWasClean];\n  }\n}\n\nObject.defineProperty(CloseEvent.prototype, 'code', { enumerable: true });\nObject.defineProperty(CloseEvent.prototype, 'reason', { enumerable: true });\nObject.defineProperty(CloseEvent.prototype, 'wasClean', { enumerable: true });\n\n/**\n * Class representing an error event.\n *\n * @extends Event\n */\nclass ErrorEvent extends Event {\n  /**\n   * Create a new `ErrorEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {*} [options.error=null] The error that generated this event\n   * @param {String} [options.message=''] The error message\n   */\n  constructor(type, options = {}) {\n    super(type);\n\n    this[kError] = options.error === undefined ? null : options.error;\n    this[kMessage] = options.message === undefined ? '' : options.message;\n  }\n\n  /**\n   * @type {*}\n   */\n  get error() {\n    return this[kError];\n  }\n\n  /**\n   * @type {String}\n   */\n  get message() {\n    return this[kMessage];\n  }\n}\n\nObject.defineProperty(ErrorEvent.prototype, 'error', { enumerable: true });\nObject.defineProperty(ErrorEvent.prototype, 'message', { enumerable: true });\n\n/**\n * Class representing a message event.\n *\n * @extends Event\n */\nclass MessageEvent extends Event {\n  /**\n   * Create a new `MessageEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {*} [options.data=null] The message content\n   */\n  constructor(type, options = {}) {\n    super(type);\n\n    this[kData] = options.data === undefined ? null : options.data;\n  }\n\n  /**\n   * @type {*}\n   */\n  get data() {\n    return this[kData];\n  }\n}\n\nObject.defineProperty(MessageEvent.prototype, 'data', { enumerable: true });\n\n/**\n * This provides methods for emulating the `EventTarget` interface. It's not\n * meant to be used directly.\n *\n * @mixin\n */\nconst EventTarget = {\n  /**\n   * Register an event listener.\n   *\n   * @param {String} type A string representing the event type to listen for\n   * @param {(Function|Object)} handler The listener to add\n   * @param {Object} [options] An options object specifies characteristics about\n   *     the event listener\n   * @param {Boolean} [options.once=false] A `Boolean` indicating that the\n   *     listener should be invoked at most once after being added. If `true`,\n   *     the listener would be automatically removed when invoked.\n   * @public\n   */\n  addEventListener(type, handler, options = {}) {\n    for (const listener of this.listeners(type)) {\n      if (\n        !options[kForOnEventAttribute] &&\n        listener[kListener] === handler &&\n        !listener[kForOnEventAttribute]\n      ) {\n        return;\n      }\n    }\n\n    let wrapper;\n\n    if (type === 'message') {\n      wrapper = function onMessage(data, isBinary) {\n        const event = new MessageEvent('message', {\n          data: isBinary ? data : data.toString()\n        });\n\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else if (type === 'close') {\n      wrapper = function onClose(code, message) {\n        const event = new CloseEvent('close', {\n          code,\n          reason: message.toString(),\n          wasClean: this._closeFrameReceived && this._closeFrameSent\n        });\n\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else if (type === 'error') {\n      wrapper = function onError(error) {\n        const event = new ErrorEvent('error', {\n          error,\n          message: error.message\n        });\n\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else if (type === 'open') {\n      wrapper = function onOpen() {\n        const event = new Event('open');\n\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else {\n      return;\n    }\n\n    wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];\n    wrapper[kListener] = handler;\n\n    if (options.once) {\n      this.once(type, wrapper);\n    } else {\n      this.on(type, wrapper);\n    }\n  },\n\n  /**\n   * Remove an event listener.\n   *\n   * @param {String} type A string representing the event type to remove\n   * @param {(Function|Object)} handler The listener to remove\n   * @public\n   */\n  removeEventListener(type, handler) {\n    for (const listener of this.listeners(type)) {\n      if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {\n        this.removeListener(type, listener);\n        break;\n      }\n    }\n  }\n};\n\nmodule.exports = {\n  CloseEvent,\n  ErrorEvent,\n  Event,\n  EventTarget,\n  MessageEvent\n};\n\n/**\n * Call an event listener\n *\n * @param {(Function|Object)} listener The listener to call\n * @param {*} thisArg The value to use as `this`` when calling the listener\n * @param {Event} event The event to pass to the listener\n * @private\n */\nfunction callListener(listener, thisArg, event) {\n  if (typeof listener === 'object' && listener.handleEvent) {\n    listener.handleEvent.call(listener, event);\n  } else {\n    listener.call(thisArg, event);\n  }\n}\n","'use strict';\n\nconst { tokenChars } = require('./validation');\n\n/**\n * Adds an offer to the map of extension offers or a parameter to the map of\n * parameters.\n *\n * @param {Object} dest The map of extension offers or parameters\n * @param {String} name The extension or parameter name\n * @param {(Object|Boolean|String)} elem The extension parameters or the\n *     parameter value\n * @private\n */\nfunction push(dest, name, elem) {\n  if (dest[name] === undefined) dest[name] = [elem];\n  else dest[name].push(elem);\n}\n\n/**\n * Parses the `Sec-WebSocket-Extensions` header into an object.\n *\n * @param {String} header The field value of the header\n * @return {Object} The parsed object\n * @public\n */\nfunction parse(header) {\n  const offers = Object.create(null);\n  let params = Object.create(null);\n  let mustUnescape = false;\n  let isEscaping = false;\n  let inQuotes = false;\n  let extensionName;\n  let paramName;\n  let start = -1;\n  let code = -1;\n  let end = -1;\n  let i = 0;\n\n  for (; i < header.length; i++) {\n    code = header.charCodeAt(i);\n\n    if (extensionName === undefined) {\n      if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (\n        i !== 0 &&\n        (code === 0x20 /* ' ' */ || code === 0x09) /* '\\t' */\n      ) {\n        if (end === -1 && start !== -1) end = i;\n      } else if (code === 0x3b /* ';' */ || code === 0x2c /* ',' */) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n\n        if (end === -1) end = i;\n        const name = header.slice(start, end);\n        if (code === 0x2c) {\n          push(offers, name, params);\n          params = Object.create(null);\n        } else {\n          extensionName = name;\n        }\n\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    } else if (paramName === undefined) {\n      if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (code === 0x20 || code === 0x09) {\n        if (end === -1 && start !== -1) end = i;\n      } else if (code === 0x3b || code === 0x2c) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n\n        if (end === -1) end = i;\n        push(params, header.slice(start, end), true);\n        if (code === 0x2c) {\n          push(offers, extensionName, params);\n          params = Object.create(null);\n          extensionName = undefined;\n        }\n\n        start = end = -1;\n      } else if (code === 0x3d /* '=' */ && start !== -1 && end === -1) {\n        paramName = header.slice(start, i);\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    } else {\n      //\n      // The value of a quoted-string after unescaping must conform to the\n      // token ABNF, so only token characters are valid.\n      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1\n      //\n      if (isEscaping) {\n        if (tokenChars[code] !== 1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n        if (start === -1) start = i;\n        else if (!mustUnescape) mustUnescape = true;\n        isEscaping = false;\n      } else if (inQuotes) {\n        if (tokenChars[code] === 1) {\n          if (start === -1) start = i;\n        } else if (code === 0x22 /* '\"' */ && start !== -1) {\n          inQuotes = false;\n          end = i;\n        } else if (code === 0x5c /* '\\' */) {\n          isEscaping = true;\n        } else {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {\n        inQuotes = true;\n      } else if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {\n        if (end === -1) end = i;\n      } else if (code === 0x3b || code === 0x2c) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n\n        if (end === -1) end = i;\n        let value = header.slice(start, end);\n        if (mustUnescape) {\n          value = value.replace(/\\\\/g, '');\n          mustUnescape = false;\n        }\n        push(params, paramName, value);\n        if (code === 0x2c) {\n          push(offers, extensionName, params);\n          params = Object.create(null);\n          extensionName = undefined;\n        }\n\n        paramName = undefined;\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    }\n  }\n\n  if (start === -1 || inQuotes || code === 0x20 || code === 0x09) {\n    throw new SyntaxError('Unexpected end of input');\n  }\n\n  if (end === -1) end = i;\n  const token = header.slice(start, end);\n  if (extensionName === undefined) {\n    push(offers, token, params);\n  } else {\n    if (paramName === undefined) {\n      push(params, token, true);\n    } else if (mustUnescape) {\n      push(params, paramName, token.replace(/\\\\/g, ''));\n    } else {\n      push(params, paramName, token);\n    }\n    push(offers, extensionName, params);\n  }\n\n  return offers;\n}\n\n/**\n * Builds the `Sec-WebSocket-Extensions` header field value.\n *\n * @param {Object} extensions The map of extensions and parameters to format\n * @return {String} A string representing the given object\n * @public\n */\nfunction format(extensions) {\n  return Object.keys(extensions)\n    .map((extension) => {\n      let configurations = extensions[extension];\n      if (!Array.isArray(configurations)) configurations = [configurations];\n      return configurations\n        .map((params) => {\n          return [extension]\n            .concat(\n              Object.keys(params).map((k) => {\n                let values = params[k];\n                if (!Array.isArray(values)) values = [values];\n                return values\n                  .map((v) => (v === true ? k : `${k}=${v}`))\n                  .join('; ');\n              })\n            )\n            .join('; ');\n        })\n        .join(', ');\n    })\n    .join(', ');\n}\n\nmodule.exports = { format, parse };\n","/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^WebSocket$\" }] */\n'use strict';\n\nconst WebSocket = require('./websocket');\nconst { Duplex } = require('stream');\n\n/**\n * Emits the `'close'` event on a stream.\n *\n * @param {Duplex} stream The stream.\n * @private\n */\nfunction emitClose(stream) {\n  stream.emit('close');\n}\n\n/**\n * The listener of the `'end'` event.\n *\n * @private\n */\nfunction duplexOnEnd() {\n  if (!this.destroyed && this._writableState.finished) {\n    this.destroy();\n  }\n}\n\n/**\n * The listener of the `'error'` event.\n *\n * @param {Error} err The error\n * @private\n */\nfunction duplexOnError(err) {\n  this.removeListener('error', duplexOnError);\n  this.destroy();\n  if (this.listenerCount('error') === 0) {\n    // Do not suppress the throwing behavior.\n    this.emit('error', err);\n  }\n}\n\n/**\n * Wraps a `WebSocket` in a duplex stream.\n *\n * @param {WebSocket} ws The `WebSocket` to wrap\n * @param {Object} [options] The options for the `Duplex` constructor\n * @return {Duplex} The duplex stream\n * @public\n */\nfunction createWebSocketStream(ws, options) {\n  let terminateOnDestroy = true;\n\n  const duplex = new Duplex({\n    ...options,\n    autoDestroy: false,\n    emitClose: false,\n    objectMode: false,\n    writableObjectMode: false\n  });\n\n  ws.on('message', function message(msg, isBinary) {\n    const data =\n      !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;\n\n    if (!duplex.push(data)) ws.pause();\n  });\n\n  ws.once('error', function error(err) {\n    if (duplex.destroyed) return;\n\n    // Prevent `ws.terminate()` from being called by `duplex._destroy()`.\n    //\n    // - If the `'error'` event is emitted before the `'open'` event, then\n    //   `ws.terminate()` is a noop as no socket is assigned.\n    // - Otherwise, the error is re-emitted by the listener of the `'error'`\n    //   event of the `Receiver` object. The listener already closes the\n    //   connection by calling `ws.close()`. This allows a close frame to be\n    //   sent to the other peer. If `ws.terminate()` is called right after this,\n    //   then the close frame might not be sent.\n    terminateOnDestroy = false;\n    duplex.destroy(err);\n  });\n\n  ws.once('close', function close() {\n    if (duplex.destroyed) return;\n\n    duplex.push(null);\n  });\n\n  duplex._destroy = function (err, callback) {\n    if (ws.readyState === ws.CLOSED) {\n      callback(err);\n      process.nextTick(emitClose, duplex);\n      return;\n    }\n\n    let called = false;\n\n    ws.once('error', function error(err) {\n      called = true;\n      callback(err);\n    });\n\n    ws.once('close', function close() {\n      if (!called) callback(err);\n      process.nextTick(emitClose, duplex);\n    });\n\n    if (terminateOnDestroy) ws.terminate();\n  };\n\n  duplex._final = function (callback) {\n    if (ws.readyState === ws.CONNECTING) {\n      ws.once('open', function open() {\n        duplex._final(callback);\n      });\n      return;\n    }\n\n    // If the value of the `_socket` property is `null` it means that `ws` is a\n    // client websocket and the handshake failed. In fact, when this happens, a\n    // socket is never assigned to the websocket. Wait for the `'error'` event\n    // that will be emitted by the websocket.\n    if (ws._socket === null) return;\n\n    if (ws._socket._writableState.finished) {\n      callback();\n      if (duplex._readableState.endEmitted) duplex.destroy();\n    } else {\n      ws._socket.once('finish', function finish() {\n        // `duplex` is not destroyed here because the `'end'` event will be\n        // emitted on `duplex` after this `'finish'` event. The EOF signaling\n        // `null` chunk is, in fact, pushed when the websocket emits `'close'`.\n        callback();\n      });\n      ws.close();\n    }\n  };\n\n  duplex._read = function () {\n    if (ws.isPaused) ws.resume();\n  };\n\n  duplex._write = function (chunk, encoding, callback) {\n    if (ws.readyState === ws.CONNECTING) {\n      ws.once('open', function open() {\n        duplex._write(chunk, encoding, callback);\n      });\n      return;\n    }\n\n    ws.send(chunk, callback);\n  };\n\n  duplex.on('end', duplexOnEnd);\n  duplex.on('error', duplexOnError);\n  return duplex;\n}\n\nmodule.exports = createWebSocketStream;\n","/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Duplex$\", \"caughtErrors\": \"none\" }] */\n\n'use strict';\n\nconst EventEmitter = require('events');\nconst http = require('http');\nconst { Duplex } = require('stream');\nconst { createHash } = require('crypto');\n\nconst extension = require('./extension');\nconst PerMessageDeflate = require('./permessage-deflate');\nconst subprotocol = require('./subprotocol');\nconst WebSocket = require('./websocket');\nconst { GUID, kWebSocket } = require('./constants');\n\nconst keyRegex = /^[+/0-9A-Za-z]{22}==$/;\n\nconst RUNNING = 0;\nconst CLOSING = 1;\nconst CLOSED = 2;\n\n/**\n * Class representing a WebSocket server.\n *\n * @extends EventEmitter\n */\nclass WebSocketServer extends EventEmitter {\n  /**\n   * Create a `WebSocketServer` instance.\n   *\n   * @param {Object} options Configuration options\n   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether\n   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted\n   *     multiple times in the same tick\n   * @param {Boolean} [options.autoPong=true] Specifies whether or not to\n   *     automatically send a pong in response to a ping\n   * @param {Number} [options.backlog=511] The maximum length of the queue of\n   *     pending connections\n   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to\n   *     track clients\n   * @param {Function} [options.handleProtocols] A hook to handle protocols\n   * @param {String} [options.host] The hostname where to bind the server\n   * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n   *     size\n   * @param {Boolean} [options.noServer=false] Enable no server mode\n   * @param {String} [options.path] Accept only connections matching this path\n   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable\n   *     permessage-deflate\n   * @param {Number} [options.port] The port where to bind the server\n   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S\n   *     server to use\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   * @param {Function} [options.verifyClient] A hook to reject connections\n   * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`\n   *     class to use. It must be the `WebSocket` class or class that extends it\n   * @param {Function} [callback] A listener for the `listening` event\n   */\n  constructor(options, callback) {\n    super();\n\n    options = {\n      allowSynchronousEvents: true,\n      autoPong: true,\n      maxPayload: 100 * 1024 * 1024,\n      skipUTF8Validation: false,\n      perMessageDeflate: false,\n      handleProtocols: null,\n      clientTracking: true,\n      verifyClient: null,\n      noServer: false,\n      backlog: null, // use default (511 as implemented in net.js)\n      server: null,\n      host: null,\n      path: null,\n      port: null,\n      WebSocket,\n      ...options\n    };\n\n    if (\n      (options.port == null && !options.server && !options.noServer) ||\n      (options.port != null && (options.server || options.noServer)) ||\n      (options.server && options.noServer)\n    ) {\n      throw new TypeError(\n        'One and only one of the \"port\", \"server\", or \"noServer\" options ' +\n          'must be specified'\n      );\n    }\n\n    if (options.port != null) {\n      this._server = http.createServer((req, res) => {\n        const body = http.STATUS_CODES[426];\n\n        res.writeHead(426, {\n          'Content-Length': body.length,\n          'Content-Type': 'text/plain'\n        });\n        res.end(body);\n      });\n      this._server.listen(\n        options.port,\n        options.host,\n        options.backlog,\n        callback\n      );\n    } else if (options.server) {\n      this._server = options.server;\n    }\n\n    if (this._server) {\n      const emitConnection = this.emit.bind(this, 'connection');\n\n      this._removeListeners = addListeners(this._server, {\n        listening: this.emit.bind(this, 'listening'),\n        error: this.emit.bind(this, 'error'),\n        upgrade: (req, socket, head) => {\n          this.handleUpgrade(req, socket, head, emitConnection);\n        }\n      });\n    }\n\n    if (options.perMessageDeflate === true) options.perMessageDeflate = {};\n    if (options.clientTracking) {\n      this.clients = new Set();\n      this._shouldEmitClose = false;\n    }\n\n    this.options = options;\n    this._state = RUNNING;\n  }\n\n  /**\n   * Returns the bound address, the address family name, and port of the server\n   * as reported by the operating system if listening on an IP socket.\n   * If the server is listening on a pipe or UNIX domain socket, the name is\n   * returned as a string.\n   *\n   * @return {(Object|String|null)} The address of the server\n   * @public\n   */\n  address() {\n    if (this.options.noServer) {\n      throw new Error('The server is operating in \"noServer\" mode');\n    }\n\n    if (!this._server) return null;\n    return this._server.address();\n  }\n\n  /**\n   * Stop the server from accepting new connections and emit the `'close'` event\n   * when all existing connections are closed.\n   *\n   * @param {Function} [cb] A one-time listener for the `'close'` event\n   * @public\n   */\n  close(cb) {\n    if (this._state === CLOSED) {\n      if (cb) {\n        this.once('close', () => {\n          cb(new Error('The server is not running'));\n        });\n      }\n\n      process.nextTick(emitClose, this);\n      return;\n    }\n\n    if (cb) this.once('close', cb);\n\n    if (this._state === CLOSING) return;\n    this._state = CLOSING;\n\n    if (this.options.noServer || this.options.server) {\n      if (this._server) {\n        this._removeListeners();\n        this._removeListeners = this._server = null;\n      }\n\n      if (this.clients) {\n        if (!this.clients.size) {\n          process.nextTick(emitClose, this);\n        } else {\n          this._shouldEmitClose = true;\n        }\n      } else {\n        process.nextTick(emitClose, this);\n      }\n    } else {\n      const server = this._server;\n\n      this._removeListeners();\n      this._removeListeners = this._server = null;\n\n      //\n      // The HTTP/S server was created internally. Close it, and rely on its\n      // `'close'` event.\n      //\n      server.close(() => {\n        emitClose(this);\n      });\n    }\n  }\n\n  /**\n   * See if a given request should be handled by this server instance.\n   *\n   * @param {http.IncomingMessage} req Request object to inspect\n   * @return {Boolean} `true` if the request is valid, else `false`\n   * @public\n   */\n  shouldHandle(req) {\n    if (this.options.path) {\n      const index = req.url.indexOf('?');\n      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;\n\n      if (pathname !== this.options.path) return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Handle a HTTP Upgrade request.\n   *\n   * @param {http.IncomingMessage} req The request object\n   * @param {Duplex} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @public\n   */\n  handleUpgrade(req, socket, head, cb) {\n    socket.on('error', socketOnError);\n\n    const key = req.headers['sec-websocket-key'];\n    const upgrade = req.headers.upgrade;\n    const version = +req.headers['sec-websocket-version'];\n\n    if (req.method !== 'GET') {\n      const message = 'Invalid HTTP method';\n      abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);\n      return;\n    }\n\n    if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {\n      const message = 'Invalid Upgrade header';\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n      return;\n    }\n\n    if (key === undefined || !keyRegex.test(key)) {\n      const message = 'Missing or invalid Sec-WebSocket-Key header';\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n      return;\n    }\n\n    if (version !== 13 && version !== 8) {\n      const message = 'Missing or invalid Sec-WebSocket-Version header';\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message, {\n        'Sec-WebSocket-Version': '13, 8'\n      });\n      return;\n    }\n\n    if (!this.shouldHandle(req)) {\n      abortHandshake(socket, 400);\n      return;\n    }\n\n    const secWebSocketProtocol = req.headers['sec-websocket-protocol'];\n    let protocols = new Set();\n\n    if (secWebSocketProtocol !== undefined) {\n      try {\n        protocols = subprotocol.parse(secWebSocketProtocol);\n      } catch (err) {\n        const message = 'Invalid Sec-WebSocket-Protocol header';\n        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n        return;\n      }\n    }\n\n    const secWebSocketExtensions = req.headers['sec-websocket-extensions'];\n    const extensions = {};\n\n    if (\n      this.options.perMessageDeflate &&\n      secWebSocketExtensions !== undefined\n    ) {\n      const perMessageDeflate = new PerMessageDeflate(\n        this.options.perMessageDeflate,\n        true,\n        this.options.maxPayload\n      );\n\n      try {\n        const offers = extension.parse(secWebSocketExtensions);\n\n        if (offers[PerMessageDeflate.extensionName]) {\n          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);\n          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n        }\n      } catch (err) {\n        const message =\n          'Invalid or unacceptable Sec-WebSocket-Extensions header';\n        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n        return;\n      }\n    }\n\n    //\n    // Optionally call external client verification handler.\n    //\n    if (this.options.verifyClient) {\n      const info = {\n        origin:\n          req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],\n        secure: !!(req.socket.authorized || req.socket.encrypted),\n        req\n      };\n\n      if (this.options.verifyClient.length === 2) {\n        this.options.verifyClient(info, (verified, code, message, headers) => {\n          if (!verified) {\n            return abortHandshake(socket, code || 401, message, headers);\n          }\n\n          this.completeUpgrade(\n            extensions,\n            key,\n            protocols,\n            req,\n            socket,\n            head,\n            cb\n          );\n        });\n        return;\n      }\n\n      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);\n    }\n\n    this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);\n  }\n\n  /**\n   * Upgrade the connection to WebSocket.\n   *\n   * @param {Object} extensions The accepted extensions\n   * @param {String} key The value of the `Sec-WebSocket-Key` header\n   * @param {Set} protocols The subprotocols\n   * @param {http.IncomingMessage} req The request object\n   * @param {Duplex} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @throws {Error} If called more than once with the same socket\n   * @private\n   */\n  completeUpgrade(extensions, key, protocols, req, socket, head, cb) {\n    //\n    // Destroy the socket if the client has already sent a FIN packet.\n    //\n    if (!socket.readable || !socket.writable) return socket.destroy();\n\n    if (socket[kWebSocket]) {\n      throw new Error(\n        'server.handleUpgrade() was called more than once with the same ' +\n          'socket, possibly due to a misconfiguration'\n      );\n    }\n\n    if (this._state > RUNNING) return abortHandshake(socket, 503);\n\n    const digest = createHash('sha1')\n      .update(key + GUID)\n      .digest('base64');\n\n    const headers = [\n      'HTTP/1.1 101 Switching Protocols',\n      'Upgrade: websocket',\n      'Connection: Upgrade',\n      `Sec-WebSocket-Accept: ${digest}`\n    ];\n\n    const ws = new this.options.WebSocket(null, undefined, this.options);\n\n    if (protocols.size) {\n      //\n      // Optionally call external protocol selection handler.\n      //\n      const protocol = this.options.handleProtocols\n        ? this.options.handleProtocols(protocols, req)\n        : protocols.values().next().value;\n\n      if (protocol) {\n        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);\n        ws._protocol = protocol;\n      }\n    }\n\n    if (extensions[PerMessageDeflate.extensionName]) {\n      const params = extensions[PerMessageDeflate.extensionName].params;\n      const value = extension.format({\n        [PerMessageDeflate.extensionName]: [params]\n      });\n      headers.push(`Sec-WebSocket-Extensions: ${value}`);\n      ws._extensions = extensions;\n    }\n\n    //\n    // Allow external modification/inspection of handshake headers.\n    //\n    this.emit('headers', headers, req);\n\n    socket.write(headers.concat('\\r\\n').join('\\r\\n'));\n    socket.removeListener('error', socketOnError);\n\n    ws.setSocket(socket, head, {\n      allowSynchronousEvents: this.options.allowSynchronousEvents,\n      maxPayload: this.options.maxPayload,\n      skipUTF8Validation: this.options.skipUTF8Validation\n    });\n\n    if (this.clients) {\n      this.clients.add(ws);\n      ws.on('close', () => {\n        this.clients.delete(ws);\n\n        if (this._shouldEmitClose && !this.clients.size) {\n          process.nextTick(emitClose, this);\n        }\n      });\n    }\n\n    cb(ws, req);\n  }\n}\n\nmodule.exports = WebSocketServer;\n\n/**\n * Add event listeners on an `EventEmitter` using a map of <event, listener>\n * pairs.\n *\n * @param {EventEmitter} server The event emitter\n * @param {Object.<String, Function>} map The listeners to add\n * @return {Function} A function that will remove the added listeners when\n *     called\n * @private\n */\nfunction addListeners(server, map) {\n  for (const event of Object.keys(map)) server.on(event, map[event]);\n\n  return function removeListeners() {\n    for (const event of Object.keys(map)) {\n      server.removeListener(event, map[event]);\n    }\n  };\n}\n\n/**\n * Emit a `'close'` event on an `EventEmitter`.\n *\n * @param {EventEmitter} server The event emitter\n * @private\n */\nfunction emitClose(server) {\n  server._state = CLOSED;\n  server.emit('close');\n}\n\n/**\n * Handle socket errors.\n *\n * @private\n */\nfunction socketOnError() {\n  this.destroy();\n}\n\n/**\n * Close the connection when preconditions are not fulfilled.\n *\n * @param {Duplex} socket The socket of the upgrade request\n * @param {Number} code The HTTP response status code\n * @param {String} [message] The HTTP response body\n * @param {Object} [headers] Additional HTTP response headers\n * @private\n */\nfunction abortHandshake(socket, code, message, headers) {\n  //\n  // The socket is writable unless the user destroyed or ended it before calling\n  // `server.handleUpgrade()` or in the `verifyClient` function, which is a user\n  // error. Handling this does not make much sense as the worst that can happen\n  // is that some of the data written by the user might be discarded due to the\n  // call to `socket.end()` below, which triggers an `'error'` event that in\n  // turn causes the socket to be destroyed.\n  //\n  message = message || http.STATUS_CODES[code];\n  headers = {\n    Connection: 'close',\n    'Content-Type': 'text/html',\n    'Content-Length': Buffer.byteLength(message),\n    ...headers\n  };\n\n  socket.once('finish', socket.destroy);\n\n  socket.end(\n    `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\\r\\n` +\n      Object.keys(headers)\n        .map((h) => `${h}: ${headers[h]}`)\n        .join('\\r\\n') +\n      '\\r\\n\\r\\n' +\n      message\n  );\n}\n\n/**\n * Emit a `'wsClientError'` event on a `WebSocketServer` if there is at least\n * one listener for it, otherwise call `abortHandshake()`.\n *\n * @param {WebSocketServer} server The WebSocket server\n * @param {http.IncomingMessage} req The request object\n * @param {Duplex} socket The socket of the upgrade request\n * @param {Number} code The HTTP response status code\n * @param {String} message The HTTP response body\n * @param {Object} [headers] The HTTP response headers\n * @private\n */\nfunction abortHandshakeOrEmitwsClientError(\n  server,\n  req,\n  socket,\n  code,\n  message,\n  headers\n) {\n  if (server.listenerCount('wsClientError')) {\n    const err = new Error(message);\n    Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);\n\n    server.emit('wsClientError', err, socket, req);\n  } else {\n    abortHandshake(socket, code, message, headers);\n  }\n}\n","'use strict';\n\nconst { tokenChars } = require('./validation');\n\n/**\n * Parses the `Sec-WebSocket-Protocol` header into a set of subprotocol names.\n *\n * @param {String} header The field value of the header\n * @return {Set} The subprotocol names\n * @public\n */\nfunction parse(header) {\n  const protocols = new Set();\n  let start = -1;\n  let end = -1;\n  let i = 0;\n\n  for (i; i < header.length; i++) {\n    const code = header.charCodeAt(i);\n\n    if (end === -1 && tokenChars[code] === 1) {\n      if (start === -1) start = i;\n    } else if (\n      i !== 0 &&\n      (code === 0x20 /* ' ' */ || code === 0x09) /* '\\t' */\n    ) {\n      if (end === -1 && start !== -1) end = i;\n    } else if (code === 0x2c /* ',' */) {\n      if (start === -1) {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n\n      if (end === -1) end = i;\n\n      const protocol = header.slice(start, end);\n\n      if (protocols.has(protocol)) {\n        throw new SyntaxError(`The \"${protocol}\" subprotocol is duplicated`);\n      }\n\n      protocols.add(protocol);\n      start = end = -1;\n    } else {\n      throw new SyntaxError(`Unexpected character at index ${i}`);\n    }\n  }\n\n  if (start === -1 || end !== -1) {\n    throw new SyntaxError('Unexpected end of input');\n  }\n\n  const protocol = header.slice(start, i);\n\n  if (protocols.has(protocol)) {\n    throw new SyntaxError(`The \"${protocol}\" subprotocol is duplicated`);\n  }\n\n  protocols.add(protocol);\n  return protocols;\n}\n\nmodule.exports = { parse };\n","import { MessageTypes } from \"./types\";\n\nexport abstract class ESPHomeConnection {\n  private handleMessage_!: (msg: MessageTypes) => void;\n\n  abstract sendMessageInternal(msg: any): void;\n  sendMessage(msg: any): void {\n    console.log(\"send \" + JSON.stringify(msg).substring(0, 150));\n    this.sendMessageInternal(msg);\n  }\n  abstract connect(): Promise<void>;\n  abstract disconnect(): void;\n  private _isConnected: boolean = false;\n  public get isConnected(): boolean {\n    return this._isConnected;\n  }\n  protected setIsConnected(v: boolean) {\n    this._isConnected = v;\n  }\n\n  protected handleMessage(msg: MessageTypes) {\n    console.log(\"rcvd \" + JSON.stringify(msg).substring(0, 150));\n    this.handleMessage_(msg);\n  }\n\n  onResponse(handleMessage: (msg: MessageTypes) => void) {\n    this.handleMessage_ = handleMessage;\n  }\n}\n","import { env } from \"process\";\nimport { ChildProcess, exec, ExecException } from \"child_process\";\n\nimport { ESPHomeConnection } from \"./connection\";\nimport { MESSAGE_STD_ERR_OUT } from \"./types\";\n\nfunction execPromise(\n  command: string,\n): Promise<{ error: ExecException | null; stdout: string; stderr: string }> {\n  return new Promise((resolve, reject) => {\n    exec(command, (error, stdout, stderr) => {\n      resolve({ error, stdout, stderr });\n    });\n  });\n}\nexport class ESPHomeLocalConnection extends ESPHomeConnection {\n  private process!: ChildProcess;\n  private killed = false;\n  private command?: string;\n\n  constructor(private pythonPath?: string) {\n    super();\n  }\n\n  sendMessageInternal(msg: any): void {\n    let send = JSON.stringify(msg) + \"\\n\";\n\n    // todo check process is alive\n    if (this.process.stdin !== null) {\n      this.process.stdin.write(send);\n    }\n  }\n\n  async initialize_command(): Promise<string | undefined> {\n    if (this.pythonPath) {\n      const cmd = `\"${this.pythonPath}\" -m esphome version`;\n      const result = await execPromise(cmd);\n      if (result.stderr) {\n        const errorMessage = `Could not execute ESPHome. Make sure selected Python interpreter is correct and restart VS Code. Actual interpreter ${this.pythonPath}.`;\n        console.error(errorMessage);\n        return undefined;\n      }\n      console.log(`Using venv \"${this.pythonPath}\" -- ${result.stdout}`);\n      return `\"${this.pythonPath}\" -m esphome vscode dummy`;\n    }\n    const cmd = \"esphome version\";\n    const result = await execPromise(cmd);\n    if (result.stderr) {\n      const errorMessage =\n        \"Could not execute ESPHome. Make sure you can run ESPHome from the command line. If you have ESPHome in a virtual environment, install the Python extension and select it.\";\n      console.error(errorMessage);\n      return undefined;\n    }\n    console.log(`Using ${result.stdout}`);\n    return \"esphome vscode dummy\";\n  }\n\n  async connect(): Promise<void> {\n    console.log(\"Using local ESPHome\");\n    var environment = env;\n    environment.PYTHONIOENCODING = \"utf-8\";\n\n    if (this.command === undefined)\n      this.command = await this.initialize_command();\n\n    if (!this.command) {\n      console.error(\"Cannot start ESPHome\");\n      return;\n    }\n\n    this.process = exec(this.command, {\n      encoding: \"utf-8\",\n      env: environment,\n    });\n    if (this.process.stdout !== null) {\n      this.process.stdout.on(\"data\", (data) => {\n        try {\n          if (data.length < 2) {\n            console.log(`Unexpected data too small: ${data}'`);\n            return;\n          }\n          const msg = JSON.parse(data);\n          this.handleMessage(msg);\n        } catch (e) {\n          console.log(\n            `Error handling response: data: ${typeof data}: '${data?.toString()}' ${e}`,\n          );\n        }\n      });\n    }\n    if (this.process.stderr !== null) {\n      this.process.stderr.on(\"data\", (data) => {\n        console.error(\"StdErr:\" + data.toString());\n\n        this.handleMessage({\n          type: MESSAGE_STD_ERR_OUT,\n          std_err: data.toString(),\n        });\n      });\n    }\n    this.process.on(\"close\", (code, signal) => {\n      console.log(\"Got close: \", code, signal);\n    });\n    this.process.on(\"exit\", async (code, signal) => {\n      console.log(\"Got exit: \", code, signal);\n      await this.connect();\n    });\n    this.process.on(\"error\", (args) => {\n      if (this.killed) return;\n      if (args.message.startsWith(\"spawn esphome\")) {\n        const errorMessage =\n          \"Could not execute ESPHome. Make sure you can run ESPHome from the command line.\";\n        console.error(errorMessage);\n      }\n      console.error(\"Got error: \", args);\n    });\n  }\n\n  disconnect(): void {\n    this.killed = true;\n    this.process.kill();\n  }\n}\n","module.exports = require(\"process\");","import { isScalar } from \"yaml\";\nimport { ESPHomeDocuments } from \"./esphome-document\";\nimport { coreSchema, createHover, Position, Range } from \"./editor-shims\";\nimport { isString } from \"./utils/objects\";\n\nexport class HoverHandler {\n  constructor(private documents: ESPHomeDocuments) {}\n\n  public async getHover(uri: string, position: Position) {\n    try {\n      const document = this.documents.getDocument(uri);\n      const lineContent = document.text.getLineContent(position.line);\n      if (lineContent.trim().length === 0) {\n        return;\n      }\n      const offset = document.text.offsetAt(position);\n      const node = document.getNodeFromOffset(offset);\n      if (!node) return;\n\n      let startPos = node.range?.[0]!;\n      if (node.tag) {\n        startPos -= node.tag.length + 1;\n      }\n      const range: Range = {\n        start: document.text.getPosition(startPos),\n        end: document.text.getPosition(node.range?.[1]!),\n      };\n\n      var path = document.getPath(node);\n\n      if (path.length === 1) {\n        const rootComponents = await coreSchema.getComponentList();\n        if (path[0] in rootComponents) {\n          const docs = rootComponents[path[0]].docs;\n          if (docs) {\n            return createHover(docs, range);\n          }\n        }\n        const platformComponents = await coreSchema.getPlatformList();\n        if (path[0] in platformComponents) {\n          const docs = platformComponents[path[0]].docs;\n          if (docs) {\n            return createHover(docs, range);\n          }\n        }\n        return;\n      }\n\n      const cvAndPath = await document.getConfigVarAndPathNode(path);\n      if (cvAndPath === undefined) {\n        return;\n      }\n      const [cv, pathNode] = cvAndPath;\n\n      let content: string | undefined = undefined;\n      if (cv !== undefined) {\n        content = cv.docs;\n        if (\n          content === undefined &&\n          path.length === 3 &&\n          path[2] === \"platform\" &&\n          isScalar(pathNode) &&\n          isString(path[0])\n        ) {\n          content = (await coreSchema.getComponent(path[0])).components[\n            pathNode.value as string\n          ].docs;\n        }\n        if (content) {\n          return createHover(content, range);\n        }\n      }\n      return;\n    } catch (error) {\n      console.log(\"Hover:\" + error);\n    }\n    return;\n  }\n}\n","'use strict';\n\nvar composer = require('./compose/composer.js');\nvar Document = require('./doc/Document.js');\nvar Schema = require('./schema/Schema.js');\nvar errors = require('./errors.js');\nvar Alias = require('./nodes/Alias.js');\nvar identity = require('./nodes/identity.js');\nvar Pair = require('./nodes/Pair.js');\nvar Scalar = require('./nodes/Scalar.js');\nvar YAMLMap = require('./nodes/YAMLMap.js');\nvar YAMLSeq = require('./nodes/YAMLSeq.js');\nvar cst = require('./parse/cst.js');\nvar lexer = require('./parse/lexer.js');\nvar lineCounter = require('./parse/line-counter.js');\nvar parser = require('./parse/parser.js');\nvar publicApi = require('./public-api.js');\nvar visit = require('./visit.js');\n\n\n\nexports.Composer = composer.Composer;\nexports.Document = Document.Document;\nexports.Schema = Schema.Schema;\nexports.YAMLError = errors.YAMLError;\nexports.YAMLParseError = errors.YAMLParseError;\nexports.YAMLWarning = errors.YAMLWarning;\nexports.Alias = Alias.Alias;\nexports.isAlias = identity.isAlias;\nexports.isCollection = identity.isCollection;\nexports.isDocument = identity.isDocument;\nexports.isMap = identity.isMap;\nexports.isNode = identity.isNode;\nexports.isPair = identity.isPair;\nexports.isScalar = identity.isScalar;\nexports.isSeq = identity.isSeq;\nexports.Pair = Pair.Pair;\nexports.Scalar = Scalar.Scalar;\nexports.YAMLMap = YAMLMap.YAMLMap;\nexports.YAMLSeq = YAMLSeq.YAMLSeq;\nexports.CST = cst;\nexports.Lexer = lexer.Lexer;\nexports.LineCounter = lineCounter.LineCounter;\nexports.Parser = parser.Parser;\nexports.parse = publicApi.parse;\nexports.parseAllDocuments = publicApi.parseAllDocuments;\nexports.parseDocument = publicApi.parseDocument;\nexports.stringify = publicApi.stringify;\nexports.visit = visit.visit;\nexports.visitAsync = visit.visitAsync;\n","'use strict';\n\nvar node_process = require('process');\nvar directives = require('../doc/directives.js');\nvar Document = require('../doc/Document.js');\nvar errors = require('../errors.js');\nvar identity = require('../nodes/identity.js');\nvar composeDoc = require('./compose-doc.js');\nvar resolveEnd = require('./resolve-end.js');\n\nfunction getErrorPos(src) {\n    if (typeof src === 'number')\n        return [src, src + 1];\n    if (Array.isArray(src))\n        return src.length === 2 ? src : [src[0], src[1]];\n    const { offset, source } = src;\n    return [offset, offset + (typeof source === 'string' ? source.length : 1)];\n}\nfunction parsePrelude(prelude) {\n    let comment = '';\n    let atComment = false;\n    let afterEmptyLine = false;\n    for (let i = 0; i < prelude.length; ++i) {\n        const source = prelude[i];\n        switch (source[0]) {\n            case '#':\n                comment +=\n                    (comment === '' ? '' : afterEmptyLine ? '\\n\\n' : '\\n') +\n                        (source.substring(1) || ' ');\n                atComment = true;\n                afterEmptyLine = false;\n                break;\n            case '%':\n                if (prelude[i + 1]?.[0] !== '#')\n                    i += 1;\n                atComment = false;\n                break;\n            default:\n                // This may be wrong after doc-end, but in that case it doesn't matter\n                if (!atComment)\n                    afterEmptyLine = true;\n                atComment = false;\n        }\n    }\n    return { comment, afterEmptyLine };\n}\n/**\n * Compose a stream of CST nodes into a stream of YAML Documents.\n *\n * ```ts\n * import { Composer, Parser } from 'yaml'\n *\n * const src: string = ...\n * const tokens = new Parser().parse(src)\n * const docs = new Composer().compose(tokens)\n * ```\n */\nclass Composer {\n    constructor(options = {}) {\n        this.doc = null;\n        this.atDirectives = false;\n        this.prelude = [];\n        this.errors = [];\n        this.warnings = [];\n        this.onError = (source, code, message, warning) => {\n            const pos = getErrorPos(source);\n            if (warning)\n                this.warnings.push(new errors.YAMLWarning(pos, code, message));\n            else\n                this.errors.push(new errors.YAMLParseError(pos, code, message));\n        };\n        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n        this.directives = new directives.Directives({ version: options.version || '1.2' });\n        this.options = options;\n    }\n    decorate(doc, afterDoc) {\n        const { comment, afterEmptyLine } = parsePrelude(this.prelude);\n        //console.log({ dc: doc.comment, prelude, comment })\n        if (comment) {\n            const dc = doc.contents;\n            if (afterDoc) {\n                doc.comment = doc.comment ? `${doc.comment}\\n${comment}` : comment;\n            }\n            else if (afterEmptyLine || doc.directives.docStart || !dc) {\n                doc.commentBefore = comment;\n            }\n            else if (identity.isCollection(dc) && !dc.flow && dc.items.length > 0) {\n                let it = dc.items[0];\n                if (identity.isPair(it))\n                    it = it.key;\n                const cb = it.commentBefore;\n                it.commentBefore = cb ? `${comment}\\n${cb}` : comment;\n            }\n            else {\n                const cb = dc.commentBefore;\n                dc.commentBefore = cb ? `${comment}\\n${cb}` : comment;\n            }\n        }\n        if (afterDoc) {\n            Array.prototype.push.apply(doc.errors, this.errors);\n            Array.prototype.push.apply(doc.warnings, this.warnings);\n        }\n        else {\n            doc.errors = this.errors;\n            doc.warnings = this.warnings;\n        }\n        this.prelude = [];\n        this.errors = [];\n        this.warnings = [];\n    }\n    /**\n     * Current stream status information.\n     *\n     * Mostly useful at the end of input for an empty stream.\n     */\n    streamInfo() {\n        return {\n            comment: parsePrelude(this.prelude).comment,\n            directives: this.directives,\n            errors: this.errors,\n            warnings: this.warnings\n        };\n    }\n    /**\n     * Compose tokens into documents.\n     *\n     * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.\n     * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.\n     */\n    *compose(tokens, forceDoc = false, endOffset = -1) {\n        for (const token of tokens)\n            yield* this.next(token);\n        yield* this.end(forceDoc, endOffset);\n    }\n    /** Advance the composer by one CST token. */\n    *next(token) {\n        if (node_process.env.LOG_STREAM)\n            console.dir(token, { depth: null });\n        switch (token.type) {\n            case 'directive':\n                this.directives.add(token.source, (offset, message, warning) => {\n                    const pos = getErrorPos(token);\n                    pos[0] += offset;\n                    this.onError(pos, 'BAD_DIRECTIVE', message, warning);\n                });\n                this.prelude.push(token.source);\n                this.atDirectives = true;\n                break;\n            case 'document': {\n                const doc = composeDoc.composeDoc(this.options, this.directives, token, this.onError);\n                if (this.atDirectives && !doc.directives.docStart)\n                    this.onError(token, 'MISSING_CHAR', 'Missing directives-end/doc-start indicator line');\n                this.decorate(doc, false);\n                if (this.doc)\n                    yield this.doc;\n                this.doc = doc;\n                this.atDirectives = false;\n                break;\n            }\n            case 'byte-order-mark':\n            case 'space':\n                break;\n            case 'comment':\n            case 'newline':\n                this.prelude.push(token.source);\n                break;\n            case 'error': {\n                const msg = token.source\n                    ? `${token.message}: ${JSON.stringify(token.source)}`\n                    : token.message;\n                const error = new errors.YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', msg);\n                if (this.atDirectives || !this.doc)\n                    this.errors.push(error);\n                else\n                    this.doc.errors.push(error);\n                break;\n            }\n            case 'doc-end': {\n                if (!this.doc) {\n                    const msg = 'Unexpected doc-end without preceding document';\n                    this.errors.push(new errors.YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', msg));\n                    break;\n                }\n                this.doc.directives.docEnd = true;\n                const end = resolveEnd.resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);\n                this.decorate(this.doc, true);\n                if (end.comment) {\n                    const dc = this.doc.comment;\n                    this.doc.comment = dc ? `${dc}\\n${end.comment}` : end.comment;\n                }\n                this.doc.range[2] = end.offset;\n                break;\n            }\n            default:\n                this.errors.push(new errors.YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', `Unsupported token ${token.type}`));\n        }\n    }\n    /**\n     * Call at end of input to yield any remaining document.\n     *\n     * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.\n     * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.\n     */\n    *end(forceDoc = false, endOffset = -1) {\n        if (this.doc) {\n            this.decorate(this.doc, true);\n            yield this.doc;\n            this.doc = null;\n        }\n        else if (forceDoc) {\n            const opts = Object.assign({ _directives: this.directives }, this.options);\n            const doc = new Document.Document(undefined, opts);\n            if (this.atDirectives)\n                this.onError(endOffset, 'MISSING_CHAR', 'Missing directives-end indicator line');\n            doc.range = [0, endOffset, endOffset];\n            this.decorate(doc, false);\n            yield doc;\n        }\n    }\n}\n\nexports.Composer = Composer;\n","'use strict';\n\nvar identity = require('../nodes/identity.js');\nvar visit = require('../visit.js');\n\nconst escapeChars = {\n    '!': '%21',\n    ',': '%2C',\n    '[': '%5B',\n    ']': '%5D',\n    '{': '%7B',\n    '}': '%7D'\n};\nconst escapeTagName = (tn) => tn.replace(/[!,[\\]{}]/g, ch => escapeChars[ch]);\nclass Directives {\n    constructor(yaml, tags) {\n        /**\n         * The directives-end/doc-start marker `---`. If `null`, a marker may still be\n         * included in the document's stringified representation.\n         */\n        this.docStart = null;\n        /** The doc-end marker `...`.  */\n        this.docEnd = false;\n        this.yaml = Object.assign({}, Directives.defaultYaml, yaml);\n        this.tags = Object.assign({}, Directives.defaultTags, tags);\n    }\n    clone() {\n        const copy = new Directives(this.yaml, this.tags);\n        copy.docStart = this.docStart;\n        return copy;\n    }\n    /**\n     * During parsing, get a Directives instance for the current document and\n     * update the stream state according to the current version's spec.\n     */\n    atDocument() {\n        const res = new Directives(this.yaml, this.tags);\n        switch (this.yaml.version) {\n            case '1.1':\n                this.atNextDocument = true;\n                break;\n            case '1.2':\n                this.atNextDocument = false;\n                this.yaml = {\n                    explicit: Directives.defaultYaml.explicit,\n                    version: '1.2'\n                };\n                this.tags = Object.assign({}, Directives.defaultTags);\n                break;\n        }\n        return res;\n    }\n    /**\n     * @param onError - May be called even if the action was successful\n     * @returns `true` on success\n     */\n    add(line, onError) {\n        if (this.atNextDocument) {\n            this.yaml = { explicit: Directives.defaultYaml.explicit, version: '1.1' };\n            this.tags = Object.assign({}, Directives.defaultTags);\n            this.atNextDocument = false;\n        }\n        const parts = line.trim().split(/[ \\t]+/);\n        const name = parts.shift();\n        switch (name) {\n            case '%TAG': {\n                if (parts.length !== 2) {\n                    onError(0, '%TAG directive should contain exactly two parts');\n                    if (parts.length < 2)\n                        return false;\n                }\n                const [handle, prefix] = parts;\n                this.tags[handle] = prefix;\n                return true;\n            }\n            case '%YAML': {\n                this.yaml.explicit = true;\n                if (parts.length !== 1) {\n                    onError(0, '%YAML directive should contain exactly one part');\n                    return false;\n                }\n                const [version] = parts;\n                if (version === '1.1' || version === '1.2') {\n                    this.yaml.version = version;\n                    return true;\n                }\n                else {\n                    const isValid = /^\\d+\\.\\d+$/.test(version);\n                    onError(6, `Unsupported YAML version ${version}`, isValid);\n                    return false;\n                }\n            }\n            default:\n                onError(0, `Unknown directive ${name}`, true);\n                return false;\n        }\n    }\n    /**\n     * Resolves a tag, matching handles to those defined in %TAG directives.\n     *\n     * @returns Resolved tag, which may also be the non-specific tag `'!'` or a\n     *   `'!local'` tag, or `null` if unresolvable.\n     */\n    tagName(source, onError) {\n        if (source === '!')\n            return '!'; // non-specific tag\n        if (source[0] !== '!') {\n            onError(`Not a valid tag: ${source}`);\n            return null;\n        }\n        if (source[1] === '<') {\n            const verbatim = source.slice(2, -1);\n            if (verbatim === '!' || verbatim === '!!') {\n                onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);\n                return null;\n            }\n            if (source[source.length - 1] !== '>')\n                onError('Verbatim tags must end with a >');\n            return verbatim;\n        }\n        const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/s);\n        if (!suffix)\n            onError(`The ${source} tag has no suffix`);\n        const prefix = this.tags[handle];\n        if (prefix) {\n            try {\n                return prefix + decodeURIComponent(suffix);\n            }\n            catch (error) {\n                onError(String(error));\n                return null;\n            }\n        }\n        if (handle === '!')\n            return source; // local tag\n        onError(`Could not resolve tag: ${source}`);\n        return null;\n    }\n    /**\n     * Given a fully resolved tag, returns its printable string form,\n     * taking into account current tag prefixes and defaults.\n     */\n    tagString(tag) {\n        for (const [handle, prefix] of Object.entries(this.tags)) {\n            if (tag.startsWith(prefix))\n                return handle + escapeTagName(tag.substring(prefix.length));\n        }\n        return tag[0] === '!' ? tag : `!<${tag}>`;\n    }\n    toString(doc) {\n        const lines = this.yaml.explicit\n            ? [`%YAML ${this.yaml.version || '1.2'}`]\n            : [];\n        const tagEntries = Object.entries(this.tags);\n        let tagNames;\n        if (doc && tagEntries.length > 0 && identity.isNode(doc.contents)) {\n            const tags = {};\n            visit.visit(doc.contents, (_key, node) => {\n                if (identity.isNode(node) && node.tag)\n                    tags[node.tag] = true;\n            });\n            tagNames = Object.keys(tags);\n        }\n        else\n            tagNames = [];\n        for (const [handle, prefix] of tagEntries) {\n            if (handle === '!!' && prefix === 'tag:yaml.org,2002:')\n                continue;\n            if (!doc || tagNames.some(tn => tn.startsWith(prefix)))\n                lines.push(`%TAG ${handle} ${prefix}`);\n        }\n        return lines.join('\\n');\n    }\n}\nDirectives.defaultYaml = { explicit: false, version: '1.2' };\nDirectives.defaultTags = { '!!': 'tag:yaml.org,2002:' };\n\nexports.Directives = Directives;\n","'use strict';\n\nconst ALIAS = Symbol.for('yaml.alias');\nconst DOC = Symbol.for('yaml.document');\nconst MAP = Symbol.for('yaml.map');\nconst PAIR = Symbol.for('yaml.pair');\nconst SCALAR = Symbol.for('yaml.scalar');\nconst SEQ = Symbol.for('yaml.seq');\nconst NODE_TYPE = Symbol.for('yaml.node.type');\nconst isAlias = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === ALIAS;\nconst isDocument = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === DOC;\nconst isMap = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === MAP;\nconst isPair = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === PAIR;\nconst isScalar = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === SCALAR;\nconst isSeq = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === SEQ;\nfunction isCollection(node) {\n    if (node && typeof node === 'object')\n        switch (node[NODE_TYPE]) {\n            case MAP:\n            case SEQ:\n                return true;\n        }\n    return false;\n}\nfunction isNode(node) {\n    if (node && typeof node === 'object')\n        switch (node[NODE_TYPE]) {\n            case ALIAS:\n            case MAP:\n            case SCALAR:\n            case SEQ:\n                return true;\n        }\n    return false;\n}\nconst hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;\n\nexports.ALIAS = ALIAS;\nexports.DOC = DOC;\nexports.MAP = MAP;\nexports.NODE_TYPE = NODE_TYPE;\nexports.PAIR = PAIR;\nexports.SCALAR = SCALAR;\nexports.SEQ = SEQ;\nexports.hasAnchor = hasAnchor;\nexports.isAlias = isAlias;\nexports.isCollection = isCollection;\nexports.isDocument = isDocument;\nexports.isMap = isMap;\nexports.isNode = isNode;\nexports.isPair = isPair;\nexports.isScalar = isScalar;\nexports.isSeq = isSeq;\n","'use strict';\n\nvar identity = require('./nodes/identity.js');\n\nconst BREAK = Symbol('break visit');\nconst SKIP = Symbol('skip children');\nconst REMOVE = Symbol('remove node');\n/**\n * Apply a visitor to an AST node or document.\n *\n * Walks through the tree (depth-first) starting from `node`, calling a\n * `visitor` function with three arguments:\n *   - `key`: For sequence values and map `Pair`, the node's index in the\n *     collection. Within a `Pair`, `'key'` or `'value'`, correspondingly.\n *     `null` for the root node.\n *   - `node`: The current node.\n *   - `path`: The ancestry of the current node.\n *\n * The return value of the visitor may be used to control the traversal:\n *   - `undefined` (default): Do nothing and continue\n *   - `visit.SKIP`: Do not visit the children of this node, continue with next\n *     sibling\n *   - `visit.BREAK`: Terminate traversal completely\n *   - `visit.REMOVE`: Remove the current node, then continue with the next one\n *   - `Node`: Replace the current node, then continue by visiting it\n *   - `number`: While iterating the items of a sequence or map, set the index\n *     of the next step. This is useful especially if the index of the current\n *     node has changed.\n *\n * If `visitor` is a single function, it will be called with all values\n * encountered in the tree, including e.g. `null` values. Alternatively,\n * separate visitor functions may be defined for each `Map`, `Pair`, `Seq`,\n * `Alias` and `Scalar` node. To define the same visitor function for more than\n * one node type, use the `Collection` (map and seq), `Value` (map, seq & scalar)\n * and `Node` (alias, map, seq & scalar) targets. Of all these, only the most\n * specific defined one will be used for each node.\n */\nfunction visit(node, visitor) {\n    const visitor_ = initVisitor(visitor);\n    if (identity.isDocument(node)) {\n        const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));\n        if (cd === REMOVE)\n            node.contents = null;\n    }\n    else\n        visit_(null, node, visitor_, Object.freeze([]));\n}\n// Without the `as symbol` casts, TS declares these in the `visit`\n// namespace using `var`, but then complains about that because\n// `unique symbol` must be `const`.\n/** Terminate visit traversal completely */\nvisit.BREAK = BREAK;\n/** Do not visit the children of the current node */\nvisit.SKIP = SKIP;\n/** Remove the current node */\nvisit.REMOVE = REMOVE;\nfunction visit_(key, node, visitor, path) {\n    const ctrl = callVisitor(key, node, visitor, path);\n    if (identity.isNode(ctrl) || identity.isPair(ctrl)) {\n        replaceNode(key, path, ctrl);\n        return visit_(key, ctrl, visitor, path);\n    }\n    if (typeof ctrl !== 'symbol') {\n        if (identity.isCollection(node)) {\n            path = Object.freeze(path.concat(node));\n            for (let i = 0; i < node.items.length; ++i) {\n                const ci = visit_(i, node.items[i], visitor, path);\n                if (typeof ci === 'number')\n                    i = ci - 1;\n                else if (ci === BREAK)\n                    return BREAK;\n                else if (ci === REMOVE) {\n                    node.items.splice(i, 1);\n                    i -= 1;\n                }\n            }\n        }\n        else if (identity.isPair(node)) {\n            path = Object.freeze(path.concat(node));\n            const ck = visit_('key', node.key, visitor, path);\n            if (ck === BREAK)\n                return BREAK;\n            else if (ck === REMOVE)\n                node.key = null;\n            const cv = visit_('value', node.value, visitor, path);\n            if (cv === BREAK)\n                return BREAK;\n            else if (cv === REMOVE)\n                node.value = null;\n        }\n    }\n    return ctrl;\n}\n/**\n * Apply an async visitor to an AST node or document.\n *\n * Walks through the tree (depth-first) starting from `node`, calling a\n * `visitor` function with three arguments:\n *   - `key`: For sequence values and map `Pair`, the node's index in the\n *     collection. Within a `Pair`, `'key'` or `'value'`, correspondingly.\n *     `null` for the root node.\n *   - `node`: The current node.\n *   - `path`: The ancestry of the current node.\n *\n * The return value of the visitor may be used to control the traversal:\n *   - `Promise`: Must resolve to one of the following values\n *   - `undefined` (default): Do nothing and continue\n *   - `visit.SKIP`: Do not visit the children of this node, continue with next\n *     sibling\n *   - `visit.BREAK`: Terminate traversal completely\n *   - `visit.REMOVE`: Remove the current node, then continue with the next one\n *   - `Node`: Replace the current node, then continue by visiting it\n *   - `number`: While iterating the items of a sequence or map, set the index\n *     of the next step. This is useful especially if the index of the current\n *     node has changed.\n *\n * If `visitor` is a single function, it will be called with all values\n * encountered in the tree, including e.g. `null` values. Alternatively,\n * separate visitor functions may be defined for each `Map`, `Pair`, `Seq`,\n * `Alias` and `Scalar` node. To define the same visitor function for more than\n * one node type, use the `Collection` (map and seq), `Value` (map, seq & scalar)\n * and `Node` (alias, map, seq & scalar) targets. Of all these, only the most\n * specific defined one will be used for each node.\n */\nasync function visitAsync(node, visitor) {\n    const visitor_ = initVisitor(visitor);\n    if (identity.isDocument(node)) {\n        const cd = await visitAsync_(null, node.contents, visitor_, Object.freeze([node]));\n        if (cd === REMOVE)\n            node.contents = null;\n    }\n    else\n        await visitAsync_(null, node, visitor_, Object.freeze([]));\n}\n// Without the `as symbol` casts, TS declares these in the `visit`\n// namespace using `var`, but then complains about that because\n// `unique symbol` must be `const`.\n/** Terminate visit traversal completely */\nvisitAsync.BREAK = BREAK;\n/** Do not visit the children of the current node */\nvisitAsync.SKIP = SKIP;\n/** Remove the current node */\nvisitAsync.REMOVE = REMOVE;\nasync function visitAsync_(key, node, visitor, path) {\n    const ctrl = await callVisitor(key, node, visitor, path);\n    if (identity.isNode(ctrl) || identity.isPair(ctrl)) {\n        replaceNode(key, path, ctrl);\n        return visitAsync_(key, ctrl, visitor, path);\n    }\n    if (typeof ctrl !== 'symbol') {\n        if (identity.isCollection(node)) {\n            path = Object.freeze(path.concat(node));\n            for (let i = 0; i < node.items.length; ++i) {\n                const ci = await visitAsync_(i, node.items[i], visitor, path);\n                if (typeof ci === 'number')\n                    i = ci - 1;\n                else if (ci === BREAK)\n                    return BREAK;\n                else if (ci === REMOVE) {\n                    node.items.splice(i, 1);\n                    i -= 1;\n                }\n            }\n        }\n        else if (identity.isPair(node)) {\n            path = Object.freeze(path.concat(node));\n            const ck = await visitAsync_('key', node.key, visitor, path);\n            if (ck === BREAK)\n                return BREAK;\n            else if (ck === REMOVE)\n                node.key = null;\n            const cv = await visitAsync_('value', node.value, visitor, path);\n            if (cv === BREAK)\n                return BREAK;\n            else if (cv === REMOVE)\n                node.value = null;\n        }\n    }\n    return ctrl;\n}\nfunction initVisitor(visitor) {\n    if (typeof visitor === 'object' &&\n        (visitor.Collection || visitor.Node || visitor.Value)) {\n        return Object.assign({\n            Alias: visitor.Node,\n            Map: visitor.Node,\n            Scalar: visitor.Node,\n            Seq: visitor.Node\n        }, visitor.Value && {\n            Map: visitor.Value,\n            Scalar: visitor.Value,\n            Seq: visitor.Value\n        }, visitor.Collection && {\n            Map: visitor.Collection,\n            Seq: visitor.Collection\n        }, visitor);\n    }\n    return visitor;\n}\nfunction callVisitor(key, node, visitor, path) {\n    if (typeof visitor === 'function')\n        return visitor(key, node, path);\n    if (identity.isMap(node))\n        return visitor.Map?.(key, node, path);\n    if (identity.isSeq(node))\n        return visitor.Seq?.(key, node, path);\n    if (identity.isPair(node))\n        return visitor.Pair?.(key, node, path);\n    if (identity.isScalar(node))\n        return visitor.Scalar?.(key, node, path);\n    if (identity.isAlias(node))\n        return visitor.Alias?.(key, node, path);\n    return undefined;\n}\nfunction replaceNode(key, path, node) {\n    const parent = path[path.length - 1];\n    if (identity.isCollection(parent)) {\n        parent.items[key] = node;\n    }\n    else if (identity.isPair(parent)) {\n        if (key === 'key')\n            parent.key = node;\n        else\n            parent.value = node;\n    }\n    else if (identity.isDocument(parent)) {\n        parent.contents = node;\n    }\n    else {\n        const pt = identity.isAlias(parent) ? 'alias' : 'scalar';\n        throw new Error(`Cannot replace node with ${pt} parent`);\n    }\n}\n\nexports.visit = visit;\nexports.visitAsync = visitAsync;\n","'use strict';\n\nvar Alias = require('../nodes/Alias.js');\nvar Collection = require('../nodes/Collection.js');\nvar identity = require('../nodes/identity.js');\nvar Pair = require('../nodes/Pair.js');\nvar toJS = require('../nodes/toJS.js');\nvar Schema = require('../schema/Schema.js');\nvar stringifyDocument = require('../stringify/stringifyDocument.js');\nvar anchors = require('./anchors.js');\nvar applyReviver = require('./applyReviver.js');\nvar createNode = require('./createNode.js');\nvar directives = require('./directives.js');\n\nclass Document {\n    constructor(value, replacer, options) {\n        /** A comment before this Document */\n        this.commentBefore = null;\n        /** A comment immediately after this Document */\n        this.comment = null;\n        /** Errors encountered during parsing. */\n        this.errors = [];\n        /** Warnings encountered during parsing. */\n        this.warnings = [];\n        Object.defineProperty(this, identity.NODE_TYPE, { value: identity.DOC });\n        let _replacer = null;\n        if (typeof replacer === 'function' || Array.isArray(replacer)) {\n            _replacer = replacer;\n        }\n        else if (options === undefined && replacer) {\n            options = replacer;\n            replacer = undefined;\n        }\n        const opt = Object.assign({\n            intAsBigInt: false,\n            keepSourceTokens: false,\n            logLevel: 'warn',\n            prettyErrors: true,\n            strict: true,\n            stringKeys: false,\n            uniqueKeys: true,\n            version: '1.2'\n        }, options);\n        this.options = opt;\n        let { version } = opt;\n        if (options?._directives) {\n            this.directives = options._directives.atDocument();\n            if (this.directives.yaml.explicit)\n                version = this.directives.yaml.version;\n        }\n        else\n            this.directives = new directives.Directives({ version });\n        this.setSchema(version, options);\n        // @ts-expect-error We can't really know that this matches Contents.\n        this.contents =\n            value === undefined ? null : this.createNode(value, _replacer, options);\n    }\n    /**\n     * Create a deep copy of this Document and its contents.\n     *\n     * Custom Node values that inherit from `Object` still refer to their original instances.\n     */\n    clone() {\n        const copy = Object.create(Document.prototype, {\n            [identity.NODE_TYPE]: { value: identity.DOC }\n        });\n        copy.commentBefore = this.commentBefore;\n        copy.comment = this.comment;\n        copy.errors = this.errors.slice();\n        copy.warnings = this.warnings.slice();\n        copy.options = Object.assign({}, this.options);\n        if (this.directives)\n            copy.directives = this.directives.clone();\n        copy.schema = this.schema.clone();\n        // @ts-expect-error We can't really know that this matches Contents.\n        copy.contents = identity.isNode(this.contents)\n            ? this.contents.clone(copy.schema)\n            : this.contents;\n        if (this.range)\n            copy.range = this.range.slice();\n        return copy;\n    }\n    /** Adds a value to the document. */\n    add(value) {\n        if (assertCollection(this.contents))\n            this.contents.add(value);\n    }\n    /** Adds a value to the document. */\n    addIn(path, value) {\n        if (assertCollection(this.contents))\n            this.contents.addIn(path, value);\n    }\n    /**\n     * Create a new `Alias` node, ensuring that the target `node` has the required anchor.\n     *\n     * If `node` already has an anchor, `name` is ignored.\n     * Otherwise, the `node.anchor` value will be set to `name`,\n     * or if an anchor with that name is already present in the document,\n     * `name` will be used as a prefix for a new unique anchor.\n     * If `name` is undefined, the generated anchor will use 'a' as a prefix.\n     */\n    createAlias(node, name) {\n        if (!node.anchor) {\n            const prev = anchors.anchorNames(this);\n            node.anchor =\n                // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n                !name || prev.has(name) ? anchors.findNewAnchor(name || 'a', prev) : name;\n        }\n        return new Alias.Alias(node.anchor);\n    }\n    createNode(value, replacer, options) {\n        let _replacer = undefined;\n        if (typeof replacer === 'function') {\n            value = replacer.call({ '': value }, '', value);\n            _replacer = replacer;\n        }\n        else if (Array.isArray(replacer)) {\n            const keyToStr = (v) => typeof v === 'number' || v instanceof String || v instanceof Number;\n            const asStr = replacer.filter(keyToStr).map(String);\n            if (asStr.length > 0)\n                replacer = replacer.concat(asStr);\n            _replacer = replacer;\n        }\n        else if (options === undefined && replacer) {\n            options = replacer;\n            replacer = undefined;\n        }\n        const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options ?? {};\n        const { onAnchor, setAnchors, sourceObjects } = anchors.createNodeAnchors(this, \n        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n        anchorPrefix || 'a');\n        const ctx = {\n            aliasDuplicateObjects: aliasDuplicateObjects ?? true,\n            keepUndefined: keepUndefined ?? false,\n            onAnchor,\n            onTagObj,\n            replacer: _replacer,\n            schema: this.schema,\n            sourceObjects\n        };\n        const node = createNode.createNode(value, tag, ctx);\n        if (flow && identity.isCollection(node))\n            node.flow = true;\n        setAnchors();\n        return node;\n    }\n    /**\n     * Convert a key and a value into a `Pair` using the current schema,\n     * recursively wrapping all values as `Scalar` or `Collection` nodes.\n     */\n    createPair(key, value, options = {}) {\n        const k = this.createNode(key, null, options);\n        const v = this.createNode(value, null, options);\n        return new Pair.Pair(k, v);\n    }\n    /**\n     * Removes a value from the document.\n     * @returns `true` if the item was found and removed.\n     */\n    delete(key) {\n        return assertCollection(this.contents) ? this.contents.delete(key) : false;\n    }\n    /**\n     * Removes a value from the document.\n     * @returns `true` if the item was found and removed.\n     */\n    deleteIn(path) {\n        if (Collection.isEmptyPath(path)) {\n            if (this.contents == null)\n                return false;\n            // @ts-expect-error Presumed impossible if Strict extends false\n            this.contents = null;\n            return true;\n        }\n        return assertCollection(this.contents)\n            ? this.contents.deleteIn(path)\n            : false;\n    }\n    /**\n     * Returns item at `key`, or `undefined` if not found. By default unwraps\n     * scalar values from their surrounding node; to disable set `keepScalar` to\n     * `true` (collections are always returned intact).\n     */\n    get(key, keepScalar) {\n        return identity.isCollection(this.contents)\n            ? this.contents.get(key, keepScalar)\n            : undefined;\n    }\n    /**\n     * Returns item at `path`, or `undefined` if not found. By default unwraps\n     * scalar values from their surrounding node; to disable set `keepScalar` to\n     * `true` (collections are always returned intact).\n     */\n    getIn(path, keepScalar) {\n        if (Collection.isEmptyPath(path))\n            return !keepScalar && identity.isScalar(this.contents)\n                ? this.contents.value\n                : this.contents;\n        return identity.isCollection(this.contents)\n            ? this.contents.getIn(path, keepScalar)\n            : undefined;\n    }\n    /**\n     * Checks if the document includes a value with the key `key`.\n     */\n    has(key) {\n        return identity.isCollection(this.contents) ? this.contents.has(key) : false;\n    }\n    /**\n     * Checks if the document includes a value at `path`.\n     */\n    hasIn(path) {\n        if (Collection.isEmptyPath(path))\n            return this.contents !== undefined;\n        return identity.isCollection(this.contents) ? this.contents.hasIn(path) : false;\n    }\n    /**\n     * Sets a value in this document. For `!!set`, `value` needs to be a\n     * boolean to add/remove the item from the set.\n     */\n    set(key, value) {\n        if (this.contents == null) {\n            // @ts-expect-error We can't really know that this matches Contents.\n            this.contents = Collection.collectionFromPath(this.schema, [key], value);\n        }\n        else if (assertCollection(this.contents)) {\n            this.contents.set(key, value);\n        }\n    }\n    /**\n     * Sets a value in this document. For `!!set`, `value` needs to be a\n     * boolean to add/remove the item from the set.\n     */\n    setIn(path, value) {\n        if (Collection.isEmptyPath(path)) {\n            // @ts-expect-error We can't really know that this matches Contents.\n            this.contents = value;\n        }\n        else if (this.contents == null) {\n            // @ts-expect-error We can't really know that this matches Contents.\n            this.contents = Collection.collectionFromPath(this.schema, Array.from(path), value);\n        }\n        else if (assertCollection(this.contents)) {\n            this.contents.setIn(path, value);\n        }\n    }\n    /**\n     * Change the YAML version and schema used by the document.\n     * A `null` version disables support for directives, explicit tags, anchors, and aliases.\n     * It also requires the `schema` option to be given as a `Schema` instance value.\n     *\n     * Overrides all previously set schema options.\n     */\n    setSchema(version, options = {}) {\n        if (typeof version === 'number')\n            version = String(version);\n        let opt;\n        switch (version) {\n            case '1.1':\n                if (this.directives)\n                    this.directives.yaml.version = '1.1';\n                else\n                    this.directives = new directives.Directives({ version: '1.1' });\n                opt = { resolveKnownTags: false, schema: 'yaml-1.1' };\n                break;\n            case '1.2':\n            case 'next':\n                if (this.directives)\n                    this.directives.yaml.version = version;\n                else\n                    this.directives = new directives.Directives({ version });\n                opt = { resolveKnownTags: true, schema: 'core' };\n                break;\n            case null:\n                if (this.directives)\n                    delete this.directives;\n                opt = null;\n                break;\n            default: {\n                const sv = JSON.stringify(version);\n                throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);\n            }\n        }\n        // Not using `instanceof Schema` to allow for duck typing\n        if (options.schema instanceof Object)\n            this.schema = options.schema;\n        else if (opt)\n            this.schema = new Schema.Schema(Object.assign(opt, options));\n        else\n            throw new Error(`With a null YAML version, the { schema: Schema } option is required`);\n    }\n    // json & jsonArg are only used from toJSON()\n    toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {\n        const ctx = {\n            anchors: new Map(),\n            doc: this,\n            keep: !json,\n            mapAsMap: mapAsMap === true,\n            mapKeyWarned: false,\n            maxAliasCount: typeof maxAliasCount === 'number' ? maxAliasCount : 100\n        };\n        const res = toJS.toJS(this.contents, jsonArg ?? '', ctx);\n        if (typeof onAnchor === 'function')\n            for (const { count, res } of ctx.anchors.values())\n                onAnchor(res, count);\n        return typeof reviver === 'function'\n            ? applyReviver.applyReviver(reviver, { '': res }, '', res)\n            : res;\n    }\n    /**\n     * A JSON representation of the document `contents`.\n     *\n     * @param jsonArg Used by `JSON.stringify` to indicate the array index or\n     *   property name.\n     */\n    toJSON(jsonArg, onAnchor) {\n        return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });\n    }\n    /** A YAML representation of the document. */\n    toString(options = {}) {\n        if (this.errors.length > 0)\n            throw new Error('Document with errors cannot be stringified');\n        if ('indent' in options &&\n            (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {\n            const s = JSON.stringify(options.indent);\n            throw new Error(`\"indent\" option must be a positive integer, not ${s}`);\n        }\n        return stringifyDocument.stringifyDocument(this, options);\n    }\n}\nfunction assertCollection(contents) {\n    if (identity.isCollection(contents))\n        return true;\n    throw new Error('Expected a YAML collection as document contents');\n}\n\nexports.Document = Document;\n","'use strict';\n\nvar anchors = require('../doc/anchors.js');\nvar visit = require('../visit.js');\nvar identity = require('./identity.js');\nvar Node = require('./Node.js');\nvar toJS = require('./toJS.js');\n\nclass Alias extends Node.NodeBase {\n    constructor(source) {\n        super(identity.ALIAS);\n        this.source = source;\n        Object.defineProperty(this, 'tag', {\n            set() {\n                throw new Error('Alias nodes cannot have tags');\n            }\n        });\n    }\n    /**\n     * Resolve the value of this alias within `doc`, finding the last\n     * instance of the `source` anchor before this node.\n     */\n    resolve(doc, ctx) {\n        let nodes;\n        if (ctx?.aliasResolveCache) {\n            nodes = ctx.aliasResolveCache;\n        }\n        else {\n            nodes = [];\n            visit.visit(doc, {\n                Node: (_key, node) => {\n                    if (identity.isAlias(node) || identity.hasAnchor(node))\n                        nodes.push(node);\n                }\n            });\n            if (ctx)\n                ctx.aliasResolveCache = nodes;\n        }\n        let found = undefined;\n        for (const node of nodes) {\n            if (node === this)\n                break;\n            if (node.anchor === this.source)\n                found = node;\n        }\n        return found;\n    }\n    toJSON(_arg, ctx) {\n        if (!ctx)\n            return { source: this.source };\n        const { anchors, doc, maxAliasCount } = ctx;\n        const source = this.resolve(doc, ctx);\n        if (!source) {\n            const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;\n            throw new ReferenceError(msg);\n        }\n        let data = anchors.get(source);\n        if (!data) {\n            // Resolve anchors for Node.prototype.toJS()\n            toJS.toJS(source, null, ctx);\n            data = anchors.get(source);\n        }\n        /* istanbul ignore if */\n        if (!data || data.res === undefined) {\n            const msg = 'This should not happen: Alias anchor was not resolved?';\n            throw new ReferenceError(msg);\n        }\n        if (maxAliasCount >= 0) {\n            data.count += 1;\n            if (data.aliasCount === 0)\n                data.aliasCount = getAliasCount(doc, source, anchors);\n            if (data.count * data.aliasCount > maxAliasCount) {\n                const msg = 'Excessive alias count indicates a resource exhaustion attack';\n                throw new ReferenceError(msg);\n            }\n        }\n        return data.res;\n    }\n    toString(ctx, _onComment, _onChompKeep) {\n        const src = `*${this.source}`;\n        if (ctx) {\n            anchors.anchorIsValid(this.source);\n            if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {\n                const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;\n                throw new Error(msg);\n            }\n            if (ctx.implicitKey)\n                return `${src} `;\n        }\n        return src;\n    }\n}\nfunction getAliasCount(doc, node, anchors) {\n    if (identity.isAlias(node)) {\n        const source = node.resolve(doc);\n        const anchor = anchors && source && anchors.get(source);\n        return anchor ? anchor.count * anchor.aliasCount : 0;\n    }\n    else if (identity.isCollection(node)) {\n        let count = 0;\n        for (const item of node.items) {\n            const c = getAliasCount(doc, item, anchors);\n            if (c > count)\n                count = c;\n        }\n        return count;\n    }\n    else if (identity.isPair(node)) {\n        const kc = getAliasCount(doc, node.key, anchors);\n        const vc = getAliasCount(doc, node.value, anchors);\n        return Math.max(kc, vc);\n    }\n    return 1;\n}\n\nexports.Alias = Alias;\n","'use strict';\n\nvar identity = require('../nodes/identity.js');\nvar visit = require('../visit.js');\n\n/**\n * Verify that the input string is a valid anchor.\n *\n * Will throw on errors.\n */\nfunction anchorIsValid(anchor) {\n    if (/[\\x00-\\x19\\s,[\\]{}]/.test(anchor)) {\n        const sa = JSON.stringify(anchor);\n        const msg = `Anchor must not contain whitespace or control characters: ${sa}`;\n        throw new Error(msg);\n    }\n    return true;\n}\nfunction anchorNames(root) {\n    const anchors = new Set();\n    visit.visit(root, {\n        Value(_key, node) {\n            if (node.anchor)\n                anchors.add(node.anchor);\n        }\n    });\n    return anchors;\n}\n/** Find a new anchor name with the given `prefix` and a one-indexed suffix. */\nfunction findNewAnchor(prefix, exclude) {\n    for (let i = 1; true; ++i) {\n        const name = `${prefix}${i}`;\n        if (!exclude.has(name))\n            return name;\n    }\n}\nfunction createNodeAnchors(doc, prefix) {\n    const aliasObjects = [];\n    const sourceObjects = new Map();\n    let prevAnchors = null;\n    return {\n        onAnchor: (source) => {\n            aliasObjects.push(source);\n            prevAnchors ?? (prevAnchors = anchorNames(doc));\n            const anchor = findNewAnchor(prefix, prevAnchors);\n            prevAnchors.add(anchor);\n            return anchor;\n        },\n        /**\n         * With circular references, the source node is only resolved after all\n         * of its child nodes are. This is why anchors are set only after all of\n         * the nodes have been created.\n         */\n        setAnchors: () => {\n            for (const source of aliasObjects) {\n                const ref = sourceObjects.get(source);\n                if (typeof ref === 'object' &&\n                    ref.anchor &&\n                    (identity.isScalar(ref.node) || identity.isCollection(ref.node))) {\n                    ref.node.anchor = ref.anchor;\n                }\n                else {\n                    const error = new Error('Failed to resolve repeated object (this should not happen)');\n                    error.source = source;\n                    throw error;\n                }\n            }\n        },\n        sourceObjects\n    };\n}\n\nexports.anchorIsValid = anchorIsValid;\nexports.anchorNames = anchorNames;\nexports.createNodeAnchors = createNodeAnchors;\nexports.findNewAnchor = findNewAnchor;\n","'use strict';\n\nvar applyReviver = require('../doc/applyReviver.js');\nvar identity = require('./identity.js');\nvar toJS = require('./toJS.js');\n\nclass NodeBase {\n    constructor(type) {\n        Object.defineProperty(this, identity.NODE_TYPE, { value: type });\n    }\n    /** Create a copy of this node.  */\n    clone() {\n        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));\n        if (this.range)\n            copy.range = this.range.slice();\n        return copy;\n    }\n    /** A plain JavaScript representation of this node. */\n    toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {\n        if (!identity.isDocument(doc))\n            throw new TypeError('A document argument is required');\n        const ctx = {\n            anchors: new Map(),\n            doc,\n            keep: true,\n            mapAsMap: mapAsMap === true,\n            mapKeyWarned: false,\n            maxAliasCount: typeof maxAliasCount === 'number' ? maxAliasCount : 100\n        };\n        const res = toJS.toJS(this, '', ctx);\n        if (typeof onAnchor === 'function')\n            for (const { count, res } of ctx.anchors.values())\n                onAnchor(res, count);\n        return typeof reviver === 'function'\n            ? applyReviver.applyReviver(reviver, { '': res }, '', res)\n            : res;\n    }\n}\n\nexports.NodeBase = NodeBase;\n","'use strict';\n\n/**\n * Applies the JSON.parse reviver algorithm as defined in the ECMA-262 spec,\n * in section 24.5.1.1 \"Runtime Semantics: InternalizeJSONProperty\" of the\n * 2021 edition: https://tc39.es/ecma262/#sec-json.parse\n *\n * Includes extensions for handling Map and Set objects.\n */\nfunction applyReviver(reviver, obj, key, val) {\n    if (val && typeof val === 'object') {\n        if (Array.isArray(val)) {\n            for (let i = 0, len = val.length; i < len; ++i) {\n                const v0 = val[i];\n                const v1 = applyReviver(reviver, val, String(i), v0);\n                // eslint-disable-next-line @typescript-eslint/no-array-delete\n                if (v1 === undefined)\n                    delete val[i];\n                else if (v1 !== v0)\n                    val[i] = v1;\n            }\n        }\n        else if (val instanceof Map) {\n            for (const k of Array.from(val.keys())) {\n                const v0 = val.get(k);\n                const v1 = applyReviver(reviver, val, k, v0);\n                if (v1 === undefined)\n                    val.delete(k);\n                else if (v1 !== v0)\n                    val.set(k, v1);\n            }\n        }\n        else if (val instanceof Set) {\n            for (const v0 of Array.from(val)) {\n                const v1 = applyReviver(reviver, val, v0, v0);\n                if (v1 === undefined)\n                    val.delete(v0);\n                else if (v1 !== v0) {\n                    val.delete(v0);\n                    val.add(v1);\n                }\n            }\n        }\n        else {\n            for (const [k, v0] of Object.entries(val)) {\n                const v1 = applyReviver(reviver, val, k, v0);\n                if (v1 === undefined)\n                    delete val[k];\n                else if (v1 !== v0)\n                    val[k] = v1;\n            }\n        }\n    }\n    return reviver.call(obj, key, val);\n}\n\nexports.applyReviver = applyReviver;\n","'use strict';\n\nvar identity = require('./identity.js');\n\n/**\n * Recursively convert any node or its contents to native JavaScript\n *\n * @param value - The input value\n * @param arg - If `value` defines a `toJSON()` method, use this\n *   as its first argument\n * @param ctx - Conversion context, originally set in Document#toJS(). If\n *   `{ keep: true }` is not set, output should be suitable for JSON\n *   stringification.\n */\nfunction toJS(value, arg, ctx) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    if (Array.isArray(value))\n        return value.map((v, i) => toJS(v, String(i), ctx));\n    if (value && typeof value.toJSON === 'function') {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n        if (!ctx || !identity.hasAnchor(value))\n            return value.toJSON(arg, ctx);\n        const data = { aliasCount: 0, count: 1, res: undefined };\n        ctx.anchors.set(value, data);\n        ctx.onCreate = res => {\n            data.res = res;\n            delete ctx.onCreate;\n        };\n        const res = value.toJSON(arg, ctx);\n        if (ctx.onCreate)\n            ctx.onCreate(res);\n        return res;\n    }\n    if (typeof value === 'bigint' && !ctx?.keep)\n        return Number(value);\n    return value;\n}\n\nexports.toJS = toJS;\n","'use strict';\n\nvar createNode = require('../doc/createNode.js');\nvar identity = require('./identity.js');\nvar Node = require('./Node.js');\n\nfunction collectionFromPath(schema, path, value) {\n    let v = value;\n    for (let i = path.length - 1; i >= 0; --i) {\n        const k = path[i];\n        if (typeof k === 'number' && Number.isInteger(k) && k >= 0) {\n            const a = [];\n            a[k] = v;\n            v = a;\n        }\n        else {\n            v = new Map([[k, v]]);\n        }\n    }\n    return createNode.createNode(v, undefined, {\n        aliasDuplicateObjects: false,\n        keepUndefined: false,\n        onAnchor: () => {\n            throw new Error('This should not happen, please report a bug.');\n        },\n        schema,\n        sourceObjects: new Map()\n    });\n}\n// Type guard is intentionally a little wrong so as to be more useful,\n// as it does not cover untypable empty non-string iterables (e.g. []).\nconst isEmptyPath = (path) => path == null ||\n    (typeof path === 'object' && !!path[Symbol.iterator]().next().done);\nclass Collection extends Node.NodeBase {\n    constructor(type, schema) {\n        super(type);\n        Object.defineProperty(this, 'schema', {\n            value: schema,\n            configurable: true,\n            enumerable: false,\n            writable: true\n        });\n    }\n    /**\n     * Create a copy of this collection.\n     *\n     * @param schema - If defined, overwrites the original's schema\n     */\n    clone(schema) {\n        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));\n        if (schema)\n            copy.schema = schema;\n        copy.items = copy.items.map(it => identity.isNode(it) || identity.isPair(it) ? it.clone(schema) : it);\n        if (this.range)\n            copy.range = this.range.slice();\n        return copy;\n    }\n    /**\n     * Adds a value to the collection. For `!!map` and `!!omap` the value must\n     * be a Pair instance or a `{ key, value }` object, which may not have a key\n     * that already exists in the map.\n     */\n    addIn(path, value) {\n        if (isEmptyPath(path))\n            this.add(value);\n        else {\n            const [key, ...rest] = path;\n            const node = this.get(key, true);\n            if (identity.isCollection(node))\n                node.addIn(rest, value);\n            else if (node === undefined && this.schema)\n                this.set(key, collectionFromPath(this.schema, rest, value));\n            else\n                throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n        }\n    }\n    /**\n     * Removes a value from the collection.\n     * @returns `true` if the item was found and removed.\n     */\n    deleteIn(path) {\n        const [key, ...rest] = path;\n        if (rest.length === 0)\n            return this.delete(key);\n        const node = this.get(key, true);\n        if (identity.isCollection(node))\n            return node.deleteIn(rest);\n        else\n            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n    }\n    /**\n     * Returns item at `key`, or `undefined` if not found. By default unwraps\n     * scalar values from their surrounding node; to disable set `keepScalar` to\n     * `true` (collections are always returned intact).\n     */\n    getIn(path, keepScalar) {\n        const [key, ...rest] = path;\n        const node = this.get(key, true);\n        if (rest.length === 0)\n            return !keepScalar && identity.isScalar(node) ? node.value : node;\n        else\n            return identity.isCollection(node) ? node.getIn(rest, keepScalar) : undefined;\n    }\n    hasAllNullValues(allowScalar) {\n        return this.items.every(node => {\n            if (!identity.isPair(node))\n                return false;\n            const n = node.value;\n            return (n == null ||\n                (allowScalar &&\n                    identity.isScalar(n) &&\n                    n.value == null &&\n                    !n.commentBefore &&\n                    !n.comment &&\n                    !n.tag));\n        });\n    }\n    /**\n     * Checks if the collection includes a value with the key `key`.\n     */\n    hasIn(path) {\n        const [key, ...rest] = path;\n        if (rest.length === 0)\n            return this.has(key);\n        const node = this.get(key, true);\n        return identity.isCollection(node) ? node.hasIn(rest) : false;\n    }\n    /**\n     * Sets a value in this collection. For `!!set`, `value` needs to be a\n     * boolean to add/remove the item from the set.\n     */\n    setIn(path, value) {\n        const [key, ...rest] = path;\n        if (rest.length === 0) {\n            this.set(key, value);\n        }\n        else {\n            const node = this.get(key, true);\n            if (identity.isCollection(node))\n                node.setIn(rest, value);\n            else if (node === undefined && this.schema)\n                this.set(key, collectionFromPath(this.schema, rest, value));\n            else\n                throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n        }\n    }\n}\n\nexports.Collection = Collection;\nexports.collectionFromPath = collectionFromPath;\nexports.isEmptyPath = isEmptyPath;\n","'use strict';\n\nvar Alias = require('../nodes/Alias.js');\nvar identity = require('../nodes/identity.js');\nvar Scalar = require('../nodes/Scalar.js');\n\nconst defaultTagPrefix = 'tag:yaml.org,2002:';\nfunction findTagObject(value, tagName, tags) {\n    if (tagName) {\n        const match = tags.filter(t => t.tag === tagName);\n        const tagObj = match.find(t => !t.format) ?? match[0];\n        if (!tagObj)\n            throw new Error(`Tag ${tagName} not found`);\n        return tagObj;\n    }\n    return tags.find(t => t.identify?.(value) && !t.format);\n}\nfunction createNode(value, tagName, ctx) {\n    if (identity.isDocument(value))\n        value = value.contents;\n    if (identity.isNode(value))\n        return value;\n    if (identity.isPair(value)) {\n        const map = ctx.schema[identity.MAP].createNode?.(ctx.schema, null, ctx);\n        map.items.push(value);\n        return map;\n    }\n    if (value instanceof String ||\n        value instanceof Number ||\n        value instanceof Boolean ||\n        (typeof BigInt !== 'undefined' && value instanceof BigInt) // not supported everywhere\n    ) {\n        // https://tc39.es/ecma262/#sec-serializejsonproperty\n        value = value.valueOf();\n    }\n    const { aliasDuplicateObjects, onAnchor, onTagObj, schema, sourceObjects } = ctx;\n    // Detect duplicate references to the same object & use Alias nodes for all\n    // after first. The `ref` wrapper allows for circular references to resolve.\n    let ref = undefined;\n    if (aliasDuplicateObjects && value && typeof value === 'object') {\n        ref = sourceObjects.get(value);\n        if (ref) {\n            ref.anchor ?? (ref.anchor = onAnchor(value));\n            return new Alias.Alias(ref.anchor);\n        }\n        else {\n            ref = { anchor: null, node: null };\n            sourceObjects.set(value, ref);\n        }\n    }\n    if (tagName?.startsWith('!!'))\n        tagName = defaultTagPrefix + tagName.slice(2);\n    let tagObj = findTagObject(value, tagName, schema.tags);\n    if (!tagObj) {\n        if (value && typeof value.toJSON === 'function') {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n            value = value.toJSON();\n        }\n        if (!value || typeof value !== 'object') {\n            const node = new Scalar.Scalar(value);\n            if (ref)\n                ref.node = node;\n            return node;\n        }\n        tagObj =\n            value instanceof Map\n                ? schema[identity.MAP]\n                : Symbol.iterator in Object(value)\n                    ? schema[identity.SEQ]\n                    : schema[identity.MAP];\n    }\n    if (onTagObj) {\n        onTagObj(tagObj);\n        delete ctx.onTagObj;\n    }\n    const node = tagObj?.createNode\n        ? tagObj.createNode(ctx.schema, value, ctx)\n        : typeof tagObj?.nodeClass?.from === 'function'\n            ? tagObj.nodeClass.from(ctx.schema, value, ctx)\n            : new Scalar.Scalar(value);\n    if (tagName)\n        node.tag = tagName;\n    else if (!tagObj.default)\n        node.tag = tagObj.tag;\n    if (ref)\n        ref.node = node;\n    return node;\n}\n\nexports.createNode = createNode;\n","'use strict';\n\nvar identity = require('./identity.js');\nvar Node = require('./Node.js');\nvar toJS = require('./toJS.js');\n\nconst isScalarValue = (value) => !value || (typeof value !== 'function' && typeof value !== 'object');\nclass Scalar extends Node.NodeBase {\n    constructor(value) {\n        super(identity.SCALAR);\n        this.value = value;\n    }\n    toJSON(arg, ctx) {\n        return ctx?.keep ? this.value : toJS.toJS(this.value, arg, ctx);\n    }\n    toString() {\n        return String(this.value);\n    }\n}\nScalar.BLOCK_FOLDED = 'BLOCK_FOLDED';\nScalar.BLOCK_LITERAL = 'BLOCK_LITERAL';\nScalar.PLAIN = 'PLAIN';\nScalar.QUOTE_DOUBLE = 'QUOTE_DOUBLE';\nScalar.QUOTE_SINGLE = 'QUOTE_SINGLE';\n\nexports.Scalar = Scalar;\nexports.isScalarValue = isScalarValue;\n","'use strict';\n\nvar createNode = require('../doc/createNode.js');\nvar stringifyPair = require('../stringify/stringifyPair.js');\nvar addPairToJSMap = require('./addPairToJSMap.js');\nvar identity = require('./identity.js');\n\nfunction createPair(key, value, ctx) {\n    const k = createNode.createNode(key, undefined, ctx);\n    const v = createNode.createNode(value, undefined, ctx);\n    return new Pair(k, v);\n}\nclass Pair {\n    constructor(key, value = null) {\n        Object.defineProperty(this, identity.NODE_TYPE, { value: identity.PAIR });\n        this.key = key;\n        this.value = value;\n    }\n    clone(schema) {\n        let { key, value } = this;\n        if (identity.isNode(key))\n            key = key.clone(schema);\n        if (identity.isNode(value))\n            value = value.clone(schema);\n        return new Pair(key, value);\n    }\n    toJSON(_, ctx) {\n        const pair = ctx?.mapAsMap ? new Map() : {};\n        return addPairToJSMap.addPairToJSMap(ctx, pair, this);\n    }\n    toString(ctx, onComment, onChompKeep) {\n        return ctx?.doc\n            ? stringifyPair.stringifyPair(this, ctx, onComment, onChompKeep)\n            : JSON.stringify(this);\n    }\n}\n\nexports.Pair = Pair;\nexports.createPair = createPair;\n","'use strict';\n\nvar identity = require('../nodes/identity.js');\nvar Scalar = require('../nodes/Scalar.js');\nvar stringify = require('./stringify.js');\nvar stringifyComment = require('./stringifyComment.js');\n\nfunction stringifyPair({ key, value }, ctx, onComment, onChompKeep) {\n    const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;\n    let keyComment = (identity.isNode(key) && key.comment) || null;\n    if (simpleKeys) {\n        if (keyComment) {\n            throw new Error('With simple keys, key nodes cannot have comments');\n        }\n        if (identity.isCollection(key) || (!identity.isNode(key) && typeof key === 'object')) {\n            const msg = 'With simple keys, collection cannot be used as a key value';\n            throw new Error(msg);\n        }\n    }\n    let explicitKey = !simpleKeys &&\n        (!key ||\n            (keyComment && value == null && !ctx.inFlow) ||\n            identity.isCollection(key) ||\n            (identity.isScalar(key)\n                ? key.type === Scalar.Scalar.BLOCK_FOLDED || key.type === Scalar.Scalar.BLOCK_LITERAL\n                : typeof key === 'object'));\n    ctx = Object.assign({}, ctx, {\n        allNullValues: false,\n        implicitKey: !explicitKey && (simpleKeys || !allNullValues),\n        indent: indent + indentStep\n    });\n    let keyCommentDone = false;\n    let chompKeep = false;\n    let str = stringify.stringify(key, ctx, () => (keyCommentDone = true), () => (chompKeep = true));\n    if (!explicitKey && !ctx.inFlow && str.length > 1024) {\n        if (simpleKeys)\n            throw new Error('With simple keys, single line scalar must not span more than 1024 characters');\n        explicitKey = true;\n    }\n    if (ctx.inFlow) {\n        if (allNullValues || value == null) {\n            if (keyCommentDone && onComment)\n                onComment();\n            return str === '' ? '?' : explicitKey ? `? ${str}` : str;\n        }\n    }\n    else if ((allNullValues && !simpleKeys) || (value == null && explicitKey)) {\n        str = `? ${str}`;\n        if (keyComment && !keyCommentDone) {\n            str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));\n        }\n        else if (chompKeep && onChompKeep)\n            onChompKeep();\n        return str;\n    }\n    if (keyCommentDone)\n        keyComment = null;\n    if (explicitKey) {\n        if (keyComment)\n            str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));\n        str = `? ${str}\\n${indent}:`;\n    }\n    else {\n        str = `${str}:`;\n        if (keyComment)\n            str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));\n    }\n    let vsb, vcb, valueComment;\n    if (identity.isNode(value)) {\n        vsb = !!value.spaceBefore;\n        vcb = value.commentBefore;\n        valueComment = value.comment;\n    }\n    else {\n        vsb = false;\n        vcb = null;\n        valueComment = null;\n        if (value && typeof value === 'object')\n            value = doc.createNode(value);\n    }\n    ctx.implicitKey = false;\n    if (!explicitKey && !keyComment && identity.isScalar(value))\n        ctx.indentAtStart = str.length + 1;\n    chompKeep = false;\n    if (!indentSeq &&\n        indentStep.length >= 2 &&\n        !ctx.inFlow &&\n        !explicitKey &&\n        identity.isSeq(value) &&\n        !value.flow &&\n        !value.tag &&\n        !value.anchor) {\n        // If indentSeq === false, consider '- ' as part of indentation where possible\n        ctx.indent = ctx.indent.substring(2);\n    }\n    let valueCommentDone = false;\n    const valueStr = stringify.stringify(value, ctx, () => (valueCommentDone = true), () => (chompKeep = true));\n    let ws = ' ';\n    if (keyComment || vsb || vcb) {\n        ws = vsb ? '\\n' : '';\n        if (vcb) {\n            const cs = commentString(vcb);\n            ws += `\\n${stringifyComment.indentComment(cs, ctx.indent)}`;\n        }\n        if (valueStr === '' && !ctx.inFlow) {\n            if (ws === '\\n')\n                ws = '\\n\\n';\n        }\n        else {\n            ws += `\\n${ctx.indent}`;\n        }\n    }\n    else if (!explicitKey && identity.isCollection(value)) {\n        const vs0 = valueStr[0];\n        const nl0 = valueStr.indexOf('\\n');\n        const hasNewline = nl0 !== -1;\n        const flow = ctx.inFlow ?? value.flow ?? value.items.length === 0;\n        if (hasNewline || !flow) {\n            let hasPropsLine = false;\n            if (hasNewline && (vs0 === '&' || vs0 === '!')) {\n                let sp0 = valueStr.indexOf(' ');\n                if (vs0 === '&' &&\n                    sp0 !== -1 &&\n                    sp0 < nl0 &&\n                    valueStr[sp0 + 1] === '!') {\n                    sp0 = valueStr.indexOf(' ', sp0 + 1);\n                }\n                if (sp0 === -1 || nl0 < sp0)\n                    hasPropsLine = true;\n            }\n            if (!hasPropsLine)\n                ws = `\\n${ctx.indent}`;\n        }\n    }\n    else if (valueStr === '' || valueStr[0] === '\\n') {\n        ws = '';\n    }\n    str += ws + valueStr;\n    if (ctx.inFlow) {\n        if (valueCommentDone && onComment)\n            onComment();\n    }\n    else if (valueComment && !valueCommentDone) {\n        str += stringifyComment.lineComment(str, ctx.indent, commentString(valueComment));\n    }\n    else if (chompKeep && onChompKeep) {\n        onChompKeep();\n    }\n    return str;\n}\n\nexports.stringifyPair = stringifyPair;\n","'use strict';\n\nvar anchors = require('../doc/anchors.js');\nvar identity = require('../nodes/identity.js');\nvar stringifyComment = require('./stringifyComment.js');\nvar stringifyString = require('./stringifyString.js');\n\nfunction createStringifyContext(doc, options) {\n    const opt = Object.assign({\n        blockQuote: true,\n        commentString: stringifyComment.stringifyComment,\n        defaultKeyType: null,\n        defaultStringType: 'PLAIN',\n        directives: null,\n        doubleQuotedAsJSON: false,\n        doubleQuotedMinMultiLineLength: 40,\n        falseStr: 'false',\n        flowCollectionPadding: true,\n        indentSeq: true,\n        lineWidth: 80,\n        minContentWidth: 20,\n        nullStr: 'null',\n        simpleKeys: false,\n        singleQuote: null,\n        trueStr: 'true',\n        verifyAliasOrder: true\n    }, doc.schema.toStringOptions, options);\n    let inFlow;\n    switch (opt.collectionStyle) {\n        case 'block':\n            inFlow = false;\n            break;\n        case 'flow':\n            inFlow = true;\n            break;\n        default:\n            inFlow = null;\n    }\n    return {\n        anchors: new Set(),\n        doc,\n        flowCollectionPadding: opt.flowCollectionPadding ? ' ' : '',\n        indent: '',\n        indentStep: typeof opt.indent === 'number' ? ' '.repeat(opt.indent) : '  ',\n        inFlow,\n        options: opt\n    };\n}\nfunction getTagObject(tags, item) {\n    if (item.tag) {\n        const match = tags.filter(t => t.tag === item.tag);\n        if (match.length > 0)\n            return match.find(t => t.format === item.format) ?? match[0];\n    }\n    let tagObj = undefined;\n    let obj;\n    if (identity.isScalar(item)) {\n        obj = item.value;\n        let match = tags.filter(t => t.identify?.(obj));\n        if (match.length > 1) {\n            const testMatch = match.filter(t => t.test);\n            if (testMatch.length > 0)\n                match = testMatch;\n        }\n        tagObj =\n            match.find(t => t.format === item.format) ?? match.find(t => !t.format);\n    }\n    else {\n        obj = item;\n        tagObj = tags.find(t => t.nodeClass && obj instanceof t.nodeClass);\n    }\n    if (!tagObj) {\n        const name = obj?.constructor?.name ?? (obj === null ? 'null' : typeof obj);\n        throw new Error(`Tag not resolved for ${name} value`);\n    }\n    return tagObj;\n}\n// needs to be called before value stringifier to allow for circular anchor refs\nfunction stringifyProps(node, tagObj, { anchors: anchors$1, doc }) {\n    if (!doc.directives)\n        return '';\n    const props = [];\n    const anchor = (identity.isScalar(node) || identity.isCollection(node)) && node.anchor;\n    if (anchor && anchors.anchorIsValid(anchor)) {\n        anchors$1.add(anchor);\n        props.push(`&${anchor}`);\n    }\n    const tag = node.tag ?? (tagObj.default ? null : tagObj.tag);\n    if (tag)\n        props.push(doc.directives.tagString(tag));\n    return props.join(' ');\n}\nfunction stringify(item, ctx, onComment, onChompKeep) {\n    if (identity.isPair(item))\n        return item.toString(ctx, onComment, onChompKeep);\n    if (identity.isAlias(item)) {\n        if (ctx.doc.directives)\n            return item.toString(ctx);\n        if (ctx.resolvedAliases?.has(item)) {\n            throw new TypeError(`Cannot stringify circular structure without alias nodes`);\n        }\n        else {\n            if (ctx.resolvedAliases)\n                ctx.resolvedAliases.add(item);\n            else\n                ctx.resolvedAliases = new Set([item]);\n            item = item.resolve(ctx.doc);\n        }\n    }\n    let tagObj = undefined;\n    const node = identity.isNode(item)\n        ? item\n        : ctx.doc.createNode(item, { onTagObj: o => (tagObj = o) });\n    tagObj ?? (tagObj = getTagObject(ctx.doc.schema.tags, node));\n    const props = stringifyProps(node, tagObj, ctx);\n    if (props.length > 0)\n        ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;\n    const str = typeof tagObj.stringify === 'function'\n        ? tagObj.stringify(node, ctx, onComment, onChompKeep)\n        : identity.isScalar(node)\n            ? stringifyString.stringifyString(node, ctx, onComment, onChompKeep)\n            : node.toString(ctx, onComment, onChompKeep);\n    if (!props)\n        return str;\n    return identity.isScalar(node) || str[0] === '{' || str[0] === '['\n        ? `${props} ${str}`\n        : `${props}\\n${ctx.indent}${str}`;\n}\n\nexports.createStringifyContext = createStringifyContext;\nexports.stringify = stringify;\n","'use strict';\n\n/**\n * Stringifies a comment.\n *\n * Empty comment lines are left empty,\n * lines consisting of a single space are replaced by `#`,\n * and all other lines are prefixed with a `#`.\n */\nconst stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, '#');\nfunction indentComment(comment, indent) {\n    if (/^\\n+$/.test(comment))\n        return comment.substring(1);\n    return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;\n}\nconst lineComment = (str, indent, comment) => str.endsWith('\\n')\n    ? indentComment(comment, indent)\n    : comment.includes('\\n')\n        ? '\\n' + indentComment(comment, indent)\n        : (str.endsWith(' ') ? '' : ' ') + comment;\n\nexports.indentComment = indentComment;\nexports.lineComment = lineComment;\nexports.stringifyComment = stringifyComment;\n","'use strict';\n\nvar Scalar = require('../nodes/Scalar.js');\nvar foldFlowLines = require('./foldFlowLines.js');\n\nconst getFoldOptions = (ctx, isBlock) => ({\n    indentAtStart: isBlock ? ctx.indent.length : ctx.indentAtStart,\n    lineWidth: ctx.options.lineWidth,\n    minContentWidth: ctx.options.minContentWidth\n});\n// Also checks for lines starting with %, as parsing the output as YAML 1.1 will\n// presume that's starting a new document.\nconst containsDocumentMarker = (str) => /^(%|---|\\.\\.\\.)/m.test(str);\nfunction lineLengthOverLimit(str, lineWidth, indentLength) {\n    if (!lineWidth || lineWidth < 0)\n        return false;\n    const limit = lineWidth - indentLength;\n    const strLen = str.length;\n    if (strLen <= limit)\n        return false;\n    for (let i = 0, start = 0; i < strLen; ++i) {\n        if (str[i] === '\\n') {\n            if (i - start > limit)\n                return true;\n            start = i + 1;\n            if (strLen - start <= limit)\n                return false;\n        }\n    }\n    return true;\n}\nfunction doubleQuotedString(value, ctx) {\n    const json = JSON.stringify(value);\n    if (ctx.options.doubleQuotedAsJSON)\n        return json;\n    const { implicitKey } = ctx;\n    const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;\n    const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');\n    let str = '';\n    let start = 0;\n    for (let i = 0, ch = json[i]; ch; ch = json[++i]) {\n        if (ch === ' ' && json[i + 1] === '\\\\' && json[i + 2] === 'n') {\n            // space before newline needs to be escaped to not be folded\n            str += json.slice(start, i) + '\\\\ ';\n            i += 1;\n            start = i;\n            ch = '\\\\';\n        }\n        if (ch === '\\\\')\n            switch (json[i + 1]) {\n                case 'u':\n                    {\n                        str += json.slice(start, i);\n                        const code = json.substr(i + 2, 4);\n                        switch (code) {\n                            case '0000':\n                                str += '\\\\0';\n                                break;\n                            case '0007':\n                                str += '\\\\a';\n                                break;\n                            case '000b':\n                                str += '\\\\v';\n                                break;\n                            case '001b':\n                                str += '\\\\e';\n                                break;\n                            case '0085':\n                                str += '\\\\N';\n                                break;\n                            case '00a0':\n                                str += '\\\\_';\n                                break;\n                            case '2028':\n                                str += '\\\\L';\n                                break;\n                            case '2029':\n                                str += '\\\\P';\n                                break;\n                            default:\n                                if (code.substr(0, 2) === '00')\n                                    str += '\\\\x' + code.substr(2);\n                                else\n                                    str += json.substr(i, 6);\n                        }\n                        i += 5;\n                        start = i + 1;\n                    }\n                    break;\n                case 'n':\n                    if (implicitKey ||\n                        json[i + 2] === '\"' ||\n                        json.length < minMultiLineLength) {\n                        i += 1;\n                    }\n                    else {\n                        // folding will eat first newline\n                        str += json.slice(start, i) + '\\n\\n';\n                        while (json[i + 2] === '\\\\' &&\n                            json[i + 3] === 'n' &&\n                            json[i + 4] !== '\"') {\n                            str += '\\n';\n                            i += 2;\n                        }\n                        str += indent;\n                        // space after newline needs to be escaped to not be folded\n                        if (json[i + 2] === ' ')\n                            str += '\\\\';\n                        i += 1;\n                        start = i + 1;\n                    }\n                    break;\n                default:\n                    i += 1;\n            }\n    }\n    str = start ? str + json.slice(start) : json;\n    return implicitKey\n        ? str\n        : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_QUOTED, getFoldOptions(ctx, false));\n}\nfunction singleQuotedString(value, ctx) {\n    if (ctx.options.singleQuote === false ||\n        (ctx.implicitKey && value.includes('\\n')) ||\n        /[ \\t]\\n|\\n[ \\t]/.test(value) // single quoted string can't have leading or trailing whitespace around newline\n    )\n        return doubleQuotedString(value, ctx);\n    const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');\n    const res = \"'\" + value.replace(/'/g, \"''\").replace(/\\n+/g, `$&\\n${indent}`) + \"'\";\n    return ctx.implicitKey\n        ? res\n        : foldFlowLines.foldFlowLines(res, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));\n}\nfunction quotedString(value, ctx) {\n    const { singleQuote } = ctx.options;\n    let qs;\n    if (singleQuote === false)\n        qs = doubleQuotedString;\n    else {\n        const hasDouble = value.includes('\"');\n        const hasSingle = value.includes(\"'\");\n        if (hasDouble && !hasSingle)\n            qs = singleQuotedString;\n        else if (hasSingle && !hasDouble)\n            qs = doubleQuotedString;\n        else\n            qs = singleQuote ? singleQuotedString : doubleQuotedString;\n    }\n    return qs(value, ctx);\n}\n// The negative lookbehind avoids a polynomial search,\n// but isn't supported yet on Safari: https://caniuse.com/js-regexp-lookbehind\nlet blockEndNewlines;\ntry {\n    blockEndNewlines = new RegExp('(^|(?<!\\n))\\n+(?!\\n|$)', 'g');\n}\ncatch {\n    blockEndNewlines = /\\n+(?!\\n|$)/g;\n}\nfunction blockString({ comment, type, value }, ctx, onComment, onChompKeep) {\n    const { blockQuote, commentString, lineWidth } = ctx.options;\n    // 1. Block can't end in whitespace unless the last line is non-empty.\n    // 2. Strings consisting of only whitespace are best rendered explicitly.\n    if (!blockQuote || /\\n[\\t ]+$/.test(value) || /^\\s*$/.test(value)) {\n        return quotedString(value, ctx);\n    }\n    const indent = ctx.indent ||\n        (ctx.forceBlockIndent || containsDocumentMarker(value) ? '  ' : '');\n    const literal = blockQuote === 'literal'\n        ? true\n        : blockQuote === 'folded' || type === Scalar.Scalar.BLOCK_FOLDED\n            ? false\n            : type === Scalar.Scalar.BLOCK_LITERAL\n                ? true\n                : !lineLengthOverLimit(value, lineWidth, indent.length);\n    if (!value)\n        return literal ? '|\\n' : '>\\n';\n    // determine chomping from whitespace at value end\n    let chomp;\n    let endStart;\n    for (endStart = value.length; endStart > 0; --endStart) {\n        const ch = value[endStart - 1];\n        if (ch !== '\\n' && ch !== '\\t' && ch !== ' ')\n            break;\n    }\n    let end = value.substring(endStart);\n    const endNlPos = end.indexOf('\\n');\n    if (endNlPos === -1) {\n        chomp = '-'; // strip\n    }\n    else if (value === end || endNlPos !== end.length - 1) {\n        chomp = '+'; // keep\n        if (onChompKeep)\n            onChompKeep();\n    }\n    else {\n        chomp = ''; // clip\n    }\n    if (end) {\n        value = value.slice(0, -end.length);\n        if (end[end.length - 1] === '\\n')\n            end = end.slice(0, -1);\n        end = end.replace(blockEndNewlines, `$&${indent}`);\n    }\n    // determine indent indicator from whitespace at value start\n    let startWithSpace = false;\n    let startEnd;\n    let startNlPos = -1;\n    for (startEnd = 0; startEnd < value.length; ++startEnd) {\n        const ch = value[startEnd];\n        if (ch === ' ')\n            startWithSpace = true;\n        else if (ch === '\\n')\n            startNlPos = startEnd;\n        else\n            break;\n    }\n    let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);\n    if (start) {\n        value = value.substring(start.length);\n        start = start.replace(/\\n+/g, `$&${indent}`);\n    }\n    const indentSize = indent ? '2' : '1'; // root is at -1\n    // Leading | or > is added later\n    let header = (startWithSpace ? indentSize : '') + chomp;\n    if (comment) {\n        header += ' ' + commentString(comment.replace(/ ?[\\r\\n]+/g, ' '));\n        if (onComment)\n            onComment();\n    }\n    if (!literal) {\n        const foldedValue = value\n            .replace(/\\n+/g, '\\n$&')\n            .replace(/(?:^|\\n)([\\t ].*)(?:([\\n\\t ]*)\\n(?![\\n\\t ]))?/g, '$1$2') // more-indented lines aren't folded\n            //                ^ more-ind. ^ empty     ^ capture next empty lines only at end of indent\n            .replace(/\\n+/g, `$&${indent}`);\n        let literalFallback = false;\n        const foldOptions = getFoldOptions(ctx, true);\n        if (blockQuote !== 'folded' && type !== Scalar.Scalar.BLOCK_FOLDED) {\n            foldOptions.onOverflow = () => {\n                literalFallback = true;\n            };\n        }\n        const body = foldFlowLines.foldFlowLines(`${start}${foldedValue}${end}`, indent, foldFlowLines.FOLD_BLOCK, foldOptions);\n        if (!literalFallback)\n            return `>${header}\\n${indent}${body}`;\n    }\n    value = value.replace(/\\n+/g, `$&${indent}`);\n    return `|${header}\\n${indent}${start}${value}${end}`;\n}\nfunction plainString(item, ctx, onComment, onChompKeep) {\n    const { type, value } = item;\n    const { actualString, implicitKey, indent, indentStep, inFlow } = ctx;\n    if ((implicitKey && value.includes('\\n')) ||\n        (inFlow && /[[\\]{},]/.test(value))) {\n        return quotedString(value, ctx);\n    }\n    if (/^[\\n\\t ,[\\]{}#&*!|>'\"%@`]|^[?-]$|^[?-][ \\t]|[\\n:][ \\t]|[ \\t]\\n|[\\n\\t ]#|[\\n\\t :]$/.test(value)) {\n        // not allowed:\n        // - '-' or '?'\n        // - start with an indicator character (except [?:-]) or /[?-] /\n        // - '\\n ', ': ' or ' \\n' anywhere\n        // - '#' not preceded by a non-space char\n        // - end with ' ' or ':'\n        return implicitKey || inFlow || !value.includes('\\n')\n            ? quotedString(value, ctx)\n            : blockString(item, ctx, onComment, onChompKeep);\n    }\n    if (!implicitKey &&\n        !inFlow &&\n        type !== Scalar.Scalar.PLAIN &&\n        value.includes('\\n')) {\n        // Where allowed & type not set explicitly, prefer block style for multiline strings\n        return blockString(item, ctx, onComment, onChompKeep);\n    }\n    if (containsDocumentMarker(value)) {\n        if (indent === '') {\n            ctx.forceBlockIndent = true;\n            return blockString(item, ctx, onComment, onChompKeep);\n        }\n        else if (implicitKey && indent === indentStep) {\n            return quotedString(value, ctx);\n        }\n    }\n    const str = value.replace(/\\n+/g, `$&\\n${indent}`);\n    // Verify that output will be parsed as a string, as e.g. plain numbers and\n    // booleans get parsed with those types in v1.2 (e.g. '42', 'true' & '0.9e-3'),\n    // and others in v1.1.\n    if (actualString) {\n        const test = (tag) => tag.default && tag.tag !== 'tag:yaml.org,2002:str' && tag.test?.test(str);\n        const { compat, tags } = ctx.doc.schema;\n        if (tags.some(test) || compat?.some(test))\n            return quotedString(value, ctx);\n    }\n    return implicitKey\n        ? str\n        : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));\n}\nfunction stringifyString(item, ctx, onComment, onChompKeep) {\n    const { implicitKey, inFlow } = ctx;\n    const ss = typeof item.value === 'string'\n        ? item\n        : Object.assign({}, item, { value: String(item.value) });\n    let { type } = item;\n    if (type !== Scalar.Scalar.QUOTE_DOUBLE) {\n        // force double quotes on control characters & unpaired surrogates\n        if (/[\\x00-\\x08\\x0b-\\x1f\\x7f-\\x9f\\u{D800}-\\u{DFFF}]/u.test(ss.value))\n            type = Scalar.Scalar.QUOTE_DOUBLE;\n    }\n    const _stringify = (_type) => {\n        switch (_type) {\n            case Scalar.Scalar.BLOCK_FOLDED:\n            case Scalar.Scalar.BLOCK_LITERAL:\n                return implicitKey || inFlow\n                    ? quotedString(ss.value, ctx) // blocks are not valid inside flow containers\n                    : blockString(ss, ctx, onComment, onChompKeep);\n            case Scalar.Scalar.QUOTE_DOUBLE:\n                return doubleQuotedString(ss.value, ctx);\n            case Scalar.Scalar.QUOTE_SINGLE:\n                return singleQuotedString(ss.value, ctx);\n            case Scalar.Scalar.PLAIN:\n                return plainString(ss, ctx, onComment, onChompKeep);\n            default:\n                return null;\n        }\n    };\n    let res = _stringify(type);\n    if (res === null) {\n        const { defaultKeyType, defaultStringType } = ctx.options;\n        const t = (implicitKey && defaultKeyType) || defaultStringType;\n        res = _stringify(t);\n        if (res === null)\n            throw new Error(`Unsupported default string type ${t}`);\n    }\n    return res;\n}\n\nexports.stringifyString = stringifyString;\n","'use strict';\n\nconst FOLD_FLOW = 'flow';\nconst FOLD_BLOCK = 'block';\nconst FOLD_QUOTED = 'quoted';\n/**\n * Tries to keep input at up to `lineWidth` characters, splitting only on spaces\n * not followed by newlines or spaces unless `mode` is `'quoted'`. Lines are\n * terminated with `\\n` and started with `indent`.\n */\nfunction foldFlowLines(text, indent, mode = 'flow', { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {\n    if (!lineWidth || lineWidth < 0)\n        return text;\n    if (lineWidth < minContentWidth)\n        minContentWidth = 0;\n    const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);\n    if (text.length <= endStep)\n        return text;\n    const folds = [];\n    const escapedFolds = {};\n    let end = lineWidth - indent.length;\n    if (typeof indentAtStart === 'number') {\n        if (indentAtStart > lineWidth - Math.max(2, minContentWidth))\n            folds.push(0);\n        else\n            end = lineWidth - indentAtStart;\n    }\n    let split = undefined;\n    let prev = undefined;\n    let overflow = false;\n    let i = -1;\n    let escStart = -1;\n    let escEnd = -1;\n    if (mode === FOLD_BLOCK) {\n        i = consumeMoreIndentedLines(text, i, indent.length);\n        if (i !== -1)\n            end = i + endStep;\n    }\n    for (let ch; (ch = text[(i += 1)]);) {\n        if (mode === FOLD_QUOTED && ch === '\\\\') {\n            escStart = i;\n            switch (text[i + 1]) {\n                case 'x':\n                    i += 3;\n                    break;\n                case 'u':\n                    i += 5;\n                    break;\n                case 'U':\n                    i += 9;\n                    break;\n                default:\n                    i += 1;\n            }\n            escEnd = i;\n        }\n        if (ch === '\\n') {\n            if (mode === FOLD_BLOCK)\n                i = consumeMoreIndentedLines(text, i, indent.length);\n            end = i + indent.length + endStep;\n            split = undefined;\n        }\n        else {\n            if (ch === ' ' &&\n                prev &&\n                prev !== ' ' &&\n                prev !== '\\n' &&\n                prev !== '\\t') {\n                // space surrounded by non-space can be replaced with newline + indent\n                const next = text[i + 1];\n                if (next && next !== ' ' && next !== '\\n' && next !== '\\t')\n                    split = i;\n            }\n            if (i >= end) {\n                if (split) {\n                    folds.push(split);\n                    end = split + endStep;\n                    split = undefined;\n                }\n                else if (mode === FOLD_QUOTED) {\n                    // white-space collected at end may stretch past lineWidth\n                    while (prev === ' ' || prev === '\\t') {\n                        prev = ch;\n                        ch = text[(i += 1)];\n                        overflow = true;\n                    }\n                    // Account for newline escape, but don't break preceding escape\n                    const j = i > escEnd + 1 ? i - 2 : escStart - 1;\n                    // Bail out if lineWidth & minContentWidth are shorter than an escape string\n                    if (escapedFolds[j])\n                        return text;\n                    folds.push(j);\n                    escapedFolds[j] = true;\n                    end = j + endStep;\n                    split = undefined;\n                }\n                else {\n                    overflow = true;\n                }\n            }\n        }\n        prev = ch;\n    }\n    if (overflow && onOverflow)\n        onOverflow();\n    if (folds.length === 0)\n        return text;\n    if (onFold)\n        onFold();\n    let res = text.slice(0, folds[0]);\n    for (let i = 0; i < folds.length; ++i) {\n        const fold = folds[i];\n        const end = folds[i + 1] || text.length;\n        if (fold === 0)\n            res = `\\n${indent}${text.slice(0, end)}`;\n        else {\n            if (mode === FOLD_QUOTED && escapedFolds[fold])\n                res += `${text[fold]}\\\\`;\n            res += `\\n${indent}${text.slice(fold + 1, end)}`;\n        }\n    }\n    return res;\n}\n/**\n * Presumes `i + 1` is at the start of a line\n * @returns index of last newline in more-indented block\n */\nfunction consumeMoreIndentedLines(text, i, indent) {\n    let end = i;\n    let start = i + 1;\n    let ch = text[start];\n    while (ch === ' ' || ch === '\\t') {\n        if (i < start + indent) {\n            ch = text[++i];\n        }\n        else {\n            do {\n                ch = text[++i];\n            } while (ch && ch !== '\\n');\n            end = i;\n            start = i + 1;\n            ch = text[start];\n        }\n    }\n    return end;\n}\n\nexports.FOLD_BLOCK = FOLD_BLOCK;\nexports.FOLD_FLOW = FOLD_FLOW;\nexports.FOLD_QUOTED = FOLD_QUOTED;\nexports.foldFlowLines = foldFlowLines;\n","'use strict';\n\nvar log = require('../log.js');\nvar merge = require('../schema/yaml-1.1/merge.js');\nvar stringify = require('../stringify/stringify.js');\nvar identity = require('./identity.js');\nvar toJS = require('./toJS.js');\n\nfunction addPairToJSMap(ctx, map, { key, value }) {\n    if (identity.isNode(key) && key.addToJSMap)\n        key.addToJSMap(ctx, map, value);\n    // TODO: Should drop this special case for bare << handling\n    else if (merge.isMergeKey(ctx, key))\n        merge.addMergeToJSMap(ctx, map, value);\n    else {\n        const jsKey = toJS.toJS(key, '', ctx);\n        if (map instanceof Map) {\n            map.set(jsKey, toJS.toJS(value, jsKey, ctx));\n        }\n        else if (map instanceof Set) {\n            map.add(jsKey);\n        }\n        else {\n            const stringKey = stringifyKey(key, jsKey, ctx);\n            const jsValue = toJS.toJS(value, stringKey, ctx);\n            if (stringKey in map)\n                Object.defineProperty(map, stringKey, {\n                    value: jsValue,\n                    writable: true,\n                    enumerable: true,\n                    configurable: true\n                });\n            else\n                map[stringKey] = jsValue;\n        }\n    }\n    return map;\n}\nfunction stringifyKey(key, jsKey, ctx) {\n    if (jsKey === null)\n        return '';\n    // eslint-disable-next-line @typescript-eslint/no-base-to-string\n    if (typeof jsKey !== 'object')\n        return String(jsKey);\n    if (identity.isNode(key) && ctx?.doc) {\n        const strCtx = stringify.createStringifyContext(ctx.doc, {});\n        strCtx.anchors = new Set();\n        for (const node of ctx.anchors.keys())\n            strCtx.anchors.add(node.anchor);\n        strCtx.inFlow = true;\n        strCtx.inStringifyKey = true;\n        const strKey = key.toString(strCtx);\n        if (!ctx.mapKeyWarned) {\n            let jsonStr = JSON.stringify(strKey);\n            if (jsonStr.length > 40)\n                jsonStr = jsonStr.substring(0, 36) + '...\"';\n            log.warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);\n            ctx.mapKeyWarned = true;\n        }\n        return strKey;\n    }\n    return JSON.stringify(jsKey);\n}\n\nexports.addPairToJSMap = addPairToJSMap;\n","'use strict';\n\nvar node_process = require('process');\n\nfunction debug(logLevel, ...messages) {\n    if (logLevel === 'debug')\n        console.log(...messages);\n}\nfunction warn(logLevel, warning) {\n    if (logLevel === 'debug' || logLevel === 'warn') {\n        if (typeof node_process.emitWarning === 'function')\n            node_process.emitWarning(warning);\n        else\n            console.warn(warning);\n    }\n}\n\nexports.debug = debug;\nexports.warn = warn;\n","'use strict';\n\nvar identity = require('../../nodes/identity.js');\nvar Scalar = require('../../nodes/Scalar.js');\n\n// If the value associated with a merge key is a single mapping node, each of\n// its key/value pairs is inserted into the current mapping, unless the key\n// already exists in it. If the value associated with the merge key is a\n// sequence, then this sequence is expected to contain mapping nodes and each\n// of these nodes is merged in turn according to its order in the sequence.\n// Keys in mapping nodes earlier in the sequence override keys specified in\n// later mapping nodes. -- http://yaml.org/type/merge.html\nconst MERGE_KEY = '<<';\nconst merge = {\n    identify: value => value === MERGE_KEY ||\n        (typeof value === 'symbol' && value.description === MERGE_KEY),\n    default: 'key',\n    tag: 'tag:yaml.org,2002:merge',\n    test: /^<<$/,\n    resolve: () => Object.assign(new Scalar.Scalar(Symbol(MERGE_KEY)), {\n        addToJSMap: addMergeToJSMap\n    }),\n    stringify: () => MERGE_KEY\n};\nconst isMergeKey = (ctx, key) => (merge.identify(key) ||\n    (identity.isScalar(key) &&\n        (!key.type || key.type === Scalar.Scalar.PLAIN) &&\n        merge.identify(key.value))) &&\n    ctx?.doc.schema.tags.some(tag => tag.tag === merge.tag && tag.default);\nfunction addMergeToJSMap(ctx, map, value) {\n    value = ctx && identity.isAlias(value) ? value.resolve(ctx.doc) : value;\n    if (identity.isSeq(value))\n        for (const it of value.items)\n            mergeValue(ctx, map, it);\n    else if (Array.isArray(value))\n        for (const it of value)\n            mergeValue(ctx, map, it);\n    else\n        mergeValue(ctx, map, value);\n}\nfunction mergeValue(ctx, map, value) {\n    const source = ctx && identity.isAlias(value) ? value.resolve(ctx.doc) : value;\n    if (!identity.isMap(source))\n        throw new Error('Merge sources must be maps or map aliases');\n    const srcMap = source.toJSON(null, ctx, Map);\n    for (const [key, value] of srcMap) {\n        if (map instanceof Map) {\n            if (!map.has(key))\n                map.set(key, value);\n        }\n        else if (map instanceof Set) {\n            map.add(key);\n        }\n        else if (!Object.prototype.hasOwnProperty.call(map, key)) {\n            Object.defineProperty(map, key, {\n                value,\n                writable: true,\n                enumerable: true,\n                configurable: true\n            });\n        }\n    }\n    return map;\n}\n\nexports.addMergeToJSMap = addMergeToJSMap;\nexports.isMergeKey = isMergeKey;\nexports.merge = merge;\n","'use strict';\n\nvar identity = require('../nodes/identity.js');\nvar map = require('./common/map.js');\nvar seq = require('./common/seq.js');\nvar string = require('./common/string.js');\nvar tags = require('./tags.js');\n\nconst sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;\nclass Schema {\n    constructor({ compat, customTags, merge, resolveKnownTags, schema, sortMapEntries, toStringDefaults }) {\n        this.compat = Array.isArray(compat)\n            ? tags.getTags(compat, 'compat')\n            : compat\n                ? tags.getTags(null, compat)\n                : null;\n        this.name = (typeof schema === 'string' && schema) || 'core';\n        this.knownTags = resolveKnownTags ? tags.coreKnownTags : {};\n        this.tags = tags.getTags(customTags, this.name, merge);\n        this.toStringOptions = toStringDefaults ?? null;\n        Object.defineProperty(this, identity.MAP, { value: map.map });\n        Object.defineProperty(this, identity.SCALAR, { value: string.string });\n        Object.defineProperty(this, identity.SEQ, { value: seq.seq });\n        // Used by createMap()\n        this.sortMapEntries =\n            typeof sortMapEntries === 'function'\n                ? sortMapEntries\n                : sortMapEntries === true\n                    ? sortMapEntriesByKey\n                    : null;\n    }\n    clone() {\n        const copy = Object.create(Schema.prototype, Object.getOwnPropertyDescriptors(this));\n        copy.tags = this.tags.slice();\n        return copy;\n    }\n}\n\nexports.Schema = Schema;\n","'use strict';\n\nvar identity = require('../../nodes/identity.js');\nvar YAMLMap = require('../../nodes/YAMLMap.js');\n\nconst map = {\n    collection: 'map',\n    default: true,\n    nodeClass: YAMLMap.YAMLMap,\n    tag: 'tag:yaml.org,2002:map',\n    resolve(map, onError) {\n        if (!identity.isMap(map))\n            onError('Expected a mapping for this tag');\n        return map;\n    },\n    createNode: (schema, obj, ctx) => YAMLMap.YAMLMap.from(schema, obj, ctx)\n};\n\nexports.map = map;\n","'use strict';\n\nvar stringifyCollection = require('../stringify/stringifyCollection.js');\nvar addPairToJSMap = require('./addPairToJSMap.js');\nvar Collection = require('./Collection.js');\nvar identity = require('./identity.js');\nvar Pair = require('./Pair.js');\nvar Scalar = require('./Scalar.js');\n\nfunction findPair(items, key) {\n    const k = identity.isScalar(key) ? key.value : key;\n    for (const it of items) {\n        if (identity.isPair(it)) {\n            if (it.key === key || it.key === k)\n                return it;\n            if (identity.isScalar(it.key) && it.key.value === k)\n                return it;\n        }\n    }\n    return undefined;\n}\nclass YAMLMap extends Collection.Collection {\n    static get tagName() {\n        return 'tag:yaml.org,2002:map';\n    }\n    constructor(schema) {\n        super(identity.MAP, schema);\n        this.items = [];\n    }\n    /**\n     * A generic collection parsing method that can be extended\n     * to other node classes that inherit from YAMLMap\n     */\n    static from(schema, obj, ctx) {\n        const { keepUndefined, replacer } = ctx;\n        const map = new this(schema);\n        const add = (key, value) => {\n            if (typeof replacer === 'function')\n                value = replacer.call(obj, key, value);\n            else if (Array.isArray(replacer) && !replacer.includes(key))\n                return;\n            if (value !== undefined || keepUndefined)\n                map.items.push(Pair.createPair(key, value, ctx));\n        };\n        if (obj instanceof Map) {\n            for (const [key, value] of obj)\n                add(key, value);\n        }\n        else if (obj && typeof obj === 'object') {\n            for (const key of Object.keys(obj))\n                add(key, obj[key]);\n        }\n        if (typeof schema.sortMapEntries === 'function') {\n            map.items.sort(schema.sortMapEntries);\n        }\n        return map;\n    }\n    /**\n     * Adds a value to the collection.\n     *\n     * @param overwrite - If not set `true`, using a key that is already in the\n     *   collection will throw. Otherwise, overwrites the previous value.\n     */\n    add(pair, overwrite) {\n        let _pair;\n        if (identity.isPair(pair))\n            _pair = pair;\n        else if (!pair || typeof pair !== 'object' || !('key' in pair)) {\n            // In TypeScript, this never happens.\n            _pair = new Pair.Pair(pair, pair?.value);\n        }\n        else\n            _pair = new Pair.Pair(pair.key, pair.value);\n        const prev = findPair(this.items, _pair.key);\n        const sortEntries = this.schema?.sortMapEntries;\n        if (prev) {\n            if (!overwrite)\n                throw new Error(`Key ${_pair.key} already set`);\n            // For scalars, keep the old node & its comments and anchors\n            if (identity.isScalar(prev.value) && Scalar.isScalarValue(_pair.value))\n                prev.value.value = _pair.value;\n            else\n                prev.value = _pair.value;\n        }\n        else if (sortEntries) {\n            const i = this.items.findIndex(item => sortEntries(_pair, item) < 0);\n            if (i === -1)\n                this.items.push(_pair);\n            else\n                this.items.splice(i, 0, _pair);\n        }\n        else {\n            this.items.push(_pair);\n        }\n    }\n    delete(key) {\n        const it = findPair(this.items, key);\n        if (!it)\n            return false;\n        const del = this.items.splice(this.items.indexOf(it), 1);\n        return del.length > 0;\n    }\n    get(key, keepScalar) {\n        const it = findPair(this.items, key);\n        const node = it?.value;\n        return (!keepScalar && identity.isScalar(node) ? node.value : node) ?? undefined;\n    }\n    has(key) {\n        return !!findPair(this.items, key);\n    }\n    set(key, value) {\n        this.add(new Pair.Pair(key, value), true);\n    }\n    /**\n     * @param ctx - Conversion context, originally set in Document#toJS()\n     * @param {Class} Type - If set, forces the returned collection type\n     * @returns Instance of Type, Map, or Object\n     */\n    toJSON(_, ctx, Type) {\n        const map = Type ? new Type() : ctx?.mapAsMap ? new Map() : {};\n        if (ctx?.onCreate)\n            ctx.onCreate(map);\n        for (const item of this.items)\n            addPairToJSMap.addPairToJSMap(ctx, map, item);\n        return map;\n    }\n    toString(ctx, onComment, onChompKeep) {\n        if (!ctx)\n            return JSON.stringify(this);\n        for (const item of this.items) {\n            if (!identity.isPair(item))\n                throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);\n        }\n        if (!ctx.allNullValues && this.hasAllNullValues(false))\n            ctx = Object.assign({}, ctx, { allNullValues: true });\n        return stringifyCollection.stringifyCollection(this, ctx, {\n            blockItemPrefix: '',\n            flowChars: { start: '{', end: '}' },\n            itemIndent: ctx.indent || '',\n            onChompKeep,\n            onComment\n        });\n    }\n}\n\nexports.YAMLMap = YAMLMap;\nexports.findPair = findPair;\n","'use strict';\n\nvar identity = require('../nodes/identity.js');\nvar stringify = require('./stringify.js');\nvar stringifyComment = require('./stringifyComment.js');\n\nfunction stringifyCollection(collection, ctx, options) {\n    const flow = ctx.inFlow ?? collection.flow;\n    const stringify = flow ? stringifyFlowCollection : stringifyBlockCollection;\n    return stringify(collection, ctx, options);\n}\nfunction stringifyBlockCollection({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {\n    const { indent, options: { commentString } } = ctx;\n    const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });\n    let chompKeep = false; // flag for the preceding node's status\n    const lines = [];\n    for (let i = 0; i < items.length; ++i) {\n        const item = items[i];\n        let comment = null;\n        if (identity.isNode(item)) {\n            if (!chompKeep && item.spaceBefore)\n                lines.push('');\n            addCommentBefore(ctx, lines, item.commentBefore, chompKeep);\n            if (item.comment)\n                comment = item.comment;\n        }\n        else if (identity.isPair(item)) {\n            const ik = identity.isNode(item.key) ? item.key : null;\n            if (ik) {\n                if (!chompKeep && ik.spaceBefore)\n                    lines.push('');\n                addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);\n            }\n        }\n        chompKeep = false;\n        let str = stringify.stringify(item, itemCtx, () => (comment = null), () => (chompKeep = true));\n        if (comment)\n            str += stringifyComment.lineComment(str, itemIndent, commentString(comment));\n        if (chompKeep && comment)\n            chompKeep = false;\n        lines.push(blockItemPrefix + str);\n    }\n    let str;\n    if (lines.length === 0) {\n        str = flowChars.start + flowChars.end;\n    }\n    else {\n        str = lines[0];\n        for (let i = 1; i < lines.length; ++i) {\n            const line = lines[i];\n            str += line ? `\\n${indent}${line}` : '\\n';\n        }\n    }\n    if (comment) {\n        str += '\\n' + stringifyComment.indentComment(commentString(comment), indent);\n        if (onComment)\n            onComment();\n    }\n    else if (chompKeep && onChompKeep)\n        onChompKeep();\n    return str;\n}\nfunction stringifyFlowCollection({ items }, ctx, { flowChars, itemIndent }) {\n    const { indent, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;\n    itemIndent += indentStep;\n    const itemCtx = Object.assign({}, ctx, {\n        indent: itemIndent,\n        inFlow: true,\n        type: null\n    });\n    let reqNewline = false;\n    let linesAtValue = 0;\n    const lines = [];\n    for (let i = 0; i < items.length; ++i) {\n        const item = items[i];\n        let comment = null;\n        if (identity.isNode(item)) {\n            if (item.spaceBefore)\n                lines.push('');\n            addCommentBefore(ctx, lines, item.commentBefore, false);\n            if (item.comment)\n                comment = item.comment;\n        }\n        else if (identity.isPair(item)) {\n            const ik = identity.isNode(item.key) ? item.key : null;\n            if (ik) {\n                if (ik.spaceBefore)\n                    lines.push('');\n                addCommentBefore(ctx, lines, ik.commentBefore, false);\n                if (ik.comment)\n                    reqNewline = true;\n            }\n            const iv = identity.isNode(item.value) ? item.value : null;\n            if (iv) {\n                if (iv.comment)\n                    comment = iv.comment;\n                if (iv.commentBefore)\n                    reqNewline = true;\n            }\n            else if (item.value == null && ik?.comment) {\n                comment = ik.comment;\n            }\n        }\n        if (comment)\n            reqNewline = true;\n        let str = stringify.stringify(item, itemCtx, () => (comment = null));\n        if (i < items.length - 1)\n            str += ',';\n        if (comment)\n            str += stringifyComment.lineComment(str, itemIndent, commentString(comment));\n        if (!reqNewline && (lines.length > linesAtValue || str.includes('\\n')))\n            reqNewline = true;\n        lines.push(str);\n        linesAtValue = lines.length;\n    }\n    const { start, end } = flowChars;\n    if (lines.length === 0) {\n        return start + end;\n    }\n    else {\n        if (!reqNewline) {\n            const len = lines.reduce((sum, line) => sum + line.length + 2, 2);\n            reqNewline = ctx.options.lineWidth > 0 && len > ctx.options.lineWidth;\n        }\n        if (reqNewline) {\n            let str = start;\n            for (const line of lines)\n                str += line ? `\\n${indentStep}${indent}${line}` : '\\n';\n            return `${str}\\n${indent}${end}`;\n        }\n        else {\n            return `${start}${fcPadding}${lines.join(' ')}${fcPadding}${end}`;\n        }\n    }\n}\nfunction addCommentBefore({ indent, options: { commentString } }, lines, comment, chompKeep) {\n    if (comment && chompKeep)\n        comment = comment.replace(/^\\n+/, '');\n    if (comment) {\n        const ic = stringifyComment.indentComment(commentString(comment), indent);\n        lines.push(ic.trimStart()); // Avoid double indent on first line\n    }\n}\n\nexports.stringifyCollection = stringifyCollection;\n","'use strict';\n\nvar identity = require('../../nodes/identity.js');\nvar YAMLSeq = require('../../nodes/YAMLSeq.js');\n\nconst seq = {\n    collection: 'seq',\n    default: true,\n    nodeClass: YAMLSeq.YAMLSeq,\n    tag: 'tag:yaml.org,2002:seq',\n    resolve(seq, onError) {\n        if (!identity.isSeq(seq))\n            onError('Expected a sequence for this tag');\n        return seq;\n    },\n    createNode: (schema, obj, ctx) => YAMLSeq.YAMLSeq.from(schema, obj, ctx)\n};\n\nexports.seq = seq;\n","'use strict';\n\nvar createNode = require('../doc/createNode.js');\nvar stringifyCollection = require('../stringify/stringifyCollection.js');\nvar Collection = require('./Collection.js');\nvar identity = require('./identity.js');\nvar Scalar = require('./Scalar.js');\nvar toJS = require('./toJS.js');\n\nclass YAMLSeq extends Collection.Collection {\n    static get tagName() {\n        return 'tag:yaml.org,2002:seq';\n    }\n    constructor(schema) {\n        super(identity.SEQ, schema);\n        this.items = [];\n    }\n    add(value) {\n        this.items.push(value);\n    }\n    /**\n     * Removes a value from the collection.\n     *\n     * `key` must contain a representation of an integer for this to succeed.\n     * It may be wrapped in a `Scalar`.\n     *\n     * @returns `true` if the item was found and removed.\n     */\n    delete(key) {\n        const idx = asItemIndex(key);\n        if (typeof idx !== 'number')\n            return false;\n        const del = this.items.splice(idx, 1);\n        return del.length > 0;\n    }\n    get(key, keepScalar) {\n        const idx = asItemIndex(key);\n        if (typeof idx !== 'number')\n            return undefined;\n        const it = this.items[idx];\n        return !keepScalar && identity.isScalar(it) ? it.value : it;\n    }\n    /**\n     * Checks if the collection includes a value with the key `key`.\n     *\n     * `key` must contain a representation of an integer for this to succeed.\n     * It may be wrapped in a `Scalar`.\n     */\n    has(key) {\n        const idx = asItemIndex(key);\n        return typeof idx === 'number' && idx < this.items.length;\n    }\n    /**\n     * Sets a value in this collection. For `!!set`, `value` needs to be a\n     * boolean to add/remove the item from the set.\n     *\n     * If `key` does not contain a representation of an integer, this will throw.\n     * It may be wrapped in a `Scalar`.\n     */\n    set(key, value) {\n        const idx = asItemIndex(key);\n        if (typeof idx !== 'number')\n            throw new Error(`Expected a valid index, not ${key}.`);\n        const prev = this.items[idx];\n        if (identity.isScalar(prev) && Scalar.isScalarValue(value))\n            prev.value = value;\n        else\n            this.items[idx] = value;\n    }\n    toJSON(_, ctx) {\n        const seq = [];\n        if (ctx?.onCreate)\n            ctx.onCreate(seq);\n        let i = 0;\n        for (const item of this.items)\n            seq.push(toJS.toJS(item, String(i++), ctx));\n        return seq;\n    }\n    toString(ctx, onComment, onChompKeep) {\n        if (!ctx)\n            return JSON.stringify(this);\n        return stringifyCollection.stringifyCollection(this, ctx, {\n            blockItemPrefix: '- ',\n            flowChars: { start: '[', end: ']' },\n            itemIndent: (ctx.indent || '') + '  ',\n            onChompKeep,\n            onComment\n        });\n    }\n    static from(schema, obj, ctx) {\n        const { replacer } = ctx;\n        const seq = new this(schema);\n        if (obj && Symbol.iterator in Object(obj)) {\n            let i = 0;\n            for (let it of obj) {\n                if (typeof replacer === 'function') {\n                    const key = obj instanceof Set ? it : String(i++);\n                    it = replacer.call(obj, key, it);\n                }\n                seq.items.push(createNode.createNode(it, undefined, ctx));\n            }\n        }\n        return seq;\n    }\n}\nfunction asItemIndex(key) {\n    let idx = identity.isScalar(key) ? key.value : key;\n    if (idx && typeof idx === 'string')\n        idx = Number(idx);\n    return typeof idx === 'number' && Number.isInteger(idx) && idx >= 0\n        ? idx\n        : null;\n}\n\nexports.YAMLSeq = YAMLSeq;\n","'use strict';\n\nvar stringifyString = require('../../stringify/stringifyString.js');\n\nconst string = {\n    identify: value => typeof value === 'string',\n    default: true,\n    tag: 'tag:yaml.org,2002:str',\n    resolve: str => str,\n    stringify(item, ctx, onComment, onChompKeep) {\n        ctx = Object.assign({ actualString: true }, ctx);\n        return stringifyString.stringifyString(item, ctx, onComment, onChompKeep);\n    }\n};\n\nexports.string = string;\n","'use strict';\n\nvar map = require('./common/map.js');\nvar _null = require('./common/null.js');\nvar seq = require('./common/seq.js');\nvar string = require('./common/string.js');\nvar bool = require('./core/bool.js');\nvar float = require('./core/float.js');\nvar int = require('./core/int.js');\nvar schema = require('./core/schema.js');\nvar schema$1 = require('./json/schema.js');\nvar binary = require('./yaml-1.1/binary.js');\nvar merge = require('./yaml-1.1/merge.js');\nvar omap = require('./yaml-1.1/omap.js');\nvar pairs = require('./yaml-1.1/pairs.js');\nvar schema$2 = require('./yaml-1.1/schema.js');\nvar set = require('./yaml-1.1/set.js');\nvar timestamp = require('./yaml-1.1/timestamp.js');\n\nconst schemas = new Map([\n    ['core', schema.schema],\n    ['failsafe', [map.map, seq.seq, string.string]],\n    ['json', schema$1.schema],\n    ['yaml11', schema$2.schema],\n    ['yaml-1.1', schema$2.schema]\n]);\nconst tagsByName = {\n    binary: binary.binary,\n    bool: bool.boolTag,\n    float: float.float,\n    floatExp: float.floatExp,\n    floatNaN: float.floatNaN,\n    floatTime: timestamp.floatTime,\n    int: int.int,\n    intHex: int.intHex,\n    intOct: int.intOct,\n    intTime: timestamp.intTime,\n    map: map.map,\n    merge: merge.merge,\n    null: _null.nullTag,\n    omap: omap.omap,\n    pairs: pairs.pairs,\n    seq: seq.seq,\n    set: set.set,\n    timestamp: timestamp.timestamp\n};\nconst coreKnownTags = {\n    'tag:yaml.org,2002:binary': binary.binary,\n    'tag:yaml.org,2002:merge': merge.merge,\n    'tag:yaml.org,2002:omap': omap.omap,\n    'tag:yaml.org,2002:pairs': pairs.pairs,\n    'tag:yaml.org,2002:set': set.set,\n    'tag:yaml.org,2002:timestamp': timestamp.timestamp\n};\nfunction getTags(customTags, schemaName, addMergeTag) {\n    const schemaTags = schemas.get(schemaName);\n    if (schemaTags && !customTags) {\n        return addMergeTag && !schemaTags.includes(merge.merge)\n            ? schemaTags.concat(merge.merge)\n            : schemaTags.slice();\n    }\n    let tags = schemaTags;\n    if (!tags) {\n        if (Array.isArray(customTags))\n            tags = [];\n        else {\n            const keys = Array.from(schemas.keys())\n                .filter(key => key !== 'yaml11')\n                .map(key => JSON.stringify(key))\n                .join(', ');\n            throw new Error(`Unknown schema \"${schemaName}\"; use one of ${keys} or define customTags array`);\n        }\n    }\n    if (Array.isArray(customTags)) {\n        for (const tag of customTags)\n            tags = tags.concat(tag);\n    }\n    else if (typeof customTags === 'function') {\n        tags = customTags(tags.slice());\n    }\n    if (addMergeTag)\n        tags = tags.concat(merge.merge);\n    return tags.reduce((tags, tag) => {\n        const tagObj = typeof tag === 'string' ? tagsByName[tag] : tag;\n        if (!tagObj) {\n            const tagName = JSON.stringify(tag);\n            const keys = Object.keys(tagsByName)\n                .map(key => JSON.stringify(key))\n                .join(', ');\n            throw new Error(`Unknown custom tag ${tagName}; use one of ${keys}`);\n        }\n        if (!tags.includes(tagObj))\n            tags.push(tagObj);\n        return tags;\n    }, []);\n}\n\nexports.coreKnownTags = coreKnownTags;\nexports.getTags = getTags;\n","'use strict';\n\nvar Scalar = require('../../nodes/Scalar.js');\n\nconst nullTag = {\n    identify: value => value == null,\n    createNode: () => new Scalar.Scalar(null),\n    default: true,\n    tag: 'tag:yaml.org,2002:null',\n    test: /^(?:~|[Nn]ull|NULL)?$/,\n    resolve: () => new Scalar.Scalar(null),\n    stringify: ({ source }, ctx) => typeof source === 'string' && nullTag.test.test(source)\n        ? source\n        : ctx.options.nullStr\n};\n\nexports.nullTag = nullTag;\n","'use strict';\n\nvar Scalar = require('../../nodes/Scalar.js');\n\nconst boolTag = {\n    identify: value => typeof value === 'boolean',\n    default: true,\n    tag: 'tag:yaml.org,2002:bool',\n    test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,\n    resolve: str => new Scalar.Scalar(str[0] === 't' || str[0] === 'T'),\n    stringify({ source, value }, ctx) {\n        if (source && boolTag.test.test(source)) {\n            const sv = source[0] === 't' || source[0] === 'T';\n            if (value === sv)\n                return source;\n        }\n        return value ? ctx.options.trueStr : ctx.options.falseStr;\n    }\n};\n\nexports.boolTag = boolTag;\n","'use strict';\n\nvar Scalar = require('../../nodes/Scalar.js');\nvar stringifyNumber = require('../../stringify/stringifyNumber.js');\n\nconst floatNaN = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    test: /^(?:[-+]?\\.(?:inf|Inf|INF)|\\.nan|\\.NaN|\\.NAN)$/,\n    resolve: str => str.slice(-3).toLowerCase() === 'nan'\n        ? NaN\n        : str[0] === '-'\n            ? Number.NEGATIVE_INFINITY\n            : Number.POSITIVE_INFINITY,\n    stringify: stringifyNumber.stringifyNumber\n};\nconst floatExp = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    format: 'EXP',\n    test: /^[-+]?(?:\\.[0-9]+|[0-9]+(?:\\.[0-9]*)?)[eE][-+]?[0-9]+$/,\n    resolve: str => parseFloat(str),\n    stringify(node) {\n        const num = Number(node.value);\n        return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);\n    }\n};\nconst float = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    test: /^[-+]?(?:\\.[0-9]+|[0-9]+\\.[0-9]*)$/,\n    resolve(str) {\n        const node = new Scalar.Scalar(parseFloat(str));\n        const dot = str.indexOf('.');\n        if (dot !== -1 && str[str.length - 1] === '0')\n            node.minFractionDigits = str.length - dot - 1;\n        return node;\n    },\n    stringify: stringifyNumber.stringifyNumber\n};\n\nexports.float = float;\nexports.floatExp = floatExp;\nexports.floatNaN = floatNaN;\n","'use strict';\n\nfunction stringifyNumber({ format, minFractionDigits, tag, value }) {\n    if (typeof value === 'bigint')\n        return String(value);\n    const num = typeof value === 'number' ? value : Number(value);\n    if (!isFinite(num))\n        return isNaN(num) ? '.nan' : num < 0 ? '-.inf' : '.inf';\n    let n = JSON.stringify(value);\n    if (!format &&\n        minFractionDigits &&\n        (!tag || tag === 'tag:yaml.org,2002:float') &&\n        /^\\d/.test(n)) {\n        let i = n.indexOf('.');\n        if (i < 0) {\n            i = n.length;\n            n += '.';\n        }\n        let d = minFractionDigits - (n.length - i - 1);\n        while (d-- > 0)\n            n += '0';\n    }\n    return n;\n}\n\nexports.stringifyNumber = stringifyNumber;\n","'use strict';\n\nvar stringifyNumber = require('../../stringify/stringifyNumber.js');\n\nconst intIdentify = (value) => typeof value === 'bigint' || Number.isInteger(value);\nconst intResolve = (str, offset, radix, { intAsBigInt }) => (intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix));\nfunction intStringify(node, radix, prefix) {\n    const { value } = node;\n    if (intIdentify(value) && value >= 0)\n        return prefix + value.toString(radix);\n    return stringifyNumber.stringifyNumber(node);\n}\nconst intOct = {\n    identify: value => intIdentify(value) && value >= 0,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    format: 'OCT',\n    test: /^0o[0-7]+$/,\n    resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),\n    stringify: node => intStringify(node, 8, '0o')\n};\nconst int = {\n    identify: intIdentify,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    test: /^[-+]?[0-9]+$/,\n    resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),\n    stringify: stringifyNumber.stringifyNumber\n};\nconst intHex = {\n    identify: value => intIdentify(value) && value >= 0,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    format: 'HEX',\n    test: /^0x[0-9a-fA-F]+$/,\n    resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),\n    stringify: node => intStringify(node, 16, '0x')\n};\n\nexports.int = int;\nexports.intHex = intHex;\nexports.intOct = intOct;\n","'use strict';\n\nvar map = require('../common/map.js');\nvar _null = require('../common/null.js');\nvar seq = require('../common/seq.js');\nvar string = require('../common/string.js');\nvar bool = require('./bool.js');\nvar float = require('./float.js');\nvar int = require('./int.js');\n\nconst schema = [\n    map.map,\n    seq.seq,\n    string.string,\n    _null.nullTag,\n    bool.boolTag,\n    int.intOct,\n    int.int,\n    int.intHex,\n    float.floatNaN,\n    float.floatExp,\n    float.float\n];\n\nexports.schema = schema;\n","'use strict';\n\nvar Scalar = require('../../nodes/Scalar.js');\nvar map = require('../common/map.js');\nvar seq = require('../common/seq.js');\n\nfunction intIdentify(value) {\n    return typeof value === 'bigint' || Number.isInteger(value);\n}\nconst stringifyJSON = ({ value }) => JSON.stringify(value);\nconst jsonScalars = [\n    {\n        identify: value => typeof value === 'string',\n        default: true,\n        tag: 'tag:yaml.org,2002:str',\n        resolve: str => str,\n        stringify: stringifyJSON\n    },\n    {\n        identify: value => value == null,\n        createNode: () => new Scalar.Scalar(null),\n        default: true,\n        tag: 'tag:yaml.org,2002:null',\n        test: /^null$/,\n        resolve: () => null,\n        stringify: stringifyJSON\n    },\n    {\n        identify: value => typeof value === 'boolean',\n        default: true,\n        tag: 'tag:yaml.org,2002:bool',\n        test: /^true$|^false$/,\n        resolve: str => str === 'true',\n        stringify: stringifyJSON\n    },\n    {\n        identify: intIdentify,\n        default: true,\n        tag: 'tag:yaml.org,2002:int',\n        test: /^-?(?:0|[1-9][0-9]*)$/,\n        resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),\n        stringify: ({ value }) => intIdentify(value) ? value.toString() : JSON.stringify(value)\n    },\n    {\n        identify: value => typeof value === 'number',\n        default: true,\n        tag: 'tag:yaml.org,2002:float',\n        test: /^-?(?:0|[1-9][0-9]*)(?:\\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,\n        resolve: str => parseFloat(str),\n        stringify: stringifyJSON\n    }\n];\nconst jsonError = {\n    default: true,\n    tag: '',\n    test: /^/,\n    resolve(str, onError) {\n        onError(`Unresolved plain scalar ${JSON.stringify(str)}`);\n        return str;\n    }\n};\nconst schema = [map.map, seq.seq].concat(jsonScalars, jsonError);\n\nexports.schema = schema;\n","'use strict';\n\nvar node_buffer = require('buffer');\nvar Scalar = require('../../nodes/Scalar.js');\nvar stringifyString = require('../../stringify/stringifyString.js');\n\nconst binary = {\n    identify: value => value instanceof Uint8Array, // Buffer inherits from Uint8Array\n    default: false,\n    tag: 'tag:yaml.org,2002:binary',\n    /**\n     * Returns a Buffer in node and an Uint8Array in browsers\n     *\n     * To use the resulting buffer as an image, you'll want to do something like:\n     *\n     *   const blob = new Blob([buffer], { type: 'image/jpeg' })\n     *   document.querySelector('#photo').src = URL.createObjectURL(blob)\n     */\n    resolve(src, onError) {\n        if (typeof node_buffer.Buffer === 'function') {\n            return node_buffer.Buffer.from(src, 'base64');\n        }\n        else if (typeof atob === 'function') {\n            // On IE 11, atob() can't handle newlines\n            const str = atob(src.replace(/[\\n\\r]/g, ''));\n            const buffer = new Uint8Array(str.length);\n            for (let i = 0; i < str.length; ++i)\n                buffer[i] = str.charCodeAt(i);\n            return buffer;\n        }\n        else {\n            onError('This environment does not support reading binary tags; either Buffer or atob is required');\n            return src;\n        }\n    },\n    stringify({ comment, type, value }, ctx, onComment, onChompKeep) {\n        if (!value)\n            return '';\n        const buf = value; // checked earlier by binary.identify()\n        let str;\n        if (typeof node_buffer.Buffer === 'function') {\n            str =\n                buf instanceof node_buffer.Buffer\n                    ? buf.toString('base64')\n                    : node_buffer.Buffer.from(buf.buffer).toString('base64');\n        }\n        else if (typeof btoa === 'function') {\n            let s = '';\n            for (let i = 0; i < buf.length; ++i)\n                s += String.fromCharCode(buf[i]);\n            str = btoa(s);\n        }\n        else {\n            throw new Error('This environment does not support writing binary tags; either Buffer or btoa is required');\n        }\n        type ?? (type = Scalar.Scalar.BLOCK_LITERAL);\n        if (type !== Scalar.Scalar.QUOTE_DOUBLE) {\n            const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);\n            const n = Math.ceil(str.length / lineWidth);\n            const lines = new Array(n);\n            for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {\n                lines[i] = str.substr(o, lineWidth);\n            }\n            str = lines.join(type === Scalar.Scalar.BLOCK_LITERAL ? '\\n' : ' ');\n        }\n        return stringifyString.stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);\n    }\n};\n\nexports.binary = binary;\n","'use strict';\n\nvar identity = require('../../nodes/identity.js');\nvar toJS = require('../../nodes/toJS.js');\nvar YAMLMap = require('../../nodes/YAMLMap.js');\nvar YAMLSeq = require('../../nodes/YAMLSeq.js');\nvar pairs = require('./pairs.js');\n\nclass YAMLOMap extends YAMLSeq.YAMLSeq {\n    constructor() {\n        super();\n        this.add = YAMLMap.YAMLMap.prototype.add.bind(this);\n        this.delete = YAMLMap.YAMLMap.prototype.delete.bind(this);\n        this.get = YAMLMap.YAMLMap.prototype.get.bind(this);\n        this.has = YAMLMap.YAMLMap.prototype.has.bind(this);\n        this.set = YAMLMap.YAMLMap.prototype.set.bind(this);\n        this.tag = YAMLOMap.tag;\n    }\n    /**\n     * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,\n     * but TypeScript won't allow widening the signature of a child method.\n     */\n    toJSON(_, ctx) {\n        if (!ctx)\n            return super.toJSON(_);\n        const map = new Map();\n        if (ctx?.onCreate)\n            ctx.onCreate(map);\n        for (const pair of this.items) {\n            let key, value;\n            if (identity.isPair(pair)) {\n                key = toJS.toJS(pair.key, '', ctx);\n                value = toJS.toJS(pair.value, key, ctx);\n            }\n            else {\n                key = toJS.toJS(pair, '', ctx);\n            }\n            if (map.has(key))\n                throw new Error('Ordered maps must not include duplicate keys');\n            map.set(key, value);\n        }\n        return map;\n    }\n    static from(schema, iterable, ctx) {\n        const pairs$1 = pairs.createPairs(schema, iterable, ctx);\n        const omap = new this();\n        omap.items = pairs$1.items;\n        return omap;\n    }\n}\nYAMLOMap.tag = 'tag:yaml.org,2002:omap';\nconst omap = {\n    collection: 'seq',\n    identify: value => value instanceof Map,\n    nodeClass: YAMLOMap,\n    default: false,\n    tag: 'tag:yaml.org,2002:omap',\n    resolve(seq, onError) {\n        const pairs$1 = pairs.resolvePairs(seq, onError);\n        const seenKeys = [];\n        for (const { key } of pairs$1.items) {\n            if (identity.isScalar(key)) {\n                if (seenKeys.includes(key.value)) {\n                    onError(`Ordered maps must not include duplicate keys: ${key.value}`);\n                }\n                else {\n                    seenKeys.push(key.value);\n                }\n            }\n        }\n        return Object.assign(new YAMLOMap(), pairs$1);\n    },\n    createNode: (schema, iterable, ctx) => YAMLOMap.from(schema, iterable, ctx)\n};\n\nexports.YAMLOMap = YAMLOMap;\nexports.omap = omap;\n","'use strict';\n\nvar identity = require('../../nodes/identity.js');\nvar Pair = require('../../nodes/Pair.js');\nvar Scalar = require('../../nodes/Scalar.js');\nvar YAMLSeq = require('../../nodes/YAMLSeq.js');\n\nfunction resolvePairs(seq, onError) {\n    if (identity.isSeq(seq)) {\n        for (let i = 0; i < seq.items.length; ++i) {\n            let item = seq.items[i];\n            if (identity.isPair(item))\n                continue;\n            else if (identity.isMap(item)) {\n                if (item.items.length > 1)\n                    onError('Each pair must have its own sequence indicator');\n                const pair = item.items[0] || new Pair.Pair(new Scalar.Scalar(null));\n                if (item.commentBefore)\n                    pair.key.commentBefore = pair.key.commentBefore\n                        ? `${item.commentBefore}\\n${pair.key.commentBefore}`\n                        : item.commentBefore;\n                if (item.comment) {\n                    const cn = pair.value ?? pair.key;\n                    cn.comment = cn.comment\n                        ? `${item.comment}\\n${cn.comment}`\n                        : item.comment;\n                }\n                item = pair;\n            }\n            seq.items[i] = identity.isPair(item) ? item : new Pair.Pair(item);\n        }\n    }\n    else\n        onError('Expected a sequence for this tag');\n    return seq;\n}\nfunction createPairs(schema, iterable, ctx) {\n    const { replacer } = ctx;\n    const pairs = new YAMLSeq.YAMLSeq(schema);\n    pairs.tag = 'tag:yaml.org,2002:pairs';\n    let i = 0;\n    if (iterable && Symbol.iterator in Object(iterable))\n        for (let it of iterable) {\n            if (typeof replacer === 'function')\n                it = replacer.call(iterable, String(i++), it);\n            let key, value;\n            if (Array.isArray(it)) {\n                if (it.length === 2) {\n                    key = it[0];\n                    value = it[1];\n                }\n                else\n                    throw new TypeError(`Expected [key, value] tuple: ${it}`);\n            }\n            else if (it && it instanceof Object) {\n                const keys = Object.keys(it);\n                if (keys.length === 1) {\n                    key = keys[0];\n                    value = it[key];\n                }\n                else {\n                    throw new TypeError(`Expected tuple with one key, not ${keys.length} keys`);\n                }\n            }\n            else {\n                key = it;\n            }\n            pairs.items.push(Pair.createPair(key, value, ctx));\n        }\n    return pairs;\n}\nconst pairs = {\n    collection: 'seq',\n    default: false,\n    tag: 'tag:yaml.org,2002:pairs',\n    resolve: resolvePairs,\n    createNode: createPairs\n};\n\nexports.createPairs = createPairs;\nexports.pairs = pairs;\nexports.resolvePairs = resolvePairs;\n","'use strict';\n\nvar map = require('../common/map.js');\nvar _null = require('../common/null.js');\nvar seq = require('../common/seq.js');\nvar string = require('../common/string.js');\nvar binary = require('./binary.js');\nvar bool = require('./bool.js');\nvar float = require('./float.js');\nvar int = require('./int.js');\nvar merge = require('./merge.js');\nvar omap = require('./omap.js');\nvar pairs = require('./pairs.js');\nvar set = require('./set.js');\nvar timestamp = require('./timestamp.js');\n\nconst schema = [\n    map.map,\n    seq.seq,\n    string.string,\n    _null.nullTag,\n    bool.trueTag,\n    bool.falseTag,\n    int.intBin,\n    int.intOct,\n    int.int,\n    int.intHex,\n    float.floatNaN,\n    float.floatExp,\n    float.float,\n    binary.binary,\n    merge.merge,\n    omap.omap,\n    pairs.pairs,\n    set.set,\n    timestamp.intTime,\n    timestamp.floatTime,\n    timestamp.timestamp\n];\n\nexports.schema = schema;\n","'use strict';\n\nvar Scalar = require('../../nodes/Scalar.js');\n\nfunction boolStringify({ value, source }, ctx) {\n    const boolObj = value ? trueTag : falseTag;\n    if (source && boolObj.test.test(source))\n        return source;\n    return value ? ctx.options.trueStr : ctx.options.falseStr;\n}\nconst trueTag = {\n    identify: value => value === true,\n    default: true,\n    tag: 'tag:yaml.org,2002:bool',\n    test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,\n    resolve: () => new Scalar.Scalar(true),\n    stringify: boolStringify\n};\nconst falseTag = {\n    identify: value => value === false,\n    default: true,\n    tag: 'tag:yaml.org,2002:bool',\n    test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,\n    resolve: () => new Scalar.Scalar(false),\n    stringify: boolStringify\n};\n\nexports.falseTag = falseTag;\nexports.trueTag = trueTag;\n","'use strict';\n\nvar Scalar = require('../../nodes/Scalar.js');\nvar stringifyNumber = require('../../stringify/stringifyNumber.js');\n\nconst floatNaN = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    test: /^(?:[-+]?\\.(?:inf|Inf|INF)|\\.nan|\\.NaN|\\.NAN)$/,\n    resolve: (str) => str.slice(-3).toLowerCase() === 'nan'\n        ? NaN\n        : str[0] === '-'\n            ? Number.NEGATIVE_INFINITY\n            : Number.POSITIVE_INFINITY,\n    stringify: stringifyNumber.stringifyNumber\n};\nconst floatExp = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    format: 'EXP',\n    test: /^[-+]?(?:[0-9][0-9_]*)?(?:\\.[0-9_]*)?[eE][-+]?[0-9]+$/,\n    resolve: (str) => parseFloat(str.replace(/_/g, '')),\n    stringify(node) {\n        const num = Number(node.value);\n        return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);\n    }\n};\nconst float = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    test: /^[-+]?(?:[0-9][0-9_]*)?\\.[0-9_]*$/,\n    resolve(str) {\n        const node = new Scalar.Scalar(parseFloat(str.replace(/_/g, '')));\n        const dot = str.indexOf('.');\n        if (dot !== -1) {\n            const f = str.substring(dot + 1).replace(/_/g, '');\n            if (f[f.length - 1] === '0')\n                node.minFractionDigits = f.length;\n        }\n        return node;\n    },\n    stringify: stringifyNumber.stringifyNumber\n};\n\nexports.float = float;\nexports.floatExp = floatExp;\nexports.floatNaN = floatNaN;\n","'use strict';\n\nvar stringifyNumber = require('../../stringify/stringifyNumber.js');\n\nconst intIdentify = (value) => typeof value === 'bigint' || Number.isInteger(value);\nfunction intResolve(str, offset, radix, { intAsBigInt }) {\n    const sign = str[0];\n    if (sign === '-' || sign === '+')\n        offset += 1;\n    str = str.substring(offset).replace(/_/g, '');\n    if (intAsBigInt) {\n        switch (radix) {\n            case 2:\n                str = `0b${str}`;\n                break;\n            case 8:\n                str = `0o${str}`;\n                break;\n            case 16:\n                str = `0x${str}`;\n                break;\n        }\n        const n = BigInt(str);\n        return sign === '-' ? BigInt(-1) * n : n;\n    }\n    const n = parseInt(str, radix);\n    return sign === '-' ? -1 * n : n;\n}\nfunction intStringify(node, radix, prefix) {\n    const { value } = node;\n    if (intIdentify(value)) {\n        const str = value.toString(radix);\n        return value < 0 ? '-' + prefix + str.substr(1) : prefix + str;\n    }\n    return stringifyNumber.stringifyNumber(node);\n}\nconst intBin = {\n    identify: intIdentify,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    format: 'BIN',\n    test: /^[-+]?0b[0-1_]+$/,\n    resolve: (str, _onError, opt) => intResolve(str, 2, 2, opt),\n    stringify: node => intStringify(node, 2, '0b')\n};\nconst intOct = {\n    identify: intIdentify,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    format: 'OCT',\n    test: /^[-+]?0[0-7_]+$/,\n    resolve: (str, _onError, opt) => intResolve(str, 1, 8, opt),\n    stringify: node => intStringify(node, 8, '0')\n};\nconst int = {\n    identify: intIdentify,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    test: /^[-+]?[0-9][0-9_]*$/,\n    resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),\n    stringify: stringifyNumber.stringifyNumber\n};\nconst intHex = {\n    identify: intIdentify,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    format: 'HEX',\n    test: /^[-+]?0x[0-9a-fA-F_]+$/,\n    resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),\n    stringify: node => intStringify(node, 16, '0x')\n};\n\nexports.int = int;\nexports.intBin = intBin;\nexports.intHex = intHex;\nexports.intOct = intOct;\n","'use strict';\n\nvar identity = require('../../nodes/identity.js');\nvar Pair = require('../../nodes/Pair.js');\nvar YAMLMap = require('../../nodes/YAMLMap.js');\n\nclass YAMLSet extends YAMLMap.YAMLMap {\n    constructor(schema) {\n        super(schema);\n        this.tag = YAMLSet.tag;\n    }\n    add(key) {\n        let pair;\n        if (identity.isPair(key))\n            pair = key;\n        else if (key &&\n            typeof key === 'object' &&\n            'key' in key &&\n            'value' in key &&\n            key.value === null)\n            pair = new Pair.Pair(key.key, null);\n        else\n            pair = new Pair.Pair(key, null);\n        const prev = YAMLMap.findPair(this.items, pair.key);\n        if (!prev)\n            this.items.push(pair);\n    }\n    /**\n     * If `keepPair` is `true`, returns the Pair matching `key`.\n     * Otherwise, returns the value of that Pair's key.\n     */\n    get(key, keepPair) {\n        const pair = YAMLMap.findPair(this.items, key);\n        return !keepPair && identity.isPair(pair)\n            ? identity.isScalar(pair.key)\n                ? pair.key.value\n                : pair.key\n            : pair;\n    }\n    set(key, value) {\n        if (typeof value !== 'boolean')\n            throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);\n        const prev = YAMLMap.findPair(this.items, key);\n        if (prev && !value) {\n            this.items.splice(this.items.indexOf(prev), 1);\n        }\n        else if (!prev && value) {\n            this.items.push(new Pair.Pair(key));\n        }\n    }\n    toJSON(_, ctx) {\n        return super.toJSON(_, ctx, Set);\n    }\n    toString(ctx, onComment, onChompKeep) {\n        if (!ctx)\n            return JSON.stringify(this);\n        if (this.hasAllNullValues(true))\n            return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);\n        else\n            throw new Error('Set items must all have null values');\n    }\n    static from(schema, iterable, ctx) {\n        const { replacer } = ctx;\n        const set = new this(schema);\n        if (iterable && Symbol.iterator in Object(iterable))\n            for (let value of iterable) {\n                if (typeof replacer === 'function')\n                    value = replacer.call(iterable, value, value);\n                set.items.push(Pair.createPair(value, null, ctx));\n            }\n        return set;\n    }\n}\nYAMLSet.tag = 'tag:yaml.org,2002:set';\nconst set = {\n    collection: 'map',\n    identify: value => value instanceof Set,\n    nodeClass: YAMLSet,\n    default: false,\n    tag: 'tag:yaml.org,2002:set',\n    createNode: (schema, iterable, ctx) => YAMLSet.from(schema, iterable, ctx),\n    resolve(map, onError) {\n        if (identity.isMap(map)) {\n            if (map.hasAllNullValues(true))\n                return Object.assign(new YAMLSet(), map);\n            else\n                onError('Set items must all have null values');\n        }\n        else\n            onError('Expected a mapping for this tag');\n        return map;\n    }\n};\n\nexports.YAMLSet = YAMLSet;\nexports.set = set;\n","'use strict';\n\nvar stringifyNumber = require('../../stringify/stringifyNumber.js');\n\n/** Internal types handle bigint as number, because TS can't figure it out. */\nfunction parseSexagesimal(str, asBigInt) {\n    const sign = str[0];\n    const parts = sign === '-' || sign === '+' ? str.substring(1) : str;\n    const num = (n) => asBigInt ? BigInt(n) : Number(n);\n    const res = parts\n        .replace(/_/g, '')\n        .split(':')\n        .reduce((res, p) => res * num(60) + num(p), num(0));\n    return (sign === '-' ? num(-1) * res : res);\n}\n/**\n * hhhh:mm:ss.sss\n *\n * Internal types handle bigint as number, because TS can't figure it out.\n */\nfunction stringifySexagesimal(node) {\n    let { value } = node;\n    let num = (n) => n;\n    if (typeof value === 'bigint')\n        num = n => BigInt(n);\n    else if (isNaN(value) || !isFinite(value))\n        return stringifyNumber.stringifyNumber(node);\n    let sign = '';\n    if (value < 0) {\n        sign = '-';\n        value *= num(-1);\n    }\n    const _60 = num(60);\n    const parts = [value % _60]; // seconds, including ms\n    if (value < 60) {\n        parts.unshift(0); // at least one : is required\n    }\n    else {\n        value = (value - parts[0]) / _60;\n        parts.unshift(value % _60); // minutes\n        if (value >= 60) {\n            value = (value - parts[0]) / _60;\n            parts.unshift(value); // hours\n        }\n    }\n    return (sign +\n        parts\n            .map(n => String(n).padStart(2, '0'))\n            .join(':')\n            .replace(/000000\\d*$/, '') // % 60 may introduce error\n    );\n}\nconst intTime = {\n    identify: value => typeof value === 'bigint' || Number.isInteger(value),\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    format: 'TIME',\n    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,\n    resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),\n    stringify: stringifySexagesimal\n};\nconst floatTime = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    format: 'TIME',\n    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*$/,\n    resolve: str => parseSexagesimal(str, false),\n    stringify: stringifySexagesimal\n};\nconst timestamp = {\n    identify: value => value instanceof Date,\n    default: true,\n    tag: 'tag:yaml.org,2002:timestamp',\n    // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part\n    // may be omitted altogether, resulting in a date format. In such a case, the time part is\n    // assumed to be 00:00:00Z (start of day, UTC).\n    test: RegExp('^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})' + // YYYY-Mm-Dd\n        '(?:' + // time is optional\n        '(?:t|T|[ \\\\t]+)' + // t | T | whitespace\n        '([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\\\.[0-9]+)?)' + // Hh:Mm:Ss(.ss)?\n        '(?:[ \\\\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?' + // Z | +5 | -03:30\n        ')?$'),\n    resolve(str) {\n        const match = str.match(timestamp.test);\n        if (!match)\n            throw new Error('!!timestamp expects a date, starting with yyyy-mm-dd');\n        const [, year, month, day, hour, minute, second] = match.map(Number);\n        const millisec = match[7] ? Number((match[7] + '00').substr(1, 3)) : 0;\n        let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);\n        const tz = match[8];\n        if (tz && tz !== 'Z') {\n            let d = parseSexagesimal(tz, false);\n            if (Math.abs(d) < 30)\n                d *= 60;\n            date -= 60000 * d;\n        }\n        return new Date(date);\n    },\n    stringify: ({ value }) => value?.toISOString().replace(/(T00:00:00)?\\.000Z$/, '') ?? ''\n};\n\nexports.floatTime = floatTime;\nexports.intTime = intTime;\nexports.timestamp = timestamp;\n","'use strict';\n\nvar identity = require('../nodes/identity.js');\nvar stringify = require('./stringify.js');\nvar stringifyComment = require('./stringifyComment.js');\n\nfunction stringifyDocument(doc, options) {\n    const lines = [];\n    let hasDirectives = options.directives === true;\n    if (options.directives !== false && doc.directives) {\n        const dir = doc.directives.toString(doc);\n        if (dir) {\n            lines.push(dir);\n            hasDirectives = true;\n        }\n        else if (doc.directives.docStart)\n            hasDirectives = true;\n    }\n    if (hasDirectives)\n        lines.push('---');\n    const ctx = stringify.createStringifyContext(doc, options);\n    const { commentString } = ctx.options;\n    if (doc.commentBefore) {\n        if (lines.length !== 1)\n            lines.unshift('');\n        const cs = commentString(doc.commentBefore);\n        lines.unshift(stringifyComment.indentComment(cs, ''));\n    }\n    let chompKeep = false;\n    let contentComment = null;\n    if (doc.contents) {\n        if (identity.isNode(doc.contents)) {\n            if (doc.contents.spaceBefore && hasDirectives)\n                lines.push('');\n            if (doc.contents.commentBefore) {\n                const cs = commentString(doc.contents.commentBefore);\n                lines.push(stringifyComment.indentComment(cs, ''));\n            }\n            // top-level block scalars need to be indented if followed by a comment\n            ctx.forceBlockIndent = !!doc.comment;\n            contentComment = doc.contents.comment;\n        }\n        const onChompKeep = contentComment ? undefined : () => (chompKeep = true);\n        let body = stringify.stringify(doc.contents, ctx, () => (contentComment = null), onChompKeep);\n        if (contentComment)\n            body += stringifyComment.lineComment(body, '', commentString(contentComment));\n        if ((body[0] === '|' || body[0] === '>') &&\n            lines[lines.length - 1] === '---') {\n            // Top-level block scalars with a preceding doc marker ought to use the\n            // same line for their header.\n            lines[lines.length - 1] = `--- ${body}`;\n        }\n        else\n            lines.push(body);\n    }\n    else {\n        lines.push(stringify.stringify(doc.contents, ctx));\n    }\n    if (doc.directives?.docEnd) {\n        if (doc.comment) {\n            const cs = commentString(doc.comment);\n            if (cs.includes('\\n')) {\n                lines.push('...');\n                lines.push(stringifyComment.indentComment(cs, ''));\n            }\n            else {\n                lines.push(`... ${cs}`);\n            }\n        }\n        else {\n            lines.push('...');\n        }\n    }\n    else {\n        let dc = doc.comment;\n        if (dc && chompKeep)\n            dc = dc.replace(/^\\n+/, '');\n        if (dc) {\n            if ((!chompKeep || contentComment) && lines[lines.length - 1] !== '')\n                lines.push('');\n            lines.push(stringifyComment.indentComment(commentString(dc), ''));\n        }\n    }\n    return lines.join('\\n') + '\\n';\n}\n\nexports.stringifyDocument = stringifyDocument;\n","'use strict';\n\nclass YAMLError extends Error {\n    constructor(name, pos, code, message) {\n        super();\n        this.name = name;\n        this.code = code;\n        this.message = message;\n        this.pos = pos;\n    }\n}\nclass YAMLParseError extends YAMLError {\n    constructor(pos, code, message) {\n        super('YAMLParseError', pos, code, message);\n    }\n}\nclass YAMLWarning extends YAMLError {\n    constructor(pos, code, message) {\n        super('YAMLWarning', pos, code, message);\n    }\n}\nconst prettifyError = (src, lc) => (error) => {\n    if (error.pos[0] === -1)\n        return;\n    error.linePos = error.pos.map(pos => lc.linePos(pos));\n    const { line, col } = error.linePos[0];\n    error.message += ` at line ${line}, column ${col}`;\n    let ci = col - 1;\n    let lineStr = src\n        .substring(lc.lineStarts[line - 1], lc.lineStarts[line])\n        .replace(/[\\n\\r]+$/, '');\n    // Trim to max 80 chars, keeping col position near the middle\n    if (ci >= 60 && lineStr.length > 80) {\n        const trimStart = Math.min(ci - 39, lineStr.length - 79);\n        lineStr = '' + lineStr.substring(trimStart);\n        ci -= trimStart - 1;\n    }\n    if (lineStr.length > 80)\n        lineStr = lineStr.substring(0, 79) + '';\n    // Include previous line in context if pointing at line start\n    if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {\n        // Regexp won't match if start is trimmed\n        let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);\n        if (prev.length > 80)\n            prev = prev.substring(0, 79) + '\\n';\n        lineStr = prev + lineStr;\n    }\n    if (/[^ ]/.test(lineStr)) {\n        let count = 1;\n        const end = error.linePos[1];\n        if (end && end.line === line && end.col > col) {\n            count = Math.max(1, Math.min(end.col - col, 80 - ci));\n        }\n        const pointer = ' '.repeat(ci) + '^'.repeat(count);\n        error.message += `:\\n\\n${lineStr}\\n${pointer}\\n`;\n    }\n};\n\nexports.YAMLError = YAMLError;\nexports.YAMLParseError = YAMLParseError;\nexports.YAMLWarning = YAMLWarning;\nexports.prettifyError = prettifyError;\n","'use strict';\n\nvar Document = require('../doc/Document.js');\nvar composeNode = require('./compose-node.js');\nvar resolveEnd = require('./resolve-end.js');\nvar resolveProps = require('./resolve-props.js');\n\nfunction composeDoc(options, directives, { offset, start, value, end }, onError) {\n    const opts = Object.assign({ _directives: directives }, options);\n    const doc = new Document.Document(undefined, opts);\n    const ctx = {\n        atKey: false,\n        atRoot: true,\n        directives: doc.directives,\n        options: doc.options,\n        schema: doc.schema\n    };\n    const props = resolveProps.resolveProps(start, {\n        indicator: 'doc-start',\n        next: value ?? end?.[0],\n        offset,\n        onError,\n        parentIndent: 0,\n        startOnNewline: true\n    });\n    if (props.found) {\n        doc.directives.docStart = true;\n        if (value &&\n            (value.type === 'block-map' || value.type === 'block-seq') &&\n            !props.hasNewline)\n            onError(props.end, 'MISSING_CHAR', 'Block collection cannot start on same line with directives-end marker');\n    }\n    // @ts-expect-error If Contents is set, let's trust the user\n    doc.contents = value\n        ? composeNode.composeNode(ctx, value, props, onError)\n        : composeNode.composeEmptyNode(ctx, props.end, start, null, props, onError);\n    const contentEnd = doc.contents.range[2];\n    const re = resolveEnd.resolveEnd(end, contentEnd, false, onError);\n    if (re.comment)\n        doc.comment = re.comment;\n    doc.range = [offset, contentEnd, re.offset];\n    return doc;\n}\n\nexports.composeDoc = composeDoc;\n","'use strict';\n\nvar Alias = require('../nodes/Alias.js');\nvar identity = require('../nodes/identity.js');\nvar composeCollection = require('./compose-collection.js');\nvar composeScalar = require('./compose-scalar.js');\nvar resolveEnd = require('./resolve-end.js');\nvar utilEmptyScalarPosition = require('./util-empty-scalar-position.js');\n\nconst CN = { composeNode, composeEmptyNode };\nfunction composeNode(ctx, token, props, onError) {\n    const atKey = ctx.atKey;\n    const { spaceBefore, comment, anchor, tag } = props;\n    let node;\n    let isSrcToken = true;\n    switch (token.type) {\n        case 'alias':\n            node = composeAlias(ctx, token, onError);\n            if (anchor || tag)\n                onError(token, 'ALIAS_PROPS', 'An alias node must not specify any properties');\n            break;\n        case 'scalar':\n        case 'single-quoted-scalar':\n        case 'double-quoted-scalar':\n        case 'block-scalar':\n            node = composeScalar.composeScalar(ctx, token, tag, onError);\n            if (anchor)\n                node.anchor = anchor.source.substring(1);\n            break;\n        case 'block-map':\n        case 'block-seq':\n        case 'flow-collection':\n            node = composeCollection.composeCollection(CN, ctx, token, props, onError);\n            if (anchor)\n                node.anchor = anchor.source.substring(1);\n            break;\n        default: {\n            const message = token.type === 'error'\n                ? token.message\n                : `Unsupported token (type: ${token.type})`;\n            onError(token, 'UNEXPECTED_TOKEN', message);\n            node = composeEmptyNode(ctx, token.offset, undefined, null, props, onError);\n            isSrcToken = false;\n        }\n    }\n    if (anchor && node.anchor === '')\n        onError(anchor, 'BAD_ALIAS', 'Anchor cannot be an empty string');\n    if (atKey &&\n        ctx.options.stringKeys &&\n        (!identity.isScalar(node) ||\n            typeof node.value !== 'string' ||\n            (node.tag && node.tag !== 'tag:yaml.org,2002:str'))) {\n        const msg = 'With stringKeys, all keys must be strings';\n        onError(tag ?? token, 'NON_STRING_KEY', msg);\n    }\n    if (spaceBefore)\n        node.spaceBefore = true;\n    if (comment) {\n        if (token.type === 'scalar' && token.source === '')\n            node.comment = comment;\n        else\n            node.commentBefore = comment;\n    }\n    // @ts-expect-error Type checking misses meaning of isSrcToken\n    if (ctx.options.keepSourceTokens && isSrcToken)\n        node.srcToken = token;\n    return node;\n}\nfunction composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag, end }, onError) {\n    const token = {\n        type: 'scalar',\n        offset: utilEmptyScalarPosition.emptyScalarPosition(offset, before, pos),\n        indent: -1,\n        source: ''\n    };\n    const node = composeScalar.composeScalar(ctx, token, tag, onError);\n    if (anchor) {\n        node.anchor = anchor.source.substring(1);\n        if (node.anchor === '')\n            onError(anchor, 'BAD_ALIAS', 'Anchor cannot be an empty string');\n    }\n    if (spaceBefore)\n        node.spaceBefore = true;\n    if (comment) {\n        node.comment = comment;\n        node.range[2] = end;\n    }\n    return node;\n}\nfunction composeAlias({ options }, { offset, source, end }, onError) {\n    const alias = new Alias.Alias(source.substring(1));\n    if (alias.source === '')\n        onError(offset, 'BAD_ALIAS', 'Alias cannot be an empty string');\n    if (alias.source.endsWith(':'))\n        onError(offset + source.length - 1, 'BAD_ALIAS', 'Alias ending in : is ambiguous', true);\n    const valueEnd = offset + source.length;\n    const re = resolveEnd.resolveEnd(end, valueEnd, options.strict, onError);\n    alias.range = [offset, valueEnd, re.offset];\n    if (re.comment)\n        alias.comment = re.comment;\n    return alias;\n}\n\nexports.composeEmptyNode = composeEmptyNode;\nexports.composeNode = composeNode;\n","'use strict';\n\nvar identity = require('../nodes/identity.js');\nvar Scalar = require('../nodes/Scalar.js');\nvar YAMLMap = require('../nodes/YAMLMap.js');\nvar YAMLSeq = require('../nodes/YAMLSeq.js');\nvar resolveBlockMap = require('./resolve-block-map.js');\nvar resolveBlockSeq = require('./resolve-block-seq.js');\nvar resolveFlowCollection = require('./resolve-flow-collection.js');\n\nfunction resolveCollection(CN, ctx, token, onError, tagName, tag) {\n    const coll = token.type === 'block-map'\n        ? resolveBlockMap.resolveBlockMap(CN, ctx, token, onError, tag)\n        : token.type === 'block-seq'\n            ? resolveBlockSeq.resolveBlockSeq(CN, ctx, token, onError, tag)\n            : resolveFlowCollection.resolveFlowCollection(CN, ctx, token, onError, tag);\n    const Coll = coll.constructor;\n    // If we got a tagName matching the class, or the tag name is '!',\n    // then use the tagName from the node class used to create it.\n    if (tagName === '!' || tagName === Coll.tagName) {\n        coll.tag = Coll.tagName;\n        return coll;\n    }\n    if (tagName)\n        coll.tag = tagName;\n    return coll;\n}\nfunction composeCollection(CN, ctx, token, props, onError) {\n    const tagToken = props.tag;\n    const tagName = !tagToken\n        ? null\n        : ctx.directives.tagName(tagToken.source, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg));\n    if (token.type === 'block-seq') {\n        const { anchor, newlineAfterProp: nl } = props;\n        const lastProp = anchor && tagToken\n            ? anchor.offset > tagToken.offset\n                ? anchor\n                : tagToken\n            : (anchor ?? tagToken);\n        if (lastProp && (!nl || nl.offset < lastProp.offset)) {\n            const message = 'Missing newline after block sequence props';\n            onError(lastProp, 'MISSING_CHAR', message);\n        }\n    }\n    const expType = token.type === 'block-map'\n        ? 'map'\n        : token.type === 'block-seq'\n            ? 'seq'\n            : token.start.source === '{'\n                ? 'map'\n                : 'seq';\n    // shortcut: check if it's a generic YAMLMap or YAMLSeq\n    // before jumping into the custom tag logic.\n    if (!tagToken ||\n        !tagName ||\n        tagName === '!' ||\n        (tagName === YAMLMap.YAMLMap.tagName && expType === 'map') ||\n        (tagName === YAMLSeq.YAMLSeq.tagName && expType === 'seq')) {\n        return resolveCollection(CN, ctx, token, onError, tagName);\n    }\n    let tag = ctx.schema.tags.find(t => t.tag === tagName && t.collection === expType);\n    if (!tag) {\n        const kt = ctx.schema.knownTags[tagName];\n        if (kt && kt.collection === expType) {\n            ctx.schema.tags.push(Object.assign({}, kt, { default: false }));\n            tag = kt;\n        }\n        else {\n            if (kt) {\n                onError(tagToken, 'BAD_COLLECTION_TYPE', `${kt.tag} used for ${expType} collection, but expects ${kt.collection ?? 'scalar'}`, true);\n            }\n            else {\n                onError(tagToken, 'TAG_RESOLVE_FAILED', `Unresolved tag: ${tagName}`, true);\n            }\n            return resolveCollection(CN, ctx, token, onError, tagName);\n        }\n    }\n    const coll = resolveCollection(CN, ctx, token, onError, tagName, tag);\n    const res = tag.resolve?.(coll, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg), ctx.options) ?? coll;\n    const node = identity.isNode(res)\n        ? res\n        : new Scalar.Scalar(res);\n    node.range = coll.range;\n    node.tag = tagName;\n    if (tag?.format)\n        node.format = tag.format;\n    return node;\n}\n\nexports.composeCollection = composeCollection;\n","'use strict';\n\nvar Pair = require('../nodes/Pair.js');\nvar YAMLMap = require('../nodes/YAMLMap.js');\nvar resolveProps = require('./resolve-props.js');\nvar utilContainsNewline = require('./util-contains-newline.js');\nvar utilFlowIndentCheck = require('./util-flow-indent-check.js');\nvar utilMapIncludes = require('./util-map-includes.js');\n\nconst startColMsg = 'All mapping items must start at the same column';\nfunction resolveBlockMap({ composeNode, composeEmptyNode }, ctx, bm, onError, tag) {\n    const NodeClass = tag?.nodeClass ?? YAMLMap.YAMLMap;\n    const map = new NodeClass(ctx.schema);\n    if (ctx.atRoot)\n        ctx.atRoot = false;\n    let offset = bm.offset;\n    let commentEnd = null;\n    for (const collItem of bm.items) {\n        const { start, key, sep, value } = collItem;\n        // key properties\n        const keyProps = resolveProps.resolveProps(start, {\n            indicator: 'explicit-key-ind',\n            next: key ?? sep?.[0],\n            offset,\n            onError,\n            parentIndent: bm.indent,\n            startOnNewline: true\n        });\n        const implicitKey = !keyProps.found;\n        if (implicitKey) {\n            if (key) {\n                if (key.type === 'block-seq')\n                    onError(offset, 'BLOCK_AS_IMPLICIT_KEY', 'A block sequence may not be used as an implicit map key');\n                else if ('indent' in key && key.indent !== bm.indent)\n                    onError(offset, 'BAD_INDENT', startColMsg);\n            }\n            if (!keyProps.anchor && !keyProps.tag && !sep) {\n                commentEnd = keyProps.end;\n                if (keyProps.comment) {\n                    if (map.comment)\n                        map.comment += '\\n' + keyProps.comment;\n                    else\n                        map.comment = keyProps.comment;\n                }\n                continue;\n            }\n            if (keyProps.newlineAfterProp || utilContainsNewline.containsNewline(key)) {\n                onError(key ?? start[start.length - 1], 'MULTILINE_IMPLICIT_KEY', 'Implicit keys need to be on a single line');\n            }\n        }\n        else if (keyProps.found?.indent !== bm.indent) {\n            onError(offset, 'BAD_INDENT', startColMsg);\n        }\n        // key value\n        ctx.atKey = true;\n        const keyStart = keyProps.end;\n        const keyNode = key\n            ? composeNode(ctx, key, keyProps, onError)\n            : composeEmptyNode(ctx, keyStart, start, null, keyProps, onError);\n        if (ctx.schema.compat)\n            utilFlowIndentCheck.flowIndentCheck(bm.indent, key, onError);\n        ctx.atKey = false;\n        if (utilMapIncludes.mapIncludes(ctx, map.items, keyNode))\n            onError(keyStart, 'DUPLICATE_KEY', 'Map keys must be unique');\n        // value properties\n        const valueProps = resolveProps.resolveProps(sep ?? [], {\n            indicator: 'map-value-ind',\n            next: value,\n            offset: keyNode.range[2],\n            onError,\n            parentIndent: bm.indent,\n            startOnNewline: !key || key.type === 'block-scalar'\n        });\n        offset = valueProps.end;\n        if (valueProps.found) {\n            if (implicitKey) {\n                if (value?.type === 'block-map' && !valueProps.hasNewline)\n                    onError(offset, 'BLOCK_AS_IMPLICIT_KEY', 'Nested mappings are not allowed in compact mappings');\n                if (ctx.options.strict &&\n                    keyProps.start < valueProps.found.offset - 1024)\n                    onError(keyNode.range, 'KEY_OVER_1024_CHARS', 'The : indicator must be at most 1024 chars after the start of an implicit block mapping key');\n            }\n            // value value\n            const valueNode = value\n                ? composeNode(ctx, value, valueProps, onError)\n                : composeEmptyNode(ctx, offset, sep, null, valueProps, onError);\n            if (ctx.schema.compat)\n                utilFlowIndentCheck.flowIndentCheck(bm.indent, value, onError);\n            offset = valueNode.range[2];\n            const pair = new Pair.Pair(keyNode, valueNode);\n            if (ctx.options.keepSourceTokens)\n                pair.srcToken = collItem;\n            map.items.push(pair);\n        }\n        else {\n            // key with no value\n            if (implicitKey)\n                onError(keyNode.range, 'MISSING_CHAR', 'Implicit map keys need to be followed by map values');\n            if (valueProps.comment) {\n                if (keyNode.comment)\n                    keyNode.comment += '\\n' + valueProps.comment;\n                else\n                    keyNode.comment = valueProps.comment;\n            }\n            const pair = new Pair.Pair(keyNode);\n            if (ctx.options.keepSourceTokens)\n                pair.srcToken = collItem;\n            map.items.push(pair);\n        }\n    }\n    if (commentEnd && commentEnd < offset)\n        onError(commentEnd, 'IMPOSSIBLE', 'Map comment with trailing content');\n    map.range = [bm.offset, offset, commentEnd ?? offset];\n    return map;\n}\n\nexports.resolveBlockMap = resolveBlockMap;\n","'use strict';\n\nfunction resolveProps(tokens, { flow, indicator, next, offset, onError, parentIndent, startOnNewline }) {\n    let spaceBefore = false;\n    let atNewline = startOnNewline;\n    let hasSpace = startOnNewline;\n    let comment = '';\n    let commentSep = '';\n    let hasNewline = false;\n    let reqSpace = false;\n    let tab = null;\n    let anchor = null;\n    let tag = null;\n    let newlineAfterProp = null;\n    let comma = null;\n    let found = null;\n    let start = null;\n    for (const token of tokens) {\n        if (reqSpace) {\n            if (token.type !== 'space' &&\n                token.type !== 'newline' &&\n                token.type !== 'comma')\n                onError(token.offset, 'MISSING_CHAR', 'Tags and anchors must be separated from the next token by white space');\n            reqSpace = false;\n        }\n        if (tab) {\n            if (atNewline && token.type !== 'comment' && token.type !== 'newline') {\n                onError(tab, 'TAB_AS_INDENT', 'Tabs are not allowed as indentation');\n            }\n            tab = null;\n        }\n        switch (token.type) {\n            case 'space':\n                // At the doc level, tabs at line start may be parsed\n                // as leading white space rather than indentation.\n                // In a flow collection, only the parser handles indent.\n                if (!flow &&\n                    (indicator !== 'doc-start' || next?.type !== 'flow-collection') &&\n                    token.source.includes('\\t')) {\n                    tab = token;\n                }\n                hasSpace = true;\n                break;\n            case 'comment': {\n                if (!hasSpace)\n                    onError(token, 'MISSING_CHAR', 'Comments must be separated from other tokens by white space characters');\n                const cb = token.source.substring(1) || ' ';\n                if (!comment)\n                    comment = cb;\n                else\n                    comment += commentSep + cb;\n                commentSep = '';\n                atNewline = false;\n                break;\n            }\n            case 'newline':\n                if (atNewline) {\n                    if (comment)\n                        comment += token.source;\n                    else if (!found || indicator !== 'seq-item-ind')\n                        spaceBefore = true;\n                }\n                else\n                    commentSep += token.source;\n                atNewline = true;\n                hasNewline = true;\n                if (anchor || tag)\n                    newlineAfterProp = token;\n                hasSpace = true;\n                break;\n            case 'anchor':\n                if (anchor)\n                    onError(token, 'MULTIPLE_ANCHORS', 'A node can have at most one anchor');\n                if (token.source.endsWith(':'))\n                    onError(token.offset + token.source.length - 1, 'BAD_ALIAS', 'Anchor ending in : is ambiguous', true);\n                anchor = token;\n                start ?? (start = token.offset);\n                atNewline = false;\n                hasSpace = false;\n                reqSpace = true;\n                break;\n            case 'tag': {\n                if (tag)\n                    onError(token, 'MULTIPLE_TAGS', 'A node can have at most one tag');\n                tag = token;\n                start ?? (start = token.offset);\n                atNewline = false;\n                hasSpace = false;\n                reqSpace = true;\n                break;\n            }\n            case indicator:\n                // Could here handle preceding comments differently\n                if (anchor || tag)\n                    onError(token, 'BAD_PROP_ORDER', `Anchors and tags must be after the ${token.source} indicator`);\n                if (found)\n                    onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${token.source} in ${flow ?? 'collection'}`);\n                found = token;\n                atNewline =\n                    indicator === 'seq-item-ind' || indicator === 'explicit-key-ind';\n                hasSpace = false;\n                break;\n            case 'comma':\n                if (flow) {\n                    if (comma)\n                        onError(token, 'UNEXPECTED_TOKEN', `Unexpected , in ${flow}`);\n                    comma = token;\n                    atNewline = false;\n                    hasSpace = false;\n                    break;\n                }\n            // else fallthrough\n            default:\n                onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${token.type} token`);\n                atNewline = false;\n                hasSpace = false;\n        }\n    }\n    const last = tokens[tokens.length - 1];\n    const end = last ? last.offset + last.source.length : offset;\n    if (reqSpace &&\n        next &&\n        next.type !== 'space' &&\n        next.type !== 'newline' &&\n        next.type !== 'comma' &&\n        (next.type !== 'scalar' || next.source !== '')) {\n        onError(next.offset, 'MISSING_CHAR', 'Tags and anchors must be separated from the next token by white space');\n    }\n    if (tab &&\n        ((atNewline && tab.indent <= parentIndent) ||\n            next?.type === 'block-map' ||\n            next?.type === 'block-seq'))\n        onError(tab, 'TAB_AS_INDENT', 'Tabs are not allowed as indentation');\n    return {\n        comma,\n        found,\n        spaceBefore,\n        comment,\n        hasNewline,\n        anchor,\n        tag,\n        newlineAfterProp,\n        end,\n        start: start ?? end\n    };\n}\n\nexports.resolveProps = resolveProps;\n","'use strict';\n\nfunction containsNewline(key) {\n    if (!key)\n        return null;\n    switch (key.type) {\n        case 'alias':\n        case 'scalar':\n        case 'double-quoted-scalar':\n        case 'single-quoted-scalar':\n            if (key.source.includes('\\n'))\n                return true;\n            if (key.end)\n                for (const st of key.end)\n                    if (st.type === 'newline')\n                        return true;\n            return false;\n        case 'flow-collection':\n            for (const it of key.items) {\n                for (const st of it.start)\n                    if (st.type === 'newline')\n                        return true;\n                if (it.sep)\n                    for (const st of it.sep)\n                        if (st.type === 'newline')\n                            return true;\n                if (containsNewline(it.key) || containsNewline(it.value))\n                    return true;\n            }\n            return false;\n        default:\n            return true;\n    }\n}\n\nexports.containsNewline = containsNewline;\n","'use strict';\n\nvar utilContainsNewline = require('./util-contains-newline.js');\n\nfunction flowIndentCheck(indent, fc, onError) {\n    if (fc?.type === 'flow-collection') {\n        const end = fc.end[0];\n        if (end.indent === indent &&\n            (end.source === ']' || end.source === '}') &&\n            utilContainsNewline.containsNewline(fc)) {\n            const msg = 'Flow end indicator should be more indented than parent';\n            onError(end, 'BAD_INDENT', msg, true);\n        }\n    }\n}\n\nexports.flowIndentCheck = flowIndentCheck;\n","'use strict';\n\nvar identity = require('../nodes/identity.js');\n\nfunction mapIncludes(ctx, items, search) {\n    const { uniqueKeys } = ctx.options;\n    if (uniqueKeys === false)\n        return false;\n    const isEqual = typeof uniqueKeys === 'function'\n        ? uniqueKeys\n        : (a, b) => a === b || (identity.isScalar(a) && identity.isScalar(b) && a.value === b.value);\n    return items.some(pair => isEqual(pair.key, search));\n}\n\nexports.mapIncludes = mapIncludes;\n","'use strict';\n\nvar YAMLSeq = require('../nodes/YAMLSeq.js');\nvar resolveProps = require('./resolve-props.js');\nvar utilFlowIndentCheck = require('./util-flow-indent-check.js');\n\nfunction resolveBlockSeq({ composeNode, composeEmptyNode }, ctx, bs, onError, tag) {\n    const NodeClass = tag?.nodeClass ?? YAMLSeq.YAMLSeq;\n    const seq = new NodeClass(ctx.schema);\n    if (ctx.atRoot)\n        ctx.atRoot = false;\n    if (ctx.atKey)\n        ctx.atKey = false;\n    let offset = bs.offset;\n    let commentEnd = null;\n    for (const { start, value } of bs.items) {\n        const props = resolveProps.resolveProps(start, {\n            indicator: 'seq-item-ind',\n            next: value,\n            offset,\n            onError,\n            parentIndent: bs.indent,\n            startOnNewline: true\n        });\n        if (!props.found) {\n            if (props.anchor || props.tag || value) {\n                if (value && value.type === 'block-seq')\n                    onError(props.end, 'BAD_INDENT', 'All sequence items must start at the same column');\n                else\n                    onError(offset, 'MISSING_CHAR', 'Sequence item without - indicator');\n            }\n            else {\n                commentEnd = props.end;\n                if (props.comment)\n                    seq.comment = props.comment;\n                continue;\n            }\n        }\n        const node = value\n            ? composeNode(ctx, value, props, onError)\n            : composeEmptyNode(ctx, props.end, start, null, props, onError);\n        if (ctx.schema.compat)\n            utilFlowIndentCheck.flowIndentCheck(bs.indent, value, onError);\n        offset = node.range[2];\n        seq.items.push(node);\n    }\n    seq.range = [bs.offset, offset, commentEnd ?? offset];\n    return seq;\n}\n\nexports.resolveBlockSeq = resolveBlockSeq;\n","'use strict';\n\nvar identity = require('../nodes/identity.js');\nvar Pair = require('../nodes/Pair.js');\nvar YAMLMap = require('../nodes/YAMLMap.js');\nvar YAMLSeq = require('../nodes/YAMLSeq.js');\nvar resolveEnd = require('./resolve-end.js');\nvar resolveProps = require('./resolve-props.js');\nvar utilContainsNewline = require('./util-contains-newline.js');\nvar utilMapIncludes = require('./util-map-includes.js');\n\nconst blockMsg = 'Block collections are not allowed within flow collections';\nconst isBlock = (token) => token && (token.type === 'block-map' || token.type === 'block-seq');\nfunction resolveFlowCollection({ composeNode, composeEmptyNode }, ctx, fc, onError, tag) {\n    const isMap = fc.start.source === '{';\n    const fcName = isMap ? 'flow map' : 'flow sequence';\n    const NodeClass = (tag?.nodeClass ?? (isMap ? YAMLMap.YAMLMap : YAMLSeq.YAMLSeq));\n    const coll = new NodeClass(ctx.schema);\n    coll.flow = true;\n    const atRoot = ctx.atRoot;\n    if (atRoot)\n        ctx.atRoot = false;\n    if (ctx.atKey)\n        ctx.atKey = false;\n    let offset = fc.offset + fc.start.source.length;\n    for (let i = 0; i < fc.items.length; ++i) {\n        const collItem = fc.items[i];\n        const { start, key, sep, value } = collItem;\n        const props = resolveProps.resolveProps(start, {\n            flow: fcName,\n            indicator: 'explicit-key-ind',\n            next: key ?? sep?.[0],\n            offset,\n            onError,\n            parentIndent: fc.indent,\n            startOnNewline: false\n        });\n        if (!props.found) {\n            if (!props.anchor && !props.tag && !sep && !value) {\n                if (i === 0 && props.comma)\n                    onError(props.comma, 'UNEXPECTED_TOKEN', `Unexpected , in ${fcName}`);\n                else if (i < fc.items.length - 1)\n                    onError(props.start, 'UNEXPECTED_TOKEN', `Unexpected empty item in ${fcName}`);\n                if (props.comment) {\n                    if (coll.comment)\n                        coll.comment += '\\n' + props.comment;\n                    else\n                        coll.comment = props.comment;\n                }\n                offset = props.end;\n                continue;\n            }\n            if (!isMap && ctx.options.strict && utilContainsNewline.containsNewline(key))\n                onError(key, // checked by containsNewline()\n                'MULTILINE_IMPLICIT_KEY', 'Implicit keys of flow sequence pairs need to be on a single line');\n        }\n        if (i === 0) {\n            if (props.comma)\n                onError(props.comma, 'UNEXPECTED_TOKEN', `Unexpected , in ${fcName}`);\n        }\n        else {\n            if (!props.comma)\n                onError(props.start, 'MISSING_CHAR', `Missing , between ${fcName} items`);\n            if (props.comment) {\n                let prevItemComment = '';\n                loop: for (const st of start) {\n                    switch (st.type) {\n                        case 'comma':\n                        case 'space':\n                            break;\n                        case 'comment':\n                            prevItemComment = st.source.substring(1);\n                            break loop;\n                        default:\n                            break loop;\n                    }\n                }\n                if (prevItemComment) {\n                    let prev = coll.items[coll.items.length - 1];\n                    if (identity.isPair(prev))\n                        prev = prev.value ?? prev.key;\n                    if (prev.comment)\n                        prev.comment += '\\n' + prevItemComment;\n                    else\n                        prev.comment = prevItemComment;\n                    props.comment = props.comment.substring(prevItemComment.length + 1);\n                }\n            }\n        }\n        if (!isMap && !sep && !props.found) {\n            // item is a value in a seq\n            //  key & sep are empty, start does not include ? or :\n            const valueNode = value\n                ? composeNode(ctx, value, props, onError)\n                : composeEmptyNode(ctx, props.end, sep, null, props, onError);\n            coll.items.push(valueNode);\n            offset = valueNode.range[2];\n            if (isBlock(value))\n                onError(valueNode.range, 'BLOCK_IN_FLOW', blockMsg);\n        }\n        else {\n            // item is a key+value pair\n            // key value\n            ctx.atKey = true;\n            const keyStart = props.end;\n            const keyNode = key\n                ? composeNode(ctx, key, props, onError)\n                : composeEmptyNode(ctx, keyStart, start, null, props, onError);\n            if (isBlock(key))\n                onError(keyNode.range, 'BLOCK_IN_FLOW', blockMsg);\n            ctx.atKey = false;\n            // value properties\n            const valueProps = resolveProps.resolveProps(sep ?? [], {\n                flow: fcName,\n                indicator: 'map-value-ind',\n                next: value,\n                offset: keyNode.range[2],\n                onError,\n                parentIndent: fc.indent,\n                startOnNewline: false\n            });\n            if (valueProps.found) {\n                if (!isMap && !props.found && ctx.options.strict) {\n                    if (sep)\n                        for (const st of sep) {\n                            if (st === valueProps.found)\n                                break;\n                            if (st.type === 'newline') {\n                                onError(st, 'MULTILINE_IMPLICIT_KEY', 'Implicit keys of flow sequence pairs need to be on a single line');\n                                break;\n                            }\n                        }\n                    if (props.start < valueProps.found.offset - 1024)\n                        onError(valueProps.found, 'KEY_OVER_1024_CHARS', 'The : indicator must be at most 1024 chars after the start of an implicit flow sequence key');\n                }\n            }\n            else if (value) {\n                if ('source' in value && value.source && value.source[0] === ':')\n                    onError(value, 'MISSING_CHAR', `Missing space after : in ${fcName}`);\n                else\n                    onError(valueProps.start, 'MISSING_CHAR', `Missing , or : between ${fcName} items`);\n            }\n            // value value\n            const valueNode = value\n                ? composeNode(ctx, value, valueProps, onError)\n                : valueProps.found\n                    ? composeEmptyNode(ctx, valueProps.end, sep, null, valueProps, onError)\n                    : null;\n            if (valueNode) {\n                if (isBlock(value))\n                    onError(valueNode.range, 'BLOCK_IN_FLOW', blockMsg);\n            }\n            else if (valueProps.comment) {\n                if (keyNode.comment)\n                    keyNode.comment += '\\n' + valueProps.comment;\n                else\n                    keyNode.comment = valueProps.comment;\n            }\n            const pair = new Pair.Pair(keyNode, valueNode);\n            if (ctx.options.keepSourceTokens)\n                pair.srcToken = collItem;\n            if (isMap) {\n                const map = coll;\n                if (utilMapIncludes.mapIncludes(ctx, map.items, keyNode))\n                    onError(keyStart, 'DUPLICATE_KEY', 'Map keys must be unique');\n                map.items.push(pair);\n            }\n            else {\n                const map = new YAMLMap.YAMLMap(ctx.schema);\n                map.flow = true;\n                map.items.push(pair);\n                const endRange = (valueNode ?? keyNode).range;\n                map.range = [keyNode.range[0], endRange[1], endRange[2]];\n                coll.items.push(map);\n            }\n            offset = valueNode ? valueNode.range[2] : valueProps.end;\n        }\n    }\n    const expectedEnd = isMap ? '}' : ']';\n    const [ce, ...ee] = fc.end;\n    let cePos = offset;\n    if (ce && ce.source === expectedEnd)\n        cePos = ce.offset + ce.source.length;\n    else {\n        const name = fcName[0].toUpperCase() + fcName.substring(1);\n        const msg = atRoot\n            ? `${name} must end with a ${expectedEnd}`\n            : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;\n        onError(offset, atRoot ? 'MISSING_CHAR' : 'BAD_INDENT', msg);\n        if (ce && ce.source.length !== 1)\n            ee.unshift(ce);\n    }\n    if (ee.length > 0) {\n        const end = resolveEnd.resolveEnd(ee, cePos, ctx.options.strict, onError);\n        if (end.comment) {\n            if (coll.comment)\n                coll.comment += '\\n' + end.comment;\n            else\n                coll.comment = end.comment;\n        }\n        coll.range = [fc.offset, cePos, end.offset];\n    }\n    else {\n        coll.range = [fc.offset, cePos, cePos];\n    }\n    return coll;\n}\n\nexports.resolveFlowCollection = resolveFlowCollection;\n","'use strict';\n\nfunction resolveEnd(end, offset, reqSpace, onError) {\n    let comment = '';\n    if (end) {\n        let hasSpace = false;\n        let sep = '';\n        for (const token of end) {\n            const { source, type } = token;\n            switch (type) {\n                case 'space':\n                    hasSpace = true;\n                    break;\n                case 'comment': {\n                    if (reqSpace && !hasSpace)\n                        onError(token, 'MISSING_CHAR', 'Comments must be separated from other tokens by white space characters');\n                    const cb = source.substring(1) || ' ';\n                    if (!comment)\n                        comment = cb;\n                    else\n                        comment += sep + cb;\n                    sep = '';\n                    break;\n                }\n                case 'newline':\n                    if (comment)\n                        sep += source;\n                    hasSpace = true;\n                    break;\n                default:\n                    onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${type} at node end`);\n            }\n            offset += source.length;\n        }\n    }\n    return { comment, offset };\n}\n\nexports.resolveEnd = resolveEnd;\n","'use strict';\n\nvar identity = require('../nodes/identity.js');\nvar Scalar = require('../nodes/Scalar.js');\nvar resolveBlockScalar = require('./resolve-block-scalar.js');\nvar resolveFlowScalar = require('./resolve-flow-scalar.js');\n\nfunction composeScalar(ctx, token, tagToken, onError) {\n    const { value, type, comment, range } = token.type === 'block-scalar'\n        ? resolveBlockScalar.resolveBlockScalar(ctx, token, onError)\n        : resolveFlowScalar.resolveFlowScalar(token, ctx.options.strict, onError);\n    const tagName = tagToken\n        ? ctx.directives.tagName(tagToken.source, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg))\n        : null;\n    let tag;\n    if (ctx.options.stringKeys && ctx.atKey) {\n        tag = ctx.schema[identity.SCALAR];\n    }\n    else if (tagName)\n        tag = findScalarTagByName(ctx.schema, value, tagName, tagToken, onError);\n    else if (token.type === 'scalar')\n        tag = findScalarTagByTest(ctx, value, token, onError);\n    else\n        tag = ctx.schema[identity.SCALAR];\n    let scalar;\n    try {\n        const res = tag.resolve(value, msg => onError(tagToken ?? token, 'TAG_RESOLVE_FAILED', msg), ctx.options);\n        scalar = identity.isScalar(res) ? res : new Scalar.Scalar(res);\n    }\n    catch (error) {\n        const msg = error instanceof Error ? error.message : String(error);\n        onError(tagToken ?? token, 'TAG_RESOLVE_FAILED', msg);\n        scalar = new Scalar.Scalar(value);\n    }\n    scalar.range = range;\n    scalar.source = value;\n    if (type)\n        scalar.type = type;\n    if (tagName)\n        scalar.tag = tagName;\n    if (tag.format)\n        scalar.format = tag.format;\n    if (comment)\n        scalar.comment = comment;\n    return scalar;\n}\nfunction findScalarTagByName(schema, value, tagName, tagToken, onError) {\n    if (tagName === '!')\n        return schema[identity.SCALAR]; // non-specific tag\n    const matchWithTest = [];\n    for (const tag of schema.tags) {\n        if (!tag.collection && tag.tag === tagName) {\n            if (tag.default && tag.test)\n                matchWithTest.push(tag);\n            else\n                return tag;\n        }\n    }\n    for (const tag of matchWithTest)\n        if (tag.test?.test(value))\n            return tag;\n    const kt = schema.knownTags[tagName];\n    if (kt && !kt.collection) {\n        // Ensure that the known tag is available for stringifying,\n        // but does not get used by default.\n        schema.tags.push(Object.assign({}, kt, { default: false, test: undefined }));\n        return kt;\n    }\n    onError(tagToken, 'TAG_RESOLVE_FAILED', `Unresolved tag: ${tagName}`, tagName !== 'tag:yaml.org,2002:str');\n    return schema[identity.SCALAR];\n}\nfunction findScalarTagByTest({ atKey, directives, schema }, value, token, onError) {\n    const tag = schema.tags.find(tag => (tag.default === true || (atKey && tag.default === 'key')) &&\n        tag.test?.test(value)) || schema[identity.SCALAR];\n    if (schema.compat) {\n        const compat = schema.compat.find(tag => tag.default && tag.test?.test(value)) ??\n            schema[identity.SCALAR];\n        if (tag.tag !== compat.tag) {\n            const ts = directives.tagString(tag.tag);\n            const cs = directives.tagString(compat.tag);\n            const msg = `Value may be parsed as either ${ts} or ${cs}`;\n            onError(token, 'TAG_RESOLVE_FAILED', msg, true);\n        }\n    }\n    return tag;\n}\n\nexports.composeScalar = composeScalar;\n","'use strict';\n\nvar Scalar = require('../nodes/Scalar.js');\n\nfunction resolveBlockScalar(ctx, scalar, onError) {\n    const start = scalar.offset;\n    const header = parseBlockScalarHeader(scalar, ctx.options.strict, onError);\n    if (!header)\n        return { value: '', type: null, comment: '', range: [start, start, start] };\n    const type = header.mode === '>' ? Scalar.Scalar.BLOCK_FOLDED : Scalar.Scalar.BLOCK_LITERAL;\n    const lines = scalar.source ? splitLines(scalar.source) : [];\n    // determine the end of content & start of chomping\n    let chompStart = lines.length;\n    for (let i = lines.length - 1; i >= 0; --i) {\n        const content = lines[i][1];\n        if (content === '' || content === '\\r')\n            chompStart = i;\n        else\n            break;\n    }\n    // shortcut for empty contents\n    if (chompStart === 0) {\n        const value = header.chomp === '+' && lines.length > 0\n            ? '\\n'.repeat(Math.max(1, lines.length - 1))\n            : '';\n        let end = start + header.length;\n        if (scalar.source)\n            end += scalar.source.length;\n        return { value, type, comment: header.comment, range: [start, end, end] };\n    }\n    // find the indentation level to trim from start\n    let trimIndent = scalar.indent + header.indent;\n    let offset = scalar.offset + header.length;\n    let contentStart = 0;\n    for (let i = 0; i < chompStart; ++i) {\n        const [indent, content] = lines[i];\n        if (content === '' || content === '\\r') {\n            if (header.indent === 0 && indent.length > trimIndent)\n                trimIndent = indent.length;\n        }\n        else {\n            if (indent.length < trimIndent) {\n                const message = 'Block scalars with more-indented leading empty lines must use an explicit indentation indicator';\n                onError(offset + indent.length, 'MISSING_CHAR', message);\n            }\n            if (header.indent === 0)\n                trimIndent = indent.length;\n            contentStart = i;\n            if (trimIndent === 0 && !ctx.atRoot) {\n                const message = 'Block scalar values in collections must be indented';\n                onError(offset, 'BAD_INDENT', message);\n            }\n            break;\n        }\n        offset += indent.length + content.length + 1;\n    }\n    // include trailing more-indented empty lines in content\n    for (let i = lines.length - 1; i >= chompStart; --i) {\n        if (lines[i][0].length > trimIndent)\n            chompStart = i + 1;\n    }\n    let value = '';\n    let sep = '';\n    let prevMoreIndented = false;\n    // leading whitespace is kept intact\n    for (let i = 0; i < contentStart; ++i)\n        value += lines[i][0].slice(trimIndent) + '\\n';\n    for (let i = contentStart; i < chompStart; ++i) {\n        let [indent, content] = lines[i];\n        offset += indent.length + content.length + 1;\n        const crlf = content[content.length - 1] === '\\r';\n        if (crlf)\n            content = content.slice(0, -1);\n        /* istanbul ignore if already caught in lexer */\n        if (content && indent.length < trimIndent) {\n            const src = header.indent\n                ? 'explicit indentation indicator'\n                : 'first line';\n            const message = `Block scalar lines must not be less indented than their ${src}`;\n            onError(offset - content.length - (crlf ? 2 : 1), 'BAD_INDENT', message);\n            indent = '';\n        }\n        if (type === Scalar.Scalar.BLOCK_LITERAL) {\n            value += sep + indent.slice(trimIndent) + content;\n            sep = '\\n';\n        }\n        else if (indent.length > trimIndent || content[0] === '\\t') {\n            // more-indented content within a folded block\n            if (sep === ' ')\n                sep = '\\n';\n            else if (!prevMoreIndented && sep === '\\n')\n                sep = '\\n\\n';\n            value += sep + indent.slice(trimIndent) + content;\n            sep = '\\n';\n            prevMoreIndented = true;\n        }\n        else if (content === '') {\n            // empty line\n            if (sep === '\\n')\n                value += '\\n';\n            else\n                sep = '\\n';\n        }\n        else {\n            value += sep + content;\n            sep = ' ';\n            prevMoreIndented = false;\n        }\n    }\n    switch (header.chomp) {\n        case '-':\n            break;\n        case '+':\n            for (let i = chompStart; i < lines.length; ++i)\n                value += '\\n' + lines[i][0].slice(trimIndent);\n            if (value[value.length - 1] !== '\\n')\n                value += '\\n';\n            break;\n        default:\n            value += '\\n';\n    }\n    const end = start + header.length + scalar.source.length;\n    return { value, type, comment: header.comment, range: [start, end, end] };\n}\nfunction parseBlockScalarHeader({ offset, props }, strict, onError) {\n    /* istanbul ignore if should not happen */\n    if (props[0].type !== 'block-scalar-header') {\n        onError(props[0], 'IMPOSSIBLE', 'Block scalar header not found');\n        return null;\n    }\n    const { source } = props[0];\n    const mode = source[0];\n    let indent = 0;\n    let chomp = '';\n    let error = -1;\n    for (let i = 1; i < source.length; ++i) {\n        const ch = source[i];\n        if (!chomp && (ch === '-' || ch === '+'))\n            chomp = ch;\n        else {\n            const n = Number(ch);\n            if (!indent && n)\n                indent = n;\n            else if (error === -1)\n                error = offset + i;\n        }\n    }\n    if (error !== -1)\n        onError(error, 'UNEXPECTED_TOKEN', `Block scalar header includes extra characters: ${source}`);\n    let hasSpace = false;\n    let comment = '';\n    let length = source.length;\n    for (let i = 1; i < props.length; ++i) {\n        const token = props[i];\n        switch (token.type) {\n            case 'space':\n                hasSpace = true;\n            // fallthrough\n            case 'newline':\n                length += token.source.length;\n                break;\n            case 'comment':\n                if (strict && !hasSpace) {\n                    const message = 'Comments must be separated from other tokens by white space characters';\n                    onError(token, 'MISSING_CHAR', message);\n                }\n                length += token.source.length;\n                comment = token.source.substring(1);\n                break;\n            case 'error':\n                onError(token, 'UNEXPECTED_TOKEN', token.message);\n                length += token.source.length;\n                break;\n            /* istanbul ignore next should not happen */\n            default: {\n                const message = `Unexpected token in block scalar header: ${token.type}`;\n                onError(token, 'UNEXPECTED_TOKEN', message);\n                const ts = token.source;\n                if (ts && typeof ts === 'string')\n                    length += ts.length;\n            }\n        }\n    }\n    return { mode, indent, chomp, comment, length };\n}\n/** @returns Array of lines split up as `[indent, content]` */\nfunction splitLines(source) {\n    const split = source.split(/\\n( *)/);\n    const first = split[0];\n    const m = first.match(/^( *)/);\n    const line0 = m?.[1]\n        ? [m[1], first.slice(m[1].length)]\n        : ['', first];\n    const lines = [line0];\n    for (let i = 1; i < split.length; i += 2)\n        lines.push([split[i], split[i + 1]]);\n    return lines;\n}\n\nexports.resolveBlockScalar = resolveBlockScalar;\n","'use strict';\n\nvar Scalar = require('../nodes/Scalar.js');\nvar resolveEnd = require('./resolve-end.js');\n\nfunction resolveFlowScalar(scalar, strict, onError) {\n    const { offset, type, source, end } = scalar;\n    let _type;\n    let value;\n    const _onError = (rel, code, msg) => onError(offset + rel, code, msg);\n    switch (type) {\n        case 'scalar':\n            _type = Scalar.Scalar.PLAIN;\n            value = plainValue(source, _onError);\n            break;\n        case 'single-quoted-scalar':\n            _type = Scalar.Scalar.QUOTE_SINGLE;\n            value = singleQuotedValue(source, _onError);\n            break;\n        case 'double-quoted-scalar':\n            _type = Scalar.Scalar.QUOTE_DOUBLE;\n            value = doubleQuotedValue(source, _onError);\n            break;\n        /* istanbul ignore next should not happen */\n        default:\n            onError(scalar, 'UNEXPECTED_TOKEN', `Expected a flow scalar value, but found: ${type}`);\n            return {\n                value: '',\n                type: null,\n                comment: '',\n                range: [offset, offset + source.length, offset + source.length]\n            };\n    }\n    const valueEnd = offset + source.length;\n    const re = resolveEnd.resolveEnd(end, valueEnd, strict, onError);\n    return {\n        value,\n        type: _type,\n        comment: re.comment,\n        range: [offset, valueEnd, re.offset]\n    };\n}\nfunction plainValue(source, onError) {\n    let badChar = '';\n    switch (source[0]) {\n        /* istanbul ignore next should not happen */\n        case '\\t':\n            badChar = 'a tab character';\n            break;\n        case ',':\n            badChar = 'flow indicator character ,';\n            break;\n        case '%':\n            badChar = 'directive indicator character %';\n            break;\n        case '|':\n        case '>': {\n            badChar = `block scalar indicator ${source[0]}`;\n            break;\n        }\n        case '@':\n        case '`': {\n            badChar = `reserved character ${source[0]}`;\n            break;\n        }\n    }\n    if (badChar)\n        onError(0, 'BAD_SCALAR_START', `Plain value cannot start with ${badChar}`);\n    return foldLines(source);\n}\nfunction singleQuotedValue(source, onError) {\n    if (source[source.length - 1] !== \"'\" || source.length === 1)\n        onError(source.length, 'MISSING_CHAR', \"Missing closing 'quote\");\n    return foldLines(source.slice(1, -1)).replace(/''/g, \"'\");\n}\nfunction foldLines(source) {\n    /**\n     * The negative lookbehind here and in the `re` RegExp is to\n     * prevent causing a polynomial search time in certain cases.\n     *\n     * The try-catch is for Safari, which doesn't support this yet:\n     * https://caniuse.com/js-regexp-lookbehind\n     */\n    let first, line;\n    try {\n        first = new RegExp('(.*?)(?<![ \\t])[ \\t]*\\r?\\n', 'sy');\n        line = new RegExp('[ \\t]*(.*?)(?:(?<![ \\t])[ \\t]*)?\\r?\\n', 'sy');\n    }\n    catch {\n        first = /(.*?)[ \\t]*\\r?\\n/sy;\n        line = /[ \\t]*(.*?)[ \\t]*\\r?\\n/sy;\n    }\n    let match = first.exec(source);\n    if (!match)\n        return source;\n    let res = match[1];\n    let sep = ' ';\n    let pos = first.lastIndex;\n    line.lastIndex = pos;\n    while ((match = line.exec(source))) {\n        if (match[1] === '') {\n            if (sep === '\\n')\n                res += sep;\n            else\n                sep = '\\n';\n        }\n        else {\n            res += sep + match[1];\n            sep = ' ';\n        }\n        pos = line.lastIndex;\n    }\n    const last = /[ \\t]*(.*)/sy;\n    last.lastIndex = pos;\n    match = last.exec(source);\n    return res + sep + (match?.[1] ?? '');\n}\nfunction doubleQuotedValue(source, onError) {\n    let res = '';\n    for (let i = 1; i < source.length - 1; ++i) {\n        const ch = source[i];\n        if (ch === '\\r' && source[i + 1] === '\\n')\n            continue;\n        if (ch === '\\n') {\n            const { fold, offset } = foldNewline(source, i);\n            res += fold;\n            i = offset;\n        }\n        else if (ch === '\\\\') {\n            let next = source[++i];\n            const cc = escapeCodes[next];\n            if (cc)\n                res += cc;\n            else if (next === '\\n') {\n                // skip escaped newlines, but still trim the following line\n                next = source[i + 1];\n                while (next === ' ' || next === '\\t')\n                    next = source[++i + 1];\n            }\n            else if (next === '\\r' && source[i + 1] === '\\n') {\n                // skip escaped CRLF newlines, but still trim the following line\n                next = source[++i + 1];\n                while (next === ' ' || next === '\\t')\n                    next = source[++i + 1];\n            }\n            else if (next === 'x' || next === 'u' || next === 'U') {\n                const length = { x: 2, u: 4, U: 8 }[next];\n                res += parseCharCode(source, i + 1, length, onError);\n                i += length;\n            }\n            else {\n                const raw = source.substr(i - 1, 2);\n                onError(i - 1, 'BAD_DQ_ESCAPE', `Invalid escape sequence ${raw}`);\n                res += raw;\n            }\n        }\n        else if (ch === ' ' || ch === '\\t') {\n            // trim trailing whitespace\n            const wsStart = i;\n            let next = source[i + 1];\n            while (next === ' ' || next === '\\t')\n                next = source[++i + 1];\n            if (next !== '\\n' && !(next === '\\r' && source[i + 2] === '\\n'))\n                res += i > wsStart ? source.slice(wsStart, i + 1) : ch;\n        }\n        else {\n            res += ch;\n        }\n    }\n    if (source[source.length - 1] !== '\"' || source.length === 1)\n        onError(source.length, 'MISSING_CHAR', 'Missing closing \"quote');\n    return res;\n}\n/**\n * Fold a single newline into a space, multiple newlines to N - 1 newlines.\n * Presumes `source[offset] === '\\n'`\n */\nfunction foldNewline(source, offset) {\n    let fold = '';\n    let ch = source[offset + 1];\n    while (ch === ' ' || ch === '\\t' || ch === '\\n' || ch === '\\r') {\n        if (ch === '\\r' && source[offset + 2] !== '\\n')\n            break;\n        if (ch === '\\n')\n            fold += '\\n';\n        offset += 1;\n        ch = source[offset + 1];\n    }\n    if (!fold)\n        fold = ' ';\n    return { fold, offset };\n}\nconst escapeCodes = {\n    '0': '\\0', // null character\n    a: '\\x07', // bell character\n    b: '\\b', // backspace\n    e: '\\x1b', // escape character\n    f: '\\f', // form feed\n    n: '\\n', // line feed\n    r: '\\r', // carriage return\n    t: '\\t', // horizontal tab\n    v: '\\v', // vertical tab\n    N: '\\u0085', // Unicode next line\n    _: '\\u00a0', // Unicode non-breaking space\n    L: '\\u2028', // Unicode line separator\n    P: '\\u2029', // Unicode paragraph separator\n    ' ': ' ',\n    '\"': '\"',\n    '/': '/',\n    '\\\\': '\\\\',\n    '\\t': '\\t'\n};\nfunction parseCharCode(source, offset, length, onError) {\n    const cc = source.substr(offset, length);\n    const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);\n    const code = ok ? parseInt(cc, 16) : NaN;\n    if (isNaN(code)) {\n        const raw = source.substr(offset - 2, length + 2);\n        onError(offset - 2, 'BAD_DQ_ESCAPE', `Invalid escape sequence ${raw}`);\n        return raw;\n    }\n    return String.fromCodePoint(code);\n}\n\nexports.resolveFlowScalar = resolveFlowScalar;\n","'use strict';\n\nfunction emptyScalarPosition(offset, before, pos) {\n    if (before) {\n        pos ?? (pos = before.length);\n        for (let i = pos - 1; i >= 0; --i) {\n            let st = before[i];\n            switch (st.type) {\n                case 'space':\n                case 'comment':\n                case 'newline':\n                    offset -= st.source.length;\n                    continue;\n            }\n            // Technically, an empty scalar is immediately after the last non-empty\n            // node, but it's more useful to place it after any whitespace.\n            st = before[++i];\n            while (st?.type === 'space') {\n                offset += st.source.length;\n                st = before[++i];\n            }\n            break;\n        }\n    }\n    return offset;\n}\n\nexports.emptyScalarPosition = emptyScalarPosition;\n","'use strict';\n\nvar cstScalar = require('./cst-scalar.js');\nvar cstStringify = require('./cst-stringify.js');\nvar cstVisit = require('./cst-visit.js');\n\n/** The byte order mark */\nconst BOM = '\\u{FEFF}';\n/** Start of doc-mode */\nconst DOCUMENT = '\\x02'; // C0: Start of Text\n/** Unexpected end of flow-mode */\nconst FLOW_END = '\\x18'; // C0: Cancel\n/** Next token is a scalar value */\nconst SCALAR = '\\x1f'; // C0: Unit Separator\n/** @returns `true` if `token` is a flow or block collection */\nconst isCollection = (token) => !!token && 'items' in token;\n/** @returns `true` if `token` is a flow or block scalar; not an alias */\nconst isScalar = (token) => !!token &&\n    (token.type === 'scalar' ||\n        token.type === 'single-quoted-scalar' ||\n        token.type === 'double-quoted-scalar' ||\n        token.type === 'block-scalar');\n/* istanbul ignore next */\n/** Get a printable representation of a lexer token */\nfunction prettyToken(token) {\n    switch (token) {\n        case BOM:\n            return '<BOM>';\n        case DOCUMENT:\n            return '<DOC>';\n        case FLOW_END:\n            return '<FLOW_END>';\n        case SCALAR:\n            return '<SCALAR>';\n        default:\n            return JSON.stringify(token);\n    }\n}\n/** Identify the type of a lexer token. May return `null` for unknown tokens. */\nfunction tokenType(source) {\n    switch (source) {\n        case BOM:\n            return 'byte-order-mark';\n        case DOCUMENT:\n            return 'doc-mode';\n        case FLOW_END:\n            return 'flow-error-end';\n        case SCALAR:\n            return 'scalar';\n        case '---':\n            return 'doc-start';\n        case '...':\n            return 'doc-end';\n        case '':\n        case '\\n':\n        case '\\r\\n':\n            return 'newline';\n        case '-':\n            return 'seq-item-ind';\n        case '?':\n            return 'explicit-key-ind';\n        case ':':\n            return 'map-value-ind';\n        case '{':\n            return 'flow-map-start';\n        case '}':\n            return 'flow-map-end';\n        case '[':\n            return 'flow-seq-start';\n        case ']':\n            return 'flow-seq-end';\n        case ',':\n            return 'comma';\n    }\n    switch (source[0]) {\n        case ' ':\n        case '\\t':\n            return 'space';\n        case '#':\n            return 'comment';\n        case '%':\n            return 'directive-line';\n        case '*':\n            return 'alias';\n        case '&':\n            return 'anchor';\n        case '!':\n            return 'tag';\n        case \"'\":\n            return 'single-quoted-scalar';\n        case '\"':\n            return 'double-quoted-scalar';\n        case '|':\n        case '>':\n            return 'block-scalar-header';\n    }\n    return null;\n}\n\nexports.createScalarToken = cstScalar.createScalarToken;\nexports.resolveAsScalar = cstScalar.resolveAsScalar;\nexports.setScalarValue = cstScalar.setScalarValue;\nexports.stringify = cstStringify.stringify;\nexports.visit = cstVisit.visit;\nexports.BOM = BOM;\nexports.DOCUMENT = DOCUMENT;\nexports.FLOW_END = FLOW_END;\nexports.SCALAR = SCALAR;\nexports.isCollection = isCollection;\nexports.isScalar = isScalar;\nexports.prettyToken = prettyToken;\nexports.tokenType = tokenType;\n","'use strict';\n\nvar resolveBlockScalar = require('../compose/resolve-block-scalar.js');\nvar resolveFlowScalar = require('../compose/resolve-flow-scalar.js');\nvar errors = require('../errors.js');\nvar stringifyString = require('../stringify/stringifyString.js');\n\nfunction resolveAsScalar(token, strict = true, onError) {\n    if (token) {\n        const _onError = (pos, code, message) => {\n            const offset = typeof pos === 'number' ? pos : Array.isArray(pos) ? pos[0] : pos.offset;\n            if (onError)\n                onError(offset, code, message);\n            else\n                throw new errors.YAMLParseError([offset, offset + 1], code, message);\n        };\n        switch (token.type) {\n            case 'scalar':\n            case 'single-quoted-scalar':\n            case 'double-quoted-scalar':\n                return resolveFlowScalar.resolveFlowScalar(token, strict, _onError);\n            case 'block-scalar':\n                return resolveBlockScalar.resolveBlockScalar({ options: { strict } }, token, _onError);\n        }\n    }\n    return null;\n}\n/**\n * Create a new scalar token with `value`\n *\n * Values that represent an actual string but may be parsed as a different type should use a `type` other than `'PLAIN'`,\n * as this function does not support any schema operations and won't check for such conflicts.\n *\n * @param value The string representation of the value, which will have its content properly indented.\n * @param context.end Comments and whitespace after the end of the value, or after the block scalar header. If undefined, a newline will be added.\n * @param context.implicitKey Being within an implicit key may affect the resolved type of the token's value.\n * @param context.indent The indent level of the token.\n * @param context.inFlow Is this scalar within a flow collection? This may affect the resolved type of the token's value.\n * @param context.offset The offset position of the token.\n * @param context.type The preferred type of the scalar token. If undefined, the previous type of the `token` will be used, defaulting to `'PLAIN'`.\n */\nfunction createScalarToken(value, context) {\n    const { implicitKey = false, indent, inFlow = false, offset = -1, type = 'PLAIN' } = context;\n    const source = stringifyString.stringifyString({ type, value }, {\n        implicitKey,\n        indent: indent > 0 ? ' '.repeat(indent) : '',\n        inFlow,\n        options: { blockQuote: true, lineWidth: -1 }\n    });\n    const end = context.end ?? [\n        { type: 'newline', offset: -1, indent, source: '\\n' }\n    ];\n    switch (source[0]) {\n        case '|':\n        case '>': {\n            const he = source.indexOf('\\n');\n            const head = source.substring(0, he);\n            const body = source.substring(he + 1) + '\\n';\n            const props = [\n                { type: 'block-scalar-header', offset, indent, source: head }\n            ];\n            if (!addEndtoBlockProps(props, end))\n                props.push({ type: 'newline', offset: -1, indent, source: '\\n' });\n            return { type: 'block-scalar', offset, indent, props, source: body };\n        }\n        case '\"':\n            return { type: 'double-quoted-scalar', offset, indent, source, end };\n        case \"'\":\n            return { type: 'single-quoted-scalar', offset, indent, source, end };\n        default:\n            return { type: 'scalar', offset, indent, source, end };\n    }\n}\n/**\n * Set the value of `token` to the given string `value`, overwriting any previous contents and type that it may have.\n *\n * Best efforts are made to retain any comments previously associated with the `token`,\n * though all contents within a collection's `items` will be overwritten.\n *\n * Values that represent an actual string but may be parsed as a different type should use a `type` other than `'PLAIN'`,\n * as this function does not support any schema operations and won't check for such conflicts.\n *\n * @param token Any token. If it does not include an `indent` value, the value will be stringified as if it were an implicit key.\n * @param value The string representation of the value, which will have its content properly indented.\n * @param context.afterKey In most cases, values after a key should have an additional level of indentation.\n * @param context.implicitKey Being within an implicit key may affect the resolved type of the token's value.\n * @param context.inFlow Being within a flow collection may affect the resolved type of the token's value.\n * @param context.type The preferred type of the scalar token. If undefined, the previous type of the `token` will be used, defaulting to `'PLAIN'`.\n */\nfunction setScalarValue(token, value, context = {}) {\n    let { afterKey = false, implicitKey = false, inFlow = false, type } = context;\n    let indent = 'indent' in token ? token.indent : null;\n    if (afterKey && typeof indent === 'number')\n        indent += 2;\n    if (!type)\n        switch (token.type) {\n            case 'single-quoted-scalar':\n                type = 'QUOTE_SINGLE';\n                break;\n            case 'double-quoted-scalar':\n                type = 'QUOTE_DOUBLE';\n                break;\n            case 'block-scalar': {\n                const header = token.props[0];\n                if (header.type !== 'block-scalar-header')\n                    throw new Error('Invalid block scalar header');\n                type = header.source[0] === '>' ? 'BLOCK_FOLDED' : 'BLOCK_LITERAL';\n                break;\n            }\n            default:\n                type = 'PLAIN';\n        }\n    const source = stringifyString.stringifyString({ type, value }, {\n        implicitKey: implicitKey || indent === null,\n        indent: indent !== null && indent > 0 ? ' '.repeat(indent) : '',\n        inFlow,\n        options: { blockQuote: true, lineWidth: -1 }\n    });\n    switch (source[0]) {\n        case '|':\n        case '>':\n            setBlockScalarValue(token, source);\n            break;\n        case '\"':\n            setFlowScalarValue(token, source, 'double-quoted-scalar');\n            break;\n        case \"'\":\n            setFlowScalarValue(token, source, 'single-quoted-scalar');\n            break;\n        default:\n            setFlowScalarValue(token, source, 'scalar');\n    }\n}\nfunction setBlockScalarValue(token, source) {\n    const he = source.indexOf('\\n');\n    const head = source.substring(0, he);\n    const body = source.substring(he + 1) + '\\n';\n    if (token.type === 'block-scalar') {\n        const header = token.props[0];\n        if (header.type !== 'block-scalar-header')\n            throw new Error('Invalid block scalar header');\n        header.source = head;\n        token.source = body;\n    }\n    else {\n        const { offset } = token;\n        const indent = 'indent' in token ? token.indent : -1;\n        const props = [\n            { type: 'block-scalar-header', offset, indent, source: head }\n        ];\n        if (!addEndtoBlockProps(props, 'end' in token ? token.end : undefined))\n            props.push({ type: 'newline', offset: -1, indent, source: '\\n' });\n        for (const key of Object.keys(token))\n            if (key !== 'type' && key !== 'offset')\n                delete token[key];\n        Object.assign(token, { type: 'block-scalar', indent, props, source: body });\n    }\n}\n/** @returns `true` if last token is a newline */\nfunction addEndtoBlockProps(props, end) {\n    if (end)\n        for (const st of end)\n            switch (st.type) {\n                case 'space':\n                case 'comment':\n                    props.push(st);\n                    break;\n                case 'newline':\n                    props.push(st);\n                    return true;\n            }\n    return false;\n}\nfunction setFlowScalarValue(token, source, type) {\n    switch (token.type) {\n        case 'scalar':\n        case 'double-quoted-scalar':\n        case 'single-quoted-scalar':\n            token.type = type;\n            token.source = source;\n            break;\n        case 'block-scalar': {\n            const end = token.props.slice(1);\n            let oa = source.length;\n            if (token.props[0].type === 'block-scalar-header')\n                oa -= token.props[0].source.length;\n            for (const tok of end)\n                tok.offset += oa;\n            delete token.props;\n            Object.assign(token, { type, source, end });\n            break;\n        }\n        case 'block-map':\n        case 'block-seq': {\n            const offset = token.offset + source.length;\n            const nl = { type: 'newline', offset, indent: token.indent, source: '\\n' };\n            delete token.items;\n            Object.assign(token, { type, source, end: [nl] });\n            break;\n        }\n        default: {\n            const indent = 'indent' in token ? token.indent : -1;\n            const end = 'end' in token && Array.isArray(token.end)\n                ? token.end.filter(st => st.type === 'space' ||\n                    st.type === 'comment' ||\n                    st.type === 'newline')\n                : [];\n            for (const key of Object.keys(token))\n                if (key !== 'type' && key !== 'offset')\n                    delete token[key];\n            Object.assign(token, { type, indent, source, end });\n        }\n    }\n}\n\nexports.createScalarToken = createScalarToken;\nexports.resolveAsScalar = resolveAsScalar;\nexports.setScalarValue = setScalarValue;\n","'use strict';\n\n/**\n * Stringify a CST document, token, or collection item\n *\n * Fair warning: This applies no validation whatsoever, and\n * simply concatenates the sources in their logical order.\n */\nconst stringify = (cst) => 'type' in cst ? stringifyToken(cst) : stringifyItem(cst);\nfunction stringifyToken(token) {\n    switch (token.type) {\n        case 'block-scalar': {\n            let res = '';\n            for (const tok of token.props)\n                res += stringifyToken(tok);\n            return res + token.source;\n        }\n        case 'block-map':\n        case 'block-seq': {\n            let res = '';\n            for (const item of token.items)\n                res += stringifyItem(item);\n            return res;\n        }\n        case 'flow-collection': {\n            let res = token.start.source;\n            for (const item of token.items)\n                res += stringifyItem(item);\n            for (const st of token.end)\n                res += st.source;\n            return res;\n        }\n        case 'document': {\n            let res = stringifyItem(token);\n            if (token.end)\n                for (const st of token.end)\n                    res += st.source;\n            return res;\n        }\n        default: {\n            let res = token.source;\n            if ('end' in token && token.end)\n                for (const st of token.end)\n                    res += st.source;\n            return res;\n        }\n    }\n}\nfunction stringifyItem({ start, key, sep, value }) {\n    let res = '';\n    for (const st of start)\n        res += st.source;\n    if (key)\n        res += stringifyToken(key);\n    if (sep)\n        for (const st of sep)\n            res += st.source;\n    if (value)\n        res += stringifyToken(value);\n    return res;\n}\n\nexports.stringify = stringify;\n","'use strict';\n\nconst BREAK = Symbol('break visit');\nconst SKIP = Symbol('skip children');\nconst REMOVE = Symbol('remove item');\n/**\n * Apply a visitor to a CST document or item.\n *\n * Walks through the tree (depth-first) starting from the root, calling a\n * `visitor` function with two arguments when entering each item:\n *   - `item`: The current item, which included the following members:\n *     - `start: SourceToken[]`  Source tokens before the key or value,\n *       possibly including its anchor or tag.\n *     - `key?: Token | null`  Set for pair values. May then be `null`, if\n *       the key before the `:` separator is empty.\n *     - `sep?: SourceToken[]`  Source tokens between the key and the value,\n *       which should include the `:` map value indicator if `value` is set.\n *     - `value?: Token`  The value of a sequence item, or of a map pair.\n *   - `path`: The steps from the root to the current node, as an array of\n *     `['key' | 'value', number]` tuples.\n *\n * The return value of the visitor may be used to control the traversal:\n *   - `undefined` (default): Do nothing and continue\n *   - `visit.SKIP`: Do not visit the children of this token, continue with\n *      next sibling\n *   - `visit.BREAK`: Terminate traversal completely\n *   - `visit.REMOVE`: Remove the current item, then continue with the next one\n *   - `number`: Set the index of the next step. This is useful especially if\n *     the index of the current token has changed.\n *   - `function`: Define the next visitor for this item. After the original\n *     visitor is called on item entry, next visitors are called after handling\n *     a non-empty `key` and when exiting the item.\n */\nfunction visit(cst, visitor) {\n    if ('type' in cst && cst.type === 'document')\n        cst = { start: cst.start, value: cst.value };\n    _visit(Object.freeze([]), cst, visitor);\n}\n// Without the `as symbol` casts, TS declares these in the `visit`\n// namespace using `var`, but then complains about that because\n// `unique symbol` must be `const`.\n/** Terminate visit traversal completely */\nvisit.BREAK = BREAK;\n/** Do not visit the children of the current item */\nvisit.SKIP = SKIP;\n/** Remove the current item */\nvisit.REMOVE = REMOVE;\n/** Find the item at `path` from `cst` as the root */\nvisit.itemAtPath = (cst, path) => {\n    let item = cst;\n    for (const [field, index] of path) {\n        const tok = item?.[field];\n        if (tok && 'items' in tok) {\n            item = tok.items[index];\n        }\n        else\n            return undefined;\n    }\n    return item;\n};\n/**\n * Get the immediate parent collection of the item at `path` from `cst` as the root.\n *\n * Throws an error if the collection is not found, which should never happen if the item itself exists.\n */\nvisit.parentCollection = (cst, path) => {\n    const parent = visit.itemAtPath(cst, path.slice(0, -1));\n    const field = path[path.length - 1][0];\n    const coll = parent?.[field];\n    if (coll && 'items' in coll)\n        return coll;\n    throw new Error('Parent collection not found');\n};\nfunction _visit(path, item, visitor) {\n    let ctrl = visitor(item, path);\n    if (typeof ctrl === 'symbol')\n        return ctrl;\n    for (const field of ['key', 'value']) {\n        const token = item[field];\n        if (token && 'items' in token) {\n            for (let i = 0; i < token.items.length; ++i) {\n                const ci = _visit(Object.freeze(path.concat([[field, i]])), token.items[i], visitor);\n                if (typeof ci === 'number')\n                    i = ci - 1;\n                else if (ci === BREAK)\n                    return BREAK;\n                else if (ci === REMOVE) {\n                    token.items.splice(i, 1);\n                    i -= 1;\n                }\n            }\n            if (typeof ctrl === 'function' && field === 'key')\n                ctrl = ctrl(item, path);\n        }\n    }\n    return typeof ctrl === 'function' ? ctrl(item, path) : ctrl;\n}\n\nexports.visit = visit;\n","'use strict';\n\nvar cst = require('./cst.js');\n\n/*\nSTART -> stream\n\nstream\n  directive -> line-end -> stream\n  indent + line-end -> stream\n  [else] -> line-start\n\nline-end\n  comment -> line-end\n  newline -> .\n  input-end -> END\n\nline-start\n  doc-start -> doc\n  doc-end -> stream\n  [else] -> indent -> block-start\n\nblock-start\n  seq-item-start -> block-start\n  explicit-key-start -> block-start\n  map-value-start -> block-start\n  [else] -> doc\n\ndoc\n  line-end -> line-start\n  spaces -> doc\n  anchor -> doc\n  tag -> doc\n  flow-start -> flow -> doc\n  flow-end -> error -> doc\n  seq-item-start -> error -> doc\n  explicit-key-start -> error -> doc\n  map-value-start -> doc\n  alias -> doc\n  quote-start -> quoted-scalar -> doc\n  block-scalar-header -> line-end -> block-scalar(min) -> line-start\n  [else] -> plain-scalar(false, min) -> doc\n\nflow\n  line-end -> flow\n  spaces -> flow\n  anchor -> flow\n  tag -> flow\n  flow-start -> flow -> flow\n  flow-end -> .\n  seq-item-start -> error -> flow\n  explicit-key-start -> flow\n  map-value-start -> flow\n  alias -> flow\n  quote-start -> quoted-scalar -> flow\n  comma -> flow\n  [else] -> plain-scalar(true, 0) -> flow\n\nquoted-scalar\n  quote-end -> .\n  [else] -> quoted-scalar\n\nblock-scalar(min)\n  newline + peek(indent < min) -> .\n  [else] -> block-scalar(min)\n\nplain-scalar(is-flow, min)\n  scalar-end(is-flow) -> .\n  peek(newline + (indent < min)) -> .\n  [else] -> plain-scalar(min)\n*/\nfunction isEmpty(ch) {\n    switch (ch) {\n        case undefined:\n        case ' ':\n        case '\\n':\n        case '\\r':\n        case '\\t':\n            return true;\n        default:\n            return false;\n    }\n}\nconst hexDigits = new Set('0123456789ABCDEFabcdef');\nconst tagChars = new Set(\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()\");\nconst flowIndicatorChars = new Set(',[]{}');\nconst invalidAnchorChars = new Set(' ,[]{}\\n\\r\\t');\nconst isNotAnchorChar = (ch) => !ch || invalidAnchorChars.has(ch);\n/**\n * Splits an input string into lexical tokens, i.e. smaller strings that are\n * easily identifiable by `tokens.tokenType()`.\n *\n * Lexing starts always in a \"stream\" context. Incomplete input may be buffered\n * until a complete token can be emitted.\n *\n * In addition to slices of the original input, the following control characters\n * may also be emitted:\n *\n * - `\\x02` (Start of Text): A document starts with the next token\n * - `\\x18` (Cancel): Unexpected end of flow-mode (indicates an error)\n * - `\\x1f` (Unit Separator): Next token is a scalar value\n * - `\\u{FEFF}` (Byte order mark): Emitted separately outside documents\n */\nclass Lexer {\n    constructor() {\n        /**\n         * Flag indicating whether the end of the current buffer marks the end of\n         * all input\n         */\n        this.atEnd = false;\n        /**\n         * Explicit indent set in block scalar header, as an offset from the current\n         * minimum indent, so e.g. set to 1 from a header `|2+`. Set to -1 if not\n         * explicitly set.\n         */\n        this.blockScalarIndent = -1;\n        /**\n         * Block scalars that include a + (keep) chomping indicator in their header\n         * include trailing empty lines, which are otherwise excluded from the\n         * scalar's contents.\n         */\n        this.blockScalarKeep = false;\n        /** Current input */\n        this.buffer = '';\n        /**\n         * Flag noting whether the map value indicator : can immediately follow this\n         * node within a flow context.\n         */\n        this.flowKey = false;\n        /** Count of surrounding flow collection levels. */\n        this.flowLevel = 0;\n        /**\n         * Minimum level of indentation required for next lines to be parsed as a\n         * part of the current scalar value.\n         */\n        this.indentNext = 0;\n        /** Indentation level of the current line. */\n        this.indentValue = 0;\n        /** Position of the next \\n character. */\n        this.lineEndPos = null;\n        /** Stores the state of the lexer if reaching the end of incpomplete input */\n        this.next = null;\n        /** A pointer to `buffer`; the current position of the lexer. */\n        this.pos = 0;\n    }\n    /**\n     * Generate YAML tokens from the `source` string. If `incomplete`,\n     * a part of the last line may be left as a buffer for the next call.\n     *\n     * @returns A generator of lexical tokens\n     */\n    *lex(source, incomplete = false) {\n        if (source) {\n            if (typeof source !== 'string')\n                throw TypeError('source is not a string');\n            this.buffer = this.buffer ? this.buffer + source : source;\n            this.lineEndPos = null;\n        }\n        this.atEnd = !incomplete;\n        let next = this.next ?? 'stream';\n        while (next && (incomplete || this.hasChars(1)))\n            next = yield* this.parseNext(next);\n    }\n    atLineEnd() {\n        let i = this.pos;\n        let ch = this.buffer[i];\n        while (ch === ' ' || ch === '\\t')\n            ch = this.buffer[++i];\n        if (!ch || ch === '#' || ch === '\\n')\n            return true;\n        if (ch === '\\r')\n            return this.buffer[i + 1] === '\\n';\n        return false;\n    }\n    charAt(n) {\n        return this.buffer[this.pos + n];\n    }\n    continueScalar(offset) {\n        let ch = this.buffer[offset];\n        if (this.indentNext > 0) {\n            let indent = 0;\n            while (ch === ' ')\n                ch = this.buffer[++indent + offset];\n            if (ch === '\\r') {\n                const next = this.buffer[indent + offset + 1];\n                if (next === '\\n' || (!next && !this.atEnd))\n                    return offset + indent + 1;\n            }\n            return ch === '\\n' || indent >= this.indentNext || (!ch && !this.atEnd)\n                ? offset + indent\n                : -1;\n        }\n        if (ch === '-' || ch === '.') {\n            const dt = this.buffer.substr(offset, 3);\n            if ((dt === '---' || dt === '...') && isEmpty(this.buffer[offset + 3]))\n                return -1;\n        }\n        return offset;\n    }\n    getLine() {\n        let end = this.lineEndPos;\n        if (typeof end !== 'number' || (end !== -1 && end < this.pos)) {\n            end = this.buffer.indexOf('\\n', this.pos);\n            this.lineEndPos = end;\n        }\n        if (end === -1)\n            return this.atEnd ? this.buffer.substring(this.pos) : null;\n        if (this.buffer[end - 1] === '\\r')\n            end -= 1;\n        return this.buffer.substring(this.pos, end);\n    }\n    hasChars(n) {\n        return this.pos + n <= this.buffer.length;\n    }\n    setNext(state) {\n        this.buffer = this.buffer.substring(this.pos);\n        this.pos = 0;\n        this.lineEndPos = null;\n        this.next = state;\n        return null;\n    }\n    peek(n) {\n        return this.buffer.substr(this.pos, n);\n    }\n    *parseNext(next) {\n        switch (next) {\n            case 'stream':\n                return yield* this.parseStream();\n            case 'line-start':\n                return yield* this.parseLineStart();\n            case 'block-start':\n                return yield* this.parseBlockStart();\n            case 'doc':\n                return yield* this.parseDocument();\n            case 'flow':\n                return yield* this.parseFlowCollection();\n            case 'quoted-scalar':\n                return yield* this.parseQuotedScalar();\n            case 'block-scalar':\n                return yield* this.parseBlockScalar();\n            case 'plain-scalar':\n                return yield* this.parsePlainScalar();\n        }\n    }\n    *parseStream() {\n        let line = this.getLine();\n        if (line === null)\n            return this.setNext('stream');\n        if (line[0] === cst.BOM) {\n            yield* this.pushCount(1);\n            line = line.substring(1);\n        }\n        if (line[0] === '%') {\n            let dirEnd = line.length;\n            let cs = line.indexOf('#');\n            while (cs !== -1) {\n                const ch = line[cs - 1];\n                if (ch === ' ' || ch === '\\t') {\n                    dirEnd = cs - 1;\n                    break;\n                }\n                else {\n                    cs = line.indexOf('#', cs + 1);\n                }\n            }\n            while (true) {\n                const ch = line[dirEnd - 1];\n                if (ch === ' ' || ch === '\\t')\n                    dirEnd -= 1;\n                else\n                    break;\n            }\n            const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));\n            yield* this.pushCount(line.length - n); // possible comment\n            this.pushNewline();\n            return 'stream';\n        }\n        if (this.atLineEnd()) {\n            const sp = yield* this.pushSpaces(true);\n            yield* this.pushCount(line.length - sp);\n            yield* this.pushNewline();\n            return 'stream';\n        }\n        yield cst.DOCUMENT;\n        return yield* this.parseLineStart();\n    }\n    *parseLineStart() {\n        const ch = this.charAt(0);\n        if (!ch && !this.atEnd)\n            return this.setNext('line-start');\n        if (ch === '-' || ch === '.') {\n            if (!this.atEnd && !this.hasChars(4))\n                return this.setNext('line-start');\n            const s = this.peek(3);\n            if ((s === '---' || s === '...') && isEmpty(this.charAt(3))) {\n                yield* this.pushCount(3);\n                this.indentValue = 0;\n                this.indentNext = 0;\n                return s === '---' ? 'doc' : 'stream';\n            }\n        }\n        this.indentValue = yield* this.pushSpaces(false);\n        if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))\n            this.indentNext = this.indentValue;\n        return yield* this.parseBlockStart();\n    }\n    *parseBlockStart() {\n        const [ch0, ch1] = this.peek(2);\n        if (!ch1 && !this.atEnd)\n            return this.setNext('block-start');\n        if ((ch0 === '-' || ch0 === '?' || ch0 === ':') && isEmpty(ch1)) {\n            const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));\n            this.indentNext = this.indentValue + 1;\n            this.indentValue += n;\n            return yield* this.parseBlockStart();\n        }\n        return 'doc';\n    }\n    *parseDocument() {\n        yield* this.pushSpaces(true);\n        const line = this.getLine();\n        if (line === null)\n            return this.setNext('doc');\n        let n = yield* this.pushIndicators();\n        switch (line[n]) {\n            case '#':\n                yield* this.pushCount(line.length - n);\n            // fallthrough\n            case undefined:\n                yield* this.pushNewline();\n                return yield* this.parseLineStart();\n            case '{':\n            case '[':\n                yield* this.pushCount(1);\n                this.flowKey = false;\n                this.flowLevel = 1;\n                return 'flow';\n            case '}':\n            case ']':\n                // this is an error\n                yield* this.pushCount(1);\n                return 'doc';\n            case '*':\n                yield* this.pushUntil(isNotAnchorChar);\n                return 'doc';\n            case '\"':\n            case \"'\":\n                return yield* this.parseQuotedScalar();\n            case '|':\n            case '>':\n                n += yield* this.parseBlockScalarHeader();\n                n += yield* this.pushSpaces(true);\n                yield* this.pushCount(line.length - n);\n                yield* this.pushNewline();\n                return yield* this.parseBlockScalar();\n            default:\n                return yield* this.parsePlainScalar();\n        }\n    }\n    *parseFlowCollection() {\n        let nl, sp;\n        let indent = -1;\n        do {\n            nl = yield* this.pushNewline();\n            if (nl > 0) {\n                sp = yield* this.pushSpaces(false);\n                this.indentValue = indent = sp;\n            }\n            else {\n                sp = 0;\n            }\n            sp += yield* this.pushSpaces(true);\n        } while (nl + sp > 0);\n        const line = this.getLine();\n        if (line === null)\n            return this.setNext('flow');\n        if ((indent !== -1 && indent < this.indentNext && line[0] !== '#') ||\n            (indent === 0 &&\n                (line.startsWith('---') || line.startsWith('...')) &&\n                isEmpty(line[3]))) {\n            // Allowing for the terminal ] or } at the same (rather than greater)\n            // indent level as the initial [ or { is technically invalid, but\n            // failing here would be surprising to users.\n            const atFlowEndMarker = indent === this.indentNext - 1 &&\n                this.flowLevel === 1 &&\n                (line[0] === ']' || line[0] === '}');\n            if (!atFlowEndMarker) {\n                // this is an error\n                this.flowLevel = 0;\n                yield cst.FLOW_END;\n                return yield* this.parseLineStart();\n            }\n        }\n        let n = 0;\n        while (line[n] === ',') {\n            n += yield* this.pushCount(1);\n            n += yield* this.pushSpaces(true);\n            this.flowKey = false;\n        }\n        n += yield* this.pushIndicators();\n        switch (line[n]) {\n            case undefined:\n                return 'flow';\n            case '#':\n                yield* this.pushCount(line.length - n);\n                return 'flow';\n            case '{':\n            case '[':\n                yield* this.pushCount(1);\n                this.flowKey = false;\n                this.flowLevel += 1;\n                return 'flow';\n            case '}':\n            case ']':\n                yield* this.pushCount(1);\n                this.flowKey = true;\n                this.flowLevel -= 1;\n                return this.flowLevel ? 'flow' : 'doc';\n            case '*':\n                yield* this.pushUntil(isNotAnchorChar);\n                return 'flow';\n            case '\"':\n            case \"'\":\n                this.flowKey = true;\n                return yield* this.parseQuotedScalar();\n            case ':': {\n                const next = this.charAt(1);\n                if (this.flowKey || isEmpty(next) || next === ',') {\n                    this.flowKey = false;\n                    yield* this.pushCount(1);\n                    yield* this.pushSpaces(true);\n                    return 'flow';\n                }\n            }\n            // fallthrough\n            default:\n                this.flowKey = false;\n                return yield* this.parsePlainScalar();\n        }\n    }\n    *parseQuotedScalar() {\n        const quote = this.charAt(0);\n        let end = this.buffer.indexOf(quote, this.pos + 1);\n        if (quote === \"'\") {\n            while (end !== -1 && this.buffer[end + 1] === \"'\")\n                end = this.buffer.indexOf(\"'\", end + 2);\n        }\n        else {\n            // double-quote\n            while (end !== -1) {\n                let n = 0;\n                while (this.buffer[end - 1 - n] === '\\\\')\n                    n += 1;\n                if (n % 2 === 0)\n                    break;\n                end = this.buffer.indexOf('\"', end + 1);\n            }\n        }\n        // Only looking for newlines within the quotes\n        const qb = this.buffer.substring(0, end);\n        let nl = qb.indexOf('\\n', this.pos);\n        if (nl !== -1) {\n            while (nl !== -1) {\n                const cs = this.continueScalar(nl + 1);\n                if (cs === -1)\n                    break;\n                nl = qb.indexOf('\\n', cs);\n            }\n            if (nl !== -1) {\n                // this is an error caused by an unexpected unindent\n                end = nl - (qb[nl - 1] === '\\r' ? 2 : 1);\n            }\n        }\n        if (end === -1) {\n            if (!this.atEnd)\n                return this.setNext('quoted-scalar');\n            end = this.buffer.length;\n        }\n        yield* this.pushToIndex(end + 1, false);\n        return this.flowLevel ? 'flow' : 'doc';\n    }\n    *parseBlockScalarHeader() {\n        this.blockScalarIndent = -1;\n        this.blockScalarKeep = false;\n        let i = this.pos;\n        while (true) {\n            const ch = this.buffer[++i];\n            if (ch === '+')\n                this.blockScalarKeep = true;\n            else if (ch > '0' && ch <= '9')\n                this.blockScalarIndent = Number(ch) - 1;\n            else if (ch !== '-')\n                break;\n        }\n        return yield* this.pushUntil(ch => isEmpty(ch) || ch === '#');\n    }\n    *parseBlockScalar() {\n        let nl = this.pos - 1; // may be -1 if this.pos === 0\n        let indent = 0;\n        let ch;\n        loop: for (let i = this.pos; (ch = this.buffer[i]); ++i) {\n            switch (ch) {\n                case ' ':\n                    indent += 1;\n                    break;\n                case '\\n':\n                    nl = i;\n                    indent = 0;\n                    break;\n                case '\\r': {\n                    const next = this.buffer[i + 1];\n                    if (!next && !this.atEnd)\n                        return this.setNext('block-scalar');\n                    if (next === '\\n')\n                        break;\n                } // fallthrough\n                default:\n                    break loop;\n            }\n        }\n        if (!ch && !this.atEnd)\n            return this.setNext('block-scalar');\n        if (indent >= this.indentNext) {\n            if (this.blockScalarIndent === -1)\n                this.indentNext = indent;\n            else {\n                this.indentNext =\n                    this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);\n            }\n            do {\n                const cs = this.continueScalar(nl + 1);\n                if (cs === -1)\n                    break;\n                nl = this.buffer.indexOf('\\n', cs);\n            } while (nl !== -1);\n            if (nl === -1) {\n                if (!this.atEnd)\n                    return this.setNext('block-scalar');\n                nl = this.buffer.length;\n            }\n        }\n        // Trailing insufficiently indented tabs are invalid.\n        // To catch that during parsing, we include them in the block scalar value.\n        let i = nl + 1;\n        ch = this.buffer[i];\n        while (ch === ' ')\n            ch = this.buffer[++i];\n        if (ch === '\\t') {\n            while (ch === '\\t' || ch === ' ' || ch === '\\r' || ch === '\\n')\n                ch = this.buffer[++i];\n            nl = i - 1;\n        }\n        else if (!this.blockScalarKeep) {\n            do {\n                let i = nl - 1;\n                let ch = this.buffer[i];\n                if (ch === '\\r')\n                    ch = this.buffer[--i];\n                const lastChar = i; // Drop the line if last char not more indented\n                while (ch === ' ')\n                    ch = this.buffer[--i];\n                if (ch === '\\n' && i >= this.pos && i + 1 + indent > lastChar)\n                    nl = i;\n                else\n                    break;\n            } while (true);\n        }\n        yield cst.SCALAR;\n        yield* this.pushToIndex(nl + 1, true);\n        return yield* this.parseLineStart();\n    }\n    *parsePlainScalar() {\n        const inFlow = this.flowLevel > 0;\n        let end = this.pos - 1;\n        let i = this.pos - 1;\n        let ch;\n        while ((ch = this.buffer[++i])) {\n            if (ch === ':') {\n                const next = this.buffer[i + 1];\n                if (isEmpty(next) || (inFlow && flowIndicatorChars.has(next)))\n                    break;\n                end = i;\n            }\n            else if (isEmpty(ch)) {\n                let next = this.buffer[i + 1];\n                if (ch === '\\r') {\n                    if (next === '\\n') {\n                        i += 1;\n                        ch = '\\n';\n                        next = this.buffer[i + 1];\n                    }\n                    else\n                        end = i;\n                }\n                if (next === '#' || (inFlow && flowIndicatorChars.has(next)))\n                    break;\n                if (ch === '\\n') {\n                    const cs = this.continueScalar(i + 1);\n                    if (cs === -1)\n                        break;\n                    i = Math.max(i, cs - 2); // to advance, but still account for ' #'\n                }\n            }\n            else {\n                if (inFlow && flowIndicatorChars.has(ch))\n                    break;\n                end = i;\n            }\n        }\n        if (!ch && !this.atEnd)\n            return this.setNext('plain-scalar');\n        yield cst.SCALAR;\n        yield* this.pushToIndex(end + 1, true);\n        return inFlow ? 'flow' : 'doc';\n    }\n    *pushCount(n) {\n        if (n > 0) {\n            yield this.buffer.substr(this.pos, n);\n            this.pos += n;\n            return n;\n        }\n        return 0;\n    }\n    *pushToIndex(i, allowEmpty) {\n        const s = this.buffer.slice(this.pos, i);\n        if (s) {\n            yield s;\n            this.pos += s.length;\n            return s.length;\n        }\n        else if (allowEmpty)\n            yield '';\n        return 0;\n    }\n    *pushIndicators() {\n        switch (this.charAt(0)) {\n            case '!':\n                return ((yield* this.pushTag()) +\n                    (yield* this.pushSpaces(true)) +\n                    (yield* this.pushIndicators()));\n            case '&':\n                return ((yield* this.pushUntil(isNotAnchorChar)) +\n                    (yield* this.pushSpaces(true)) +\n                    (yield* this.pushIndicators()));\n            case '-': // this is an error\n            case '?': // this is an error outside flow collections\n            case ':': {\n                const inFlow = this.flowLevel > 0;\n                const ch1 = this.charAt(1);\n                if (isEmpty(ch1) || (inFlow && flowIndicatorChars.has(ch1))) {\n                    if (!inFlow)\n                        this.indentNext = this.indentValue + 1;\n                    else if (this.flowKey)\n                        this.flowKey = false;\n                    return ((yield* this.pushCount(1)) +\n                        (yield* this.pushSpaces(true)) +\n                        (yield* this.pushIndicators()));\n                }\n            }\n        }\n        return 0;\n    }\n    *pushTag() {\n        if (this.charAt(1) === '<') {\n            let i = this.pos + 2;\n            let ch = this.buffer[i];\n            while (!isEmpty(ch) && ch !== '>')\n                ch = this.buffer[++i];\n            return yield* this.pushToIndex(ch === '>' ? i + 1 : i, false);\n        }\n        else {\n            let i = this.pos + 1;\n            let ch = this.buffer[i];\n            while (ch) {\n                if (tagChars.has(ch))\n                    ch = this.buffer[++i];\n                else if (ch === '%' &&\n                    hexDigits.has(this.buffer[i + 1]) &&\n                    hexDigits.has(this.buffer[i + 2])) {\n                    ch = this.buffer[(i += 3)];\n                }\n                else\n                    break;\n            }\n            return yield* this.pushToIndex(i, false);\n        }\n    }\n    *pushNewline() {\n        const ch = this.buffer[this.pos];\n        if (ch === '\\n')\n            return yield* this.pushCount(1);\n        else if (ch === '\\r' && this.charAt(1) === '\\n')\n            return yield* this.pushCount(2);\n        else\n            return 0;\n    }\n    *pushSpaces(allowTabs) {\n        let i = this.pos - 1;\n        let ch;\n        do {\n            ch = this.buffer[++i];\n        } while (ch === ' ' || (allowTabs && ch === '\\t'));\n        const n = i - this.pos;\n        if (n > 0) {\n            yield this.buffer.substr(this.pos, n);\n            this.pos = i;\n        }\n        return n;\n    }\n    *pushUntil(test) {\n        let i = this.pos;\n        let ch = this.buffer[i];\n        while (!test(ch))\n            ch = this.buffer[++i];\n        return yield* this.pushToIndex(i, false);\n    }\n}\n\nexports.Lexer = Lexer;\n","'use strict';\n\n/**\n * Tracks newlines during parsing in order to provide an efficient API for\n * determining the one-indexed `{ line, col }` position for any offset\n * within the input.\n */\nclass LineCounter {\n    constructor() {\n        this.lineStarts = [];\n        /**\n         * Should be called in ascending order. Otherwise, call\n         * `lineCounter.lineStarts.sort()` before calling `linePos()`.\n         */\n        this.addNewLine = (offset) => this.lineStarts.push(offset);\n        /**\n         * Performs a binary search and returns the 1-indexed { line, col }\n         * position of `offset`. If `line === 0`, `addNewLine` has never been\n         * called or `offset` is before the first known newline.\n         */\n        this.linePos = (offset) => {\n            let low = 0;\n            let high = this.lineStarts.length;\n            while (low < high) {\n                const mid = (low + high) >> 1; // Math.floor((low + high) / 2)\n                if (this.lineStarts[mid] < offset)\n                    low = mid + 1;\n                else\n                    high = mid;\n            }\n            if (this.lineStarts[low] === offset)\n                return { line: low + 1, col: 1 };\n            if (low === 0)\n                return { line: 0, col: offset };\n            const start = this.lineStarts[low - 1];\n            return { line: low, col: offset - start + 1 };\n        };\n    }\n}\n\nexports.LineCounter = LineCounter;\n","'use strict';\n\nvar node_process = require('process');\nvar cst = require('./cst.js');\nvar lexer = require('./lexer.js');\n\nfunction includesToken(list, type) {\n    for (let i = 0; i < list.length; ++i)\n        if (list[i].type === type)\n            return true;\n    return false;\n}\nfunction findNonEmptyIndex(list) {\n    for (let i = 0; i < list.length; ++i) {\n        switch (list[i].type) {\n            case 'space':\n            case 'comment':\n            case 'newline':\n                break;\n            default:\n                return i;\n        }\n    }\n    return -1;\n}\nfunction isFlowToken(token) {\n    switch (token?.type) {\n        case 'alias':\n        case 'scalar':\n        case 'single-quoted-scalar':\n        case 'double-quoted-scalar':\n        case 'flow-collection':\n            return true;\n        default:\n            return false;\n    }\n}\nfunction getPrevProps(parent) {\n    switch (parent.type) {\n        case 'document':\n            return parent.start;\n        case 'block-map': {\n            const it = parent.items[parent.items.length - 1];\n            return it.sep ?? it.start;\n        }\n        case 'block-seq':\n            return parent.items[parent.items.length - 1].start;\n        /* istanbul ignore next should not happen */\n        default:\n            return [];\n    }\n}\n/** Note: May modify input array */\nfunction getFirstKeyStartProps(prev) {\n    if (prev.length === 0)\n        return [];\n    let i = prev.length;\n    loop: while (--i >= 0) {\n        switch (prev[i].type) {\n            case 'doc-start':\n            case 'explicit-key-ind':\n            case 'map-value-ind':\n            case 'seq-item-ind':\n            case 'newline':\n                break loop;\n        }\n    }\n    while (prev[++i]?.type === 'space') {\n        /* loop */\n    }\n    return prev.splice(i, prev.length);\n}\nfunction fixFlowSeqItems(fc) {\n    if (fc.start.type === 'flow-seq-start') {\n        for (const it of fc.items) {\n            if (it.sep &&\n                !it.value &&\n                !includesToken(it.start, 'explicit-key-ind') &&\n                !includesToken(it.sep, 'map-value-ind')) {\n                if (it.key)\n                    it.value = it.key;\n                delete it.key;\n                if (isFlowToken(it.value)) {\n                    if (it.value.end)\n                        Array.prototype.push.apply(it.value.end, it.sep);\n                    else\n                        it.value.end = it.sep;\n                }\n                else\n                    Array.prototype.push.apply(it.start, it.sep);\n                delete it.sep;\n            }\n        }\n    }\n}\n/**\n * A YAML concrete syntax tree (CST) parser\n *\n * ```ts\n * const src: string = ...\n * for (const token of new Parser().parse(src)) {\n *   // token: Token\n * }\n * ```\n *\n * To use the parser with a user-provided lexer:\n *\n * ```ts\n * function* parse(source: string, lexer: Lexer) {\n *   const parser = new Parser()\n *   for (const lexeme of lexer.lex(source))\n *     yield* parser.next(lexeme)\n *   yield* parser.end()\n * }\n *\n * const src: string = ...\n * const lexer = new Lexer()\n * for (const token of parse(src, lexer)) {\n *   // token: Token\n * }\n * ```\n */\nclass Parser {\n    /**\n     * @param onNewLine - If defined, called separately with the start position of\n     *   each new line (in `parse()`, including the start of input).\n     */\n    constructor(onNewLine) {\n        /** If true, space and sequence indicators count as indentation */\n        this.atNewLine = true;\n        /** If true, next token is a scalar value */\n        this.atScalar = false;\n        /** Current indentation level */\n        this.indent = 0;\n        /** Current offset since the start of parsing */\n        this.offset = 0;\n        /** On the same line with a block map key */\n        this.onKeyLine = false;\n        /** Top indicates the node that's currently being built */\n        this.stack = [];\n        /** The source of the current token, set in parse() */\n        this.source = '';\n        /** The type of the current token, set in parse() */\n        this.type = '';\n        // Must be defined after `next()`\n        this.lexer = new lexer.Lexer();\n        this.onNewLine = onNewLine;\n    }\n    /**\n     * Parse `source` as a YAML stream.\n     * If `incomplete`, a part of the last line may be left as a buffer for the next call.\n     *\n     * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.\n     *\n     * @returns A generator of tokens representing each directive, document, and other structure.\n     */\n    *parse(source, incomplete = false) {\n        if (this.onNewLine && this.offset === 0)\n            this.onNewLine(0);\n        for (const lexeme of this.lexer.lex(source, incomplete))\n            yield* this.next(lexeme);\n        if (!incomplete)\n            yield* this.end();\n    }\n    /**\n     * Advance the parser by the `source` of one lexical token.\n     */\n    *next(source) {\n        this.source = source;\n        if (node_process.env.LOG_TOKENS)\n            console.log('|', cst.prettyToken(source));\n        if (this.atScalar) {\n            this.atScalar = false;\n            yield* this.step();\n            this.offset += source.length;\n            return;\n        }\n        const type = cst.tokenType(source);\n        if (!type) {\n            const message = `Not a YAML token: ${source}`;\n            yield* this.pop({ type: 'error', offset: this.offset, message, source });\n            this.offset += source.length;\n        }\n        else if (type === 'scalar') {\n            this.atNewLine = false;\n            this.atScalar = true;\n            this.type = 'scalar';\n        }\n        else {\n            this.type = type;\n            yield* this.step();\n            switch (type) {\n                case 'newline':\n                    this.atNewLine = true;\n                    this.indent = 0;\n                    if (this.onNewLine)\n                        this.onNewLine(this.offset + source.length);\n                    break;\n                case 'space':\n                    if (this.atNewLine && source[0] === ' ')\n                        this.indent += source.length;\n                    break;\n                case 'explicit-key-ind':\n                case 'map-value-ind':\n                case 'seq-item-ind':\n                    if (this.atNewLine)\n                        this.indent += source.length;\n                    break;\n                case 'doc-mode':\n                case 'flow-error-end':\n                    return;\n                default:\n                    this.atNewLine = false;\n            }\n            this.offset += source.length;\n        }\n    }\n    /** Call at end of input to push out any remaining constructions */\n    *end() {\n        while (this.stack.length > 0)\n            yield* this.pop();\n    }\n    get sourceToken() {\n        const st = {\n            type: this.type,\n            offset: this.offset,\n            indent: this.indent,\n            source: this.source\n        };\n        return st;\n    }\n    *step() {\n        const top = this.peek(1);\n        if (this.type === 'doc-end' && (!top || top.type !== 'doc-end')) {\n            while (this.stack.length > 0)\n                yield* this.pop();\n            this.stack.push({\n                type: 'doc-end',\n                offset: this.offset,\n                source: this.source\n            });\n            return;\n        }\n        if (!top)\n            return yield* this.stream();\n        switch (top.type) {\n            case 'document':\n                return yield* this.document(top);\n            case 'alias':\n            case 'scalar':\n            case 'single-quoted-scalar':\n            case 'double-quoted-scalar':\n                return yield* this.scalar(top);\n            case 'block-scalar':\n                return yield* this.blockScalar(top);\n            case 'block-map':\n                return yield* this.blockMap(top);\n            case 'block-seq':\n                return yield* this.blockSequence(top);\n            case 'flow-collection':\n                return yield* this.flowCollection(top);\n            case 'doc-end':\n                return yield* this.documentEnd(top);\n        }\n        /* istanbul ignore next should not happen */\n        yield* this.pop();\n    }\n    peek(n) {\n        return this.stack[this.stack.length - n];\n    }\n    *pop(error) {\n        const token = error ?? this.stack.pop();\n        /* istanbul ignore if should not happen */\n        if (!token) {\n            const message = 'Tried to pop an empty stack';\n            yield { type: 'error', offset: this.offset, source: '', message };\n        }\n        else if (this.stack.length === 0) {\n            yield token;\n        }\n        else {\n            const top = this.peek(1);\n            if (token.type === 'block-scalar') {\n                // Block scalars use their parent rather than header indent\n                token.indent = 'indent' in top ? top.indent : 0;\n            }\n            else if (token.type === 'flow-collection' && top.type === 'document') {\n                // Ignore all indent for top-level flow collections\n                token.indent = 0;\n            }\n            if (token.type === 'flow-collection')\n                fixFlowSeqItems(token);\n            switch (top.type) {\n                case 'document':\n                    top.value = token;\n                    break;\n                case 'block-scalar':\n                    top.props.push(token); // error\n                    break;\n                case 'block-map': {\n                    const it = top.items[top.items.length - 1];\n                    if (it.value) {\n                        top.items.push({ start: [], key: token, sep: [] });\n                        this.onKeyLine = true;\n                        return;\n                    }\n                    else if (it.sep) {\n                        it.value = token;\n                    }\n                    else {\n                        Object.assign(it, { key: token, sep: [] });\n                        this.onKeyLine = !it.explicitKey;\n                        return;\n                    }\n                    break;\n                }\n                case 'block-seq': {\n                    const it = top.items[top.items.length - 1];\n                    if (it.value)\n                        top.items.push({ start: [], value: token });\n                    else\n                        it.value = token;\n                    break;\n                }\n                case 'flow-collection': {\n                    const it = top.items[top.items.length - 1];\n                    if (!it || it.value)\n                        top.items.push({ start: [], key: token, sep: [] });\n                    else if (it.sep)\n                        it.value = token;\n                    else\n                        Object.assign(it, { key: token, sep: [] });\n                    return;\n                }\n                /* istanbul ignore next should not happen */\n                default:\n                    yield* this.pop();\n                    yield* this.pop(token);\n            }\n            if ((top.type === 'document' ||\n                top.type === 'block-map' ||\n                top.type === 'block-seq') &&\n                (token.type === 'block-map' || token.type === 'block-seq')) {\n                const last = token.items[token.items.length - 1];\n                if (last &&\n                    !last.sep &&\n                    !last.value &&\n                    last.start.length > 0 &&\n                    findNonEmptyIndex(last.start) === -1 &&\n                    (token.indent === 0 ||\n                        last.start.every(st => st.type !== 'comment' || st.indent < token.indent))) {\n                    if (top.type === 'document')\n                        top.end = last.start;\n                    else\n                        top.items.push({ start: last.start });\n                    token.items.splice(-1, 1);\n                }\n            }\n        }\n    }\n    *stream() {\n        switch (this.type) {\n            case 'directive-line':\n                yield { type: 'directive', offset: this.offset, source: this.source };\n                return;\n            case 'byte-order-mark':\n            case 'space':\n            case 'comment':\n            case 'newline':\n                yield this.sourceToken;\n                return;\n            case 'doc-mode':\n            case 'doc-start': {\n                const doc = {\n                    type: 'document',\n                    offset: this.offset,\n                    start: []\n                };\n                if (this.type === 'doc-start')\n                    doc.start.push(this.sourceToken);\n                this.stack.push(doc);\n                return;\n            }\n        }\n        yield {\n            type: 'error',\n            offset: this.offset,\n            message: `Unexpected ${this.type} token in YAML stream`,\n            source: this.source\n        };\n    }\n    *document(doc) {\n        if (doc.value)\n            return yield* this.lineEnd(doc);\n        switch (this.type) {\n            case 'doc-start': {\n                if (findNonEmptyIndex(doc.start) !== -1) {\n                    yield* this.pop();\n                    yield* this.step();\n                }\n                else\n                    doc.start.push(this.sourceToken);\n                return;\n            }\n            case 'anchor':\n            case 'tag':\n            case 'space':\n            case 'comment':\n            case 'newline':\n                doc.start.push(this.sourceToken);\n                return;\n        }\n        const bv = this.startBlockValue(doc);\n        if (bv)\n            this.stack.push(bv);\n        else {\n            yield {\n                type: 'error',\n                offset: this.offset,\n                message: `Unexpected ${this.type} token in YAML document`,\n                source: this.source\n            };\n        }\n    }\n    *scalar(scalar) {\n        if (this.type === 'map-value-ind') {\n            const prev = getPrevProps(this.peek(2));\n            const start = getFirstKeyStartProps(prev);\n            let sep;\n            if (scalar.end) {\n                sep = scalar.end;\n                sep.push(this.sourceToken);\n                delete scalar.end;\n            }\n            else\n                sep = [this.sourceToken];\n            const map = {\n                type: 'block-map',\n                offset: scalar.offset,\n                indent: scalar.indent,\n                items: [{ start, key: scalar, sep }]\n            };\n            this.onKeyLine = true;\n            this.stack[this.stack.length - 1] = map;\n        }\n        else\n            yield* this.lineEnd(scalar);\n    }\n    *blockScalar(scalar) {\n        switch (this.type) {\n            case 'space':\n            case 'comment':\n            case 'newline':\n                scalar.props.push(this.sourceToken);\n                return;\n            case 'scalar':\n                scalar.source = this.source;\n                // block-scalar source includes trailing newline\n                this.atNewLine = true;\n                this.indent = 0;\n                if (this.onNewLine) {\n                    let nl = this.source.indexOf('\\n') + 1;\n                    while (nl !== 0) {\n                        this.onNewLine(this.offset + nl);\n                        nl = this.source.indexOf('\\n', nl) + 1;\n                    }\n                }\n                yield* this.pop();\n                break;\n            /* istanbul ignore next should not happen */\n            default:\n                yield* this.pop();\n                yield* this.step();\n        }\n    }\n    *blockMap(map) {\n        const it = map.items[map.items.length - 1];\n        // it.sep is true-ish if pair already has key or : separator\n        switch (this.type) {\n            case 'newline':\n                this.onKeyLine = false;\n                if (it.value) {\n                    const end = 'end' in it.value ? it.value.end : undefined;\n                    const last = Array.isArray(end) ? end[end.length - 1] : undefined;\n                    if (last?.type === 'comment')\n                        end?.push(this.sourceToken);\n                    else\n                        map.items.push({ start: [this.sourceToken] });\n                }\n                else if (it.sep) {\n                    it.sep.push(this.sourceToken);\n                }\n                else {\n                    it.start.push(this.sourceToken);\n                }\n                return;\n            case 'space':\n            case 'comment':\n                if (it.value) {\n                    map.items.push({ start: [this.sourceToken] });\n                }\n                else if (it.sep) {\n                    it.sep.push(this.sourceToken);\n                }\n                else {\n                    if (this.atIndentedComment(it.start, map.indent)) {\n                        const prev = map.items[map.items.length - 2];\n                        const end = prev?.value?.end;\n                        if (Array.isArray(end)) {\n                            Array.prototype.push.apply(end, it.start);\n                            end.push(this.sourceToken);\n                            map.items.pop();\n                            return;\n                        }\n                    }\n                    it.start.push(this.sourceToken);\n                }\n                return;\n        }\n        if (this.indent >= map.indent) {\n            const atMapIndent = !this.onKeyLine && this.indent === map.indent;\n            const atNextItem = atMapIndent &&\n                (it.sep || it.explicitKey) &&\n                this.type !== 'seq-item-ind';\n            // For empty nodes, assign newline-separated not indented empty tokens to following node\n            let start = [];\n            if (atNextItem && it.sep && !it.value) {\n                const nl = [];\n                for (let i = 0; i < it.sep.length; ++i) {\n                    const st = it.sep[i];\n                    switch (st.type) {\n                        case 'newline':\n                            nl.push(i);\n                            break;\n                        case 'space':\n                            break;\n                        case 'comment':\n                            if (st.indent > map.indent)\n                                nl.length = 0;\n                            break;\n                        default:\n                            nl.length = 0;\n                    }\n                }\n                if (nl.length >= 2)\n                    start = it.sep.splice(nl[1]);\n            }\n            switch (this.type) {\n                case 'anchor':\n                case 'tag':\n                    if (atNextItem || it.value) {\n                        start.push(this.sourceToken);\n                        map.items.push({ start });\n                        this.onKeyLine = true;\n                    }\n                    else if (it.sep) {\n                        it.sep.push(this.sourceToken);\n                    }\n                    else {\n                        it.start.push(this.sourceToken);\n                    }\n                    return;\n                case 'explicit-key-ind':\n                    if (!it.sep && !it.explicitKey) {\n                        it.start.push(this.sourceToken);\n                        it.explicitKey = true;\n                    }\n                    else if (atNextItem || it.value) {\n                        start.push(this.sourceToken);\n                        map.items.push({ start, explicitKey: true });\n                    }\n                    else {\n                        this.stack.push({\n                            type: 'block-map',\n                            offset: this.offset,\n                            indent: this.indent,\n                            items: [{ start: [this.sourceToken], explicitKey: true }]\n                        });\n                    }\n                    this.onKeyLine = true;\n                    return;\n                case 'map-value-ind':\n                    if (it.explicitKey) {\n                        if (!it.sep) {\n                            if (includesToken(it.start, 'newline')) {\n                                Object.assign(it, { key: null, sep: [this.sourceToken] });\n                            }\n                            else {\n                                const start = getFirstKeyStartProps(it.start);\n                                this.stack.push({\n                                    type: 'block-map',\n                                    offset: this.offset,\n                                    indent: this.indent,\n                                    items: [{ start, key: null, sep: [this.sourceToken] }]\n                                });\n                            }\n                        }\n                        else if (it.value) {\n                            map.items.push({ start: [], key: null, sep: [this.sourceToken] });\n                        }\n                        else if (includesToken(it.sep, 'map-value-ind')) {\n                            this.stack.push({\n                                type: 'block-map',\n                                offset: this.offset,\n                                indent: this.indent,\n                                items: [{ start, key: null, sep: [this.sourceToken] }]\n                            });\n                        }\n                        else if (isFlowToken(it.key) &&\n                            !includesToken(it.sep, 'newline')) {\n                            const start = getFirstKeyStartProps(it.start);\n                            const key = it.key;\n                            const sep = it.sep;\n                            sep.push(this.sourceToken);\n                            // @ts-expect-error type guard is wrong here\n                            delete it.key;\n                            // @ts-expect-error type guard is wrong here\n                            delete it.sep;\n                            this.stack.push({\n                                type: 'block-map',\n                                offset: this.offset,\n                                indent: this.indent,\n                                items: [{ start, key, sep }]\n                            });\n                        }\n                        else if (start.length > 0) {\n                            // Not actually at next item\n                            it.sep = it.sep.concat(start, this.sourceToken);\n                        }\n                        else {\n                            it.sep.push(this.sourceToken);\n                        }\n                    }\n                    else {\n                        if (!it.sep) {\n                            Object.assign(it, { key: null, sep: [this.sourceToken] });\n                        }\n                        else if (it.value || atNextItem) {\n                            map.items.push({ start, key: null, sep: [this.sourceToken] });\n                        }\n                        else if (includesToken(it.sep, 'map-value-ind')) {\n                            this.stack.push({\n                                type: 'block-map',\n                                offset: this.offset,\n                                indent: this.indent,\n                                items: [{ start: [], key: null, sep: [this.sourceToken] }]\n                            });\n                        }\n                        else {\n                            it.sep.push(this.sourceToken);\n                        }\n                    }\n                    this.onKeyLine = true;\n                    return;\n                case 'alias':\n                case 'scalar':\n                case 'single-quoted-scalar':\n                case 'double-quoted-scalar': {\n                    const fs = this.flowScalar(this.type);\n                    if (atNextItem || it.value) {\n                        map.items.push({ start, key: fs, sep: [] });\n                        this.onKeyLine = true;\n                    }\n                    else if (it.sep) {\n                        this.stack.push(fs);\n                    }\n                    else {\n                        Object.assign(it, { key: fs, sep: [] });\n                        this.onKeyLine = true;\n                    }\n                    return;\n                }\n                default: {\n                    const bv = this.startBlockValue(map);\n                    if (bv) {\n                        if (bv.type === 'block-seq') {\n                            if (!it.explicitKey &&\n                                it.sep &&\n                                !includesToken(it.sep, 'newline')) {\n                                yield* this.pop({\n                                    type: 'error',\n                                    offset: this.offset,\n                                    message: 'Unexpected block-seq-ind on same line with key',\n                                    source: this.source\n                                });\n                                return;\n                            }\n                        }\n                        else if (atMapIndent) {\n                            map.items.push({ start });\n                        }\n                        this.stack.push(bv);\n                        return;\n                    }\n                }\n            }\n        }\n        yield* this.pop();\n        yield* this.step();\n    }\n    *blockSequence(seq) {\n        const it = seq.items[seq.items.length - 1];\n        switch (this.type) {\n            case 'newline':\n                if (it.value) {\n                    const end = 'end' in it.value ? it.value.end : undefined;\n                    const last = Array.isArray(end) ? end[end.length - 1] : undefined;\n                    if (last?.type === 'comment')\n                        end?.push(this.sourceToken);\n                    else\n                        seq.items.push({ start: [this.sourceToken] });\n                }\n                else\n                    it.start.push(this.sourceToken);\n                return;\n            case 'space':\n            case 'comment':\n                if (it.value)\n                    seq.items.push({ start: [this.sourceToken] });\n                else {\n                    if (this.atIndentedComment(it.start, seq.indent)) {\n                        const prev = seq.items[seq.items.length - 2];\n                        const end = prev?.value?.end;\n                        if (Array.isArray(end)) {\n                            Array.prototype.push.apply(end, it.start);\n                            end.push(this.sourceToken);\n                            seq.items.pop();\n                            return;\n                        }\n                    }\n                    it.start.push(this.sourceToken);\n                }\n                return;\n            case 'anchor':\n            case 'tag':\n                if (it.value || this.indent <= seq.indent)\n                    break;\n                it.start.push(this.sourceToken);\n                return;\n            case 'seq-item-ind':\n                if (this.indent !== seq.indent)\n                    break;\n                if (it.value || includesToken(it.start, 'seq-item-ind'))\n                    seq.items.push({ start: [this.sourceToken] });\n                else\n                    it.start.push(this.sourceToken);\n                return;\n        }\n        if (this.indent > seq.indent) {\n            const bv = this.startBlockValue(seq);\n            if (bv) {\n                this.stack.push(bv);\n                return;\n            }\n        }\n        yield* this.pop();\n        yield* this.step();\n    }\n    *flowCollection(fc) {\n        const it = fc.items[fc.items.length - 1];\n        if (this.type === 'flow-error-end') {\n            let top;\n            do {\n                yield* this.pop();\n                top = this.peek(1);\n            } while (top && top.type === 'flow-collection');\n        }\n        else if (fc.end.length === 0) {\n            switch (this.type) {\n                case 'comma':\n                case 'explicit-key-ind':\n                    if (!it || it.sep)\n                        fc.items.push({ start: [this.sourceToken] });\n                    else\n                        it.start.push(this.sourceToken);\n                    return;\n                case 'map-value-ind':\n                    if (!it || it.value)\n                        fc.items.push({ start: [], key: null, sep: [this.sourceToken] });\n                    else if (it.sep)\n                        it.sep.push(this.sourceToken);\n                    else\n                        Object.assign(it, { key: null, sep: [this.sourceToken] });\n                    return;\n                case 'space':\n                case 'comment':\n                case 'newline':\n                case 'anchor':\n                case 'tag':\n                    if (!it || it.value)\n                        fc.items.push({ start: [this.sourceToken] });\n                    else if (it.sep)\n                        it.sep.push(this.sourceToken);\n                    else\n                        it.start.push(this.sourceToken);\n                    return;\n                case 'alias':\n                case 'scalar':\n                case 'single-quoted-scalar':\n                case 'double-quoted-scalar': {\n                    const fs = this.flowScalar(this.type);\n                    if (!it || it.value)\n                        fc.items.push({ start: [], key: fs, sep: [] });\n                    else if (it.sep)\n                        this.stack.push(fs);\n                    else\n                        Object.assign(it, { key: fs, sep: [] });\n                    return;\n                }\n                case 'flow-map-end':\n                case 'flow-seq-end':\n                    fc.end.push(this.sourceToken);\n                    return;\n            }\n            const bv = this.startBlockValue(fc);\n            /* istanbul ignore else should not happen */\n            if (bv)\n                this.stack.push(bv);\n            else {\n                yield* this.pop();\n                yield* this.step();\n            }\n        }\n        else {\n            const parent = this.peek(2);\n            if (parent.type === 'block-map' &&\n                ((this.type === 'map-value-ind' && parent.indent === fc.indent) ||\n                    (this.type === 'newline' &&\n                        !parent.items[parent.items.length - 1].sep))) {\n                yield* this.pop();\n                yield* this.step();\n            }\n            else if (this.type === 'map-value-ind' &&\n                parent.type !== 'flow-collection') {\n                const prev = getPrevProps(parent);\n                const start = getFirstKeyStartProps(prev);\n                fixFlowSeqItems(fc);\n                const sep = fc.end.splice(1, fc.end.length);\n                sep.push(this.sourceToken);\n                const map = {\n                    type: 'block-map',\n                    offset: fc.offset,\n                    indent: fc.indent,\n                    items: [{ start, key: fc, sep }]\n                };\n                this.onKeyLine = true;\n                this.stack[this.stack.length - 1] = map;\n            }\n            else {\n                yield* this.lineEnd(fc);\n            }\n        }\n    }\n    flowScalar(type) {\n        if (this.onNewLine) {\n            let nl = this.source.indexOf('\\n') + 1;\n            while (nl !== 0) {\n                this.onNewLine(this.offset + nl);\n                nl = this.source.indexOf('\\n', nl) + 1;\n            }\n        }\n        return {\n            type,\n            offset: this.offset,\n            indent: this.indent,\n            source: this.source\n        };\n    }\n    startBlockValue(parent) {\n        switch (this.type) {\n            case 'alias':\n            case 'scalar':\n            case 'single-quoted-scalar':\n            case 'double-quoted-scalar':\n                return this.flowScalar(this.type);\n            case 'block-scalar-header':\n                return {\n                    type: 'block-scalar',\n                    offset: this.offset,\n                    indent: this.indent,\n                    props: [this.sourceToken],\n                    source: ''\n                };\n            case 'flow-map-start':\n            case 'flow-seq-start':\n                return {\n                    type: 'flow-collection',\n                    offset: this.offset,\n                    indent: this.indent,\n                    start: this.sourceToken,\n                    items: [],\n                    end: []\n                };\n            case 'seq-item-ind':\n                return {\n                    type: 'block-seq',\n                    offset: this.offset,\n                    indent: this.indent,\n                    items: [{ start: [this.sourceToken] }]\n                };\n            case 'explicit-key-ind': {\n                this.onKeyLine = true;\n                const prev = getPrevProps(parent);\n                const start = getFirstKeyStartProps(prev);\n                start.push(this.sourceToken);\n                return {\n                    type: 'block-map',\n                    offset: this.offset,\n                    indent: this.indent,\n                    items: [{ start, explicitKey: true }]\n                };\n            }\n            case 'map-value-ind': {\n                this.onKeyLine = true;\n                const prev = getPrevProps(parent);\n                const start = getFirstKeyStartProps(prev);\n                return {\n                    type: 'block-map',\n                    offset: this.offset,\n                    indent: this.indent,\n                    items: [{ start, key: null, sep: [this.sourceToken] }]\n                };\n            }\n        }\n        return null;\n    }\n    atIndentedComment(start, indent) {\n        if (this.type !== 'comment')\n            return false;\n        if (this.indent <= indent)\n            return false;\n        return start.every(st => st.type === 'newline' || st.type === 'space');\n    }\n    *documentEnd(docEnd) {\n        if (this.type !== 'doc-mode') {\n            if (docEnd.end)\n                docEnd.end.push(this.sourceToken);\n            else\n                docEnd.end = [this.sourceToken];\n            if (this.type === 'newline')\n                yield* this.pop();\n        }\n    }\n    *lineEnd(token) {\n        switch (this.type) {\n            case 'comma':\n            case 'doc-start':\n            case 'doc-end':\n            case 'flow-seq-end':\n            case 'flow-map-end':\n            case 'map-value-ind':\n                yield* this.pop();\n                yield* this.step();\n                break;\n            case 'newline':\n                this.onKeyLine = false;\n            // fallthrough\n            case 'space':\n            case 'comment':\n            default:\n                // all other values are errors\n                if (token.end)\n                    token.end.push(this.sourceToken);\n                else\n                    token.end = [this.sourceToken];\n                if (this.type === 'newline')\n                    yield* this.pop();\n        }\n    }\n}\n\nexports.Parser = Parser;\n","'use strict';\n\nvar composer = require('./compose/composer.js');\nvar Document = require('./doc/Document.js');\nvar errors = require('./errors.js');\nvar log = require('./log.js');\nvar identity = require('./nodes/identity.js');\nvar lineCounter = require('./parse/line-counter.js');\nvar parser = require('./parse/parser.js');\n\nfunction parseOptions(options) {\n    const prettyErrors = options.prettyErrors !== false;\n    const lineCounter$1 = options.lineCounter || (prettyErrors && new lineCounter.LineCounter()) || null;\n    return { lineCounter: lineCounter$1, prettyErrors };\n}\n/**\n * Parse the input as a stream of YAML documents.\n *\n * Documents should be separated from each other by `...` or `---` marker lines.\n *\n * @returns If an empty `docs` array is returned, it will be of type\n *   EmptyStream and contain additional stream information. In\n *   TypeScript, you should use `'empty' in docs` as a type guard for it.\n */\nfunction parseAllDocuments(source, options = {}) {\n    const { lineCounter, prettyErrors } = parseOptions(options);\n    const parser$1 = new parser.Parser(lineCounter?.addNewLine);\n    const composer$1 = new composer.Composer(options);\n    const docs = Array.from(composer$1.compose(parser$1.parse(source)));\n    if (prettyErrors && lineCounter)\n        for (const doc of docs) {\n            doc.errors.forEach(errors.prettifyError(source, lineCounter));\n            doc.warnings.forEach(errors.prettifyError(source, lineCounter));\n        }\n    if (docs.length > 0)\n        return docs;\n    return Object.assign([], { empty: true }, composer$1.streamInfo());\n}\n/** Parse an input string into a single YAML.Document */\nfunction parseDocument(source, options = {}) {\n    const { lineCounter, prettyErrors } = parseOptions(options);\n    const parser$1 = new parser.Parser(lineCounter?.addNewLine);\n    const composer$1 = new composer.Composer(options);\n    // `doc` is always set by compose.end(true) at the very latest\n    let doc = null;\n    for (const _doc of composer$1.compose(parser$1.parse(source), true, source.length)) {\n        if (!doc)\n            doc = _doc;\n        else if (doc.options.logLevel !== 'silent') {\n            doc.errors.push(new errors.YAMLParseError(_doc.range.slice(0, 2), 'MULTIPLE_DOCS', 'Source contains multiple documents; please use YAML.parseAllDocuments()'));\n            break;\n        }\n    }\n    if (prettyErrors && lineCounter) {\n        doc.errors.forEach(errors.prettifyError(source, lineCounter));\n        doc.warnings.forEach(errors.prettifyError(source, lineCounter));\n    }\n    return doc;\n}\nfunction parse(src, reviver, options) {\n    let _reviver = undefined;\n    if (typeof reviver === 'function') {\n        _reviver = reviver;\n    }\n    else if (options === undefined && reviver && typeof reviver === 'object') {\n        options = reviver;\n    }\n    const doc = parseDocument(src, options);\n    if (!doc)\n        return null;\n    doc.warnings.forEach(warning => log.warn(doc.options.logLevel, warning));\n    if (doc.errors.length > 0) {\n        if (doc.options.logLevel !== 'silent')\n            throw doc.errors[0];\n        else\n            doc.errors = [];\n    }\n    return doc.toJS(Object.assign({ reviver: _reviver }, options));\n}\nfunction stringify(value, replacer, options) {\n    let _replacer = null;\n    if (typeof replacer === 'function' || Array.isArray(replacer)) {\n        _replacer = replacer;\n    }\n    else if (options === undefined && replacer) {\n        options = replacer;\n    }\n    if (typeof options === 'string')\n        options = options.length;\n    if (typeof options === 'number') {\n        const indent = Math.round(options);\n        options = indent < 1 ? undefined : indent > 8 ? { indent: 8 } : { indent };\n    }\n    if (value === undefined) {\n        const { keepUndefined } = options ?? replacer ?? {};\n        if (!keepUndefined)\n            return undefined;\n    }\n    if (identity.isDocument(value) && !_replacer)\n        return value.toString(options);\n    return new Document.Document(value, _replacer, options).toString(options);\n}\n\nexports.parse = parse;\nexports.parseAllDocuments = parseAllDocuments;\nexports.parseDocument = parseDocument;\nexports.stringify = stringify;\n","import * as fs from \"fs\";\nimport path = require(\"path\");\n\nimport {\n  Hover,\n  Range,\n  CompletionItem,\n  CompletionItemKind,\n  InsertTextFormat,\n} from \"vscode-languageserver-types\";\n\nimport { ESPHomeSchema } from \"./esphome-schema\";\nimport { ensureSchemaAvailable } from \"./schema-fetcher\";\n\nexport {\n  Position,\n  Range,\n  CompletionItem,\n  CompletionItemKind,\n} from \"vscode-languageserver-types\";\n\nexport const coreSchema = new ESPHomeSchema(async (name: string) => {\n  const schemaPath = await ensureSchemaAvailable();\n  const jsonPath = path.join(schemaPath, `schema/${name}.json`);\n  const fileContents = fs.readFileSync(jsonPath, \"utf-8\");\n  return JSON.parse(fileContents);\n});\n\nexport const createHover = (contents: string, range: Range): Hover => {\n  const hover: Hover = {\n    contents: {\n      kind: \"markdown\",\n      value: contents,\n    },\n    range,\n  };\n  return hover;\n};\n\nexport const createCompletion = (\n  label: string,\n  insertText: string,\n  kind: CompletionItemKind,\n  documentation: string | undefined = undefined,\n  triggerSuggest: boolean = false,\n  preselect?: boolean,\n  snippet?: boolean,\n  sortText?: string,\n  detail?: string,\n) => {\n  const completion: CompletionItem = {\n    label: label,\n    insertText: insertText,\n    kind,\n    detail,\n    sortText,\n    preselect,\n  };\n  if (triggerSuggest) {\n    completion.command = {\n      title: \"chain\",\n      command: \"editor.action.triggerSuggest\",\n    };\n  }\n  if (documentation) {\n    completion.documentation = {\n      kind: \"markdown\",\n      value: documentation,\n    };\n  }\n  if (snippet) {\n    completion.insertTextFormat = InsertTextFormat.Snippet;\n  }\n\n  return completion;\n};\n\nexport const createCompletionSnippet = (\n  label: string,\n  insertText: string,\n  kind: CompletionItemKind,\n  documentation: string | undefined = undefined,\n) => {\n  const completion: CompletionItem = {\n    label: label,\n    insertText: insertText,\n    kind,\n    insertTextFormat: InsertTextFormat.Snippet,\n    documentation,\n  };\n  return completion;\n};\n\n//export const createDefinition = ()\n","import { Document, isMap, isPair, isScalar, isSeq, Node, YAMLMap } from \"yaml\";\nimport { Range } from \"yaml/dist/nodes/Node\";\n\nexport interface SchemaSet {\n  [name: string]: Component;\n  core: CoreComponent;\n}\n\ninterface ConfigVarBase {\n  key: string;\n  is_list?: boolean;\n  docs?: string;\n  maybe?: string;\n  templatable?: boolean;\n}\n\nexport interface ConfigVarRegistry extends ConfigVarBase {\n  type: \"registry\";\n  registry: ComponentRegistry;\n  filter?: string[];\n}\n\nexport interface ConfigVarTrigger extends ConfigVarBase {\n  type: \"trigger\";\n  schema: Schema | undefined;\n  has_required_var: Boolean;\n}\n\nexport interface ConfigVarEnum extends ConfigVarBase {\n  type: \"enum\";\n  values: { [key: string]: { docs: string } | null };\n  default?: string;\n}\n\nexport interface ConfigVarSchema extends ConfigVarBase {\n  type: \"schema\";\n  schema: Schema;\n  maybe?: string;\n}\n\nexport interface ConfigVarTyped extends ConfigVarBase {\n  type: \"typed\";\n  typed_key: string;\n  types: {\n    [name: string]: Schema;\n  };\n}\nexport interface ConfigVarPin extends ConfigVarBase {\n  type: \"pin\";\n  schema: Boolean;\n  internal: Boolean;\n  modes: (\"output\" | \"input\" | \"pullup\")[];\n}\ninterface ConfigVarBoolean extends ConfigVarBase {\n  type: \"boolean\";\n  default: string;\n}\ninterface ConfigVarString extends ConfigVarBase {\n  type: \"string\" | \"integer\";\n  default?: string;\n}\nexport interface ConfigVarUseId extends ConfigVarBase {\n  type: \"use_id\";\n  use_id_type: string;\n}\n\nexport interface ConfigVarId {\n  id_type: {\n    class: string;\n    parents: string[];\n  };\n}\n\nexport type ConfigVar =\n  | ConfigVarSchema\n  | ConfigVarRegistry\n  | ConfigVarEnum\n  | ConfigVarTrigger\n  | ConfigVarTyped\n  | ConfigVarPin\n  | ConfigVarBoolean\n  | ConfigVarString\n  | ConfigVarUseId;\n\ninterface ConfigVars {\n  [name: string]: ConfigVar | undefined;\n  id?: ConfigVar & ConfigVarId;\n}\n\nexport interface Schema {\n  config_vars: ConfigVars;\n  extends: string[];\n}\n\ninterface Registry {\n  [name: string]: ConfigVar;\n}\n\ntype ComponentRegistry = \"action\" | \"condition\" | \"filter\" | \"effects\";\n\ninterface Component {\n  schemas: {\n    [name: string]: ConfigVar;\n    CONFIG_SCHEMA: ConfigVarSchema;\n  };\n  // These are the components e.g. of sensor, binary_sensor\n  components: { [name: string]: { docs?: string } };\n\n  action: Registry;\n  condition: Registry;\n  filter: Registry;\n  effects: Registry;\n  pin?: ConfigVar;\n}\ninterface CoreComponent extends Component {\n  platforms: { [name: string]: { docs?: string } };\n  components: { [name: string]: { docs?: string; dependencies?: string[] } };\n  pins: string[];\n}\n\nexport class ESPHomeSchema {\n  schema: SchemaSet | undefined;\n  loaded_schemas: string[] = [\"core\", \"esphome\"];\n\n  constructor(private schemaLoader: (schemaName: string) => Promise<any>) {}\n\n  async getSchema(): Promise<SchemaSet> {\n    if (this.schema) {\n      return this.schema;\n    }\n    this.schema = await this.schemaLoader(\"esphome\");\n    return this.schema!;\n  }\n\n  async getPlatformList() {\n    return (await this.getSchema()).core.platforms;\n  }\n  async getComponentList() {\n    return (await this.getSchema()).core.components;\n  }\n\n  async getComponent(\n    domain: string,\n    platform: string | null = null,\n  ): Promise<Component> {\n    if (!this.loaded_schemas.includes(domain)) {\n      this.schema = {\n        ...this.schema,\n        ...(await this.schemaLoader(domain)),\n      };\n      this.loaded_schemas.push(domain);\n    }\n    if (platform !== null) {\n      return (await this.getSchema())[`${domain}.${platform}`];\n    }\n    return (await this.getSchema())[domain];\n  }\n\n  async getComponentSchema(domain: string): Promise<ConfigVar> {\n    const component = await this.getComponent(domain);\n    return component.schemas.CONFIG_SCHEMA;\n  }\n  async getComponentPlatformSchema(\n    domain: string,\n    platform: string,\n  ): Promise<ConfigVar> {\n    const component = await this.getComponent(domain, platform);\n    return component.schemas.CONFIG_SCHEMA;\n  }\n\n  async getExtendedConfigVar(name: string): Promise<ConfigVar> {\n    const parts = name.split(\".\");\n    if (parts.length === 3) {\n      const c = await this.getComponent(parts[0], parts[1]);\n      return c.schemas[parts[2]];\n    }\n    const c = await this.getComponent(parts[0]);\n    return c.schemas[parts[1]];\n  }\n\n  async isPlatform(name: string): Promise<boolean> {\n    return name in (await this.getSchema()).core.platforms;\n  }\n\n  async *getDocComponents(\n    doc: Document,\n  ): AsyncGenerator<[string, Component, Node?]> {\n    const docMap = doc.contents as YAMLMap;\n    let addPollingComponent = false;\n    const yieldedComponents: string[] = [];\n    for (const k of docMap.items) {\n      if (isPair(k) && isScalar(k.key)) {\n        const componentName = k.key.value as string;\n        const isPlatformComponent = await this.isPlatform(componentName);\n        if (\n          !isPlatformComponent &&\n          !(componentName in (await this.getSchema()).core.components)\n        ) {\n          // invalid or unknown name\n          continue;\n        }\n        const component = await this.getComponent(componentName);\n        if (!yieldedComponents.includes(componentName)) {\n          yield [componentName, component, k.value as Node];\n          yieldedComponents.push(componentName);\n        }\n\n        if (isPlatformComponent) {\n          // iterate elements and lookup platform to load components\n          const platList = docMap.get(componentName);\n          if (isSeq(platList)) {\n            for (const plat of platList.items) {\n              if (isMap(plat)) {\n                const platCompName = plat.get(\"platform\") as string;\n                if (platCompName in component.components) {\n                  if (!addPollingComponent) {\n                    const platComponent = await this.getComponent(\n                      platCompName,\n                      componentName,\n                    );\n                    if (\n                      platComponent.schemas.CONFIG_SCHEMA?.schema?.config_vars.id?.id_type?.parents?.includes(\n                        \"PollingComponent\",\n                      )\n                    ) {\n                      addPollingComponent = true;\n                    }\n                  }\n                  if (!yieldedComponents.includes(platCompName)) {\n                    yield [\n                      platCompName,\n                      await this.getComponent(platCompName),\n                      plat,\n                    ];\n                    yieldedComponents.push(platCompName);\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          if (\n            !addPollingComponent &&\n            component.schemas.CONFIG_SCHEMA?.schema?.config_vars.id?.id_type?.parents?.includes(\n              \"PollingComponent\",\n            )\n          ) {\n            addPollingComponent = true;\n          }\n          if (\n            componentName === \"api\" &&\n            !yieldedComponents.includes(\"homeassistant\")\n          ) {\n            yield [\n              \"homeassistant\",\n              await this.getComponent(\"homeassistant\"),\n              k.value as Node,\n            ];\n          }\n        }\n      }\n    }\n    if (addPollingComponent) {\n      yield [\"component\", await this.getComponent(\"component\"), undefined];\n    }\n    yield [\"core\", (await this.getSchema()).core, undefined];\n  }\n\n  async *getRegistry(\n    registry: ComponentRegistry,\n    doc: Document,\n  ): AsyncGenerator<[string, ConfigVar]> {\n    if (registry.includes(\".\")) {\n      // e.g. sensor.filter only items from one component\n      const [domain, registryName] = registry.split(\".\");\n      if (this.isRegistry(registryName)) {\n        for (const name in (await this.getSchema())[domain][registryName]) {\n          yield [name, (await this.getSchema())[domain][registryName][name]];\n        }\n      }\n    } else {\n      // e.g. action, condition: search in all domains\n      if (this.isRegistry(registry))\n        for await (const [componentName, component] of this.getDocComponents(\n          doc,\n        )) {\n          // component might be undefined if this component has no registries\n          const componentRegistry = component ? component[registry] : undefined;\n          if (componentRegistry !== undefined) {\n            for (const name in componentRegistry) {\n              if (componentName === \"core\") {\n                yield [name, componentRegistry[name]];\n              } else {\n                yield [\n                  componentName.split(\".\").reverse().join(\".\") + \".\" + name,\n                  componentRegistry[name],\n                ];\n              }\n            }\n          }\n        }\n    }\n  }\n\n  async getRegistryConfigVar(\n    registry: string,\n    entry: string,\n  ): Promise<ConfigVar | undefined> {\n    if (registry.includes(\".\")) {\n      const [domain, registryName] = registry.split(\".\");\n      if (this.isRegistry(registryName))\n        return (await this.getComponent(domain))[registryName][entry];\n    } else {\n      if (this.isRegistry(registry)) {\n        if (entry.includes(\".\")) {\n          const parts = entry.split(\".\");\n          if (parts.length === 3) {\n            const [domain, platform, actionName] = parts;\n            return (await this.getComponent(platform, domain))[registry][\n              actionName\n            ];\n          } else {\n            const [domain, actionName] = parts;\n            return (await this.getComponent(domain))[registry][actionName];\n          }\n        }\n        for (const c in this.schema) {\n          const schema = await this.getComponent(c);\n          if (\n            schema[registry] !== undefined &&\n            schema[registry][entry] !== undefined\n          ) {\n            return schema[registry][entry];\n          }\n        }\n      }\n    }\n    return undefined;\n  }\n  isRegistry(name: string): name is ComponentRegistry {\n    return (\n      name === \"filter\" ||\n      name === \"effects\" ||\n      name === \"condition\" ||\n      name === \"action\"\n    );\n  }\n  async getActionConfigVar(entry: string): Promise<ConfigVarTrigger> {\n    return (await this.getRegistryConfigVar(\n      \"action\",\n      entry,\n    )) as ConfigVarTrigger;\n  }\n  async getPinConfigVar(component: string): Promise<ConfigVar> {\n    var c = await this.getComponent(component);\n    if (!c.pin) throw new Error(\"Attempt to get pin from not pin component.\");\n    return c.pin;\n  }\n  async getPins(): Promise<string[]> {\n    return (await this.getSchema()).core.pins;\n  }\n\n  async getConfigVarComplete(schema: Schema, key: string): Promise<ConfigVar> {\n    var cv = { ...schema.config_vars[key] } as ConfigVar;\n\n    const appendCvs = async (s: Schema, c: ConfigVar) => {\n      if (s.extends !== undefined) {\n        for (const extended of s.extends) {\n          const s_cv = await this.getExtendedConfigVar(extended);\n          if (s_cv.type === \"schema\") {\n            if (\n              s_cv.schema.config_vars !== undefined &&\n              key in s_cv.schema.config_vars\n            ) {\n              c = {\n                ...s_cv.schema.config_vars[key],\n                ...c,\n              };\n            }\n            c = await appendCvs(s_cv.schema, c);\n          }\n        }\n      }\n      return c;\n    };\n    cv = await appendCvs(schema, cv);\n    return await this.getConfigVarComplete2(cv);\n  }\n\n  async getConfigVarComplete2(cv: ConfigVar): Promise<ConfigVar> {\n    var ret = { ...cv };\n\n    if (cv.type === \"schema\" && cv.schema.extends !== undefined) {\n      for (const extended of cv.schema.extends) {\n        const s_cv = await this.getExtendedConfigVar(extended);\n        ret = {\n          ...s_cv,\n          ...ret,\n        };\n        ret.type = s_cv.type;\n      }\n    }\n\n    return ret;\n  }\n\n  async *iterConfigVars(\n    schema: Schema,\n    doc: Document,\n    yielded: string[] = [],\n  ): AsyncGenerator<[string, ConfigVar]> {\n    const docMap = doc.contents as YAMLMap;\n    for (var prop in schema.config_vars) {\n      if (\n        schema.extends?.includes(\"core.MQTT_COMPONENT_SCHEMA\") &&\n        (prop === \"mqtt_id\" || prop === \"expire_after\") &&\n        docMap.get(\"mqtt\") === undefined\n      ) {\n        // filter mqtt props if mqtt is not used\n        continue;\n      }\n      if (yielded.includes(prop)) {\n        continue;\n      }\n      yielded.push(prop);\n      yield [prop, await this.getConfigVarComplete(schema, prop)];\n    }\n    if (schema.extends !== undefined) {\n      for (var extended of schema.extends) {\n        if (\n          extended.startsWith(\"core.MQTT\") &&\n          docMap.get(\"mqtt\") === undefined\n        ) {\n          continue;\n        }\n        const s = await this.getExtendedConfigVar(extended);\n        if (s.type === \"schema\") {\n          for await (const pair of this.iterConfigVars(\n            s.schema,\n            doc,\n            yielded,\n          )) {\n            yield pair;\n          }\n        } else if (s.type === \"typed\") {\n          yield [s.typed_key, s];\n        }\n      }\n    }\n  }\n\n  async findConfigVar(\n    schema: Schema,\n    prop: string,\n    doc: Document,\n  ): Promise<ConfigVar | undefined> {\n    for await (const [p, config] of this.iterConfigVars(schema, doc)) {\n      if (p === prop) {\n        return config;\n      }\n    }\n    return undefined;\n  }\n\n  async *iterDeclaringIdsInner(\n    idType: string,\n    map: YAMLMap,\n    declaringCv: ConfigVar,\n    doc: Document,\n  ): AsyncGenerator<Node> {\n    let schema: Schema;\n    if (declaringCv.type === \"schema\") {\n      schema = declaringCv.schema;\n    } else if (declaringCv.type === \"typed\") {\n      const schemaType = map.get(declaringCv.typed_key) as string;\n      schema = declaringCv.types[schemaType];\n    } else {\n      return;\n    }\n    for (const k of map.items) {\n      if (isPair(k) && isScalar(k.key)) {\n        const propName = k.key.value as string;\n        const cv = await this.findConfigVar(schema, propName, doc);\n        if (cv) {\n          const idCv = cv as any as ConfigVarId;\n          if (\n            idCv.id_type &&\n            (idCv.id_type.class === idType ||\n              idCv.id_type.parents?.includes(idType))\n          ) {\n            yield k.value as Node;\n          }\n          if (isMap(k.value)) {\n            for await (const yieldNode of this.iterDeclaringIdsInner(\n              idType,\n              k.value,\n              cv,\n              doc,\n            )) {\n              yield yieldNode;\n            }\n          } else if (cv.is_list && isSeq(k.value)) {\n            for (const seqItem of k.value.items) {\n              if (isMap(seqItem)) {\n                for await (const yieldNode of this.iterDeclaringIdsInner(\n                  idType,\n                  seqItem,\n                  cv,\n                  doc,\n                )) {\n                  yield yieldNode;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  async *iterDeclaringIds(idType: string, doc: Document): AsyncGenerator<Node> {\n    const docMap = doc.contents as YAMLMap;\n    for (const k of docMap.items) {\n      if (isPair(k) && isScalar(k.key)) {\n        const componentName = k.key.value as string;\n        if (\n          componentName in (await this.getSchema()).core.components ||\n          (await this.isPlatform(componentName))\n        ) {\n          const component = await this.getComponent(componentName);\n          const cv = component.schemas.CONFIG_SCHEMA;\n          if (isMap(k.value) && isScalar(k.value.get(\"id\", true)) && cv) {\n            for await (const yieldNode of this.iterDeclaringIdsInner(\n              idType,\n              k.value,\n              cv,\n              doc,\n            )) {\n              yield yieldNode;\n            }\n          } else if (isSeq(k.value) && cv && cv.is_list) {\n            const nodeList = k.value;\n            for (const item of nodeList.items) {\n              if (isMap(item) && isScalar(item.get(\"id\", true)) && cv) {\n                for await (const yieldNode of this.iterDeclaringIdsInner(\n                  idType,\n                  item,\n                  cv,\n                  doc,\n                )) {\n                  yield yieldNode;\n                }\n              }\n            }\n          }\n          if (await this.isPlatform(componentName)) {\n            // iterate elements and lookup platform to load components\n            const platNode = k.value;\n            if (isSeq(platNode)) {\n              for (const seqItemNode of platNode.items) {\n                if (isMap(seqItemNode)) {\n                  const platCompName = seqItemNode.get(\"platform\") as string;\n                  if (platCompName in component.components) {\n                    const component = await this.getComponent(\n                      platCompName,\n                      componentName,\n                    );\n                    const platCv = component.schemas.CONFIG_SCHEMA;\n                    for await (const yieldNode of this.iterDeclaringIdsInner(\n                      idType,\n                      seqItemNode,\n                      platCv,\n                      doc,\n                    )) {\n                      yield yieldNode;\n                    }\n                  }\n                }\n              }\n            } else if (isMap(platNode)) {\n              const platCompName = platNode.get(\"platform\") as string;\n              if (platCompName in component.components) {\n                const component = await this.getComponent(\n                  platCompName,\n                  componentName,\n                );\n                const platCv = component.schemas.CONFIG_SCHEMA;\n                for await (const yieldNode of this.iterDeclaringIdsInner(\n                  idType,\n                  platNode,\n                  platCv,\n                  doc,\n                )) {\n                  yield yieldNode;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  async findComponentDefinition(\n    id_type: string,\n    id: string,\n    doc: Document,\n  ): Promise<Range | null | undefined> {\n    for await (const item of this.iterDeclaringIds(id_type, doc)) {\n      if (isScalar(item) && item.value === id) {\n        return item.range;\n      }\n    }\n    return null;\n  }\n\n  async getUsableIds(use_id_type: string, doc: Document): Promise<string[]> {\n    const ret: string[] = [];\n    for await (const item of this.iterDeclaringIds(use_id_type, doc)) {\n      ret.push(item.toString());\n    }\n    return ret;\n  }\n}\n","import path = require(\"path\");\nimport * as unzipper from \"unzipper\";\nimport * as https from \"https\";\nimport * as os from \"os\";\nimport * as fs from \"fs\";\nimport { version } from \"./connection-source\";\n\nfunction getBaseDir(): string {\n  const base = path.join(os.homedir(), \".esphome-language-server\");\n  fs.mkdirSync(base, { recursive: true });\n  return base;\n}\nfunction downloadFile(url: string, dest: string): Promise<void> {\n  return new Promise((resolve, reject) => {\n    const request = https.get(\n      url,\n      {\n        headers: {\n          \"User-Agent\": \"esphome-vscode-extension\",\n          Accept: \"application/vnd.github.v3.raw\",\n        },\n      },\n      (res) => {\n        if (res.statusCode === 302 || res.statusCode === 301) {\n          const redirectUrl = res.headers.location;\n          if (redirectUrl) {\n            return downloadFile(redirectUrl, dest).then(resolve).catch(reject);\n          } else {\n            return reject(new Error(\"Redirected but no Location header found\"));\n          }\n        }\n\n        if (res.statusCode !== 200) {\n          return reject(\n            new Error(`Failed to download file: ${res.statusCode}`),\n          );\n        }\n\n        const file = fs.createWriteStream(dest);\n        res.pipe(file);\n        file.on(\"finish\", () =>\n          file.close((err) => {\n            if (err) reject(err);\n            else resolve();\n          }),\n        );\n      },\n    );\n\n    request.on(\"error\", reject);\n  });\n}\n\nfunction unzip(zipFile: string, dest: string): Promise<void> {\n  return fs\n    .createReadStream(zipFile)\n    .pipe(unzipper.Extract({ path: dest }))\n    .promise();\n}\n\nconst tryDownloadSchemaTag = async (tag: string): Promise<string> => {\n  const zipPath = path.join(getBaseDir(), tag + \".zip\");\n  const url = `https://schema.esphome.io/${tag}/schema.zip`;\n  console.log(`Downloading ${url} to ${zipPath}`);\n  await downloadFile(url, zipPath);\n  const schemaPath = path.join(getBaseDir(), tag);\n  await unzip(zipPath, schemaPath);\n  fs.rmSync(zipPath);\n  return schemaPath;\n};\n\nconst retrieveSchema = async (): Promise<string> => {\n  const connected_version = await version();\n  let tag = connected_version.endsWith(\"dev\") ? \"dev\" : connected_version;\n  const baseDir = getBaseDir();\n  fs.mkdirSync(baseDir, { recursive: true });\n  let schemaPath = path.join(baseDir, tag);\n  if (fs.existsSync(schemaPath)) {\n    if (tag != \"dev\") {\n      console.log(`Using cached schema at ${schemaPath}`);\n      return schemaPath;\n    }\n    // dev schema builds daily, download if file is older than 6 hours\n    let esphomeSchemaPath = path.join(schemaPath, \"schema\", \"esphome.json\");\n    if (fs.existsSync(esphomeSchemaPath)) {\n      const stats = fs.statSync(esphomeSchemaPath);\n      const modifiedTime = stats.mtime;\n      const ageMs = Date.now() - modifiedTime.getTime();\n      const TIMEOUT_HOURS = 12;\n      if (ageMs > TIMEOUT_HOURS * (60 * 60 * 1000)) {\n        console.log(\n          `Cached schema is older than ${TIMEOUT_HOURS} hours (${\n            ageMs / 1000\n          } seconds), need to re-download.`,\n        );\n      } else {\n        console.log(\"Cached dev schema is recent, using it.\");\n        return schemaPath;\n      }\n    }\n  }\n\n  // Attempt download specific version\n  try {\n    return await tryDownloadSchemaTag(tag);\n  } catch (err) {\n    // fallback to dev\n    return await tryDownloadSchemaTag(\"dev\");\n  }\n};\n\nlet schemaAvailablePromise: Promise<string>;\n\nexport function ensureSchemaAvailable(): Promise<string> {\n  if (!schemaAvailablePromise) {\n    schemaAvailablePromise = (async () => {\n      return await retrieveSchema();\n    })();\n  }\n  return schemaAvailablePromise;\n}\n","'use strict';\nexports.Parse = require('./lib/parse');\nexports.ParseOne = require('./lib/parseOne');\nexports.Extract = require('./lib/extract');\nexports.Open = require('./lib/Open');","const util = require('util');\nconst zlib = require('zlib');\nconst Stream = require('stream');\nconst PullStream = require('./PullStream');\nconst NoopStream = require('./NoopStream');\nconst BufferStream = require('./BufferStream');\nconst parseExtraField = require('./parseExtraField');\nconst parseDateTime = require('./parseDateTime');\nconst pipeline = Stream.pipeline;\nconst parseBuffer = require('./parseBuffer');\n\nconst endDirectorySignature = Buffer.alloc(4);\nendDirectorySignature.writeUInt32LE(0x06054b50, 0);\n\nfunction Parse(opts) {\n  if (!(this instanceof Parse)) {\n    return new Parse(opts);\n  }\n  const self = this;\n  self._opts = opts || { verbose: false };\n\n  PullStream.call(self, self._opts);\n  self.on('finish', function() {\n    self.emit('end');\n    self.emit('close');\n  });\n  self._readRecord().catch(function(e) {\n    if (!self.__emittedError || self.__emittedError !== e)\n      self.emit('error', e);\n  });\n}\n\nutil.inherits(Parse, PullStream);\n\nParse.prototype._readRecord = function () {\n  const self = this;\n\n  return self.pull(4).then(function(data) {\n    if (data.length === 0)\n      return;\n\n    const signature = data.readUInt32LE(0);\n\n    if (signature === 0x34327243) {\n      return self._readCrxHeader();\n    }\n    if (signature === 0x04034b50) {\n      return self._readFile();\n    }\n    else if (signature === 0x02014b50) {\n      self.reachedCD = true;\n      return self._readCentralDirectoryFileHeader();\n    }\n    else if (signature === 0x06054b50) {\n      return self._readEndOfCentralDirectoryRecord();\n    }\n    else if (self.reachedCD) {\n      // _readEndOfCentralDirectoryRecord expects the EOCD\n      // signature to be consumed so set includeEof=true\n      const includeEof = true;\n      return self.pull(endDirectorySignature, includeEof).then(function() {\n        return self._readEndOfCentralDirectoryRecord();\n      });\n    }\n    else\n      self.emit('error', new Error('invalid signature: 0x' + signature.toString(16)));\n  }).then((function(loop) {\n    if(loop) {\n      return self._readRecord();\n    }\n  }));\n};\n\nParse.prototype._readCrxHeader = function() {\n  const self = this;\n  return self.pull(12).then(function(data) {\n    self.crxHeader = parseBuffer.parse(data, [\n      ['version', 4],\n      ['pubKeyLength', 4],\n      ['signatureLength', 4],\n    ]);\n    return self.pull(self.crxHeader.pubKeyLength + self.crxHeader.signatureLength);\n  }).then(function(data) {\n    self.crxHeader.publicKey = data.slice(0, self.crxHeader.pubKeyLength);\n    self.crxHeader.signature = data.slice(self.crxHeader.pubKeyLength);\n    self.emit('crx-header', self.crxHeader);\n    return true;\n  });\n};\n\nParse.prototype._readFile = function () {\n  const self = this;\n  return self.pull(26).then(function(data) {\n    const vars = parseBuffer.parse(data, [\n      ['versionsNeededToExtract', 2],\n      ['flags', 2],\n      ['compressionMethod', 2],\n      ['lastModifiedTime', 2],\n      ['lastModifiedDate', 2],\n      ['crc32', 4],\n      ['compressedSize', 4],\n      ['uncompressedSize', 4],\n      ['fileNameLength', 2],\n      ['extraFieldLength', 2],\n    ]);\n\n    vars.lastModifiedDateTime = parseDateTime(vars.lastModifiedDate, vars.lastModifiedTime);\n\n    if (self.crxHeader) vars.crxHeader = self.crxHeader;\n\n    return self.pull(vars.fileNameLength).then(function(fileNameBuffer) {\n      const fileName = fileNameBuffer.toString('utf8');\n      const entry = Stream.PassThrough();\n      let __autodraining = false;\n\n      entry.autodrain = function() {\n        __autodraining = true;\n        const draining = entry.pipe(NoopStream());\n        draining.promise = function() {\n          return new Promise(function(resolve, reject) {\n            draining.on('finish', resolve);\n            draining.on('error', reject);\n          });\n        };\n        return draining;\n      };\n\n      entry.buffer = function() {\n        return BufferStream(entry);\n      };\n\n      entry.path = fileName;\n      entry.props = {};\n      entry.props.path = fileName;\n      entry.props.pathBuffer = fileNameBuffer;\n      entry.props.flags = {\n        \"isUnicode\": (vars.flags & 0x800) != 0\n      };\n      entry.type = (vars.uncompressedSize === 0 && /[/\\\\]$/.test(fileName)) ? 'Directory' : 'File';\n\n      if (self._opts.verbose) {\n        if (entry.type === 'Directory') {\n          console.log('   creating:', fileName);\n        } else if (entry.type === 'File') {\n          if (vars.compressionMethod === 0) {\n            console.log(' extracting:', fileName);\n          } else {\n            console.log('  inflating:', fileName);\n          }\n        }\n      }\n\n      return self.pull(vars.extraFieldLength).then(function(extraField) {\n        const extra = parseExtraField(extraField, vars);\n\n        entry.vars = vars;\n        entry.extra = extra;\n\n        if (self._opts.forceStream) {\n          self.push(entry);\n        } else {\n          self.emit('entry', entry);\n\n          if (self._readableState.pipesCount || (self._readableState.pipes && self._readableState.pipes.length))\n            self.push(entry);\n        }\n\n        if (self._opts.verbose)\n          console.log({\n            filename:fileName,\n            vars: vars,\n            extra: extra\n          });\n\n        const fileSizeKnown = !(vars.flags & 0x08) || vars.compressedSize > 0;\n        let eof;\n\n        entry.__autodraining = __autodraining; // expose __autodraining for test purposes\n        const inflater = (vars.compressionMethod && !__autodraining) ? zlib.createInflateRaw() : Stream.PassThrough();\n\n        if (fileSizeKnown) {\n          entry.size = vars.uncompressedSize;\n          eof = vars.compressedSize;\n        } else {\n          eof = Buffer.alloc(4);\n          eof.writeUInt32LE(0x08074b50, 0);\n        }\n\n        return new Promise(function(resolve, reject) {\n          pipeline(\n            self.stream(eof),\n            inflater,\n            entry,\n            function (err) {\n              if (err) {\n                return reject(err);\n              }\n\n              return fileSizeKnown ? resolve(fileSizeKnown) : self._processDataDescriptor(entry).then(resolve).catch(reject);\n            }\n          );\n        });\n      });\n    });\n  });\n};\n\nParse.prototype._processDataDescriptor = function (entry) {\n  const self = this;\n  return self.pull(16).then(function(data) {\n    const vars = parseBuffer.parse(data, [\n      ['dataDescriptorSignature', 4],\n      ['crc32', 4],\n      ['compressedSize', 4],\n      ['uncompressedSize', 4],\n    ]);\n\n    entry.size = vars.uncompressedSize;\n    return true;\n  });\n};\n\nParse.prototype._readCentralDirectoryFileHeader = function () {\n  const self = this;\n  return self.pull(42).then(function(data) {\n    const vars = parseBuffer.parse(data, [\n      ['versionMadeBy', 2],\n      ['versionsNeededToExtract', 2],\n      ['flags', 2],\n      ['compressionMethod', 2],\n      ['lastModifiedTime', 2],\n      ['lastModifiedDate', 2],\n      ['crc32', 4],\n      ['compressedSize', 4],\n      ['uncompressedSize', 4],\n      ['fileNameLength', 2],\n      ['extraFieldLength', 2],\n      ['fileCommentLength', 2],\n      ['diskNumber', 2],\n      ['internalFileAttributes', 2],\n      ['externalFileAttributes', 4],\n      ['offsetToLocalFileHeader', 4],\n    ]);\n\n    return self.pull(vars.fileNameLength).then(function(fileName) {\n      vars.fileName = fileName.toString('utf8');\n      return self.pull(vars.extraFieldLength);\n    })\n      .then(function() {\n        return self.pull(vars.fileCommentLength);\n      })\n      .then(function() {\n        return true;\n      });\n  });\n};\n\nParse.prototype._readEndOfCentralDirectoryRecord = function() {\n  const self = this;\n  return self.pull(18).then(function(data) {\n\n    const vars = parseBuffer.parse(data, [\n      ['diskNumber', 2],\n      ['diskStart', 2],\n      ['numberOfRecordsOnDisk', 2],\n      ['numberOfRecords', 2],\n      ['sizeOfCentralDirectory', 4],\n      ['offsetToStartOfCentralDirectory', 4],\n      ['commentLength', 2],\n    ]);\n\n    return self.pull(vars.commentLength).then(function() {\n      self.end();\n      self.push(null);\n    });\n\n  });\n};\n\nParse.prototype.promise = function() {\n  const self = this;\n  return new Promise(function(resolve, reject) {\n    self.on('finish', resolve);\n    self.on('error', reject);\n  });\n};\n\nmodule.exports = Parse;\n","const Stream = require('stream');\nconst util = require('util');\nconst strFunction = 'function';\n\nfunction PullStream() {\n  if (!(this instanceof PullStream))\n    return new PullStream();\n\n  Stream.Duplex.call(this, {decodeStrings:false, objectMode:true});\n  this.buffer = Buffer.from('');\n  const self = this;\n  self.on('finish', function() {\n    self.finished = true;\n    self.emit('chunk', false);\n  });\n}\n\nutil.inherits(PullStream, Stream.Duplex);\n\nPullStream.prototype._write = function(chunk, e, cb) {\n  this.buffer = Buffer.concat([this.buffer, chunk]);\n  this.cb = cb;\n  this.emit('chunk');\n};\n\n\n// The `eof` parameter is interpreted as `file_length` if the type is number\n// otherwise (i.e. buffer) it is interpreted as a pattern signaling end of stream\nPullStream.prototype.stream = function(eof, includeEof) {\n  const p = Stream.PassThrough();\n  let done;\n  const self= this;\n\n  function cb() {\n    if (typeof self.cb === strFunction) {\n      const callback = self.cb;\n      self.cb = undefined;\n      return callback();\n    }\n  }\n\n  function pull() {\n    let packet;\n    if (self.buffer && self.buffer.length) {\n      if (typeof eof === 'number') {\n        packet = self.buffer.slice(0, eof);\n        self.buffer = self.buffer.slice(eof);\n        eof -= packet.length;\n        done = done || !eof;\n      } else {\n        let match = self.buffer.indexOf(eof);\n        if (match !== -1) {\n          // store signature match byte offset to allow us to reference\n          // this for zip64 offset\n          self.match = match;\n          if (includeEof) match = match + eof.length;\n          packet = self.buffer.slice(0, match);\n          self.buffer = self.buffer.slice(match);\n          done = true;\n        } else {\n          const len = self.buffer.length - eof.length;\n          if (len <= 0) {\n            cb();\n          } else {\n            packet = self.buffer.slice(0, len);\n            self.buffer = self.buffer.slice(len);\n          }\n        }\n      }\n      if (packet) p.write(packet, function() {\n        if (self.buffer.length === 0 || (eof.length && self.buffer.length <= eof.length)) cb();\n      });\n    }\n\n    if (!done) {\n      if (self.finished) {\n        self.removeListener('chunk', pull);\n        self.emit('error', new Error('FILE_ENDED'));\n        return;\n      }\n\n    } else {\n      self.removeListener('chunk', pull);\n      p.end();\n    }\n  }\n\n  self.on('chunk', pull);\n  pull();\n  return p;\n};\n\nPullStream.prototype.pull = function(eof, includeEof) {\n  if (eof === 0) return Promise.resolve('');\n\n  // If we already have the required data in buffer\n  // we can resolve the request immediately\n  if (!isNaN(eof) && this.buffer.length > eof) {\n    const data = this.buffer.slice(0, eof);\n    this.buffer = this.buffer.slice(eof);\n    return Promise.resolve(data);\n  }\n\n  // Otherwise we stream until we have it\n  let buffer = Buffer.from('');\n  const self = this;\n\n  const concatStream = new Stream.Transform();\n  concatStream._transform = function(d, e, cb) {\n    buffer = Buffer.concat([buffer, d]);\n    cb();\n  };\n\n  let rejectHandler;\n  let pullStreamRejectHandler;\n  return new Promise(function(resolve, reject) {\n    rejectHandler = reject;\n    pullStreamRejectHandler = function(e) {\n      self.__emittedError = e;\n      reject(e);\n    };\n    if (self.finished)\n      return reject(new Error('FILE_ENDED'));\n    self.once('error', pullStreamRejectHandler); // reject any errors from pullstream itself\n    self.stream(eof, includeEof)\n      .on('error', reject)\n      .pipe(concatStream)\n      .on('finish', function() {resolve(buffer);})\n      .on('error', reject);\n  })\n    .finally(function() {\n      self.removeListener('error', rejectHandler);\n      self.removeListener('error', pullStreamRejectHandler);\n    });\n};\n\nPullStream.prototype._read = function(){};\n\nmodule.exports = PullStream;\n","const Stream = require('stream');\nconst util = require('util');\nfunction NoopStream() {\n  if (!(this instanceof NoopStream)) {\n    return new NoopStream();\n  }\n  Stream.Transform.call(this);\n}\n\nutil.inherits(NoopStream, Stream.Transform);\n\nNoopStream.prototype._transform = function(d, e, cb) { cb() ;};\n\nmodule.exports = NoopStream;","const Stream = require('stream');\n\nmodule.exports = function(entry) {\n  return new Promise(function(resolve, reject) {\n    const chunks = [];\n    const bufferStream = Stream.Transform()\n      .on('finish', function() {\n        resolve(Buffer.concat(chunks));\n      })\n      .on('error', reject);\n\n    bufferStream._transform = function(d, e, cb) {\n      chunks.push(d);\n      cb();\n    };\n    entry.on('error', reject)\n      .pipe(bufferStream);\n  });\n};\n","const parseBuffer = require('./parseBuffer');\n\nmodule.exports = function(extraField, vars) {\n  let extra;\n  // Find the ZIP64 header, if present.\n  while(!extra && extraField && extraField.length) {\n    const candidateExtra = parseBuffer.parse(extraField, [\n      ['signature', 2],\n      ['partSize', 2],\n    ]);\n\n    if(candidateExtra.signature === 0x0001) {\n      // parse buffer based on data in ZIP64 central directory; order is important!\n      const fieldsToExpect = [];\n      if (vars.uncompressedSize === 0xffffffff) fieldsToExpect.push(['uncompressedSize', 8]);\n      if (vars.compressedSize === 0xffffffff) fieldsToExpect.push(['compressedSize', 8]);\n      if (vars.offsetToLocalFileHeader === 0xffffffff) fieldsToExpect.push(['offsetToLocalFileHeader', 8]);\n\n      // slice off the 4 bytes for signature and partSize\n      extra = parseBuffer.parse(extraField.slice(4), fieldsToExpect);\n    } else {\n      // Advance the buffer to the next part.\n      // The total size of this part is the 4 byte header + partsize.\n      extraField = extraField.slice(candidateExtra.partSize + 4);\n    }\n  }\n\n  extra = extra || {};\n\n  if (vars.compressedSize === 0xffffffff)\n    vars.compressedSize = extra.compressedSize;\n\n  if (vars.uncompressedSize === 0xffffffff)\n    vars.uncompressedSize= extra.uncompressedSize;\n\n  if (vars.offsetToLocalFileHeader === 0xffffffff)\n    vars.offsetToLocalFileHeader = extra.offsetToLocalFileHeader;\n\n  return extra;\n};\n","const parseUIntLE = function(buffer, offset, size) {\n  let result;\n  switch(size) {\n    case 1:\n      result = buffer.readUInt8(offset);\n      break;\n    case 2:\n      result = buffer.readUInt16LE(offset);\n      break;\n    case 4:\n      result = buffer.readUInt32LE(offset);\n      break;\n    case 8:\n      result = Number(buffer.readBigUInt64LE(offset));\n      break;\n    default:\n      throw new Error('Unsupported UInt LE size!');\n  }\n  return result;\n};\n\n/**\n * Parses sequential unsigned little endian numbers from the head of the passed buffer according to\n * the specified format passed.  If the buffer is not large enough to satisfy the full format,\n * null values will be assigned to the remaining keys.\n * @param {*} buffer The buffer to sequentially extract numbers from.\n * @param {*} format Expected format to follow when extrcting values from the buffer.  A list of list entries\n * with the following structure:\n * [\n *   [\n *     <key>,  // Name of the key to assign the extracted number to.\n *     <size>  // The size in bytes of the number to extract. possible values are 1, 2, 4, 8.\n *   ],\n *   ...\n * ]\n * @returns An object with keys set to their associated extracted values.\n */\nconst parse = function(buffer, format) {\n  const result = {};\n  let offset = 0;\n  for(const [key, size] of format) {\n    if(buffer.length >= offset + size) {\n      result[key] = parseUIntLE(buffer, offset, size);\n    }\n    else {\n      result[key] = null;\n    }\n    offset += size;\n  }\n  return result;\n};\n\nmodule.exports = {\n  parse\n};","// Dates in zip file entries are stored as DosDateTime\n// Spec is here: https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-dosdatetimetofiletime\n\nmodule.exports = function parseDateTime(date, time) {\n  const day = date & 0x1F;\n  const month = date >> 5 & 0x0F;\n  const year = (date >> 9 & 0x7F) + 1980;\n  const seconds = time ? (time & 0x1F) * 2 : 0;\n  const minutes = time ? (time >> 5) & 0x3F : 0;\n  const hours = time ? (time >> 11): 0;\n\n  return new Date(Date.UTC(year, month-1, day, hours, minutes, seconds));\n};","const Stream = require('stream');\nconst Parse = require('./parse');\nconst duplexer2 = require('duplexer2');\nconst BufferStream = require('./BufferStream');\n\nfunction parseOne(match, opts) {\n  const inStream = Stream.PassThrough({objectMode:true});\n  const outStream = Stream.PassThrough();\n  const transform = Stream.Transform({objectMode:true});\n  const re = match instanceof RegExp ? match : (match && new RegExp(match));\n  let found;\n\n  transform._transform = function(entry, e, cb) {\n    if (found || (re && !re.exec(entry.path))) {\n      entry.autodrain();\n      return cb();\n    } else {\n      found = true;\n      out.emit('entry', entry);\n      entry.on('error', function(e) {\n        outStream.emit('error', e);\n      });\n      entry.pipe(outStream)\n        .on('error', function(err) {\n          cb(err);\n        })\n        .on('finish', function(d) {\n          cb(null, d);\n        });\n    }\n  };\n\n  inStream.pipe(Parse(opts))\n    .on('error', function(err) {\n      outStream.emit('error', err);\n    })\n    .pipe(transform)\n    .on('error', Object) // Silence error as its already addressed in transform\n    .on('finish', function() {\n      if (!found)\n        outStream.emit('error', new Error('PATTERN_NOT_FOUND'));\n      else\n        outStream.end();\n    });\n\n  const out = duplexer2(inStream, outStream);\n  out.buffer = function() {\n    return BufferStream(outStream);\n  };\n\n  return out;\n}\n\nmodule.exports = parseOne;\n","\"use strict\";\n\nvar stream = require(\"readable-stream\");\n\nfunction DuplexWrapper(options, writable, readable) {\n  if (typeof readable === \"undefined\") {\n    readable = writable;\n    writable = options;\n    options = null;\n  }\n\n  stream.Duplex.call(this, options);\n\n  if (typeof readable.read !== \"function\") {\n    readable = (new stream.Readable(options)).wrap(readable);\n  }\n\n  this._writable = writable;\n  this._readable = readable;\n  this._waiting = false;\n\n  var self = this;\n\n  writable.once(\"finish\", function() {\n    self.end();\n  });\n\n  this.once(\"finish\", function() {\n    writable.end();\n  });\n\n  readable.on(\"readable\", function() {\n    if (self._waiting) {\n      self._waiting = false;\n      self._read();\n    }\n  });\n\n  readable.once(\"end\", function() {\n    self.push(null);\n  });\n\n  if (!options || typeof options.bubbleErrors === \"undefined\" || options.bubbleErrors) {\n    writable.on(\"error\", function(err) {\n      self.emit(\"error\", err);\n    });\n\n    readable.on(\"error\", function(err) {\n      self.emit(\"error\", err);\n    });\n  }\n}\n\nDuplexWrapper.prototype = Object.create(stream.Duplex.prototype, {constructor: {value: DuplexWrapper}});\n\nDuplexWrapper.prototype._write = function _write(input, encoding, done) {\n  this._writable.write(input, encoding, done);\n};\n\nDuplexWrapper.prototype._read = function _read() {\n  var buf;\n  var reads = 0;\n  while ((buf = this._readable.read()) !== null) {\n    this.push(buf);\n    reads++;\n  }\n  if (reads === 0) {\n    this._waiting = true;\n  }\n};\n\nmodule.exports = function duplex2(options, writable, readable) {\n  return new DuplexWrapper(options, writable, readable);\n};\n\nmodule.exports.DuplexWrapper = DuplexWrapper;\n","var Stream = require('stream');\nif (process.env.READABLE_STREAM === 'disable' && Stream) {\n  module.exports = Stream;\n  exports = module.exports = Stream.Readable;\n  exports.Readable = Stream.Readable;\n  exports.Writable = Stream.Writable;\n  exports.Duplex = Stream.Duplex;\n  exports.Transform = Stream.Transform;\n  exports.PassThrough = Stream.PassThrough;\n  exports.Stream = Stream;\n} else {\n  exports = module.exports = require('./lib/_stream_readable.js');\n  exports.Stream = Stream || exports;\n  exports.Readable = exports;\n  exports.Writable = require('./lib/_stream_writable.js');\n  exports.Duplex = require('./lib/_stream_duplex.js');\n  exports.Transform = require('./lib/_stream_transform.js');\n  exports.PassThrough = require('./lib/_stream_passthrough.js');\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n/*<replacement>*/\n\nvar pna = require('process-nextick-args');\n/*</replacement>*/\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar isArray = require('isarray');\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\n/*<replacement>*/\nvar EE = require('events').EventEmitter;\n\nvar EElistenerCount = function (emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\nvar OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*</replacement>*/\n\n/*<replacement>*/\nvar util = Object.create(require('core-util-is'));\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n/*<replacement>*/\nvar debugUtil = require('util');\nvar debug = void 0;\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function () {};\n}\n/*</replacement>*/\n\nvar BufferList = require('./internal/streams/BufferList');\nvar destroyImpl = require('./internal/streams/destroy');\nvar StringDecoder;\n\nutil.inherits(Readable, Stream);\n\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);\n\n  // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\n\nfunction ReadableState(options, stream) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  var isDuplex = stream instanceof Duplex;\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  var hwm = options.highWaterMark;\n  var readableHwm = options.readableHighWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\n  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  if (!(this instanceof Readable)) return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n\n  Stream.call(this);\n}\n\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  get: function () {\n    if (this._readableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n  }\n});\n\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\nReadable.prototype._destroy = function (err, cb) {\n  this.push(null);\n  cb(err);\n};\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\n\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  var state = stream._readableState;\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n    if (er) {\n      stream.emit('error', er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n\n      if (addToFront) {\n        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        stream.emit('error', new Error('stream.push() after EOF'));\n      } else {\n        state.reading = false;\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n    }\n  }\n\n  return needMoreData(state);\n}\n\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    stream.emit('data', chunk);\n    stream.read(0);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n\n    if (state.needReadable) emitReadable(stream);\n  }\n  maybeReadMore(stream, state);\n}\n\nfunction chunkInvalid(state, chunk) {\n  var er;\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  return er;\n}\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);\n}\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n};\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n  return this;\n};\n\n// Don't raise the hwm > 8MB\nvar MAX_HWM = 0x800000;\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  }\n  // If we're asking for more than the current hwm, then raise the hwm.\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n;\n  // Don't have enough\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n  return state.length;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n\n  if (n !== 0) state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0) state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n    // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = true;\n    n = 0;\n  } else {\n    state.length -= n;\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true;\n\n    // If we tried to read() past the EOF, then emit end on the next tick.\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n\n  if (ret !== null) this.emit('data', ret);\n\n  return ret;\n};\n\nfunction onEofChunk(stream, state) {\n  if (state.ended) return;\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // emit 'readable' now to make sure it gets picked up.\n  emitReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  debug('emit readable');\n  stream.emit('readable');\n  flow(stream);\n}\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    pna.nextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;else len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function (n) {\n  this.emit('error', new Error('_read() is not implemented'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  var cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n\n    cleanedUp = true;\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  // If the user pushes more data while we're writing to dest then we'll end up\n  // in ondata again. However, we only want to increase awaitDrain once because\n  // dest will only emit one 'drain' event for the multiple writes.\n  // => Introduce a guard on increasing awaitDrain.\n  var increasedAwaitDrain = false;\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    increasedAwaitDrain = false;\n    var ret = dest.write(chunk);\n    if (false === ret && !increasedAwaitDrain) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', state.awaitDrain);\n        state.awaitDrain++;\n        increasedAwaitDrain = true;\n      }\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest, 'error', onerror);\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function () {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = { hasUnpiped: false };\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0) return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n\n    if (!dest) dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++) {\n      dests[i].emit('unpipe', this, { hasUnpiped: false });\n    }return this;\n  }\n\n  // try to find the right one.\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this, unpipeInfo);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  if (ev === 'data') {\n    // Start flowing on next tick if stream isn't explicitly paused\n    if (this._readableState.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    var state = this._readableState;\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.emittedReadable = false;\n      if (!state.reading) {\n        pna.nextTick(nReadingNextTick, this);\n      } else if (state.length) {\n        emitReadable(this);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    state.flowing = true;\n    resume(this, state);\n  }\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    pna.nextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  if (!state.reading) {\n    debug('resume read 0');\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  state.awaitDrain = 0;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (false !== this._readableState.flowing) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  while (state.flowing && stream.read() !== null) {}\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function (stream) {\n  var _this = this;\n\n  var state = this._readableState;\n  var paused = false;\n\n  stream.on('end', function () {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) _this.push(chunk);\n    }\n\n    _this.push(null);\n  });\n\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = _this.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function (method) {\n        return function () {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  }\n\n  // proxy certain important events.\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  }\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  this._read = function (n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return this;\n};\n\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._readableState.highWaterMark;\n  }\n});\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = fromListPartial(n, state.buffer, state.decoder);\n  }\n\n  return ret;\n}\n\n// Extracts only enough buffered data to satisfy the amount requested.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromListPartial(n, list, hasStrings) {\n  var ret;\n  if (n < list.head.data.length) {\n    // slice is the same for buffers and strings\n    ret = list.head.data.slice(0, n);\n    list.head.data = list.head.data.slice(n);\n  } else if (n === list.head.data.length) {\n    // first chunk is a perfect match\n    ret = list.shift();\n  } else {\n    // result spans more than one buffer\n    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);\n  }\n  return ret;\n}\n\n// Copies a specified amount of characters from the list of buffered data\n// chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBufferString(n, list) {\n  var p = list.head;\n  var c = 1;\n  var ret = p.data;\n  n -= ret.length;\n  while (p = p.next) {\n    var str = p.data;\n    var nb = n > str.length ? str.length : n;\n    if (nb === str.length) ret += str;else ret += str.slice(0, n);\n    n -= nb;\n    if (n === 0) {\n      if (nb === str.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = str.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\n// Copies a specified amount of bytes from the list of buffered data chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBuffer(n, list) {\n  var ret = Buffer.allocUnsafe(n);\n  var p = list.head;\n  var c = 1;\n  p.data.copy(ret);\n  n -= p.data.length;\n  while (p = p.next) {\n    var buf = p.data;\n    var nb = n > buf.length ? buf.length : n;\n    buf.copy(ret, ret.length - n, 0, nb);\n    n -= nb;\n    if (n === 0) {\n      if (nb === buf.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = buf.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0) throw new Error('\"endReadable()\" called on non-empty stream');\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    pna.nextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  // Check that we didn't get one last unshift.\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n  }\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}","'use strict';\n\nif (typeof process === 'undefined' ||\n    !process.version ||\n    process.version.indexOf('v0.') === 0 ||\n    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {\n  module.exports = { nextTick: nextTick };\n} else {\n  module.exports = process\n}\n\nfunction nextTick(fn, arg1, arg2, arg3) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function');\n  }\n  var len = arguments.length;\n  var args, i;\n  switch (len) {\n  case 0:\n  case 1:\n    return process.nextTick(fn);\n  case 2:\n    return process.nextTick(function afterTickOne() {\n      fn.call(null, arg1);\n    });\n  case 3:\n    return process.nextTick(function afterTickTwo() {\n      fn.call(null, arg1, arg2);\n    });\n  case 4:\n    return process.nextTick(function afterTickThree() {\n      fn.call(null, arg1, arg2, arg3);\n    });\n  default:\n    args = new Array(len - 1);\n    i = 0;\n    while (i < args.length) {\n      args[i++] = arguments[i];\n    }\n    return process.nextTick(function afterTick() {\n      fn.apply(null, args);\n    });\n  }\n}\n\n","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n","module.exports = require('stream');\n","/* eslint-disable node/no-deprecated-api */\nvar buffer = require('buffer')\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\n\nfunction isArray(arg) {\n  if (Array.isArray) {\n    return Array.isArray(arg);\n  }\n  return objectToString(arg) === '[object Array]';\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = require('buffer').Buffer.isBuffer;\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n","try {\n  var util = require('util');\n  /* istanbul ignore next */\n  if (typeof util.inherits !== 'function') throw '';\n  module.exports = util.inherits;\n} catch (e) {\n  /* istanbul ignore next */\n  module.exports = require('./inherits_browser.js');\n}\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n","'use strict';\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Buffer = require('safe-buffer').Buffer;\nvar util = require('util');\n\nfunction copyBuffer(src, target, offset) {\n  src.copy(target, offset);\n}\n\nmodule.exports = function () {\n  function BufferList() {\n    _classCallCheck(this, BufferList);\n\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  BufferList.prototype.push = function push(v) {\n    var entry = { data: v, next: null };\n    if (this.length > 0) this.tail.next = entry;else this.head = entry;\n    this.tail = entry;\n    ++this.length;\n  };\n\n  BufferList.prototype.unshift = function unshift(v) {\n    var entry = { data: v, next: this.head };\n    if (this.length === 0) this.tail = entry;\n    this.head = entry;\n    ++this.length;\n  };\n\n  BufferList.prototype.shift = function shift() {\n    if (this.length === 0) return;\n    var ret = this.head.data;\n    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n    --this.length;\n    return ret;\n  };\n\n  BufferList.prototype.clear = function clear() {\n    this.head = this.tail = null;\n    this.length = 0;\n  };\n\n  BufferList.prototype.join = function join(s) {\n    if (this.length === 0) return '';\n    var p = this.head;\n    var ret = '' + p.data;\n    while (p = p.next) {\n      ret += s + p.data;\n    }return ret;\n  };\n\n  BufferList.prototype.concat = function concat(n) {\n    if (this.length === 0) return Buffer.alloc(0);\n    var ret = Buffer.allocUnsafe(n >>> 0);\n    var p = this.head;\n    var i = 0;\n    while (p) {\n      copyBuffer(p.data, ret, i);\n      i += p.data.length;\n      p = p.next;\n    }\n    return ret;\n  };\n\n  return BufferList;\n}();\n\nif (util && util.inspect && util.inspect.custom) {\n  module.exports.prototype[util.inspect.custom] = function () {\n    var obj = util.inspect({ length: this.length });\n    return this.constructor.name + ' ' + obj;\n  };\n}","'use strict';\n\n/*<replacement>*/\n\nvar pna = require('process-nextick-args');\n/*</replacement>*/\n\n// undocumented cb() API, needed for core, not for public API\nfunction destroy(err, cb) {\n  var _this = this;\n\n  var readableDestroyed = this._readableState && this._readableState.destroyed;\n  var writableDestroyed = this._writableState && this._writableState.destroyed;\n\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err) {\n      if (!this._writableState) {\n        pna.nextTick(emitErrorNT, this, err);\n      } else if (!this._writableState.errorEmitted) {\n        this._writableState.errorEmitted = true;\n        pna.nextTick(emitErrorNT, this, err);\n      }\n    }\n\n    return this;\n  }\n\n  // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  }\n\n  // if this is a duplex stream mark the writable part as destroyed as well\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n\n  this._destroy(err || null, function (err) {\n    if (!cb && err) {\n      if (!_this._writableState) {\n        pna.nextTick(emitErrorNT, _this, err);\n      } else if (!_this._writableState.errorEmitted) {\n        _this._writableState.errorEmitted = true;\n        pna.nextTick(emitErrorNT, _this, err);\n      }\n    } else if (cb) {\n      cb(err);\n    }\n  });\n\n  return this;\n}\n\nfunction undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finalCalled = false;\n    this._writableState.prefinished = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\n\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\n\nmodule.exports = {\n  destroy: destroy,\n  undestroy: undestroy\n};","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\n'use strict';\n\n/*<replacement>*/\n\nvar pna = require('process-nextick-args');\n/*</replacement>*/\n\n/*<replacement>*/\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    keys.push(key);\n  }return keys;\n};\n/*</replacement>*/\n\nmodule.exports = Duplex;\n\n/*<replacement>*/\nvar util = Object.create(require('core-util-is'));\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar Readable = require('./_stream_readable');\nvar Writable = require('./_stream_writable');\n\nutil.inherits(Duplex, Readable);\n\n{\n  // avoid scope creep, the keys array can then be collected\n  var keys = objectKeys(Writable.prototype);\n  for (var v = 0; v < keys.length; v++) {\n    var method = keys[v];\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n  }\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n\n  Readable.call(this, options);\n  Writable.call(this, options);\n\n  if (options && options.readable === false) this.readable = false;\n\n  if (options && options.writable === false) this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;\n\n  this.once('end', onend);\n}\n\nObject.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// the no-half-open enforcer\nfunction onend() {\n  // if we allow half-open state, or if the writable side ended,\n  // then we're ok.\n  if (this.allowHalfOpen || this._writableState.ended) return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  pna.nextTick(onEndNT, this);\n}\n\nfunction onEndNT(self) {\n  self.end();\n}\n\nObject.defineProperty(Duplex.prototype, 'destroyed', {\n  get: function () {\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed && this._writableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n    this._writableState.destroyed = value;\n  }\n});\n\nDuplex.prototype._destroy = function (err, cb) {\n  this.push(null);\n  this.end();\n\n  pna.nextTick(cb, err);\n};","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n'use strict';\n\n/*<replacement>*/\n\nvar pna = require('process-nextick-args');\n/*</replacement>*/\n\nmodule.exports = Writable;\n\n/* <replacement> */\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n}\n\n// It seems a linked list but it is not\n// there will be only 2 of these for each stream\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n  this.finish = function () {\n    onCorkedFinish(_this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\nvar asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n/*<replacement>*/\nvar util = Object.create(require('core-util-is'));\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n/*<replacement>*/\nvar internalUtil = {\n  deprecate: require('util-deprecate')\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\nvar OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*</replacement>*/\n\nvar destroyImpl = require('./internal/streams/destroy');\n\nutil.inherits(Writable, Stream);\n\nfunction nop() {}\n\nfunction WritableState(options, stream) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  var isDuplex = stream instanceof Duplex;\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  var writableHwm = options.writableHighWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\n  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // if _final has been called\n  this.finalCalled = false;\n\n  // drain event flag.\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n\n  // count buffered requests\n  this.bufferedRequestCount = 0;\n\n  // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function () {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})();\n\n// Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\nvar realHasInstance;\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function (object) {\n      if (realHasInstance.call(this, object)) return true;\n      if (this !== Writable) return false;\n\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function (object) {\n    return object instanceof this;\n  };\n}\n\nfunction Writable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {\n    return new Writable(options);\n  }\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n\n    if (typeof options.writev === 'function') this._writev = options.writev;\n\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function () {\n  this.emit('error', new Error('Cannot pipe, not readable'));\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  pna.nextTick(cb, er);\n}\n\n// Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n  var er = false;\n\n  if (chunk === null) {\n    er = new TypeError('May not write null values to stream');\n  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  if (er) {\n    stream.emit('error', er);\n    pna.nextTick(cb, er);\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\n\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n\n  if (typeof cb !== 'function') cb = nop;\n\n  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  var state = this._writableState;\n\n  state.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n  return chunk;\n}\n\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk: chunk,\n      encoding: encoding,\n      isBuf: isBuf,\n      callback: cb,\n      next: null\n    };\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    pna.nextTick(cb, er);\n    // this can emit finish, and it will always happen\n    // after error\n    pna.nextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n    // this can emit finish, but finish must\n    // always follow error\n    finishMaybe(stream, state);\n  }\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state);\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      /*<replacement>*/\n      asyncWrite(afterWrite, stream, state, finished, cb);\n      /*</replacement>*/\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n\n    var count = 0;\n    var allBuffers = true;\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n    buffer.allBuffers = allBuffers;\n\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n    // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new Error('_write() is not implemented'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending) endWritable(this, state, cb);\n};\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\nfunction callFinal(stream, state) {\n  stream._final(function (err) {\n    state.pendingcb--;\n    if (err) {\n      stream.emit('error', err);\n    }\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function') {\n      state.pendingcb++;\n      state.finalCalled = true;\n      pna.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    prefinish(stream, state);\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n    }\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);\n  }\n  state.ended = true;\n  stream.writable = false;\n}\n\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  }\n\n  // reuse the free corkReq.\n  state.corkedRequestsFree.next = corkReq;\n}\n\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  get: function () {\n    if (this._writableState === undefined) {\n      return false;\n    }\n    return this._writableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._writableState.destroyed = value;\n  }\n});\n\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\nWritable.prototype._destroy = function (err, cb) {\n  this.end();\n  cb(err);\n};","\n/**\n * For Node.js, simply re-export the core `util.deprecate` function.\n */\n\nmodule.exports = require('util').deprecate;\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\n/*</replacement>*/\n\nvar isEncoding = Buffer.isEncoding || function (encoding) {\n  encoding = '' + encoding;\n  switch (encoding && encoding.toLowerCase()) {\n    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':\n      return true;\n    default:\n      return false;\n  }\n};\n\nfunction _normalizeEncoding(enc) {\n  if (!enc) return 'utf8';\n  var retried;\n  while (true) {\n    switch (enc) {\n      case 'utf8':\n      case 'utf-8':\n        return 'utf8';\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return 'utf16le';\n      case 'latin1':\n      case 'binary':\n        return 'latin1';\n      case 'base64':\n      case 'ascii':\n      case 'hex':\n        return enc;\n      default:\n        if (retried) return; // undefined\n        enc = ('' + enc).toLowerCase();\n        retried = true;\n    }\n  }\n};\n\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\nfunction normalizeEncoding(enc) {\n  var nenc = _normalizeEncoding(enc);\n  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n  return nenc || enc;\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters.\nexports.StringDecoder = StringDecoder;\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  var nb;\n  switch (this.encoding) {\n    case 'utf16le':\n      this.text = utf16Text;\n      this.end = utf16End;\n      nb = 4;\n      break;\n    case 'utf8':\n      this.fillLast = utf8FillLast;\n      nb = 4;\n      break;\n    case 'base64':\n      this.text = base64Text;\n      this.end = base64End;\n      nb = 3;\n      break;\n    default:\n      this.write = simpleWrite;\n      this.end = simpleEnd;\n      return;\n  }\n  this.lastNeed = 0;\n  this.lastTotal = 0;\n  this.lastChar = Buffer.allocUnsafe(nb);\n}\n\nStringDecoder.prototype.write = function (buf) {\n  if (buf.length === 0) return '';\n  var r;\n  var i;\n  if (this.lastNeed) {\n    r = this.fillLast(buf);\n    if (r === undefined) return '';\n    i = this.lastNeed;\n    this.lastNeed = 0;\n  } else {\n    i = 0;\n  }\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n  return r || '';\n};\n\nStringDecoder.prototype.end = utf8End;\n\n// Returns only complete characters in a Buffer\nStringDecoder.prototype.text = utf8Text;\n\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\nStringDecoder.prototype.fillLast = function (buf) {\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n  this.lastNeed -= buf.length;\n};\n\n// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n// continuation byte. If an invalid byte is detected, -2 is returned.\nfunction utf8CheckByte(byte) {\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n  return byte >> 6 === 0x02 ? -1 : -2;\n}\n\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n// needed to complete the UTF-8 character (if applicable) are returned.\nfunction utf8CheckIncomplete(self, buf, i) {\n  var j = buf.length - 1;\n  if (j < i) return 0;\n  var nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 1;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 2;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) {\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n    }\n    return nb;\n  }\n  return 0;\n}\n\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\n// needed or are available. If we see a non-continuation byte where we expect\n// one, we \"replace\" the validated continuation bytes we've seen so far with\n// a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\n// behavior. The continuation byte check is included three times in the case\n// where all of the continuation bytes for a character exist in the same buffer.\n// It is also done this way as a slight performance increase instead of using a\n// loop.\nfunction utf8CheckExtraBytes(self, buf, p) {\n  if ((buf[0] & 0xC0) !== 0x80) {\n    self.lastNeed = 0;\n    return '\\ufffd';\n  }\n  if (self.lastNeed > 1 && buf.length > 1) {\n    if ((buf[1] & 0xC0) !== 0x80) {\n      self.lastNeed = 1;\n      return '\\ufffd';\n    }\n    if (self.lastNeed > 2 && buf.length > 2) {\n      if ((buf[2] & 0xC0) !== 0x80) {\n        self.lastNeed = 2;\n        return '\\ufffd';\n      }\n    }\n  }\n}\n\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\nfunction utf8FillLast(buf) {\n  var p = this.lastTotal - this.lastNeed;\n  var r = utf8CheckExtraBytes(this, buf, p);\n  if (r !== undefined) return r;\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, p, 0, buf.length);\n  this.lastNeed -= buf.length;\n}\n\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n// partial character, the character's bytes are buffered until the required\n// number of bytes are available.\nfunction utf8Text(buf, i) {\n  var total = utf8CheckIncomplete(this, buf, i);\n  if (!this.lastNeed) return buf.toString('utf8', i);\n  this.lastTotal = total;\n  var end = buf.length - (total - this.lastNeed);\n  buf.copy(this.lastChar, 0, end);\n  return buf.toString('utf8', i, end);\n}\n\n// For UTF-8, a replacement character is added when ending on a partial\n// character.\nfunction utf8End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + '\\ufffd';\n  return r;\n}\n\n// UTF-16LE typically needs two bytes per character, but even if we have an even\n// number of bytes available, we need to check if we end on a leading/high\n// surrogate. In that case, we need to wait for the next two bytes in order to\n// decode the last character properly.\nfunction utf16Text(buf, i) {\n  if ((buf.length - i) % 2 === 0) {\n    var r = buf.toString('utf16le', i);\n    if (r) {\n      var c = r.charCodeAt(r.length - 1);\n      if (c >= 0xD800 && c <= 0xDBFF) {\n        this.lastNeed = 2;\n        this.lastTotal = 4;\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n        return r.slice(0, -1);\n      }\n    }\n    return r;\n  }\n  this.lastNeed = 1;\n  this.lastTotal = 2;\n  this.lastChar[0] = buf[buf.length - 1];\n  return buf.toString('utf16le', i, buf.length - 1);\n}\n\n// For UTF-16LE we do not explicitly append special replacement characters if we\n// end on a partial character, we simply let v8 handle that.\nfunction utf16End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) {\n    var end = this.lastTotal - this.lastNeed;\n    return r + this.lastChar.toString('utf16le', 0, end);\n  }\n  return r;\n}\n\nfunction base64Text(buf, i) {\n  var n = (buf.length - i) % 3;\n  if (n === 0) return buf.toString('base64', i);\n  this.lastNeed = 3 - n;\n  this.lastTotal = 3;\n  if (n === 1) {\n    this.lastChar[0] = buf[buf.length - 1];\n  } else {\n    this.lastChar[0] = buf[buf.length - 2];\n    this.lastChar[1] = buf[buf.length - 1];\n  }\n  return buf.toString('base64', i, buf.length - n);\n}\n\nfunction base64End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n  return r;\n}\n\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\nfunction simpleWrite(buf) {\n  return buf.toString(this.encoding);\n}\n\nfunction simpleEnd(buf) {\n  return buf && buf.length ? this.write(buf) : '';\n}","/* eslint-disable node/no-deprecated-api */\nvar buffer = require('buffer')\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n'use strict';\n\nmodule.exports = Transform;\n\nvar Duplex = require('./_stream_duplex');\n\n/*<replacement>*/\nvar util = Object.create(require('core-util-is'));\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(Transform, Duplex);\n\nfunction afterTransform(er, data) {\n  var ts = this._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb) {\n    return this.emit('error', new Error('write callback called multiple times'));\n  }\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (data != null) // single equals check for both `null` and `undefined`\n    this.push(data);\n\n  cb(er);\n\n  var rs = this._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    this._read(rs.highWaterMark);\n  }\n}\n\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n\n  Duplex.call(this, options);\n\n  this._transformState = {\n    afterTransform: afterTransform.bind(this),\n    needTransform: false,\n    transforming: false,\n    writecb: null,\n    writechunk: null,\n    writeencoding: null\n  };\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  }\n\n  // When the writable side finishes, then flush out anything remaining.\n  this.on('prefinish', prefinish);\n}\n\nfunction prefinish() {\n  var _this = this;\n\n  if (typeof this._flush === 'function') {\n    this._flush(function (er, data) {\n      done(_this, er, data);\n    });\n  } else {\n    done(this, null, null);\n  }\n}\n\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  throw new Error('_transform() is not implemented');\n};\n\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\nTransform.prototype._destroy = function (err, cb) {\n  var _this2 = this;\n\n  Duplex.prototype._destroy.call(this, err, function (err2) {\n    cb(err2);\n    _this2.emit('close');\n  });\n};\n\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n\n  if (data != null) // single equals check for both `null` and `undefined`\n    stream.push(data);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');\n\n  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');\n\n  return stream.push(null);\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n'use strict';\n\nmodule.exports = PassThrough;\n\nvar Transform = require('./_stream_transform');\n\n/*<replacement>*/\nvar util = Object.create(require('core-util-is'));\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\n\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk);\n};","module.exports = Extract;\n\nconst Parse = require('./parse');\nconst fs = require('fs-extra');\nconst path = require('path');\nconst stream = require('stream');\nconst duplexer2 = require('duplexer2');\n\nfunction Extract (opts) {\n  // make sure path is normalized before using it\n  opts.path = path.resolve(path.normalize(opts.path));\n\n  const parser = new Parse(opts);\n\n  const outStream = new stream.Writable({objectMode: true});\n  outStream._write = async function(entry, encoding, cb) {\n\n    // to avoid zip slip (writing outside of the destination), we resolve\n    // the target path, and make sure it's nested in the intended\n    // destination, or not extract it otherwise.\n    // NOTE: Need to normalize to forward slashes for UNIX OS's to properly\n    // ignore the zip slipped file entirely\n    const extractPath = path.join(opts.path, entry.path.replace(/\\\\/g, '/'));\n    if (extractPath.indexOf(opts.path) != 0) {\n      return cb();\n    }\n\n\n    if (entry.type == 'Directory') {\n      await fs.ensureDir(extractPath);\n      return cb();\n    }\n\n    await fs.ensureDir(path.dirname(extractPath));\n\n    const writer = opts.getWriter ? opts.getWriter({path: extractPath}) : fs.createWriteStream(extractPath);\n\n    entry.pipe(writer)\n      .on('error', cb)\n      .on('close', cb);\n  };\n\n  const extract = duplexer2(parser, outStream);\n  parser.once('crx-header', function(crxHeader) {\n    extract.crxHeader = crxHeader;\n  });\n\n  parser\n    .pipe(outStream)\n    .on('finish', function() {\n      extract.emit('close');\n    });\n\n  extract.promise = function() {\n    return new Promise(function(resolve, reject) {\n      extract.on('close', resolve);\n      extract.on('error', reject);\n    });\n  };\n\n  return extract;\n}\n","'use strict'\n\nmodule.exports = {\n  // Export promiseified graceful-fs:\n  ...require('./fs'),\n  // Export extra methods:\n  ...require('./copy'),\n  ...require('./empty'),\n  ...require('./ensure'),\n  ...require('./json'),\n  ...require('./mkdirs'),\n  ...require('./move'),\n  ...require('./output-file'),\n  ...require('./path-exists'),\n  ...require('./remove')\n}\n","'use strict'\n// This is adapted from https://github.com/normalize/mz\n// Copyright (c) 2014-2016 Jonathan Ong me@jongleberry.com and Contributors\nconst u = require('universalify').fromCallback\nconst fs = require('graceful-fs')\n\nconst api = [\n  'access',\n  'appendFile',\n  'chmod',\n  'chown',\n  'close',\n  'copyFile',\n  'cp',\n  'fchmod',\n  'fchown',\n  'fdatasync',\n  'fstat',\n  'fsync',\n  'ftruncate',\n  'futimes',\n  'glob',\n  'lchmod',\n  'lchown',\n  'lutimes',\n  'link',\n  'lstat',\n  'mkdir',\n  'mkdtemp',\n  'open',\n  'opendir',\n  'readdir',\n  'readFile',\n  'readlink',\n  'realpath',\n  'rename',\n  'rm',\n  'rmdir',\n  'stat',\n  'statfs',\n  'symlink',\n  'truncate',\n  'unlink',\n  'utimes',\n  'writeFile'\n].filter(key => {\n  // Some commands are not available on some systems. Ex:\n  // fs.cp was added in Node.js v16.7.0\n  // fs.statfs was added in Node v19.6.0, v18.15.0\n  // fs.glob was added in Node.js v22.0.0\n  // fs.lchown is not available on at least some Linux\n  return typeof fs[key] === 'function'\n})\n\n// Export cloned fs:\nObject.assign(exports, fs)\n\n// Universalify async methods:\napi.forEach(method => {\n  exports[method] = u(fs[method])\n})\n\n// We differ from mz/fs in that we still ship the old, broken, fs.exists()\n// since we are a drop-in replacement for the native module\nexports.exists = function (filename, callback) {\n  if (typeof callback === 'function') {\n    return fs.exists(filename, callback)\n  }\n  return new Promise(resolve => {\n    return fs.exists(filename, resolve)\n  })\n}\n\n// fs.read(), fs.write(), fs.readv(), & fs.writev() need special treatment due to multiple callback args\n\nexports.read = function (fd, buffer, offset, length, position, callback) {\n  if (typeof callback === 'function') {\n    return fs.read(fd, buffer, offset, length, position, callback)\n  }\n  return new Promise((resolve, reject) => {\n    fs.read(fd, buffer, offset, length, position, (err, bytesRead, buffer) => {\n      if (err) return reject(err)\n      resolve({ bytesRead, buffer })\n    })\n  })\n}\n\n// Function signature can be\n// fs.write(fd, buffer[, offset[, length[, position]]], callback)\n// OR\n// fs.write(fd, string[, position[, encoding]], callback)\n// We need to handle both cases, so we use ...args\nexports.write = function (fd, buffer, ...args) {\n  if (typeof args[args.length - 1] === 'function') {\n    return fs.write(fd, buffer, ...args)\n  }\n\n  return new Promise((resolve, reject) => {\n    fs.write(fd, buffer, ...args, (err, bytesWritten, buffer) => {\n      if (err) return reject(err)\n      resolve({ bytesWritten, buffer })\n    })\n  })\n}\n\n// Function signature is\n// s.readv(fd, buffers[, position], callback)\n// We need to handle the optional arg, so we use ...args\nexports.readv = function (fd, buffers, ...args) {\n  if (typeof args[args.length - 1] === 'function') {\n    return fs.readv(fd, buffers, ...args)\n  }\n\n  return new Promise((resolve, reject) => {\n    fs.readv(fd, buffers, ...args, (err, bytesRead, buffers) => {\n      if (err) return reject(err)\n      resolve({ bytesRead, buffers })\n    })\n  })\n}\n\n// Function signature is\n// s.writev(fd, buffers[, position], callback)\n// We need to handle the optional arg, so we use ...args\nexports.writev = function (fd, buffers, ...args) {\n  if (typeof args[args.length - 1] === 'function') {\n    return fs.writev(fd, buffers, ...args)\n  }\n\n  return new Promise((resolve, reject) => {\n    fs.writev(fd, buffers, ...args, (err, bytesWritten, buffers) => {\n      if (err) return reject(err)\n      resolve({ bytesWritten, buffers })\n    })\n  })\n}\n\n// fs.realpath.native sometimes not available if fs is monkey-patched\nif (typeof fs.realpath.native === 'function') {\n  exports.realpath.native = u(fs.realpath.native)\n} else {\n  process.emitWarning(\n    'fs.realpath.native is not a function. Is fs being monkey-patched?',\n    'Warning', 'fs-extra-WARN0003'\n  )\n}\n","'use strict'\n\nexports.fromCallback = function (fn) {\n  return Object.defineProperty(function (...args) {\n    if (typeof args[args.length - 1] === 'function') fn.apply(this, args)\n    else {\n      return new Promise((resolve, reject) => {\n        args.push((err, res) => (err != null) ? reject(err) : resolve(res))\n        fn.apply(this, args)\n      })\n    }\n  }, 'name', { value: fn.name })\n}\n\nexports.fromPromise = function (fn) {\n  return Object.defineProperty(function (...args) {\n    const cb = args[args.length - 1]\n    if (typeof cb !== 'function') return fn.apply(this, args)\n    else {\n      args.pop()\n      fn.apply(this, args).then(r => cb(null, r), cb)\n    }\n  }, 'name', { value: fn.name })\n}\n","var fs = require('fs')\nvar polyfills = require('./polyfills.js')\nvar legacy = require('./legacy-streams.js')\nvar clone = require('./clone.js')\n\nvar util = require('util')\n\n/* istanbul ignore next - node 0.x polyfill */\nvar gracefulQueue\nvar previousSymbol\n\n/* istanbul ignore else - node 0.x polyfill */\nif (typeof Symbol === 'function' && typeof Symbol.for === 'function') {\n  gracefulQueue = Symbol.for('graceful-fs.queue')\n  // This is used in testing by future versions\n  previousSymbol = Symbol.for('graceful-fs.previous')\n} else {\n  gracefulQueue = '___graceful-fs.queue'\n  previousSymbol = '___graceful-fs.previous'\n}\n\nfunction noop () {}\n\nfunction publishQueue(context, queue) {\n  Object.defineProperty(context, gracefulQueue, {\n    get: function() {\n      return queue\n    }\n  })\n}\n\nvar debug = noop\nif (util.debuglog)\n  debug = util.debuglog('gfs4')\nelse if (/\\bgfs4\\b/i.test(process.env.NODE_DEBUG || ''))\n  debug = function() {\n    var m = util.format.apply(util, arguments)\n    m = 'GFS4: ' + m.split(/\\n/).join('\\nGFS4: ')\n    console.error(m)\n  }\n\n// Once time initialization\nif (!fs[gracefulQueue]) {\n  // This queue can be shared by multiple loaded instances\n  var queue = global[gracefulQueue] || []\n  publishQueue(fs, queue)\n\n  // Patch fs.close/closeSync to shared queue version, because we need\n  // to retry() whenever a close happens *anywhere* in the program.\n  // This is essential when multiple graceful-fs instances are\n  // in play at the same time.\n  fs.close = (function (fs$close) {\n    function close (fd, cb) {\n      return fs$close.call(fs, fd, function (err) {\n        // This function uses the graceful-fs shared queue\n        if (!err) {\n          resetQueue()\n        }\n\n        if (typeof cb === 'function')\n          cb.apply(this, arguments)\n      })\n    }\n\n    Object.defineProperty(close, previousSymbol, {\n      value: fs$close\n    })\n    return close\n  })(fs.close)\n\n  fs.closeSync = (function (fs$closeSync) {\n    function closeSync (fd) {\n      // This function uses the graceful-fs shared queue\n      fs$closeSync.apply(fs, arguments)\n      resetQueue()\n    }\n\n    Object.defineProperty(closeSync, previousSymbol, {\n      value: fs$closeSync\n    })\n    return closeSync\n  })(fs.closeSync)\n\n  if (/\\bgfs4\\b/i.test(process.env.NODE_DEBUG || '')) {\n    process.on('exit', function() {\n      debug(fs[gracefulQueue])\n      require('assert').equal(fs[gracefulQueue].length, 0)\n    })\n  }\n}\n\nif (!global[gracefulQueue]) {\n  publishQueue(global, fs[gracefulQueue]);\n}\n\nmodule.exports = patch(clone(fs))\nif (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched) {\n    module.exports = patch(fs)\n    fs.__patched = true;\n}\n\nfunction patch (fs) {\n  // Everything that references the open() function needs to be in here\n  polyfills(fs)\n  fs.gracefulify = patch\n\n  fs.createReadStream = createReadStream\n  fs.createWriteStream = createWriteStream\n  var fs$readFile = fs.readFile\n  fs.readFile = readFile\n  function readFile (path, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$readFile(path, options, cb)\n\n    function go$readFile (path, options, cb, startTime) {\n      return fs$readFile(path, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$readFile, [path, options, cb], err, startTime || Date.now(), Date.now()])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n        }\n      })\n    }\n  }\n\n  var fs$writeFile = fs.writeFile\n  fs.writeFile = writeFile\n  function writeFile (path, data, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$writeFile(path, data, options, cb)\n\n    function go$writeFile (path, data, options, cb, startTime) {\n      return fs$writeFile(path, data, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$writeFile, [path, data, options, cb], err, startTime || Date.now(), Date.now()])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n        }\n      })\n    }\n  }\n\n  var fs$appendFile = fs.appendFile\n  if (fs$appendFile)\n    fs.appendFile = appendFile\n  function appendFile (path, data, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$appendFile(path, data, options, cb)\n\n    function go$appendFile (path, data, options, cb, startTime) {\n      return fs$appendFile(path, data, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$appendFile, [path, data, options, cb], err, startTime || Date.now(), Date.now()])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n        }\n      })\n    }\n  }\n\n  var fs$copyFile = fs.copyFile\n  if (fs$copyFile)\n    fs.copyFile = copyFile\n  function copyFile (src, dest, flags, cb) {\n    if (typeof flags === 'function') {\n      cb = flags\n      flags = 0\n    }\n    return go$copyFile(src, dest, flags, cb)\n\n    function go$copyFile (src, dest, flags, cb, startTime) {\n      return fs$copyFile(src, dest, flags, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$copyFile, [src, dest, flags, cb], err, startTime || Date.now(), Date.now()])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n        }\n      })\n    }\n  }\n\n  var fs$readdir = fs.readdir\n  fs.readdir = readdir\n  var noReaddirOptionVersions = /^v[0-5]\\./\n  function readdir (path, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    var go$readdir = noReaddirOptionVersions.test(process.version)\n      ? function go$readdir (path, options, cb, startTime) {\n        return fs$readdir(path, fs$readdirCallback(\n          path, options, cb, startTime\n        ))\n      }\n      : function go$readdir (path, options, cb, startTime) {\n        return fs$readdir(path, options, fs$readdirCallback(\n          path, options, cb, startTime\n        ))\n      }\n\n    return go$readdir(path, options, cb)\n\n    function fs$readdirCallback (path, options, cb, startTime) {\n      return function (err, files) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([\n            go$readdir,\n            [path, options, cb],\n            err,\n            startTime || Date.now(),\n            Date.now()\n          ])\n        else {\n          if (files && files.sort)\n            files.sort()\n\n          if (typeof cb === 'function')\n            cb.call(this, err, files)\n        }\n      }\n    }\n  }\n\n  if (process.version.substr(0, 4) === 'v0.8') {\n    var legStreams = legacy(fs)\n    ReadStream = legStreams.ReadStream\n    WriteStream = legStreams.WriteStream\n  }\n\n  var fs$ReadStream = fs.ReadStream\n  if (fs$ReadStream) {\n    ReadStream.prototype = Object.create(fs$ReadStream.prototype)\n    ReadStream.prototype.open = ReadStream$open\n  }\n\n  var fs$WriteStream = fs.WriteStream\n  if (fs$WriteStream) {\n    WriteStream.prototype = Object.create(fs$WriteStream.prototype)\n    WriteStream.prototype.open = WriteStream$open\n  }\n\n  Object.defineProperty(fs, 'ReadStream', {\n    get: function () {\n      return ReadStream\n    },\n    set: function (val) {\n      ReadStream = val\n    },\n    enumerable: true,\n    configurable: true\n  })\n  Object.defineProperty(fs, 'WriteStream', {\n    get: function () {\n      return WriteStream\n    },\n    set: function (val) {\n      WriteStream = val\n    },\n    enumerable: true,\n    configurable: true\n  })\n\n  // legacy names\n  var FileReadStream = ReadStream\n  Object.defineProperty(fs, 'FileReadStream', {\n    get: function () {\n      return FileReadStream\n    },\n    set: function (val) {\n      FileReadStream = val\n    },\n    enumerable: true,\n    configurable: true\n  })\n  var FileWriteStream = WriteStream\n  Object.defineProperty(fs, 'FileWriteStream', {\n    get: function () {\n      return FileWriteStream\n    },\n    set: function (val) {\n      FileWriteStream = val\n    },\n    enumerable: true,\n    configurable: true\n  })\n\n  function ReadStream (path, options) {\n    if (this instanceof ReadStream)\n      return fs$ReadStream.apply(this, arguments), this\n    else\n      return ReadStream.apply(Object.create(ReadStream.prototype), arguments)\n  }\n\n  function ReadStream$open () {\n    var that = this\n    open(that.path, that.flags, that.mode, function (err, fd) {\n      if (err) {\n        if (that.autoClose)\n          that.destroy()\n\n        that.emit('error', err)\n      } else {\n        that.fd = fd\n        that.emit('open', fd)\n        that.read()\n      }\n    })\n  }\n\n  function WriteStream (path, options) {\n    if (this instanceof WriteStream)\n      return fs$WriteStream.apply(this, arguments), this\n    else\n      return WriteStream.apply(Object.create(WriteStream.prototype), arguments)\n  }\n\n  function WriteStream$open () {\n    var that = this\n    open(that.path, that.flags, that.mode, function (err, fd) {\n      if (err) {\n        that.destroy()\n        that.emit('error', err)\n      } else {\n        that.fd = fd\n        that.emit('open', fd)\n      }\n    })\n  }\n\n  function createReadStream (path, options) {\n    return new fs.ReadStream(path, options)\n  }\n\n  function createWriteStream (path, options) {\n    return new fs.WriteStream(path, options)\n  }\n\n  var fs$open = fs.open\n  fs.open = open\n  function open (path, flags, mode, cb) {\n    if (typeof mode === 'function')\n      cb = mode, mode = null\n\n    return go$open(path, flags, mode, cb)\n\n    function go$open (path, flags, mode, cb, startTime) {\n      return fs$open(path, flags, mode, function (err, fd) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$open, [path, flags, mode, cb], err, startTime || Date.now(), Date.now()])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n        }\n      })\n    }\n  }\n\n  return fs\n}\n\nfunction enqueue (elem) {\n  debug('ENQUEUE', elem[0].name, elem[1])\n  fs[gracefulQueue].push(elem)\n  retry()\n}\n\n// keep track of the timeout between retry() calls\nvar retryTimer\n\n// reset the startTime and lastTime to now\n// this resets the start of the 60 second overall timeout as well as the\n// delay between attempts so that we'll retry these jobs sooner\nfunction resetQueue () {\n  var now = Date.now()\n  for (var i = 0; i < fs[gracefulQueue].length; ++i) {\n    // entries that are only a length of 2 are from an older version, don't\n    // bother modifying those since they'll be retried anyway.\n    if (fs[gracefulQueue][i].length > 2) {\n      fs[gracefulQueue][i][3] = now // startTime\n      fs[gracefulQueue][i][4] = now // lastTime\n    }\n  }\n  // call retry to make sure we're actively processing the queue\n  retry()\n}\n\nfunction retry () {\n  // clear the timer and remove it to help prevent unintended concurrency\n  clearTimeout(retryTimer)\n  retryTimer = undefined\n\n  if (fs[gracefulQueue].length === 0)\n    return\n\n  var elem = fs[gracefulQueue].shift()\n  var fn = elem[0]\n  var args = elem[1]\n  // these items may be unset if they were added by an older graceful-fs\n  var err = elem[2]\n  var startTime = elem[3]\n  var lastTime = elem[4]\n\n  // if we don't have a startTime we have no way of knowing if we've waited\n  // long enough, so go ahead and retry this item now\n  if (startTime === undefined) {\n    debug('RETRY', fn.name, args)\n    fn.apply(null, args)\n  } else if (Date.now() - startTime >= 60000) {\n    // it's been more than 60 seconds total, bail now\n    debug('TIMEOUT', fn.name, args)\n    var cb = args.pop()\n    if (typeof cb === 'function')\n      cb.call(null, err)\n  } else {\n    // the amount of time between the last attempt and right now\n    var sinceAttempt = Date.now() - lastTime\n    // the amount of time between when we first tried, and when we last tried\n    // rounded up to at least 1\n    var sinceStart = Math.max(lastTime - startTime, 1)\n    // backoff. wait longer than the total time we've been retrying, but only\n    // up to a maximum of 100ms\n    var desiredDelay = Math.min(sinceStart * 1.2, 100)\n    // it's been long enough since the last retry, do it again\n    if (sinceAttempt >= desiredDelay) {\n      debug('RETRY', fn.name, args)\n      fn.apply(null, args.concat([startTime]))\n    } else {\n      // if we can't do this job yet, push it to the end of the queue\n      // and let the next iteration check again\n      fs[gracefulQueue].push(elem)\n    }\n  }\n\n  // schedule our next run if one isn't already scheduled\n  if (retryTimer === undefined) {\n    retryTimer = setTimeout(retry, 0)\n  }\n}\n","var constants = require('constants')\n\nvar origCwd = process.cwd\nvar cwd = null\n\nvar platform = process.env.GRACEFUL_FS_PLATFORM || process.platform\n\nprocess.cwd = function() {\n  if (!cwd)\n    cwd = origCwd.call(process)\n  return cwd\n}\ntry {\n  process.cwd()\n} catch (er) {}\n\n// This check is needed until node.js 12 is required\nif (typeof process.chdir === 'function') {\n  var chdir = process.chdir\n  process.chdir = function (d) {\n    cwd = null\n    chdir.call(process, d)\n  }\n  if (Object.setPrototypeOf) Object.setPrototypeOf(process.chdir, chdir)\n}\n\nmodule.exports = patch\n\nfunction patch (fs) {\n  // (re-)implement some things that are known busted or missing.\n\n  // lchmod, broken prior to 0.6.2\n  // back-port the fix here.\n  if (constants.hasOwnProperty('O_SYMLINK') &&\n      process.version.match(/^v0\\.6\\.[0-2]|^v0\\.5\\./)) {\n    patchLchmod(fs)\n  }\n\n  // lutimes implementation, or no-op\n  if (!fs.lutimes) {\n    patchLutimes(fs)\n  }\n\n  // https://github.com/isaacs/node-graceful-fs/issues/4\n  // Chown should not fail on einval or eperm if non-root.\n  // It should not fail on enosys ever, as this just indicates\n  // that a fs doesn't support the intended operation.\n\n  fs.chown = chownFix(fs.chown)\n  fs.fchown = chownFix(fs.fchown)\n  fs.lchown = chownFix(fs.lchown)\n\n  fs.chmod = chmodFix(fs.chmod)\n  fs.fchmod = chmodFix(fs.fchmod)\n  fs.lchmod = chmodFix(fs.lchmod)\n\n  fs.chownSync = chownFixSync(fs.chownSync)\n  fs.fchownSync = chownFixSync(fs.fchownSync)\n  fs.lchownSync = chownFixSync(fs.lchownSync)\n\n  fs.chmodSync = chmodFixSync(fs.chmodSync)\n  fs.fchmodSync = chmodFixSync(fs.fchmodSync)\n  fs.lchmodSync = chmodFixSync(fs.lchmodSync)\n\n  fs.stat = statFix(fs.stat)\n  fs.fstat = statFix(fs.fstat)\n  fs.lstat = statFix(fs.lstat)\n\n  fs.statSync = statFixSync(fs.statSync)\n  fs.fstatSync = statFixSync(fs.fstatSync)\n  fs.lstatSync = statFixSync(fs.lstatSync)\n\n  // if lchmod/lchown do not exist, then make them no-ops\n  if (fs.chmod && !fs.lchmod) {\n    fs.lchmod = function (path, mode, cb) {\n      if (cb) process.nextTick(cb)\n    }\n    fs.lchmodSync = function () {}\n  }\n  if (fs.chown && !fs.lchown) {\n    fs.lchown = function (path, uid, gid, cb) {\n      if (cb) process.nextTick(cb)\n    }\n    fs.lchownSync = function () {}\n  }\n\n  // on Windows, A/V software can lock the directory, causing this\n  // to fail with an EACCES or EPERM if the directory contains newly\n  // created files.  Try again on failure, for up to 60 seconds.\n\n  // Set the timeout this long because some Windows Anti-Virus, such as Parity\n  // bit9, may lock files for up to a minute, causing npm package install\n  // failures. Also, take care to yield the scheduler. Windows scheduling gives\n  // CPU to a busy looping process, which can cause the program causing the lock\n  // contention to be starved of CPU by node, so the contention doesn't resolve.\n  if (platform === \"win32\") {\n    fs.rename = typeof fs.rename !== 'function' ? fs.rename\n    : (function (fs$rename) {\n      function rename (from, to, cb) {\n        var start = Date.now()\n        var backoff = 0;\n        fs$rename(from, to, function CB (er) {\n          if (er\n              && (er.code === \"EACCES\" || er.code === \"EPERM\" || er.code === \"EBUSY\")\n              && Date.now() - start < 60000) {\n            setTimeout(function() {\n              fs.stat(to, function (stater, st) {\n                if (stater && stater.code === \"ENOENT\")\n                  fs$rename(from, to, CB);\n                else\n                  cb(er)\n              })\n            }, backoff)\n            if (backoff < 100)\n              backoff += 10;\n            return;\n          }\n          if (cb) cb(er)\n        })\n      }\n      if (Object.setPrototypeOf) Object.setPrototypeOf(rename, fs$rename)\n      return rename\n    })(fs.rename)\n  }\n\n  // if read() returns EAGAIN, then just try it again.\n  fs.read = typeof fs.read !== 'function' ? fs.read\n  : (function (fs$read) {\n    function read (fd, buffer, offset, length, position, callback_) {\n      var callback\n      if (callback_ && typeof callback_ === 'function') {\n        var eagCounter = 0\n        callback = function (er, _, __) {\n          if (er && er.code === 'EAGAIN' && eagCounter < 10) {\n            eagCounter ++\n            return fs$read.call(fs, fd, buffer, offset, length, position, callback)\n          }\n          callback_.apply(this, arguments)\n        }\n      }\n      return fs$read.call(fs, fd, buffer, offset, length, position, callback)\n    }\n\n    // This ensures `util.promisify` works as it does for native `fs.read`.\n    if (Object.setPrototypeOf) Object.setPrototypeOf(read, fs$read)\n    return read\n  })(fs.read)\n\n  fs.readSync = typeof fs.readSync !== 'function' ? fs.readSync\n  : (function (fs$readSync) { return function (fd, buffer, offset, length, position) {\n    var eagCounter = 0\n    while (true) {\n      try {\n        return fs$readSync.call(fs, fd, buffer, offset, length, position)\n      } catch (er) {\n        if (er.code === 'EAGAIN' && eagCounter < 10) {\n          eagCounter ++\n          continue\n        }\n        throw er\n      }\n    }\n  }})(fs.readSync)\n\n  function patchLchmod (fs) {\n    fs.lchmod = function (path, mode, callback) {\n      fs.open( path\n             , constants.O_WRONLY | constants.O_SYMLINK\n             , mode\n             , function (err, fd) {\n        if (err) {\n          if (callback) callback(err)\n          return\n        }\n        // prefer to return the chmod error, if one occurs,\n        // but still try to close, and report closing errors if they occur.\n        fs.fchmod(fd, mode, function (err) {\n          fs.close(fd, function(err2) {\n            if (callback) callback(err || err2)\n          })\n        })\n      })\n    }\n\n    fs.lchmodSync = function (path, mode) {\n      var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode)\n\n      // prefer to return the chmod error, if one occurs,\n      // but still try to close, and report closing errors if they occur.\n      var threw = true\n      var ret\n      try {\n        ret = fs.fchmodSync(fd, mode)\n        threw = false\n      } finally {\n        if (threw) {\n          try {\n            fs.closeSync(fd)\n          } catch (er) {}\n        } else {\n          fs.closeSync(fd)\n        }\n      }\n      return ret\n    }\n  }\n\n  function patchLutimes (fs) {\n    if (constants.hasOwnProperty(\"O_SYMLINK\") && fs.futimes) {\n      fs.lutimes = function (path, at, mt, cb) {\n        fs.open(path, constants.O_SYMLINK, function (er, fd) {\n          if (er) {\n            if (cb) cb(er)\n            return\n          }\n          fs.futimes(fd, at, mt, function (er) {\n            fs.close(fd, function (er2) {\n              if (cb) cb(er || er2)\n            })\n          })\n        })\n      }\n\n      fs.lutimesSync = function (path, at, mt) {\n        var fd = fs.openSync(path, constants.O_SYMLINK)\n        var ret\n        var threw = true\n        try {\n          ret = fs.futimesSync(fd, at, mt)\n          threw = false\n        } finally {\n          if (threw) {\n            try {\n              fs.closeSync(fd)\n            } catch (er) {}\n          } else {\n            fs.closeSync(fd)\n          }\n        }\n        return ret\n      }\n\n    } else if (fs.futimes) {\n      fs.lutimes = function (_a, _b, _c, cb) { if (cb) process.nextTick(cb) }\n      fs.lutimesSync = function () {}\n    }\n  }\n\n  function chmodFix (orig) {\n    if (!orig) return orig\n    return function (target, mode, cb) {\n      return orig.call(fs, target, mode, function (er) {\n        if (chownErOk(er)) er = null\n        if (cb) cb.apply(this, arguments)\n      })\n    }\n  }\n\n  function chmodFixSync (orig) {\n    if (!orig) return orig\n    return function (target, mode) {\n      try {\n        return orig.call(fs, target, mode)\n      } catch (er) {\n        if (!chownErOk(er)) throw er\n      }\n    }\n  }\n\n\n  function chownFix (orig) {\n    if (!orig) return orig\n    return function (target, uid, gid, cb) {\n      return orig.call(fs, target, uid, gid, function (er) {\n        if (chownErOk(er)) er = null\n        if (cb) cb.apply(this, arguments)\n      })\n    }\n  }\n\n  function chownFixSync (orig) {\n    if (!orig) return orig\n    return function (target, uid, gid) {\n      try {\n        return orig.call(fs, target, uid, gid)\n      } catch (er) {\n        if (!chownErOk(er)) throw er\n      }\n    }\n  }\n\n  function statFix (orig) {\n    if (!orig) return orig\n    // Older versions of Node erroneously returned signed integers for\n    // uid + gid.\n    return function (target, options, cb) {\n      if (typeof options === 'function') {\n        cb = options\n        options = null\n      }\n      function callback (er, stats) {\n        if (stats) {\n          if (stats.uid < 0) stats.uid += 0x100000000\n          if (stats.gid < 0) stats.gid += 0x100000000\n        }\n        if (cb) cb.apply(this, arguments)\n      }\n      return options ? orig.call(fs, target, options, callback)\n        : orig.call(fs, target, callback)\n    }\n  }\n\n  function statFixSync (orig) {\n    if (!orig) return orig\n    // Older versions of Node erroneously returned signed integers for\n    // uid + gid.\n    return function (target, options) {\n      var stats = options ? orig.call(fs, target, options)\n        : orig.call(fs, target)\n      if (stats) {\n        if (stats.uid < 0) stats.uid += 0x100000000\n        if (stats.gid < 0) stats.gid += 0x100000000\n      }\n      return stats;\n    }\n  }\n\n  // ENOSYS means that the fs doesn't support the op. Just ignore\n  // that, because it doesn't matter.\n  //\n  // if there's no getuid, or if getuid() is something other\n  // than 0, and the error is EINVAL or EPERM, then just ignore\n  // it.\n  //\n  // This specific case is a silent failure in cp, install, tar,\n  // and most other unix tools that manage permissions.\n  //\n  // When running as root, or if other types of errors are\n  // encountered, then it's strict.\n  function chownErOk (er) {\n    if (!er)\n      return true\n\n    if (er.code === \"ENOSYS\")\n      return true\n\n    var nonroot = !process.getuid || process.getuid() !== 0\n    if (nonroot) {\n      if (er.code === \"EINVAL\" || er.code === \"EPERM\")\n        return true\n    }\n\n    return false\n  }\n}\n","module.exports = require(\"constants\");","var Stream = require('stream').Stream\n\nmodule.exports = legacy\n\nfunction legacy (fs) {\n  return {\n    ReadStream: ReadStream,\n    WriteStream: WriteStream\n  }\n\n  function ReadStream (path, options) {\n    if (!(this instanceof ReadStream)) return new ReadStream(path, options);\n\n    Stream.call(this);\n\n    var self = this;\n\n    this.path = path;\n    this.fd = null;\n    this.readable = true;\n    this.paused = false;\n\n    this.flags = 'r';\n    this.mode = 438; /*=0666*/\n    this.bufferSize = 64 * 1024;\n\n    options = options || {};\n\n    // Mixin options into this\n    var keys = Object.keys(options);\n    for (var index = 0, length = keys.length; index < length; index++) {\n      var key = keys[index];\n      this[key] = options[key];\n    }\n\n    if (this.encoding) this.setEncoding(this.encoding);\n\n    if (this.start !== undefined) {\n      if ('number' !== typeof this.start) {\n        throw TypeError('start must be a Number');\n      }\n      if (this.end === undefined) {\n        this.end = Infinity;\n      } else if ('number' !== typeof this.end) {\n        throw TypeError('end must be a Number');\n      }\n\n      if (this.start > this.end) {\n        throw new Error('start must be <= end');\n      }\n\n      this.pos = this.start;\n    }\n\n    if (this.fd !== null) {\n      process.nextTick(function() {\n        self._read();\n      });\n      return;\n    }\n\n    fs.open(this.path, this.flags, this.mode, function (err, fd) {\n      if (err) {\n        self.emit('error', err);\n        self.readable = false;\n        return;\n      }\n\n      self.fd = fd;\n      self.emit('open', fd);\n      self._read();\n    })\n  }\n\n  function WriteStream (path, options) {\n    if (!(this instanceof WriteStream)) return new WriteStream(path, options);\n\n    Stream.call(this);\n\n    this.path = path;\n    this.fd = null;\n    this.writable = true;\n\n    this.flags = 'w';\n    this.encoding = 'binary';\n    this.mode = 438; /*=0666*/\n    this.bytesWritten = 0;\n\n    options = options || {};\n\n    // Mixin options into this\n    var keys = Object.keys(options);\n    for (var index = 0, length = keys.length; index < length; index++) {\n      var key = keys[index];\n      this[key] = options[key];\n    }\n\n    if (this.start !== undefined) {\n      if ('number' !== typeof this.start) {\n        throw TypeError('start must be a Number');\n      }\n      if (this.start < 0) {\n        throw new Error('start must be >= zero');\n      }\n\n      this.pos = this.start;\n    }\n\n    this.busy = false;\n    this._queue = [];\n\n    if (this.fd === null) {\n      this._open = fs.open;\n      this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);\n      this.flush();\n    }\n  }\n}\n","'use strict'\n\nmodule.exports = clone\n\nvar getPrototypeOf = Object.getPrototypeOf || function (obj) {\n  return obj.__proto__\n}\n\nfunction clone (obj) {\n  if (obj === null || typeof obj !== 'object')\n    return obj\n\n  if (obj instanceof Object)\n    var copy = { __proto__: getPrototypeOf(obj) }\n  else\n    var copy = Object.create(null)\n\n  Object.getOwnPropertyNames(obj).forEach(function (key) {\n    Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key))\n  })\n\n  return copy\n}\n","module.exports = require(\"assert\");","'use strict'\n\nconst u = require('universalify').fromPromise\nmodule.exports = {\n  copy: u(require('./copy')),\n  copySync: require('./copy-sync')\n}\n","'use strict'\n\nconst fs = require('../fs')\nconst path = require('path')\nconst { mkdirs } = require('../mkdirs')\nconst { pathExists } = require('../path-exists')\nconst { utimesMillis } = require('../util/utimes')\nconst stat = require('../util/stat')\n\nasync function copy (src, dest, opts = {}) {\n  if (typeof opts === 'function') {\n    opts = { filter: opts }\n  }\n\n  opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now\n  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber\n\n  // Warn about using preserveTimestamps on 32-bit node\n  if (opts.preserveTimestamps && process.arch === 'ia32') {\n    process.emitWarning(\n      'Using the preserveTimestamps option in 32-bit node is not recommended;\\n\\n' +\n      '\\tsee https://github.com/jprichardson/node-fs-extra/issues/269',\n      'Warning', 'fs-extra-WARN0001'\n    )\n  }\n\n  const { srcStat, destStat } = await stat.checkPaths(src, dest, 'copy', opts)\n\n  await stat.checkParentPaths(src, srcStat, dest, 'copy')\n\n  const include = await runFilter(src, dest, opts)\n\n  if (!include) return\n\n  // check if the parent of dest exists, and create it if it doesn't exist\n  const destParent = path.dirname(dest)\n  const dirExists = await pathExists(destParent)\n  if (!dirExists) {\n    await mkdirs(destParent)\n  }\n\n  await getStatsAndPerformCopy(destStat, src, dest, opts)\n}\n\nasync function runFilter (src, dest, opts) {\n  if (!opts.filter) return true\n  return opts.filter(src, dest)\n}\n\nasync function getStatsAndPerformCopy (destStat, src, dest, opts) {\n  const statFn = opts.dereference ? fs.stat : fs.lstat\n  const srcStat = await statFn(src)\n\n  if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts)\n\n  if (\n    srcStat.isFile() ||\n    srcStat.isCharacterDevice() ||\n    srcStat.isBlockDevice()\n  ) return onFile(srcStat, destStat, src, dest, opts)\n\n  if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts)\n  if (srcStat.isSocket()) throw new Error(`Cannot copy a socket file: ${src}`)\n  if (srcStat.isFIFO()) throw new Error(`Cannot copy a FIFO pipe: ${src}`)\n  throw new Error(`Unknown file: ${src}`)\n}\n\nasync function onFile (srcStat, destStat, src, dest, opts) {\n  if (!destStat) return copyFile(srcStat, src, dest, opts)\n\n  if (opts.overwrite) {\n    await fs.unlink(dest)\n    return copyFile(srcStat, src, dest, opts)\n  }\n  if (opts.errorOnExist) {\n    throw new Error(`'${dest}' already exists`)\n  }\n}\n\nasync function copyFile (srcStat, src, dest, opts) {\n  await fs.copyFile(src, dest)\n  if (opts.preserveTimestamps) {\n    // Make sure the file is writable before setting the timestamp\n    // otherwise open fails with EPERM when invoked with 'r+'\n    // (through utimes call)\n    if (fileIsNotWritable(srcStat.mode)) {\n      await makeFileWritable(dest, srcStat.mode)\n    }\n\n    // Set timestamps and mode correspondingly\n\n    // Note that The initial srcStat.atime cannot be trusted\n    // because it is modified by the read(2) system call\n    // (See https://nodejs.org/api/fs.html#fs_stat_time_values)\n    const updatedSrcStat = await fs.stat(src)\n    await utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime)\n  }\n\n  return fs.chmod(dest, srcStat.mode)\n}\n\nfunction fileIsNotWritable (srcMode) {\n  return (srcMode & 0o200) === 0\n}\n\nfunction makeFileWritable (dest, srcMode) {\n  return fs.chmod(dest, srcMode | 0o200)\n}\n\nasync function onDir (srcStat, destStat, src, dest, opts) {\n  // the dest directory might not exist, create it\n  if (!destStat) {\n    await fs.mkdir(dest)\n  }\n\n  const promises = []\n\n  // loop through the files in the current directory to copy everything\n  for await (const item of await fs.opendir(src)) {\n    const srcItem = path.join(src, item.name)\n    const destItem = path.join(dest, item.name)\n\n    promises.push(\n      runFilter(srcItem, destItem, opts).then(include => {\n        if (include) {\n          // only copy the item if it matches the filter function\n          return stat.checkPaths(srcItem, destItem, 'copy', opts).then(({ destStat }) => {\n            // If the item is a copyable file, `getStatsAndPerformCopy` will copy it\n            // If the item is a directory, `getStatsAndPerformCopy` will call `onDir` recursively\n            return getStatsAndPerformCopy(destStat, srcItem, destItem, opts)\n          })\n        }\n      })\n    )\n  }\n\n  await Promise.all(promises)\n\n  if (!destStat) {\n    await fs.chmod(dest, srcStat.mode)\n  }\n}\n\nasync function onLink (destStat, src, dest, opts) {\n  let resolvedSrc = await fs.readlink(src)\n  if (opts.dereference) {\n    resolvedSrc = path.resolve(process.cwd(), resolvedSrc)\n  }\n  if (!destStat) {\n    return fs.symlink(resolvedSrc, dest)\n  }\n\n  let resolvedDest = null\n  try {\n    resolvedDest = await fs.readlink(dest)\n  } catch (e) {\n    // dest exists and is a regular file or directory,\n    // Windows may throw UNKNOWN error. If dest already exists,\n    // fs throws error anyway, so no need to guard against it here.\n    if (e.code === 'EINVAL' || e.code === 'UNKNOWN') return fs.symlink(resolvedSrc, dest)\n    throw e\n  }\n  if (opts.dereference) {\n    resolvedDest = path.resolve(process.cwd(), resolvedDest)\n  }\n  if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {\n    throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`)\n  }\n\n  // do not copy if src is a subdir of dest since unlinking\n  // dest in this case would result in removing src contents\n  // and therefore a broken symlink would be created.\n  if (stat.isSrcSubdir(resolvedDest, resolvedSrc)) {\n    throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`)\n  }\n\n  // copy the link\n  await fs.unlink(dest)\n  return fs.symlink(resolvedSrc, dest)\n}\n\nmodule.exports = copy\n","'use strict'\nconst u = require('universalify').fromPromise\nconst { makeDir: _makeDir, makeDirSync } = require('./make-dir')\nconst makeDir = u(_makeDir)\n\nmodule.exports = {\n  mkdirs: makeDir,\n  mkdirsSync: makeDirSync,\n  // alias\n  mkdirp: makeDir,\n  mkdirpSync: makeDirSync,\n  ensureDir: makeDir,\n  ensureDirSync: makeDirSync\n}\n","'use strict'\nconst fs = require('../fs')\nconst { checkPath } = require('./utils')\n\nconst getMode = options => {\n  const defaults = { mode: 0o777 }\n  if (typeof options === 'number') return options\n  return ({ ...defaults, ...options }).mode\n}\n\nmodule.exports.makeDir = async (dir, options) => {\n  checkPath(dir)\n\n  return fs.mkdir(dir, {\n    mode: getMode(options),\n    recursive: true\n  })\n}\n\nmodule.exports.makeDirSync = (dir, options) => {\n  checkPath(dir)\n\n  return fs.mkdirSync(dir, {\n    mode: getMode(options),\n    recursive: true\n  })\n}\n","// Adapted from https://github.com/sindresorhus/make-dir\n// Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n'use strict'\nconst path = require('path')\n\n// https://github.com/nodejs/node/issues/8987\n// https://github.com/libuv/libuv/pull/1088\nmodule.exports.checkPath = function checkPath (pth) {\n  if (process.platform === 'win32') {\n    const pathHasInvalidWinCharacters = /[<>:\"|?*]/.test(pth.replace(path.parse(pth).root, ''))\n\n    if (pathHasInvalidWinCharacters) {\n      const error = new Error(`Path contains invalid characters: ${pth}`)\n      error.code = 'EINVAL'\n      throw error\n    }\n  }\n}\n","'use strict'\nconst u = require('universalify').fromPromise\nconst fs = require('../fs')\n\nfunction pathExists (path) {\n  return fs.access(path).then(() => true).catch(() => false)\n}\n\nmodule.exports = {\n  pathExists: u(pathExists),\n  pathExistsSync: fs.existsSync\n}\n","'use strict'\n\nconst fs = require('../fs')\nconst u = require('universalify').fromPromise\n\nasync function utimesMillis (path, atime, mtime) {\n  // if (!HAS_MILLIS_RES) return fs.utimes(path, atime, mtime, callback)\n  const fd = await fs.open(path, 'r+')\n\n  let closeErr = null\n\n  try {\n    await fs.futimes(fd, atime, mtime)\n  } finally {\n    try {\n      await fs.close(fd)\n    } catch (e) {\n      closeErr = e\n    }\n  }\n\n  if (closeErr) {\n    throw closeErr\n  }\n}\n\nfunction utimesMillisSync (path, atime, mtime) {\n  const fd = fs.openSync(path, 'r+')\n  fs.futimesSync(fd, atime, mtime)\n  return fs.closeSync(fd)\n}\n\nmodule.exports = {\n  utimesMillis: u(utimesMillis),\n  utimesMillisSync\n}\n","'use strict'\n\nconst fs = require('../fs')\nconst path = require('path')\nconst u = require('universalify').fromPromise\n\nfunction getStats (src, dest, opts) {\n  const statFunc = opts.dereference\n    ? (file) => fs.stat(file, { bigint: true })\n    : (file) => fs.lstat(file, { bigint: true })\n  return Promise.all([\n    statFunc(src),\n    statFunc(dest).catch(err => {\n      if (err.code === 'ENOENT') return null\n      throw err\n    })\n  ]).then(([srcStat, destStat]) => ({ srcStat, destStat }))\n}\n\nfunction getStatsSync (src, dest, opts) {\n  let destStat\n  const statFunc = opts.dereference\n    ? (file) => fs.statSync(file, { bigint: true })\n    : (file) => fs.lstatSync(file, { bigint: true })\n  const srcStat = statFunc(src)\n  try {\n    destStat = statFunc(dest)\n  } catch (err) {\n    if (err.code === 'ENOENT') return { srcStat, destStat: null }\n    throw err\n  }\n  return { srcStat, destStat }\n}\n\nasync function checkPaths (src, dest, funcName, opts) {\n  const { srcStat, destStat } = await getStats(src, dest, opts)\n  if (destStat) {\n    if (areIdentical(srcStat, destStat)) {\n      const srcBaseName = path.basename(src)\n      const destBaseName = path.basename(dest)\n      if (funcName === 'move' &&\n        srcBaseName !== destBaseName &&\n        srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {\n        return { srcStat, destStat, isChangingCase: true }\n      }\n      throw new Error('Source and destination must not be the same.')\n    }\n    if (srcStat.isDirectory() && !destStat.isDirectory()) {\n      throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`)\n    }\n    if (!srcStat.isDirectory() && destStat.isDirectory()) {\n      throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`)\n    }\n  }\n\n  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n    throw new Error(errMsg(src, dest, funcName))\n  }\n\n  return { srcStat, destStat }\n}\n\nfunction checkPathsSync (src, dest, funcName, opts) {\n  const { srcStat, destStat } = getStatsSync(src, dest, opts)\n\n  if (destStat) {\n    if (areIdentical(srcStat, destStat)) {\n      const srcBaseName = path.basename(src)\n      const destBaseName = path.basename(dest)\n      if (funcName === 'move' &&\n        srcBaseName !== destBaseName &&\n        srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {\n        return { srcStat, destStat, isChangingCase: true }\n      }\n      throw new Error('Source and destination must not be the same.')\n    }\n    if (srcStat.isDirectory() && !destStat.isDirectory()) {\n      throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`)\n    }\n    if (!srcStat.isDirectory() && destStat.isDirectory()) {\n      throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`)\n    }\n  }\n\n  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n    throw new Error(errMsg(src, dest, funcName))\n  }\n  return { srcStat, destStat }\n}\n\n// recursively check if dest parent is a subdirectory of src.\n// It works for all file types including symlinks since it\n// checks the src and dest inodes. It starts from the deepest\n// parent and stops once it reaches the src parent or the root path.\nasync function checkParentPaths (src, srcStat, dest, funcName) {\n  const srcParent = path.resolve(path.dirname(src))\n  const destParent = path.resolve(path.dirname(dest))\n  if (destParent === srcParent || destParent === path.parse(destParent).root) return\n\n  let destStat\n  try {\n    destStat = await fs.stat(destParent, { bigint: true })\n  } catch (err) {\n    if (err.code === 'ENOENT') return\n    throw err\n  }\n\n  if (areIdentical(srcStat, destStat)) {\n    throw new Error(errMsg(src, dest, funcName))\n  }\n\n  return checkParentPaths(src, srcStat, destParent, funcName)\n}\n\nfunction checkParentPathsSync (src, srcStat, dest, funcName) {\n  const srcParent = path.resolve(path.dirname(src))\n  const destParent = path.resolve(path.dirname(dest))\n  if (destParent === srcParent || destParent === path.parse(destParent).root) return\n  let destStat\n  try {\n    destStat = fs.statSync(destParent, { bigint: true })\n  } catch (err) {\n    if (err.code === 'ENOENT') return\n    throw err\n  }\n  if (areIdentical(srcStat, destStat)) {\n    throw new Error(errMsg(src, dest, funcName))\n  }\n  return checkParentPathsSync(src, srcStat, destParent, funcName)\n}\n\nfunction areIdentical (srcStat, destStat) {\n  return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev\n}\n\n// return true if dest is a subdir of src, otherwise false.\n// It only checks the path strings.\nfunction isSrcSubdir (src, dest) {\n  const srcArr = path.resolve(src).split(path.sep).filter(i => i)\n  const destArr = path.resolve(dest).split(path.sep).filter(i => i)\n  return srcArr.every((cur, i) => destArr[i] === cur)\n}\n\nfunction errMsg (src, dest, funcName) {\n  return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`\n}\n\nmodule.exports = {\n  // checkPaths\n  checkPaths: u(checkPaths),\n  checkPathsSync,\n  // checkParent\n  checkParentPaths: u(checkParentPaths),\n  checkParentPathsSync,\n  // Misc\n  isSrcSubdir,\n  areIdentical\n}\n","'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst mkdirsSync = require('../mkdirs').mkdirsSync\nconst utimesMillisSync = require('../util/utimes').utimesMillisSync\nconst stat = require('../util/stat')\n\nfunction copySync (src, dest, opts) {\n  if (typeof opts === 'function') {\n    opts = { filter: opts }\n  }\n\n  opts = opts || {}\n  opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now\n  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber\n\n  // Warn about using preserveTimestamps on 32-bit node\n  if (opts.preserveTimestamps && process.arch === 'ia32') {\n    process.emitWarning(\n      'Using the preserveTimestamps option in 32-bit node is not recommended;\\n\\n' +\n      '\\tsee https://github.com/jprichardson/node-fs-extra/issues/269',\n      'Warning', 'fs-extra-WARN0002'\n    )\n  }\n\n  const { srcStat, destStat } = stat.checkPathsSync(src, dest, 'copy', opts)\n  stat.checkParentPathsSync(src, srcStat, dest, 'copy')\n  if (opts.filter && !opts.filter(src, dest)) return\n  const destParent = path.dirname(dest)\n  if (!fs.existsSync(destParent)) mkdirsSync(destParent)\n  return getStats(destStat, src, dest, opts)\n}\n\nfunction getStats (destStat, src, dest, opts) {\n  const statSync = opts.dereference ? fs.statSync : fs.lstatSync\n  const srcStat = statSync(src)\n\n  if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts)\n  else if (srcStat.isFile() ||\n           srcStat.isCharacterDevice() ||\n           srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts)\n  else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts)\n  else if (srcStat.isSocket()) throw new Error(`Cannot copy a socket file: ${src}`)\n  else if (srcStat.isFIFO()) throw new Error(`Cannot copy a FIFO pipe: ${src}`)\n  throw new Error(`Unknown file: ${src}`)\n}\n\nfunction onFile (srcStat, destStat, src, dest, opts) {\n  if (!destStat) return copyFile(srcStat, src, dest, opts)\n  return mayCopyFile(srcStat, src, dest, opts)\n}\n\nfunction mayCopyFile (srcStat, src, dest, opts) {\n  if (opts.overwrite) {\n    fs.unlinkSync(dest)\n    return copyFile(srcStat, src, dest, opts)\n  } else if (opts.errorOnExist) {\n    throw new Error(`'${dest}' already exists`)\n  }\n}\n\nfunction copyFile (srcStat, src, dest, opts) {\n  fs.copyFileSync(src, dest)\n  if (opts.preserveTimestamps) handleTimestamps(srcStat.mode, src, dest)\n  return setDestMode(dest, srcStat.mode)\n}\n\nfunction handleTimestamps (srcMode, src, dest) {\n  // Make sure the file is writable before setting the timestamp\n  // otherwise open fails with EPERM when invoked with 'r+'\n  // (through utimes call)\n  if (fileIsNotWritable(srcMode)) makeFileWritable(dest, srcMode)\n  return setDestTimestamps(src, dest)\n}\n\nfunction fileIsNotWritable (srcMode) {\n  return (srcMode & 0o200) === 0\n}\n\nfunction makeFileWritable (dest, srcMode) {\n  return setDestMode(dest, srcMode | 0o200)\n}\n\nfunction setDestMode (dest, srcMode) {\n  return fs.chmodSync(dest, srcMode)\n}\n\nfunction setDestTimestamps (src, dest) {\n  // The initial srcStat.atime cannot be trusted\n  // because it is modified by the read(2) system call\n  // (See https://nodejs.org/api/fs.html#fs_stat_time_values)\n  const updatedSrcStat = fs.statSync(src)\n  return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime)\n}\n\nfunction onDir (srcStat, destStat, src, dest, opts) {\n  if (!destStat) return mkDirAndCopy(srcStat.mode, src, dest, opts)\n  return copyDir(src, dest, opts)\n}\n\nfunction mkDirAndCopy (srcMode, src, dest, opts) {\n  fs.mkdirSync(dest)\n  copyDir(src, dest, opts)\n  return setDestMode(dest, srcMode)\n}\n\nfunction copyDir (src, dest, opts) {\n  const dir = fs.opendirSync(src)\n\n  try {\n    let dirent\n\n    while ((dirent = dir.readSync()) !== null) {\n      copyDirItem(dirent.name, src, dest, opts)\n    }\n  } finally {\n    dir.closeSync()\n  }\n}\n\nfunction copyDirItem (item, src, dest, opts) {\n  const srcItem = path.join(src, item)\n  const destItem = path.join(dest, item)\n  if (opts.filter && !opts.filter(srcItem, destItem)) return\n  const { destStat } = stat.checkPathsSync(srcItem, destItem, 'copy', opts)\n  return getStats(destStat, srcItem, destItem, opts)\n}\n\nfunction onLink (destStat, src, dest, opts) {\n  let resolvedSrc = fs.readlinkSync(src)\n  if (opts.dereference) {\n    resolvedSrc = path.resolve(process.cwd(), resolvedSrc)\n  }\n\n  if (!destStat) {\n    return fs.symlinkSync(resolvedSrc, dest)\n  } else {\n    let resolvedDest\n    try {\n      resolvedDest = fs.readlinkSync(dest)\n    } catch (err) {\n      // dest exists and is a regular file or directory,\n      // Windows may throw UNKNOWN error. If dest already exists,\n      // fs throws error anyway, so no need to guard against it here.\n      if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlinkSync(resolvedSrc, dest)\n      throw err\n    }\n    if (opts.dereference) {\n      resolvedDest = path.resolve(process.cwd(), resolvedDest)\n    }\n    if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {\n      throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`)\n    }\n\n    // prevent copy if src is a subdir of dest since unlinking\n    // dest in this case would result in removing src contents\n    // and therefore a broken symlink would be created.\n    if (stat.isSrcSubdir(resolvedDest, resolvedSrc)) {\n      throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`)\n    }\n    return copyLink(resolvedSrc, dest)\n  }\n}\n\nfunction copyLink (resolvedSrc, dest) {\n  fs.unlinkSync(dest)\n  return fs.symlinkSync(resolvedSrc, dest)\n}\n\nmodule.exports = copySync\n","'use strict'\n\nconst u = require('universalify').fromPromise\nconst fs = require('../fs')\nconst path = require('path')\nconst mkdir = require('../mkdirs')\nconst remove = require('../remove')\n\nconst emptyDir = u(async function emptyDir (dir) {\n  let items\n  try {\n    items = await fs.readdir(dir)\n  } catch {\n    return mkdir.mkdirs(dir)\n  }\n\n  return Promise.all(items.map(item => remove.remove(path.join(dir, item))))\n})\n\nfunction emptyDirSync (dir) {\n  let items\n  try {\n    items = fs.readdirSync(dir)\n  } catch {\n    return mkdir.mkdirsSync(dir)\n  }\n\n  items.forEach(item => {\n    item = path.join(dir, item)\n    remove.removeSync(item)\n  })\n}\n\nmodule.exports = {\n  emptyDirSync,\n  emptydirSync: emptyDirSync,\n  emptyDir,\n  emptydir: emptyDir\n}\n","'use strict'\n\nconst fs = require('graceful-fs')\nconst u = require('universalify').fromCallback\n\nfunction remove (path, callback) {\n  fs.rm(path, { recursive: true, force: true }, callback)\n}\n\nfunction removeSync (path) {\n  fs.rmSync(path, { recursive: true, force: true })\n}\n\nmodule.exports = {\n  remove: u(remove),\n  removeSync\n}\n","'use strict'\n\nconst { createFile, createFileSync } = require('./file')\nconst { createLink, createLinkSync } = require('./link')\nconst { createSymlink, createSymlinkSync } = require('./symlink')\n\nmodule.exports = {\n  // file\n  createFile,\n  createFileSync,\n  ensureFile: createFile,\n  ensureFileSync: createFileSync,\n  // link\n  createLink,\n  createLinkSync,\n  ensureLink: createLink,\n  ensureLinkSync: createLinkSync,\n  // symlink\n  createSymlink,\n  createSymlinkSync,\n  ensureSymlink: createSymlink,\n  ensureSymlinkSync: createSymlinkSync\n}\n","'use strict'\n\nconst u = require('universalify').fromPromise\nconst path = require('path')\nconst fs = require('../fs')\nconst mkdir = require('../mkdirs')\n\nasync function createFile (file) {\n  let stats\n  try {\n    stats = await fs.stat(file)\n  } catch { }\n  if (stats && stats.isFile()) return\n\n  const dir = path.dirname(file)\n\n  let dirStats = null\n  try {\n    dirStats = await fs.stat(dir)\n  } catch (err) {\n    // if the directory doesn't exist, make it\n    if (err.code === 'ENOENT') {\n      await mkdir.mkdirs(dir)\n      await fs.writeFile(file, '')\n      return\n    } else {\n      throw err\n    }\n  }\n\n  if (dirStats.isDirectory()) {\n    await fs.writeFile(file, '')\n  } else {\n    // parent is not a directory\n    // This is just to cause an internal ENOTDIR error to be thrown\n    await fs.readdir(dir)\n  }\n}\n\nfunction createFileSync (file) {\n  let stats\n  try {\n    stats = fs.statSync(file)\n  } catch { }\n  if (stats && stats.isFile()) return\n\n  const dir = path.dirname(file)\n  try {\n    if (!fs.statSync(dir).isDirectory()) {\n      // parent is not a directory\n      // This is just to cause an internal ENOTDIR error to be thrown\n      fs.readdirSync(dir)\n    }\n  } catch (err) {\n    // If the stat call above failed because the directory doesn't exist, create it\n    if (err && err.code === 'ENOENT') mkdir.mkdirsSync(dir)\n    else throw err\n  }\n\n  fs.writeFileSync(file, '')\n}\n\nmodule.exports = {\n  createFile: u(createFile),\n  createFileSync\n}\n","'use strict'\n\nconst u = require('universalify').fromPromise\nconst path = require('path')\nconst fs = require('../fs')\nconst mkdir = require('../mkdirs')\nconst { pathExists } = require('../path-exists')\nconst { areIdentical } = require('../util/stat')\n\nasync function createLink (srcpath, dstpath) {\n  let dstStat\n  try {\n    dstStat = await fs.lstat(dstpath)\n  } catch {\n    // ignore error\n  }\n\n  let srcStat\n  try {\n    srcStat = await fs.lstat(srcpath)\n  } catch (err) {\n    err.message = err.message.replace('lstat', 'ensureLink')\n    throw err\n  }\n\n  if (dstStat && areIdentical(srcStat, dstStat)) return\n\n  const dir = path.dirname(dstpath)\n\n  const dirExists = await pathExists(dir)\n\n  if (!dirExists) {\n    await mkdir.mkdirs(dir)\n  }\n\n  await fs.link(srcpath, dstpath)\n}\n\nfunction createLinkSync (srcpath, dstpath) {\n  let dstStat\n  try {\n    dstStat = fs.lstatSync(dstpath)\n  } catch {}\n\n  try {\n    const srcStat = fs.lstatSync(srcpath)\n    if (dstStat && areIdentical(srcStat, dstStat)) return\n  } catch (err) {\n    err.message = err.message.replace('lstat', 'ensureLink')\n    throw err\n  }\n\n  const dir = path.dirname(dstpath)\n  const dirExists = fs.existsSync(dir)\n  if (dirExists) return fs.linkSync(srcpath, dstpath)\n  mkdir.mkdirsSync(dir)\n\n  return fs.linkSync(srcpath, dstpath)\n}\n\nmodule.exports = {\n  createLink: u(createLink),\n  createLinkSync\n}\n","'use strict'\n\nconst u = require('universalify').fromPromise\nconst path = require('path')\nconst fs = require('../fs')\n\nconst { mkdirs, mkdirsSync } = require('../mkdirs')\n\nconst { symlinkPaths, symlinkPathsSync } = require('./symlink-paths')\nconst { symlinkType, symlinkTypeSync } = require('./symlink-type')\n\nconst { pathExists } = require('../path-exists')\n\nconst { areIdentical } = require('../util/stat')\n\nasync function createSymlink (srcpath, dstpath, type) {\n  let stats\n  try {\n    stats = await fs.lstat(dstpath)\n  } catch { }\n\n  if (stats && stats.isSymbolicLink()) {\n    const [srcStat, dstStat] = await Promise.all([\n      fs.stat(srcpath),\n      fs.stat(dstpath)\n    ])\n\n    if (areIdentical(srcStat, dstStat)) return\n  }\n\n  const relative = await symlinkPaths(srcpath, dstpath)\n  srcpath = relative.toDst\n  const toType = await symlinkType(relative.toCwd, type)\n  const dir = path.dirname(dstpath)\n\n  if (!(await pathExists(dir))) {\n    await mkdirs(dir)\n  }\n\n  return fs.symlink(srcpath, dstpath, toType)\n}\n\nfunction createSymlinkSync (srcpath, dstpath, type) {\n  let stats\n  try {\n    stats = fs.lstatSync(dstpath)\n  } catch { }\n  if (stats && stats.isSymbolicLink()) {\n    const srcStat = fs.statSync(srcpath)\n    const dstStat = fs.statSync(dstpath)\n    if (areIdentical(srcStat, dstStat)) return\n  }\n\n  const relative = symlinkPathsSync(srcpath, dstpath)\n  srcpath = relative.toDst\n  type = symlinkTypeSync(relative.toCwd, type)\n  const dir = path.dirname(dstpath)\n  const exists = fs.existsSync(dir)\n  if (exists) return fs.symlinkSync(srcpath, dstpath, type)\n  mkdirsSync(dir)\n  return fs.symlinkSync(srcpath, dstpath, type)\n}\n\nmodule.exports = {\n  createSymlink: u(createSymlink),\n  createSymlinkSync\n}\n","'use strict'\n\nconst path = require('path')\nconst fs = require('../fs')\nconst { pathExists } = require('../path-exists')\n\nconst u = require('universalify').fromPromise\n\n/**\n * Function that returns two types of paths, one relative to symlink, and one\n * relative to the current working directory. Checks if path is absolute or\n * relative. If the path is relative, this function checks if the path is\n * relative to symlink or relative to current working directory. This is an\n * initiative to find a smarter `srcpath` to supply when building symlinks.\n * This allows you to determine which path to use out of one of three possible\n * types of source paths. The first is an absolute path. This is detected by\n * `path.isAbsolute()`. When an absolute path is provided, it is checked to\n * see if it exists. If it does it's used, if not an error is returned\n * (callback)/ thrown (sync). The other two options for `srcpath` are a\n * relative url. By default Node's `fs.symlink` works by creating a symlink\n * using `dstpath` and expects the `srcpath` to be relative to the newly\n * created symlink. If you provide a `srcpath` that does not exist on the file\n * system it results in a broken symlink. To minimize this, the function\n * checks to see if the 'relative to symlink' source file exists, and if it\n * does it will use it. If it does not, it checks if there's a file that\n * exists that is relative to the current working directory, if does its used.\n * This preserves the expectations of the original fs.symlink spec and adds\n * the ability to pass in `relative to current working direcotry` paths.\n */\n\nasync function symlinkPaths (srcpath, dstpath) {\n  if (path.isAbsolute(srcpath)) {\n    try {\n      await fs.lstat(srcpath)\n    } catch (err) {\n      err.message = err.message.replace('lstat', 'ensureSymlink')\n      throw err\n    }\n\n    return {\n      toCwd: srcpath,\n      toDst: srcpath\n    }\n  }\n\n  const dstdir = path.dirname(dstpath)\n  const relativeToDst = path.join(dstdir, srcpath)\n\n  const exists = await pathExists(relativeToDst)\n  if (exists) {\n    return {\n      toCwd: relativeToDst,\n      toDst: srcpath\n    }\n  }\n\n  try {\n    await fs.lstat(srcpath)\n  } catch (err) {\n    err.message = err.message.replace('lstat', 'ensureSymlink')\n    throw err\n  }\n\n  return {\n    toCwd: srcpath,\n    toDst: path.relative(dstdir, srcpath)\n  }\n}\n\nfunction symlinkPathsSync (srcpath, dstpath) {\n  if (path.isAbsolute(srcpath)) {\n    const exists = fs.existsSync(srcpath)\n    if (!exists) throw new Error('absolute srcpath does not exist')\n    return {\n      toCwd: srcpath,\n      toDst: srcpath\n    }\n  }\n\n  const dstdir = path.dirname(dstpath)\n  const relativeToDst = path.join(dstdir, srcpath)\n  const exists = fs.existsSync(relativeToDst)\n  if (exists) {\n    return {\n      toCwd: relativeToDst,\n      toDst: srcpath\n    }\n  }\n\n  const srcExists = fs.existsSync(srcpath)\n  if (!srcExists) throw new Error('relative srcpath does not exist')\n  return {\n    toCwd: srcpath,\n    toDst: path.relative(dstdir, srcpath)\n  }\n}\n\nmodule.exports = {\n  symlinkPaths: u(symlinkPaths),\n  symlinkPathsSync\n}\n","'use strict'\n\nconst fs = require('../fs')\nconst u = require('universalify').fromPromise\n\nasync function symlinkType (srcpath, type) {\n  if (type) return type\n\n  let stats\n  try {\n    stats = await fs.lstat(srcpath)\n  } catch {\n    return 'file'\n  }\n\n  return (stats && stats.isDirectory()) ? 'dir' : 'file'\n}\n\nfunction symlinkTypeSync (srcpath, type) {\n  if (type) return type\n\n  let stats\n  try {\n    stats = fs.lstatSync(srcpath)\n  } catch {\n    return 'file'\n  }\n  return (stats && stats.isDirectory()) ? 'dir' : 'file'\n}\n\nmodule.exports = {\n  symlinkType: u(symlinkType),\n  symlinkTypeSync\n}\n","'use strict'\n\nconst u = require('universalify').fromPromise\nconst jsonFile = require('./jsonfile')\n\njsonFile.outputJson = u(require('./output-json'))\njsonFile.outputJsonSync = require('./output-json-sync')\n// aliases\njsonFile.outputJSON = jsonFile.outputJson\njsonFile.outputJSONSync = jsonFile.outputJsonSync\njsonFile.writeJSON = jsonFile.writeJson\njsonFile.writeJSONSync = jsonFile.writeJsonSync\njsonFile.readJSON = jsonFile.readJson\njsonFile.readJSONSync = jsonFile.readJsonSync\n\nmodule.exports = jsonFile\n","'use strict'\n\nconst jsonFile = require('jsonfile')\n\nmodule.exports = {\n  // jsonfile exports\n  readJson: jsonFile.readFile,\n  readJsonSync: jsonFile.readFileSync,\n  writeJson: jsonFile.writeFile,\n  writeJsonSync: jsonFile.writeFileSync\n}\n","let _fs\ntry {\n  _fs = require('graceful-fs')\n} catch (_) {\n  _fs = require('fs')\n}\nconst universalify = require('universalify')\nconst { stringify, stripBom } = require('./utils')\n\nasync function _readFile (file, options = {}) {\n  if (typeof options === 'string') {\n    options = { encoding: options }\n  }\n\n  const fs = options.fs || _fs\n\n  const shouldThrow = 'throws' in options ? options.throws : true\n\n  let data = await universalify.fromCallback(fs.readFile)(file, options)\n\n  data = stripBom(data)\n\n  let obj\n  try {\n    obj = JSON.parse(data, options ? options.reviver : null)\n  } catch (err) {\n    if (shouldThrow) {\n      err.message = `${file}: ${err.message}`\n      throw err\n    } else {\n      return null\n    }\n  }\n\n  return obj\n}\n\nconst readFile = universalify.fromPromise(_readFile)\n\nfunction readFileSync (file, options = {}) {\n  if (typeof options === 'string') {\n    options = { encoding: options }\n  }\n\n  const fs = options.fs || _fs\n\n  const shouldThrow = 'throws' in options ? options.throws : true\n\n  try {\n    let content = fs.readFileSync(file, options)\n    content = stripBom(content)\n    return JSON.parse(content, options.reviver)\n  } catch (err) {\n    if (shouldThrow) {\n      err.message = `${file}: ${err.message}`\n      throw err\n    } else {\n      return null\n    }\n  }\n}\n\nasync function _writeFile (file, obj, options = {}) {\n  const fs = options.fs || _fs\n\n  const str = stringify(obj, options)\n\n  await universalify.fromCallback(fs.writeFile)(file, str, options)\n}\n\nconst writeFile = universalify.fromPromise(_writeFile)\n\nfunction writeFileSync (file, obj, options = {}) {\n  const fs = options.fs || _fs\n\n  const str = stringify(obj, options)\n  // not sure if fs.writeFileSync returns anything, but just in case\n  return fs.writeFileSync(file, str, options)\n}\n\nconst jsonfile = {\n  readFile,\n  readFileSync,\n  writeFile,\n  writeFileSync\n}\n\nmodule.exports = jsonfile\n","function stringify (obj, { EOL = '\\n', finalEOL = true, replacer = null, spaces } = {}) {\n  const EOF = finalEOL ? EOL : ''\n  const str = JSON.stringify(obj, replacer, spaces)\n\n  return str.replace(/\\n/g, EOL) + EOF\n}\n\nfunction stripBom (content) {\n  // we do this because JSON.parse would convert it to a utf8 string if encoding wasn't specified\n  if (Buffer.isBuffer(content)) content = content.toString('utf8')\n  return content.replace(/^\\uFEFF/, '')\n}\n\nmodule.exports = { stringify, stripBom }\n","'use strict'\n\nconst { stringify } = require('jsonfile/utils')\nconst { outputFile } = require('../output-file')\n\nasync function outputJson (file, data, options = {}) {\n  const str = stringify(data, options)\n\n  await outputFile(file, str, options)\n}\n\nmodule.exports = outputJson\n","'use strict'\n\nconst u = require('universalify').fromPromise\nconst fs = require('../fs')\nconst path = require('path')\nconst mkdir = require('../mkdirs')\nconst pathExists = require('../path-exists').pathExists\n\nasync function outputFile (file, data, encoding = 'utf-8') {\n  const dir = path.dirname(file)\n\n  if (!(await pathExists(dir))) {\n    await mkdir.mkdirs(dir)\n  }\n\n  return fs.writeFile(file, data, encoding)\n}\n\nfunction outputFileSync (file, ...args) {\n  const dir = path.dirname(file)\n  if (!fs.existsSync(dir)) {\n    mkdir.mkdirsSync(dir)\n  }\n\n  fs.writeFileSync(file, ...args)\n}\n\nmodule.exports = {\n  outputFile: u(outputFile),\n  outputFileSync\n}\n","'use strict'\n\nconst { stringify } = require('jsonfile/utils')\nconst { outputFileSync } = require('../output-file')\n\nfunction outputJsonSync (file, data, options) {\n  const str = stringify(data, options)\n\n  outputFileSync(file, str, options)\n}\n\nmodule.exports = outputJsonSync\n","'use strict'\n\nconst u = require('universalify').fromPromise\nmodule.exports = {\n  move: u(require('./move')),\n  moveSync: require('./move-sync')\n}\n","'use strict'\n\nconst fs = require('../fs')\nconst path = require('path')\nconst { copy } = require('../copy')\nconst { remove } = require('../remove')\nconst { mkdirp } = require('../mkdirs')\nconst { pathExists } = require('../path-exists')\nconst stat = require('../util/stat')\n\nasync function move (src, dest, opts = {}) {\n  const overwrite = opts.overwrite || opts.clobber || false\n\n  const { srcStat, isChangingCase = false } = await stat.checkPaths(src, dest, 'move', opts)\n\n  await stat.checkParentPaths(src, srcStat, dest, 'move')\n\n  // If the parent of dest is not root, make sure it exists before proceeding\n  const destParent = path.dirname(dest)\n  const parsedParentPath = path.parse(destParent)\n  if (parsedParentPath.root !== destParent) {\n    await mkdirp(destParent)\n  }\n\n  return doRename(src, dest, overwrite, isChangingCase)\n}\n\nasync function doRename (src, dest, overwrite, isChangingCase) {\n  if (!isChangingCase) {\n    if (overwrite) {\n      await remove(dest)\n    } else if (await pathExists(dest)) {\n      throw new Error('dest already exists.')\n    }\n  }\n\n  try {\n    // Try w/ rename first, and try copy + remove if EXDEV\n    await fs.rename(src, dest)\n  } catch (err) {\n    if (err.code !== 'EXDEV') {\n      throw err\n    }\n    await moveAcrossDevice(src, dest, overwrite)\n  }\n}\n\nasync function moveAcrossDevice (src, dest, overwrite) {\n  const opts = {\n    overwrite,\n    errorOnExist: true,\n    preserveTimestamps: true\n  }\n\n  await copy(src, dest, opts)\n  return remove(src)\n}\n\nmodule.exports = move\n","'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst copySync = require('../copy').copySync\nconst removeSync = require('../remove').removeSync\nconst mkdirpSync = require('../mkdirs').mkdirpSync\nconst stat = require('../util/stat')\n\nfunction moveSync (src, dest, opts) {\n  opts = opts || {}\n  const overwrite = opts.overwrite || opts.clobber || false\n\n  const { srcStat, isChangingCase = false } = stat.checkPathsSync(src, dest, 'move', opts)\n  stat.checkParentPathsSync(src, srcStat, dest, 'move')\n  if (!isParentRoot(dest)) mkdirpSync(path.dirname(dest))\n  return doRename(src, dest, overwrite, isChangingCase)\n}\n\nfunction isParentRoot (dest) {\n  const parent = path.dirname(dest)\n  const parsedPath = path.parse(parent)\n  return parsedPath.root === parent\n}\n\nfunction doRename (src, dest, overwrite, isChangingCase) {\n  if (isChangingCase) return rename(src, dest, overwrite)\n  if (overwrite) {\n    removeSync(dest)\n    return rename(src, dest, overwrite)\n  }\n  if (fs.existsSync(dest)) throw new Error('dest already exists.')\n  return rename(src, dest, overwrite)\n}\n\nfunction rename (src, dest, overwrite) {\n  try {\n    fs.renameSync(src, dest)\n  } catch (err) {\n    if (err.code !== 'EXDEV') throw err\n    return moveAcrossDevice(src, dest, overwrite)\n  }\n}\n\nfunction moveAcrossDevice (src, dest, overwrite) {\n  const opts = {\n    overwrite,\n    errorOnExist: true,\n    preserveTimestamps: true\n  }\n  copySync(src, dest, opts)\n  return removeSync(src)\n}\n\nmodule.exports = moveSync\n","const fs = require('graceful-fs');\nconst directory = require('./directory');\nconst Stream = require('stream');\n\nmodule.exports = {\n  buffer: function(buffer, options) {\n    const source = {\n      stream: function(offset, length) {\n        const stream = Stream.PassThrough();\n        const end = length ? offset + length : undefined;\n        stream.end(buffer.slice(offset, end));\n        return stream;\n      },\n      size: function() {\n        return Promise.resolve(buffer.length);\n      }\n    };\n    return directory(source, options);\n  },\n  file: function(filename, options) {\n    const source = {\n      stream: function(start, length) {\n        const end = length ? start + length : undefined;\n        return fs.createReadStream(filename, {start, end});\n      },\n      size: function() {\n        return new Promise(function(resolve, reject) {\n          fs.stat(filename, function(err, d) {\n            if (err)\n              reject(err);\n            else\n              resolve(d.size);\n          });\n        });\n      }\n    };\n    return directory(source, options);\n  },\n\n  url: function(request, params, options) {\n    if (typeof params === 'string')\n      params = {url: params};\n    if (!params.url)\n      throw 'URL missing';\n    params.headers = params.headers || {};\n\n    const source = {\n      stream : function(offset, length) {\n        const options = Object.create(params);\n        const end = length ? offset + length : '';\n        options.headers = Object.create(params.headers);\n        options.headers.range = 'bytes='+offset+'-' + end;\n        return request(options);\n      },\n      size: function() {\n        return new Promise(function(resolve, reject) {\n          const req = request(params);\n          req.on('response', function(d) {\n            req.abort();\n            if (!d.headers['content-length'])\n              reject(new Error('Missing content length header'));\n            else\n              resolve(d.headers['content-length']);\n          }).on('error', reject);\n        });\n      }\n    };\n\n    return directory(source, options);\n  },\n\n  s3 : function(client, params, options) {\n    const source = {\n      size: function() {\n        return new Promise(function(resolve, reject) {\n          client.headObject(params, function(err, d) {\n            if (err)\n              reject(err);\n            else\n              resolve(d.ContentLength);\n          });\n        });\n      },\n      stream: function(offset, length) {\n        const d = {};\n        for (const key in params)\n          d[key] = params[key];\n        const end = length ? offset + length : '';\n        d.Range = 'bytes='+offset+'-' + end;\n        return client.getObject(d).createReadStream();\n      }\n    };\n\n    return directory(source, options);\n  },\n  s3_v3: function (client, params, options) {\n    //@ts-ignore\n    const { GetObjectCommand, HeadObjectCommand } = require('@aws-sdk/client-s3');\n    const source = {\n      size: async () => {\n        const head = await client.send(\n          new HeadObjectCommand({\n            Bucket: params.Bucket,\n            Key: params.Key,\n          })\n        );\n\n        if(!head.ContentLength) {\n          return 0;\n        }\n\n        return head.ContentLength;\n      },\n      stream: (offset, length) => {\n        const stream = Stream.PassThrough();\n        const end = length ? offset + length : \"\";\n        client\n          .send(\n            new GetObjectCommand({\n              Bucket: params.Bucket,\n              Key: params.Key,\n              Range: `bytes=${offset}-${end}`,\n            })\n          )\n          .then((response) => {\n            response.Body.pipe(stream);\n          })\n          .catch((error) => {\n            stream.emit(\"error\", error);\n          });\n\n        return stream;\n      },\n    };\n\n    return directory(source, options);\n  },\n  custom: function(source, options) {\n    return directory(source, options);\n  }\n};\n","const PullStream = require('../PullStream');\nconst unzip = require('./unzip');\nconst BufferStream = require('../BufferStream');\nconst parseExtraField = require('../parseExtraField');\nconst path = require('path');\nconst fs = require('fs-extra');\nconst parseDateTime = require('../parseDateTime');\nconst parseBuffer = require('../parseBuffer');\nconst Bluebird = require('bluebird');\n\nconst signature = Buffer.alloc(4);\nsignature.writeUInt32LE(0x06054b50, 0);\n\nfunction getCrxHeader(source) {\n  const sourceStream = source.stream(0).pipe(PullStream());\n\n  return sourceStream.pull(4).then(function(data) {\n    const signature = data.readUInt32LE(0);\n    if (signature === 0x34327243) {\n      let crxHeader;\n      return sourceStream.pull(12).then(function(data) {\n        crxHeader = parseBuffer.parse(data, [\n          ['version', 4],\n          ['pubKeyLength', 4],\n          ['signatureLength', 4],\n        ]);\n      }).then(function() {\n        return sourceStream.pull(crxHeader.pubKeyLength +crxHeader.signatureLength);\n      }).then(function(data) {\n        crxHeader.publicKey = data.slice(0, crxHeader.pubKeyLength);\n        crxHeader.signature = data.slice(crxHeader.pubKeyLength);\n        crxHeader.size = 16 + crxHeader.pubKeyLength +crxHeader.signatureLength;\n        return crxHeader;\n      });\n    }\n  });\n}\n\n// Zip64 File Format Notes: https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT\nfunction getZip64CentralDirectory(source, zip64CDL) {\n  const d64loc = parseBuffer.parse(zip64CDL, [\n    ['signature', 4],\n    ['diskNumber', 4],\n    ['offsetToStartOfCentralDirectory', 8],\n    ['numberOfDisks', 4],\n  ]);\n\n  if (d64loc.signature != 0x07064b50) {\n    throw new Error('invalid zip64 end of central dir locator signature (0x07064b50): 0x' + d64loc.signature.toString(16));\n  }\n\n  const dir64 = PullStream();\n  source.stream(d64loc.offsetToStartOfCentralDirectory).pipe(dir64);\n\n  return dir64.pull(56);\n}\n\n// Zip64 File Format Notes: https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT\nfunction parseZip64DirRecord (dir64record) {\n  const vars = parseBuffer.parse(dir64record, [\n    ['signature', 4],\n    ['sizeOfCentralDirectory', 8],\n    ['version', 2],\n    ['versionsNeededToExtract', 2],\n    ['diskNumber', 4],\n    ['diskStart', 4],\n    ['numberOfRecordsOnDisk', 8],\n    ['numberOfRecords', 8],\n    ['sizeOfCentralDirectory', 8],\n    ['offsetToStartOfCentralDirectory', 8],\n  ]);\n\n  if (vars.signature != 0x06064b50) {\n    throw new Error('invalid zip64 end of central dir locator signature (0x06064b50): 0x0' + vars.signature.toString(16));\n  }\n\n  return vars;\n}\n\nmodule.exports = function centralDirectory(source, options) {\n  const endDir = PullStream();\n  const records = PullStream();\n  const tailSize = (options && options.tailSize) || 80;\n  let sourceSize,\n    crxHeader,\n    startOffset,\n    vars;\n\n  if (options && options.crx)\n    crxHeader = getCrxHeader(source);\n\n  return source.size()\n    .then(function(size) {\n      sourceSize = size;\n\n      source.stream(Math.max(0, size-tailSize))\n        .on('error', function (error) { endDir.emit('error', error); })\n        .pipe(endDir);\n\n      return endDir.pull(signature);\n    })\n    .then(function() {\n      return Bluebird.props({directory: endDir.pull(22), crxHeader: crxHeader});\n    })\n    .then(function(d) {\n      const data = d.directory;\n      startOffset = d.crxHeader && d.crxHeader.size || 0;\n\n      vars = parseBuffer.parse(data, [\n        ['signature', 4],\n        ['diskNumber', 2],\n        ['diskStart', 2],\n        ['numberOfRecordsOnDisk', 2],\n        ['numberOfRecords', 2],\n        ['sizeOfCentralDirectory', 4],\n        ['offsetToStartOfCentralDirectory', 4],\n        ['commentLength', 2],\n      ]);\n\n      // Is this zip file using zip64 format? Use same check as Go:\n      // https://github.com/golang/go/blob/master/src/archive/zip/reader.go#L503\n      // For zip64 files, need to find zip64 central directory locator header to extract\n      // relative offset for zip64 central directory record.\n      if (vars.diskNumber == 0xffff || vars.numberOfRecords == 0xffff ||\n        vars.offsetToStartOfCentralDirectory == 0xffffffff) {\n\n        // Offset to zip64 CDL is 20 bytes before normal CDR\n        const zip64CDLSize = 20;\n        const zip64CDLOffset = sourceSize - (tailSize - endDir.match + zip64CDLSize);\n        const zip64CDLStream = PullStream();\n\n        source.stream(zip64CDLOffset).pipe(zip64CDLStream);\n\n        return zip64CDLStream.pull(zip64CDLSize)\n          .then(function (d) { return getZip64CentralDirectory(source, d); })\n          .then(function (dir64record) {\n            vars = parseZip64DirRecord(dir64record);\n          });\n      } else {\n        vars.offsetToStartOfCentralDirectory += startOffset;\n      }\n    })\n    .then(function() {\n      if (vars.commentLength) return endDir.pull(vars.commentLength).then(function(comment) {\n        vars.comment = comment.toString('utf8');\n      });\n    })\n    .then(function() {\n      source.stream(vars.offsetToStartOfCentralDirectory).pipe(records);\n\n      vars.extract = function(opts) {\n        if (!opts || !opts.path) throw new Error('PATH_MISSING');\n        // make sure path is normalized before using it\n        opts.path = path.resolve(path.normalize(opts.path));\n        return vars.files.then(function(files) {\n          return Bluebird.map(files, async function(entry) {\n            // to avoid zip slip (writing outside of the destination), we resolve\n            // the target path, and make sure it's nested in the intended\n            // destination, or not extract it otherwise.\n            const extractPath = path.join(opts.path, entry.path);\n            if (extractPath.indexOf(opts.path) != 0) {\n              return;\n            }\n\n            if (entry.type == 'Directory') {\n              await fs.ensureDir(extractPath);\n              return;\n            }\n\n            await fs.ensureDir(path.dirname(extractPath));\n\n            const writer = opts.getWriter ? opts.getWriter({path: extractPath}) : fs.createWriteStream(extractPath);\n\n            return new Promise(function(resolve, reject) {\n              entry.stream(opts.password)\n                .on('error', reject)\n                .pipe(writer)\n                .on('close', resolve)\n                .on('error', reject);\n            });\n          }, { concurrency: opts.concurrency > 1 ? opts.concurrency : 1 });\n        });\n      };\n\n      vars.files = Bluebird.mapSeries(Array(vars.numberOfRecords), function() {\n        return records.pull(46).then(function(data) {\n          const vars = parseBuffer.parse(data, [\n            ['signature', 4],\n            ['versionMadeBy', 2],\n            ['versionsNeededToExtract', 2],\n            ['flags', 2],\n            ['compressionMethod', 2],\n            ['lastModifiedTime', 2],\n            ['lastModifiedDate', 2],\n            ['crc32', 4],\n            ['compressedSize', 4],\n            ['uncompressedSize', 4],\n            ['fileNameLength', 2],\n            ['extraFieldLength', 2],\n            ['fileCommentLength', 2],\n            ['diskNumber', 2],\n            ['internalFileAttributes', 2],\n            ['externalFileAttributes', 4],\n            ['offsetToLocalFileHeader', 4],\n          ]);\n\n          vars.offsetToLocalFileHeader += startOffset;\n          vars.lastModifiedDateTime = parseDateTime(vars.lastModifiedDate, vars.lastModifiedTime);\n\n          return records.pull(vars.fileNameLength).then(function(fileNameBuffer) {\n            vars.pathBuffer = fileNameBuffer;\n            vars.path = fileNameBuffer.toString('utf8');\n            vars.isUnicode = (vars.flags & 0x800) != 0;\n            return records.pull(vars.extraFieldLength);\n          })\n            .then(function(extraField) {\n              vars.extra = parseExtraField(extraField, vars);\n              return records.pull(vars.fileCommentLength);\n            })\n            .then(function(comment) {\n              vars.comment = comment;\n              vars.type = (vars.uncompressedSize === 0 && /[/\\\\]$/.test(vars.path)) ? 'Directory' : 'File';\n              const padding = options && options.padding || 1000;\n              vars.stream = function(_password) {\n                const totalSize = 30\n              + padding // add an extra buffer\n              + (vars.extraFieldLength || 0)\n              + (vars.fileNameLength || 0)\n              + vars.compressedSize;\n\n                return unzip(source, vars.offsetToLocalFileHeader, _password, vars, totalSize);\n              };\n              vars.buffer = function(_password) {\n                return BufferStream(vars.stream(_password));\n              };\n              return vars;\n            });\n        });\n      });\n\n      return Bluebird.props(vars);\n    });\n};\n","const Decrypt = require('../Decrypt');\nconst PullStream = require('../PullStream');\nconst Stream = require('stream');\nconst zlib = require('zlib');\nconst parseExtraField = require('../parseExtraField');\nconst parseDateTime = require('../parseDateTime');\nconst parseBuffer = require('../parseBuffer');\n\nmodule.exports = function unzip(source, offset, _password, directoryVars, length) {\n  const file = PullStream(),\n    entry = Stream.PassThrough();\n\n  const req = source.stream(offset, length);\n  req.pipe(file).on('error', function(e) {\n    entry.emit('error', e);\n  });\n\n  entry.vars = file.pull(30)\n    .then(function(data) {\n      let vars = parseBuffer.parse(data, [\n        ['signature', 4],\n        ['versionsNeededToExtract', 2],\n        ['flags', 2],\n        ['compressionMethod', 2],\n        ['lastModifiedTime', 2],\n        ['lastModifiedDate', 2],\n        ['crc32', 4],\n        ['compressedSize', 4],\n        ['uncompressedSize', 4],\n        ['fileNameLength', 2],\n        ['extraFieldLength', 2],\n      ]);\n\n      vars.lastModifiedDateTime = parseDateTime(vars.lastModifiedDate, vars.lastModifiedTime);\n\n      return file.pull(vars.fileNameLength)\n        .then(function(fileName) {\n          vars.fileName = fileName.toString('utf8');\n          return file.pull(vars.extraFieldLength);\n        })\n        .then(function(extraField) {\n          let checkEncryption;\n          vars.extra = parseExtraField(extraField, vars);\n          // Ignore logal file header vars if the directory vars are available\n          if (directoryVars && directoryVars.compressedSize) vars = directoryVars;\n\n          if (vars.flags & 0x01) checkEncryption = file.pull(12)\n            .then(function(header) {\n              if (!_password)\n                throw new Error('MISSING_PASSWORD');\n\n              const decrypt = Decrypt();\n\n              String(_password).split('').forEach(function(d) {\n                decrypt.update(d);\n              });\n\n              for (let i=0; i < header.length; i++)\n                header[i] = decrypt.decryptByte(header[i]);\n\n              vars.decrypt = decrypt;\n              vars.compressedSize -= 12;\n\n              const check = (vars.flags & 0x8) ? (vars.lastModifiedTime >> 8) & 0xff : (vars.crc32 >> 24) & 0xff;\n              if (header[11] !== check)\n                throw new Error('BAD_PASSWORD');\n\n              return vars;\n            });\n\n          return Promise.resolve(checkEncryption)\n            .then(function() {\n              entry.emit('vars', vars);\n              return vars;\n            });\n        });\n    });\n\n  entry.vars.then(function(vars) {\n    const fileSizeKnown = !(vars.flags & 0x08) || vars.compressedSize > 0;\n    let eof;\n\n    const inflater = vars.compressionMethod ? zlib.createInflateRaw() : Stream.PassThrough();\n\n    if (fileSizeKnown) {\n      entry.size = vars.uncompressedSize;\n      eof = vars.compressedSize;\n    } else {\n      eof = Buffer.alloc(4);\n      eof.writeUInt32LE(0x08074b50, 0);\n    }\n\n    let stream = file.stream(eof);\n\n    if (vars.decrypt)\n      stream = stream.pipe(vars.decrypt.stream());\n\n    stream\n      .pipe(inflater)\n      .on('error', function(err) { entry.emit('error', err);})\n      .pipe(entry)\n      .on('finish', function() {\n        if(req.destroy)\n          req.destroy();\n        else if (req.abort)\n          req.abort();\n        else if (req.close)\n          req.close();\n        else if (req.push)\n          req.push();\n        else\n          console.log('warning - unable to close stream');\n      });\n  })\n    .catch(function(e) {\n      entry.emit('error', e);\n    });\n\n  return entry;\n};\n","const Int64 = require(\"node-int64\");\nlet Stream = require(\"stream\");\n\n// Backwards compatibility for node versions < 8\n\nif (!Stream.Writable || !Stream.Writable.prototype.destroy)\n  Stream = require(\"readable-stream\");\n\nlet table;\n\nfunction generateTable() {\n  const poly = 0xEDB88320;\n  let c, n, k;\n  table = [];\n  for (n = 0; n < 256; n++) {\n    c = n;\n    for (k = 0; k < 8; k++) c = c & 1 ? poly ^ (c >>> 1) : (c = c >>> 1);\n    table[n] = c >>> 0;\n  }\n}\n\nfunction crc(ch, crc) {\n  if (!table) generateTable();\n\n  if (ch.charCodeAt) ch = ch.charCodeAt(0);\n\n  const l = (crc.readUInt32BE() >> 8) & 0xffffff;\n  const r = table[(crc.readUInt32BE() ^ (ch >>> 0)) & 0xff];\n\n  return (l ^ r) >>> 0;\n}\n\nfunction multiply(a, b) {\n  const ah = (a >> 16) & 0xffff;\n  const al = a & 0xffff;\n  const bh = (b >> 16) & 0xffff;\n  const bl = b & 0xffff;\n  const high = (ah * bl + al * bh) & 0xffff;\n\n  return ((high << 16) >>> 0) + al * bl;\n}\n\nfunction Decrypt() {\n  if (!(this instanceof Decrypt)) return new Decrypt();\n\n  this.key0 = Buffer.allocUnsafe(4);\n  this.key1 = Buffer.allocUnsafe(4);\n  this.key2 = Buffer.allocUnsafe(4);\n\n  this.key0.writeUInt32BE(0x12345678, 0);\n  this.key1.writeUInt32BE(0x23456789, 0);\n  this.key2.writeUInt32BE(0x34567890, 0);\n}\n\nDecrypt.prototype.update = function (h) {\n  this.key0.writeUInt32BE(crc(h, this.key0));\n  this.key1.writeUInt32BE(\n    ((this.key0.readUInt32BE() & 0xff & 0xFFFFFFFF) +\n      this.key1.readUInt32BE()) >>> 0\n  );\n  const x = new Int64(\n    (multiply(this.key1.readUInt32BE(), 134775813) + 1) & 0xFFFFFFFF\n  );\n  const b = Buffer.alloc(8);\n  x.copy(b, 0);\n  b.copy(this.key1, 0, 4, 8);\n  this.key2.writeUInt32BE(\n    crc(((this.key1.readUInt32BE() >> 24) & 0xff) >>> 0, this.key2)\n  );\n};\n\nDecrypt.prototype.decryptByte = function (c) {\n  const k = (this.key2.readUInt32BE() | 2) >>> 0;\n  c = c ^ ((multiply(k, (k ^ 1 >>> 0)) >> 8) & 0xff);\n  this.update(c);\n\n  return c;\n};\n\nDecrypt.prototype.stream = function () {\n  const stream = Stream.Transform(),\n    self = this;\n  stream._transform = function (d, e, cb) {\n    for (let i = 0; i < d.length; i++) {\n      d[i] = self.decryptByte(d[i]);\n    }\n    this.push(d);\n    cb();\n  };\n\n  return stream;\n};\n\nmodule.exports = Decrypt;","//     Int64.js\n//\n//     Copyright (c) 2012 Robert Kieffer\n//     MIT License - http://opensource.org/licenses/mit-license.php\n\n/**\n * Support for handling 64-bit int numbers in Javascript (node.js)\n *\n * JS Numbers are IEEE-754 binary double-precision floats, which limits the\n * range of values that can be represented with integer precision to:\n *\n * 2^^53 <= N <= 2^53\n *\n * Int64 objects wrap a node Buffer that holds the 8-bytes of int64 data.  These\n * objects operate directly on the buffer which means that if they are created\n * using an existing buffer then setting the value will modify the Buffer, and\n * vice-versa.\n *\n * Internal Representation\n *\n * The internal buffer format is Big Endian.  I.e. the most-significant byte is\n * at buffer[0], the least-significant at buffer[7].  For the purposes of\n * converting to/from JS native numbers, the value is assumed to be a signed\n * integer stored in 2's complement form.\n *\n * For details about IEEE-754 see:\n * http://en.wikipedia.org/wiki/Double_precision_floating-point_format\n */\n\n// Useful masks and values for bit twiddling\nvar MASK31 =  0x7fffffff, VAL31 = 0x80000000;\nvar MASK32 =  0xffffffff, VAL32 = 0x100000000;\n\n// Map for converting hex octets to strings\nvar _HEX = [];\nfor (var i = 0; i < 256; i++) {\n  _HEX[i] = (i > 0xF ? '' : '0') + i.toString(16);\n}\n\n//\n// Int64\n//\n\n/**\n * Constructor accepts any of the following argument types:\n *\n * new Int64(buffer[, offset=0]) - Existing Buffer with byte offset\n * new Int64(Uint8Array[, offset=0]) - Existing Uint8Array with a byte offset\n * new Int64(string)             - Hex string (throws if n is outside int64 range)\n * new Int64(number)             - Number (throws if n is outside int64 range)\n * new Int64(hi, lo)             - Raw bits as two 32-bit values\n */\nvar Int64 = module.exports = function(a1, a2) {\n  if (a1 instanceof Buffer) {\n    this.buffer = a1;\n    this.offset = a2 || 0;\n  } else if (Object.prototype.toString.call(a1) == '[object Uint8Array]') {\n    // Under Browserify, Buffers can extend Uint8Arrays rather than an\n    // instance of Buffer. We could assume the passed in Uint8Array is actually\n    // a buffer but that won't handle the case where a raw Uint8Array is passed\n    // in. We construct a new Buffer just in case.\n    this.buffer = new Buffer(a1);\n    this.offset = a2 || 0;\n  } else {\n    this.buffer = this.buffer || new Buffer(8);\n    this.offset = 0;\n    this.setValue.apply(this, arguments);\n  }\n};\n\n\n// Max integer value that JS can accurately represent\nInt64.MAX_INT = Math.pow(2, 53);\n\n// Min integer value that JS can accurately represent\nInt64.MIN_INT = -Math.pow(2, 53);\n\nInt64.prototype = {\n\n  constructor: Int64,\n\n  /**\n   * Do in-place 2's compliment.  See\n   * http://en.wikipedia.org/wiki/Two's_complement\n   */\n  _2scomp: function() {\n    var b = this.buffer, o = this.offset, carry = 1;\n    for (var i = o + 7; i >= o; i--) {\n      var v = (b[i] ^ 0xff) + carry;\n      b[i] = v & 0xff;\n      carry = v >> 8;\n    }\n  },\n\n  /**\n   * Set the value. Takes any of the following arguments:\n   *\n   * setValue(string) - A hexidecimal string\n   * setValue(number) - Number (throws if n is outside int64 range)\n   * setValue(hi, lo) - Raw bits as two 32-bit values\n   */\n  setValue: function(hi, lo) {\n    var negate = false;\n    if (arguments.length == 1) {\n      if (typeof(hi) == 'number') {\n        // Simplify bitfield retrieval by using abs() value.  We restore sign\n        // later\n        negate = hi < 0;\n        hi = Math.abs(hi);\n        lo = hi % VAL32;\n        hi = hi / VAL32;\n        if (hi > VAL32) throw new RangeError(hi  + ' is outside Int64 range');\n        hi = hi | 0;\n      } else if (typeof(hi) == 'string') {\n        hi = (hi + '').replace(/^0x/, '');\n        lo = hi.substr(-8);\n        hi = hi.length > 8 ? hi.substr(0, hi.length - 8) : '';\n        hi = parseInt(hi, 16);\n        lo = parseInt(lo, 16);\n      } else {\n        throw new Error(hi + ' must be a Number or String');\n      }\n    }\n\n    // Technically we should throw if hi or lo is outside int32 range here, but\n    // it's not worth the effort. Anything past the 32'nd bit is ignored.\n\n    // Copy bytes to buffer\n    var b = this.buffer, o = this.offset;\n    for (var i = 7; i >= 0; i--) {\n      b[o+i] = lo & 0xff;\n      lo = i == 4 ? hi : lo >>> 8;\n    }\n\n    // Restore sign of passed argument\n    if (negate) this._2scomp();\n  },\n\n  /**\n   * Convert to a native JS number.\n   *\n   * WARNING: Do not expect this value to be accurate to integer precision for\n   * large (positive or negative) numbers!\n   *\n   * @param allowImprecise If true, no check is performed to verify the\n   * returned value is accurate to integer precision.  If false, imprecise\n   * numbers (very large positive or negative numbers) will be forced to +/-\n   * Infinity.\n   */\n  toNumber: function(allowImprecise) {\n    var b = this.buffer, o = this.offset;\n\n    // Running sum of octets, doing a 2's complement\n    var negate = b[o] & 0x80, x = 0, carry = 1;\n    for (var i = 7, m = 1; i >= 0; i--, m *= 256) {\n      var v = b[o+i];\n\n      // 2's complement for negative numbers\n      if (negate) {\n        v = (v ^ 0xff) + carry;\n        carry = v >> 8;\n        v = v & 0xff;\n      }\n\n      x += v * m;\n    }\n\n    // Return Infinity if we've lost integer precision\n    if (!allowImprecise && x >= Int64.MAX_INT) {\n      return negate ? -Infinity : Infinity;\n    }\n\n    return negate ? -x : x;\n  },\n\n  /**\n   * Convert to a JS Number. Returns +/-Infinity for values that can't be\n   * represented to integer precision.\n   */\n  valueOf: function() {\n    return this.toNumber(false);\n  },\n\n  /**\n   * Return string value\n   *\n   * @param radix Just like Number#toString()'s radix\n   */\n  toString: function(radix) {\n    return this.valueOf().toString(radix || 10);\n  },\n\n  /**\n   * Return a string showing the buffer octets, with MSB on the left.\n   *\n   * @param sep separator string. default is '' (empty string)\n   */\n  toOctetString: function(sep) {\n    var out = new Array(8);\n    var b = this.buffer, o = this.offset;\n    for (var i = 0; i < 8; i++) {\n      out[i] = _HEX[b[o+i]];\n    }\n    return out.join(sep || '');\n  },\n\n  /**\n   * Returns the int64's 8 bytes in a buffer.\n   *\n   * @param {bool} [rawBuffer=false]  If no offset and this is true, return the internal buffer.  Should only be used if\n   *                                  you're discarding the Int64 afterwards, as it breaks encapsulation.\n   */\n  toBuffer: function(rawBuffer) {\n    if (rawBuffer && this.offset === 0) return this.buffer;\n\n    var out = new Buffer(8);\n    this.buffer.copy(out, 0, this.offset, this.offset + 8);\n    return out;\n  },\n\n  /**\n   * Copy 8 bytes of int64 into target buffer at target offset.\n   *\n   * @param {Buffer} targetBuffer       Buffer to copy into.\n   * @param {number} [targetOffset=0]   Offset into target buffer.\n   */\n  copy: function(targetBuffer, targetOffset) {\n    this.buffer.copy(targetBuffer, targetOffset || 0, this.offset, this.offset + 8);\n  },\n\n  /**\n   * Returns a number indicating whether this comes before or after or is the\n   * same as the other in sort order.\n   *\n   * @param {Int64} other  Other Int64 to compare.\n   */\n  compare: function(other) {\n\n    // If sign bits differ ...\n    if ((this.buffer[this.offset] & 0x80) != (other.buffer[other.offset] & 0x80)) {\n      return other.buffer[other.offset] - this.buffer[this.offset];\n    }\n\n    // otherwise, compare bytes lexicographically\n    for (var i = 0; i < 8; i++) {\n      if (this.buffer[this.offset+i] !== other.buffer[other.offset+i]) {\n        return this.buffer[this.offset+i] - other.buffer[other.offset+i];\n      }\n    }\n    return 0;\n  },\n\n  /**\n   * Returns a boolean indicating if this integer is equal to other.\n   *\n   * @param {Int64} other  Other Int64 to compare.\n   */\n  equals: function(other) {\n    return this.compare(other) === 0;\n  },\n\n  /**\n   * Pretty output in console.log\n   */\n  inspect: function() {\n    return '[Int64 value:' + this + ' octets:' + this.toOctetString(' ') + ']';\n  }\n};\n","\"use strict\";\nvar old;\nif (typeof Promise !== \"undefined\") old = Promise;\nfunction noConflict() {\n    try { if (Promise === bluebird) Promise = old; }\n    catch (e) {}\n    return bluebird;\n}\nvar bluebird = require(\"./promise\")();\nbluebird.noConflict = noConflict;\nmodule.exports = bluebird;\n","\"use strict\";\nmodule.exports = function() {\nvar makeSelfResolutionError = function () {\n    return new TypeError(\"circular promise resolution chain\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n};\nvar reflectHandler = function() {\n    return new Promise.PromiseInspection(this._target());\n};\nvar apiRejection = function(msg) {\n    return Promise.reject(new TypeError(msg));\n};\nfunction Proxyable() {}\nvar UNDEFINED_BINDING = {};\nvar util = require(\"./util\");\nutil.setReflectHandler(reflectHandler);\n\nvar getDomain = function() {\n    var domain = process.domain;\n    if (domain === undefined) {\n        return null;\n    }\n    return domain;\n};\nvar getContextDefault = function() {\n    return null;\n};\nvar getContextDomain = function() {\n    return {\n        domain: getDomain(),\n        async: null\n    };\n};\nvar AsyncResource = util.isNode && util.nodeSupportsAsyncResource ?\n    require(\"async_hooks\").AsyncResource : null;\nvar getContextAsyncHooks = function() {\n    return {\n        domain: getDomain(),\n        async: new AsyncResource(\"Bluebird::Promise\")\n    };\n};\nvar getContext = util.isNode ? getContextDomain : getContextDefault;\nutil.notEnumerableProp(Promise, \"_getContext\", getContext);\nvar enableAsyncHooks = function() {\n    getContext = getContextAsyncHooks;\n    util.notEnumerableProp(Promise, \"_getContext\", getContextAsyncHooks);\n};\nvar disableAsyncHooks = function() {\n    getContext = getContextDomain;\n    util.notEnumerableProp(Promise, \"_getContext\", getContextDomain);\n};\n\nvar es5 = require(\"./es5\");\nvar Async = require(\"./async\");\nvar async = new Async();\nes5.defineProperty(Promise, \"_async\", {value: async});\nvar errors = require(\"./errors\");\nvar TypeError = Promise.TypeError = errors.TypeError;\nPromise.RangeError = errors.RangeError;\nvar CancellationError = Promise.CancellationError = errors.CancellationError;\nPromise.TimeoutError = errors.TimeoutError;\nPromise.OperationalError = errors.OperationalError;\nPromise.RejectionError = errors.OperationalError;\nPromise.AggregateError = errors.AggregateError;\nvar INTERNAL = function(){};\nvar APPLY = {};\nvar NEXT_FILTER = {};\nvar tryConvertToPromise = require(\"./thenables\")(Promise, INTERNAL);\nvar PromiseArray =\n    require(\"./promise_array\")(Promise, INTERNAL,\n                               tryConvertToPromise, apiRejection, Proxyable);\nvar Context = require(\"./context\")(Promise);\n /*jshint unused:false*/\nvar createContext = Context.create;\n\nvar debug = require(\"./debuggability\")(Promise, Context,\n    enableAsyncHooks, disableAsyncHooks);\nvar CapturedTrace = debug.CapturedTrace;\nvar PassThroughHandlerContext =\n    require(\"./finally\")(Promise, tryConvertToPromise, NEXT_FILTER);\nvar catchFilter = require(\"./catch_filter\")(NEXT_FILTER);\nvar nodebackForPromise = require(\"./nodeback\");\nvar errorObj = util.errorObj;\nvar tryCatch = util.tryCatch;\nfunction check(self, executor) {\n    if (self == null || self.constructor !== Promise) {\n        throw new TypeError(\"the promise constructor cannot be invoked directly\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n    }\n    if (typeof executor !== \"function\") {\n        throw new TypeError(\"expecting a function but got \" + util.classString(executor));\n    }\n\n}\n\nfunction Promise(executor) {\n    if (executor !== INTERNAL) {\n        check(this, executor);\n    }\n    this._bitField = 0;\n    this._fulfillmentHandler0 = undefined;\n    this._rejectionHandler0 = undefined;\n    this._promise0 = undefined;\n    this._receiver0 = undefined;\n    this._resolveFromExecutor(executor);\n    this._promiseCreated();\n    this._fireEvent(\"promiseCreated\", this);\n}\n\nPromise.prototype.toString = function () {\n    return \"[object Promise]\";\n};\n\nPromise.prototype.caught = Promise.prototype[\"catch\"] = function (fn) {\n    var len = arguments.length;\n    if (len > 1) {\n        var catchInstances = new Array(len - 1),\n            j = 0, i;\n        for (i = 0; i < len - 1; ++i) {\n            var item = arguments[i];\n            if (util.isObject(item)) {\n                catchInstances[j++] = item;\n            } else {\n                return apiRejection(\"Catch statement predicate: \" +\n                    \"expecting an object but got \" + util.classString(item));\n            }\n        }\n        catchInstances.length = j;\n        fn = arguments[i];\n\n        if (typeof fn !== \"function\") {\n            throw new TypeError(\"The last argument to .catch() \" +\n                \"must be a function, got \" + util.toString(fn));\n        }\n        return this.then(undefined, catchFilter(catchInstances, fn, this));\n    }\n    return this.then(undefined, fn);\n};\n\nPromise.prototype.reflect = function () {\n    return this._then(reflectHandler,\n        reflectHandler, undefined, this, undefined);\n};\n\nPromise.prototype.then = function (didFulfill, didReject) {\n    if (debug.warnings() && arguments.length > 0 &&\n        typeof didFulfill !== \"function\" &&\n        typeof didReject !== \"function\") {\n        var msg = \".then() only accepts functions but was passed: \" +\n                util.classString(didFulfill);\n        if (arguments.length > 1) {\n            msg += \", \" + util.classString(didReject);\n        }\n        this._warn(msg);\n    }\n    return this._then(didFulfill, didReject, undefined, undefined, undefined);\n};\n\nPromise.prototype.done = function (didFulfill, didReject) {\n    var promise =\n        this._then(didFulfill, didReject, undefined, undefined, undefined);\n    promise._setIsFinal();\n};\n\nPromise.prototype.spread = function (fn) {\n    if (typeof fn !== \"function\") {\n        return apiRejection(\"expecting a function but got \" + util.classString(fn));\n    }\n    return this.all()._then(fn, undefined, undefined, APPLY, undefined);\n};\n\nPromise.prototype.toJSON = function () {\n    var ret = {\n        isFulfilled: false,\n        isRejected: false,\n        fulfillmentValue: undefined,\n        rejectionReason: undefined\n    };\n    if (this.isFulfilled()) {\n        ret.fulfillmentValue = this.value();\n        ret.isFulfilled = true;\n    } else if (this.isRejected()) {\n        ret.rejectionReason = this.reason();\n        ret.isRejected = true;\n    }\n    return ret;\n};\n\nPromise.prototype.all = function () {\n    if (arguments.length > 0) {\n        this._warn(\".all() was passed arguments but it does not take any\");\n    }\n    return new PromiseArray(this).promise();\n};\n\nPromise.prototype.error = function (fn) {\n    return this.caught(util.originatesFromRejection, fn);\n};\n\nPromise.getNewLibraryCopy = module.exports;\n\nPromise.is = function (val) {\n    return val instanceof Promise;\n};\n\nPromise.fromNode = Promise.fromCallback = function(fn) {\n    var ret = new Promise(INTERNAL);\n    ret._captureStackTrace();\n    var multiArgs = arguments.length > 1 ? !!Object(arguments[1]).multiArgs\n                                         : false;\n    var result = tryCatch(fn)(nodebackForPromise(ret, multiArgs));\n    if (result === errorObj) {\n        ret._rejectCallback(result.e, true);\n    }\n    if (!ret._isFateSealed()) ret._setAsyncGuaranteed();\n    return ret;\n};\n\nPromise.all = function (promises) {\n    return new PromiseArray(promises).promise();\n};\n\nPromise.cast = function (obj) {\n    var ret = tryConvertToPromise(obj);\n    if (!(ret instanceof Promise)) {\n        ret = new Promise(INTERNAL);\n        ret._captureStackTrace();\n        ret._setFulfilled();\n        ret._rejectionHandler0 = obj;\n    }\n    return ret;\n};\n\nPromise.resolve = Promise.fulfilled = Promise.cast;\n\nPromise.reject = Promise.rejected = function (reason) {\n    var ret = new Promise(INTERNAL);\n    ret._captureStackTrace();\n    ret._rejectCallback(reason, true);\n    return ret;\n};\n\nPromise.setScheduler = function(fn) {\n    if (typeof fn !== \"function\") {\n        throw new TypeError(\"expecting a function but got \" + util.classString(fn));\n    }\n    return async.setScheduler(fn);\n};\n\nPromise.prototype._then = function (\n    didFulfill,\n    didReject,\n    _,    receiver,\n    internalData\n) {\n    var haveInternalData = internalData !== undefined;\n    var promise = haveInternalData ? internalData : new Promise(INTERNAL);\n    var target = this._target();\n    var bitField = target._bitField;\n\n    if (!haveInternalData) {\n        promise._propagateFrom(this, 3);\n        promise._captureStackTrace();\n        if (receiver === undefined &&\n            ((this._bitField & 2097152) !== 0)) {\n            if (!((bitField & 50397184) === 0)) {\n                receiver = this._boundValue();\n            } else {\n                receiver = target === this ? undefined : this._boundTo;\n            }\n        }\n        this._fireEvent(\"promiseChained\", this, promise);\n    }\n\n    var context = getContext();\n    if (!((bitField & 50397184) === 0)) {\n        var handler, value, settler = target._settlePromiseCtx;\n        if (((bitField & 33554432) !== 0)) {\n            value = target._rejectionHandler0;\n            handler = didFulfill;\n        } else if (((bitField & 16777216) !== 0)) {\n            value = target._fulfillmentHandler0;\n            handler = didReject;\n            target._unsetRejectionIsUnhandled();\n        } else {\n            settler = target._settlePromiseLateCancellationObserver;\n            value = new CancellationError(\"late cancellation observer\");\n            target._attachExtraTrace(value);\n            handler = didReject;\n        }\n\n        async.invoke(settler, target, {\n            handler: util.contextBind(context, handler),\n            promise: promise,\n            receiver: receiver,\n            value: value\n        });\n    } else {\n        target._addCallbacks(didFulfill, didReject, promise,\n                receiver, context);\n    }\n\n    return promise;\n};\n\nPromise.prototype._length = function () {\n    return this._bitField & 65535;\n};\n\nPromise.prototype._isFateSealed = function () {\n    return (this._bitField & 117506048) !== 0;\n};\n\nPromise.prototype._isFollowing = function () {\n    return (this._bitField & 67108864) === 67108864;\n};\n\nPromise.prototype._setLength = function (len) {\n    this._bitField = (this._bitField & -65536) |\n        (len & 65535);\n};\n\nPromise.prototype._setFulfilled = function () {\n    this._bitField = this._bitField | 33554432;\n    this._fireEvent(\"promiseFulfilled\", this);\n};\n\nPromise.prototype._setRejected = function () {\n    this._bitField = this._bitField | 16777216;\n    this._fireEvent(\"promiseRejected\", this);\n};\n\nPromise.prototype._setFollowing = function () {\n    this._bitField = this._bitField | 67108864;\n    this._fireEvent(\"promiseResolved\", this);\n};\n\nPromise.prototype._setIsFinal = function () {\n    this._bitField = this._bitField | 4194304;\n};\n\nPromise.prototype._isFinal = function () {\n    return (this._bitField & 4194304) > 0;\n};\n\nPromise.prototype._unsetCancelled = function() {\n    this._bitField = this._bitField & (~65536);\n};\n\nPromise.prototype._setCancelled = function() {\n    this._bitField = this._bitField | 65536;\n    this._fireEvent(\"promiseCancelled\", this);\n};\n\nPromise.prototype._setWillBeCancelled = function() {\n    this._bitField = this._bitField | 8388608;\n};\n\nPromise.prototype._setAsyncGuaranteed = function() {\n    if (async.hasCustomScheduler()) return;\n    var bitField = this._bitField;\n    this._bitField = bitField |\n        (((bitField & 536870912) >> 2) ^\n        134217728);\n};\n\nPromise.prototype._setNoAsyncGuarantee = function() {\n    this._bitField = (this._bitField | 536870912) &\n        (~134217728);\n};\n\nPromise.prototype._receiverAt = function (index) {\n    var ret = index === 0 ? this._receiver0 : this[\n            index * 4 - 4 + 3];\n    if (ret === UNDEFINED_BINDING) {\n        return undefined;\n    } else if (ret === undefined && this._isBound()) {\n        return this._boundValue();\n    }\n    return ret;\n};\n\nPromise.prototype._promiseAt = function (index) {\n    return this[\n            index * 4 - 4 + 2];\n};\n\nPromise.prototype._fulfillmentHandlerAt = function (index) {\n    return this[\n            index * 4 - 4 + 0];\n};\n\nPromise.prototype._rejectionHandlerAt = function (index) {\n    return this[\n            index * 4 - 4 + 1];\n};\n\nPromise.prototype._boundValue = function() {};\n\nPromise.prototype._migrateCallback0 = function (follower) {\n    var bitField = follower._bitField;\n    var fulfill = follower._fulfillmentHandler0;\n    var reject = follower._rejectionHandler0;\n    var promise = follower._promise0;\n    var receiver = follower._receiverAt(0);\n    if (receiver === undefined) receiver = UNDEFINED_BINDING;\n    this._addCallbacks(fulfill, reject, promise, receiver, null);\n};\n\nPromise.prototype._migrateCallbackAt = function (follower, index) {\n    var fulfill = follower._fulfillmentHandlerAt(index);\n    var reject = follower._rejectionHandlerAt(index);\n    var promise = follower._promiseAt(index);\n    var receiver = follower._receiverAt(index);\n    if (receiver === undefined) receiver = UNDEFINED_BINDING;\n    this._addCallbacks(fulfill, reject, promise, receiver, null);\n};\n\nPromise.prototype._addCallbacks = function (\n    fulfill,\n    reject,\n    promise,\n    receiver,\n    context\n) {\n    var index = this._length();\n\n    if (index >= 65535 - 4) {\n        index = 0;\n        this._setLength(0);\n    }\n\n    if (index === 0) {\n        this._promise0 = promise;\n        this._receiver0 = receiver;\n        if (typeof fulfill === \"function\") {\n            this._fulfillmentHandler0 = util.contextBind(context, fulfill);\n        }\n        if (typeof reject === \"function\") {\n            this._rejectionHandler0 = util.contextBind(context, reject);\n        }\n    } else {\n        var base = index * 4 - 4;\n        this[base + 2] = promise;\n        this[base + 3] = receiver;\n        if (typeof fulfill === \"function\") {\n            this[base + 0] =\n                util.contextBind(context, fulfill);\n        }\n        if (typeof reject === \"function\") {\n            this[base + 1] =\n                util.contextBind(context, reject);\n        }\n    }\n    this._setLength(index + 1);\n    return index;\n};\n\nPromise.prototype._proxy = function (proxyable, arg) {\n    this._addCallbacks(undefined, undefined, arg, proxyable, null);\n};\n\nPromise.prototype._resolveCallback = function(value, shouldBind) {\n    if (((this._bitField & 117506048) !== 0)) return;\n    if (value === this)\n        return this._rejectCallback(makeSelfResolutionError(), false);\n    var maybePromise = tryConvertToPromise(value, this);\n    if (!(maybePromise instanceof Promise)) return this._fulfill(value);\n\n    if (shouldBind) this._propagateFrom(maybePromise, 2);\n\n\n    var promise = maybePromise._target();\n\n    if (promise === this) {\n        this._reject(makeSelfResolutionError());\n        return;\n    }\n\n    var bitField = promise._bitField;\n    if (((bitField & 50397184) === 0)) {\n        var len = this._length();\n        if (len > 0) promise._migrateCallback0(this);\n        for (var i = 1; i < len; ++i) {\n            promise._migrateCallbackAt(this, i);\n        }\n        this._setFollowing();\n        this._setLength(0);\n        this._setFollowee(maybePromise);\n    } else if (((bitField & 33554432) !== 0)) {\n        this._fulfill(promise._value());\n    } else if (((bitField & 16777216) !== 0)) {\n        this._reject(promise._reason());\n    } else {\n        var reason = new CancellationError(\"late cancellation observer\");\n        promise._attachExtraTrace(reason);\n        this._reject(reason);\n    }\n};\n\nPromise.prototype._rejectCallback =\nfunction(reason, synchronous, ignoreNonErrorWarnings) {\n    var trace = util.ensureErrorObject(reason);\n    var hasStack = trace === reason;\n    if (!hasStack && !ignoreNonErrorWarnings && debug.warnings()) {\n        var message = \"a promise was rejected with a non-error: \" +\n            util.classString(reason);\n        this._warn(message, true);\n    }\n    this._attachExtraTrace(trace, synchronous ? hasStack : false);\n    this._reject(reason);\n};\n\nPromise.prototype._resolveFromExecutor = function (executor) {\n    if (executor === INTERNAL) return;\n    var promise = this;\n    this._captureStackTrace();\n    this._pushContext();\n    var synchronous = true;\n    var r = this._execute(executor, function(value) {\n        promise._resolveCallback(value);\n    }, function (reason) {\n        promise._rejectCallback(reason, synchronous);\n    });\n    synchronous = false;\n    this._popContext();\n\n    if (r !== undefined) {\n        promise._rejectCallback(r, true);\n    }\n};\n\nPromise.prototype._settlePromiseFromHandler = function (\n    handler, receiver, value, promise\n) {\n    var bitField = promise._bitField;\n    if (((bitField & 65536) !== 0)) return;\n    promise._pushContext();\n    var x;\n    if (receiver === APPLY) {\n        if (!value || typeof value.length !== \"number\") {\n            x = errorObj;\n            x.e = new TypeError(\"cannot .spread() a non-array: \" +\n                                    util.classString(value));\n        } else {\n            x = tryCatch(handler).apply(this._boundValue(), value);\n        }\n    } else {\n        x = tryCatch(handler).call(receiver, value);\n    }\n    var promiseCreated = promise._popContext();\n    bitField = promise._bitField;\n    if (((bitField & 65536) !== 0)) return;\n\n    if (x === NEXT_FILTER) {\n        promise._reject(value);\n    } else if (x === errorObj) {\n        promise._rejectCallback(x.e, false);\n    } else {\n        debug.checkForgottenReturns(x, promiseCreated, \"\",  promise, this);\n        promise._resolveCallback(x);\n    }\n};\n\nPromise.prototype._target = function() {\n    var ret = this;\n    while (ret._isFollowing()) ret = ret._followee();\n    return ret;\n};\n\nPromise.prototype._followee = function() {\n    return this._rejectionHandler0;\n};\n\nPromise.prototype._setFollowee = function(promise) {\n    this._rejectionHandler0 = promise;\n};\n\nPromise.prototype._settlePromise = function(promise, handler, receiver, value) {\n    var isPromise = promise instanceof Promise;\n    var bitField = this._bitField;\n    var asyncGuaranteed = ((bitField & 134217728) !== 0);\n    if (((bitField & 65536) !== 0)) {\n        if (isPromise) promise._invokeInternalOnCancel();\n\n        if (receiver instanceof PassThroughHandlerContext &&\n            receiver.isFinallyHandler()) {\n            receiver.cancelPromise = promise;\n            if (tryCatch(handler).call(receiver, value) === errorObj) {\n                promise._reject(errorObj.e);\n            }\n        } else if (handler === reflectHandler) {\n            promise._fulfill(reflectHandler.call(receiver));\n        } else if (receiver instanceof Proxyable) {\n            receiver._promiseCancelled(promise);\n        } else if (isPromise || promise instanceof PromiseArray) {\n            promise._cancel();\n        } else {\n            receiver.cancel();\n        }\n    } else if (typeof handler === \"function\") {\n        if (!isPromise) {\n            handler.call(receiver, value, promise);\n        } else {\n            if (asyncGuaranteed) promise._setAsyncGuaranteed();\n            this._settlePromiseFromHandler(handler, receiver, value, promise);\n        }\n    } else if (receiver instanceof Proxyable) {\n        if (!receiver._isResolved()) {\n            if (((bitField & 33554432) !== 0)) {\n                receiver._promiseFulfilled(value, promise);\n            } else {\n                receiver._promiseRejected(value, promise);\n            }\n        }\n    } else if (isPromise) {\n        if (asyncGuaranteed) promise._setAsyncGuaranteed();\n        if (((bitField & 33554432) !== 0)) {\n            promise._fulfill(value);\n        } else {\n            promise._reject(value);\n        }\n    }\n};\n\nPromise.prototype._settlePromiseLateCancellationObserver = function(ctx) {\n    var handler = ctx.handler;\n    var promise = ctx.promise;\n    var receiver = ctx.receiver;\n    var value = ctx.value;\n    if (typeof handler === \"function\") {\n        if (!(promise instanceof Promise)) {\n            handler.call(receiver, value, promise);\n        } else {\n            this._settlePromiseFromHandler(handler, receiver, value, promise);\n        }\n    } else if (promise instanceof Promise) {\n        promise._reject(value);\n    }\n};\n\nPromise.prototype._settlePromiseCtx = function(ctx) {\n    this._settlePromise(ctx.promise, ctx.handler, ctx.receiver, ctx.value);\n};\n\nPromise.prototype._settlePromise0 = function(handler, value, bitField) {\n    var promise = this._promise0;\n    var receiver = this._receiverAt(0);\n    this._promise0 = undefined;\n    this._receiver0 = undefined;\n    this._settlePromise(promise, handler, receiver, value);\n};\n\nPromise.prototype._clearCallbackDataAtIndex = function(index) {\n    var base = index * 4 - 4;\n    this[base + 2] =\n    this[base + 3] =\n    this[base + 0] =\n    this[base + 1] = undefined;\n};\n\nPromise.prototype._fulfill = function (value) {\n    var bitField = this._bitField;\n    if (((bitField & 117506048) >>> 16)) return;\n    if (value === this) {\n        var err = makeSelfResolutionError();\n        this._attachExtraTrace(err);\n        return this._reject(err);\n    }\n    this._setFulfilled();\n    this._rejectionHandler0 = value;\n\n    if ((bitField & 65535) > 0) {\n        if (((bitField & 134217728) !== 0)) {\n            this._settlePromises();\n        } else {\n            async.settlePromises(this);\n        }\n        this._dereferenceTrace();\n    }\n};\n\nPromise.prototype._reject = function (reason) {\n    var bitField = this._bitField;\n    if (((bitField & 117506048) >>> 16)) return;\n    this._setRejected();\n    this._fulfillmentHandler0 = reason;\n\n    if (this._isFinal()) {\n        return async.fatalError(reason, util.isNode);\n    }\n\n    if ((bitField & 65535) > 0) {\n        async.settlePromises(this);\n    } else {\n        this._ensurePossibleRejectionHandled();\n    }\n};\n\nPromise.prototype._fulfillPromises = function (len, value) {\n    for (var i = 1; i < len; i++) {\n        var handler = this._fulfillmentHandlerAt(i);\n        var promise = this._promiseAt(i);\n        var receiver = this._receiverAt(i);\n        this._clearCallbackDataAtIndex(i);\n        this._settlePromise(promise, handler, receiver, value);\n    }\n};\n\nPromise.prototype._rejectPromises = function (len, reason) {\n    for (var i = 1; i < len; i++) {\n        var handler = this._rejectionHandlerAt(i);\n        var promise = this._promiseAt(i);\n        var receiver = this._receiverAt(i);\n        this._clearCallbackDataAtIndex(i);\n        this._settlePromise(promise, handler, receiver, reason);\n    }\n};\n\nPromise.prototype._settlePromises = function () {\n    var bitField = this._bitField;\n    var len = (bitField & 65535);\n\n    if (len > 0) {\n        if (((bitField & 16842752) !== 0)) {\n            var reason = this._fulfillmentHandler0;\n            this._settlePromise0(this._rejectionHandler0, reason, bitField);\n            this._rejectPromises(len, reason);\n        } else {\n            var value = this._rejectionHandler0;\n            this._settlePromise0(this._fulfillmentHandler0, value, bitField);\n            this._fulfillPromises(len, value);\n        }\n        this._setLength(0);\n    }\n    this._clearCancellationData();\n};\n\nPromise.prototype._settledValue = function() {\n    var bitField = this._bitField;\n    if (((bitField & 33554432) !== 0)) {\n        return this._rejectionHandler0;\n    } else if (((bitField & 16777216) !== 0)) {\n        return this._fulfillmentHandler0;\n    }\n};\n\nif (typeof Symbol !== \"undefined\" && Symbol.toStringTag) {\n    es5.defineProperty(Promise.prototype, Symbol.toStringTag, {\n        get: function () {\n            return \"Object\";\n        }\n    });\n}\n\nfunction deferResolve(v) {this.promise._resolveCallback(v);}\nfunction deferReject(v) {this.promise._rejectCallback(v, false);}\n\nPromise.defer = Promise.pending = function() {\n    debug.deprecated(\"Promise.defer\", \"new Promise\");\n    var promise = new Promise(INTERNAL);\n    return {\n        promise: promise,\n        resolve: deferResolve,\n        reject: deferReject\n    };\n};\n\nutil.notEnumerableProp(Promise,\n                       \"_makeSelfResolutionError\",\n                       makeSelfResolutionError);\n\nrequire(\"./method\")(Promise, INTERNAL, tryConvertToPromise, apiRejection,\n    debug);\nrequire(\"./bind\")(Promise, INTERNAL, tryConvertToPromise, debug);\nrequire(\"./cancel\")(Promise, PromiseArray, apiRejection, debug);\nrequire(\"./direct_resolve\")(Promise);\nrequire(\"./synchronous_inspection\")(Promise);\nrequire(\"./join\")(\n    Promise, PromiseArray, tryConvertToPromise, INTERNAL, async);\nPromise.Promise = Promise;\nPromise.version = \"3.7.2\";\nrequire('./call_get.js')(Promise);\nrequire('./generators.js')(Promise, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug);\nrequire('./map.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);\nrequire('./nodeify.js')(Promise);\nrequire('./promisify.js')(Promise, INTERNAL);\nrequire('./props.js')(Promise, PromiseArray, tryConvertToPromise, apiRejection);\nrequire('./race.js')(Promise, INTERNAL, tryConvertToPromise, apiRejection);\nrequire('./reduce.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);\nrequire('./settle.js')(Promise, PromiseArray, debug);\nrequire('./some.js')(Promise, PromiseArray, apiRejection);\nrequire('./timers.js')(Promise, INTERNAL, debug);\nrequire('./using.js')(Promise, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug);\nrequire('./any.js')(Promise);\nrequire('./each.js')(Promise, INTERNAL);\nrequire('./filter.js')(Promise, INTERNAL);\n                                                         \n    util.toFastProperties(Promise);                                          \n    util.toFastProperties(Promise.prototype);                                \n    function fillTypes(value) {                                              \n        var p = new Promise(INTERNAL);                                       \n        p._fulfillmentHandler0 = value;                                      \n        p._rejectionHandler0 = value;                                        \n        p._promise0 = value;                                                 \n        p._receiver0 = value;                                                \n    }                                                                        \n    // Complete slack tracking, opt out of field-type tracking and           \n    // stabilize map                                                         \n    fillTypes({a: 1});                                                       \n    fillTypes({b: 2});                                                       \n    fillTypes({c: 3});                                                       \n    fillTypes(1);                                                            \n    fillTypes(function(){});                                                 \n    fillTypes(undefined);                                                    \n    fillTypes(false);                                                        \n    fillTypes(new Promise(INTERNAL));                                        \n    debug.setBounds(Async.firstLineError, util.lastLineError);               \n    return Promise;                                                          \n\n};\n","\"use strict\";\nvar es5 = require(\"./es5\");\nvar canEvaluate = typeof navigator == \"undefined\";\n\nvar errorObj = {e: {}};\nvar tryCatchTarget;\nvar globalObject = typeof self !== \"undefined\" ? self :\n    typeof window !== \"undefined\" ? window :\n    typeof global !== \"undefined\" ? global :\n    this !== undefined ? this : null;\n\nfunction tryCatcher() {\n    try {\n        var target = tryCatchTarget;\n        tryCatchTarget = null;\n        return target.apply(this, arguments);\n    } catch (e) {\n        errorObj.e = e;\n        return errorObj;\n    }\n}\nfunction tryCatch(fn) {\n    tryCatchTarget = fn;\n    return tryCatcher;\n}\n\nvar inherits = function(Child, Parent) {\n    var hasProp = {}.hasOwnProperty;\n\n    function T() {\n        this.constructor = Child;\n        this.constructor$ = Parent;\n        for (var propertyName in Parent.prototype) {\n            if (hasProp.call(Parent.prototype, propertyName) &&\n                propertyName.charAt(propertyName.length-1) !== \"$\"\n           ) {\n                this[propertyName + \"$\"] = Parent.prototype[propertyName];\n            }\n        }\n    }\n    T.prototype = Parent.prototype;\n    Child.prototype = new T();\n    return Child.prototype;\n};\n\n\nfunction isPrimitive(val) {\n    return val == null || val === true || val === false ||\n        typeof val === \"string\" || typeof val === \"number\";\n\n}\n\nfunction isObject(value) {\n    return typeof value === \"function\" ||\n           typeof value === \"object\" && value !== null;\n}\n\nfunction maybeWrapAsError(maybeError) {\n    if (!isPrimitive(maybeError)) return maybeError;\n\n    return new Error(safeToString(maybeError));\n}\n\nfunction withAppended(target, appendee) {\n    var len = target.length;\n    var ret = new Array(len + 1);\n    var i;\n    for (i = 0; i < len; ++i) {\n        ret[i] = target[i];\n    }\n    ret[i] = appendee;\n    return ret;\n}\n\nfunction getDataPropertyOrDefault(obj, key, defaultValue) {\n    if (es5.isES5) {\n        var desc = Object.getOwnPropertyDescriptor(obj, key);\n\n        if (desc != null) {\n            return desc.get == null && desc.set == null\n                    ? desc.value\n                    : defaultValue;\n        }\n    } else {\n        return {}.hasOwnProperty.call(obj, key) ? obj[key] : undefined;\n    }\n}\n\nfunction notEnumerableProp(obj, name, value) {\n    if (isPrimitive(obj)) return obj;\n    var descriptor = {\n        value: value,\n        configurable: true,\n        enumerable: false,\n        writable: true\n    };\n    es5.defineProperty(obj, name, descriptor);\n    return obj;\n}\n\nfunction thrower(r) {\n    throw r;\n}\n\nvar inheritedDataKeys = (function() {\n    var excludedPrototypes = [\n        Array.prototype,\n        Object.prototype,\n        Function.prototype\n    ];\n\n    var isExcludedProto = function(val) {\n        for (var i = 0; i < excludedPrototypes.length; ++i) {\n            if (excludedPrototypes[i] === val) {\n                return true;\n            }\n        }\n        return false;\n    };\n\n    if (es5.isES5) {\n        var getKeys = Object.getOwnPropertyNames;\n        return function(obj) {\n            var ret = [];\n            var visitedKeys = Object.create(null);\n            while (obj != null && !isExcludedProto(obj)) {\n                var keys;\n                try {\n                    keys = getKeys(obj);\n                } catch (e) {\n                    return ret;\n                }\n                for (var i = 0; i < keys.length; ++i) {\n                    var key = keys[i];\n                    if (visitedKeys[key]) continue;\n                    visitedKeys[key] = true;\n                    var desc = Object.getOwnPropertyDescriptor(obj, key);\n                    if (desc != null && desc.get == null && desc.set == null) {\n                        ret.push(key);\n                    }\n                }\n                obj = es5.getPrototypeOf(obj);\n            }\n            return ret;\n        };\n    } else {\n        var hasProp = {}.hasOwnProperty;\n        return function(obj) {\n            if (isExcludedProto(obj)) return [];\n            var ret = [];\n\n            /*jshint forin:false */\n            enumeration: for (var key in obj) {\n                if (hasProp.call(obj, key)) {\n                    ret.push(key);\n                } else {\n                    for (var i = 0; i < excludedPrototypes.length; ++i) {\n                        if (hasProp.call(excludedPrototypes[i], key)) {\n                            continue enumeration;\n                        }\n                    }\n                    ret.push(key);\n                }\n            }\n            return ret;\n        };\n    }\n\n})();\n\nvar thisAssignmentPattern = /this\\s*\\.\\s*\\S+\\s*=/;\nfunction isClass(fn) {\n    try {\n        if (typeof fn === \"function\") {\n            var keys = es5.names(fn.prototype);\n\n            var hasMethods = es5.isES5 && keys.length > 1;\n            var hasMethodsOtherThanConstructor = keys.length > 0 &&\n                !(keys.length === 1 && keys[0] === \"constructor\");\n            var hasThisAssignmentAndStaticMethods =\n                thisAssignmentPattern.test(fn + \"\") && es5.names(fn).length > 0;\n\n            if (hasMethods || hasMethodsOtherThanConstructor ||\n                hasThisAssignmentAndStaticMethods) {\n                return true;\n            }\n        }\n        return false;\n    } catch (e) {\n        return false;\n    }\n}\n\nfunction toFastProperties(obj) {\n    /*jshint -W027,-W055,-W031*/\n    function FakeConstructor() {}\n    FakeConstructor.prototype = obj;\n    var receiver = new FakeConstructor();\n    function ic() {\n        return typeof receiver.foo;\n    }\n    ic();\n    ic();\n    return obj;\n    eval(obj);\n}\n\nvar rident = /^[a-z$_][a-z$_0-9]*$/i;\nfunction isIdentifier(str) {\n    return rident.test(str);\n}\n\nfunction filledRange(count, prefix, suffix) {\n    var ret = new Array(count);\n    for(var i = 0; i < count; ++i) {\n        ret[i] = prefix + i + suffix;\n    }\n    return ret;\n}\n\nfunction safeToString(obj) {\n    try {\n        return obj + \"\";\n    } catch (e) {\n        return \"[no string representation]\";\n    }\n}\n\nfunction isError(obj) {\n    return obj instanceof Error ||\n        (obj !== null &&\n           typeof obj === \"object\" &&\n           typeof obj.message === \"string\" &&\n           typeof obj.name === \"string\");\n}\n\nfunction markAsOriginatingFromRejection(e) {\n    try {\n        notEnumerableProp(e, \"isOperational\", true);\n    }\n    catch(ignore) {}\n}\n\nfunction originatesFromRejection(e) {\n    if (e == null) return false;\n    return ((e instanceof Error[\"__BluebirdErrorTypes__\"].OperationalError) ||\n        e[\"isOperational\"] === true);\n}\n\nfunction canAttachTrace(obj) {\n    return isError(obj) && es5.propertyIsWritable(obj, \"stack\");\n}\n\nvar ensureErrorObject = (function() {\n    if (!(\"stack\" in new Error())) {\n        return function(value) {\n            if (canAttachTrace(value)) return value;\n            try {throw new Error(safeToString(value));}\n            catch(err) {return err;}\n        };\n    } else {\n        return function(value) {\n            if (canAttachTrace(value)) return value;\n            return new Error(safeToString(value));\n        };\n    }\n})();\n\nfunction classString(obj) {\n    return {}.toString.call(obj);\n}\n\nfunction copyDescriptors(from, to, filter) {\n    var keys = es5.names(from);\n    for (var i = 0; i < keys.length; ++i) {\n        var key = keys[i];\n        if (filter(key)) {\n            try {\n                es5.defineProperty(to, key, es5.getDescriptor(from, key));\n            } catch (ignore) {}\n        }\n    }\n}\n\nvar asArray = function(v) {\n    if (es5.isArray(v)) {\n        return v;\n    }\n    return null;\n};\n\nif (typeof Symbol !== \"undefined\" && Symbol.iterator) {\n    var ArrayFrom = typeof Array.from === \"function\" ? function(v) {\n        return Array.from(v);\n    } : function(v) {\n        var ret = [];\n        var it = v[Symbol.iterator]();\n        var itResult;\n        while (!((itResult = it.next()).done)) {\n            ret.push(itResult.value);\n        }\n        return ret;\n    };\n\n    asArray = function(v) {\n        if (es5.isArray(v)) {\n            return v;\n        } else if (v != null && typeof v[Symbol.iterator] === \"function\") {\n            return ArrayFrom(v);\n        }\n        return null;\n    };\n}\n\nvar isNode = typeof process !== \"undefined\" &&\n        classString(process).toLowerCase() === \"[object process]\";\n\nvar hasEnvVariables = typeof process !== \"undefined\" &&\n    typeof process.env !== \"undefined\";\n\nfunction env(key) {\n    return hasEnvVariables ? process.env[key] : undefined;\n}\n\nfunction getNativePromise() {\n    if (typeof Promise === \"function\") {\n        try {\n            var promise = new Promise(function(){});\n            if (classString(promise) === \"[object Promise]\") {\n                return Promise;\n            }\n        } catch (e) {}\n    }\n}\n\nvar reflectHandler;\nfunction contextBind(ctx, cb) {\n    if (ctx === null ||\n        typeof cb !== \"function\" ||\n        cb === reflectHandler) {\n        return cb;\n    }\n\n    if (ctx.domain !== null) {\n        cb = ctx.domain.bind(cb);\n    }\n\n    var async = ctx.async;\n    if (async !== null) {\n        var old = cb;\n        cb = function() {\n            var $_len = arguments.length + 2;var args = new Array($_len); for(var $_i = 2; $_i < $_len ; ++$_i) {args[$_i] = arguments[$_i  - 2];};\n            args[0] = old;\n            args[1] = this;\n            return async.runInAsyncScope.apply(async, args);\n        };\n    }\n    return cb;\n}\n\nvar ret = {\n    setReflectHandler: function(fn) {\n        reflectHandler = fn;\n    },\n    isClass: isClass,\n    isIdentifier: isIdentifier,\n    inheritedDataKeys: inheritedDataKeys,\n    getDataPropertyOrDefault: getDataPropertyOrDefault,\n    thrower: thrower,\n    isArray: es5.isArray,\n    asArray: asArray,\n    notEnumerableProp: notEnumerableProp,\n    isPrimitive: isPrimitive,\n    isObject: isObject,\n    isError: isError,\n    canEvaluate: canEvaluate,\n    errorObj: errorObj,\n    tryCatch: tryCatch,\n    inherits: inherits,\n    withAppended: withAppended,\n    maybeWrapAsError: maybeWrapAsError,\n    toFastProperties: toFastProperties,\n    filledRange: filledRange,\n    toString: safeToString,\n    canAttachTrace: canAttachTrace,\n    ensureErrorObject: ensureErrorObject,\n    originatesFromRejection: originatesFromRejection,\n    markAsOriginatingFromRejection: markAsOriginatingFromRejection,\n    classString: classString,\n    copyDescriptors: copyDescriptors,\n    isNode: isNode,\n    hasEnvVariables: hasEnvVariables,\n    env: env,\n    global: globalObject,\n    getNativePromise: getNativePromise,\n    contextBind: contextBind\n};\nret.isRecentNode = ret.isNode && (function() {\n    var version;\n    if (process.versions && process.versions.node) {\n        version = process.versions.node.split(\".\").map(Number);\n    } else if (process.version) {\n        version = process.version.split(\".\").map(Number);\n    }\n    return (version[0] === 0 && version[1] > 10) || (version[0] > 0);\n})();\nret.nodeSupportsAsyncResource = ret.isNode && (function() {\n    var supportsAsync = false;\n    try {\n        var res = require(\"async_hooks\").AsyncResource;\n        supportsAsync = typeof res.prototype.runInAsyncScope === \"function\";\n    } catch (e) {\n        supportsAsync = false;\n    }\n    return supportsAsync;\n})();\n\nif (ret.isNode) ret.toFastProperties(process);\n\ntry {throw new Error(); } catch (e) {ret.lastLineError = e;}\nmodule.exports = ret;\n","var isES5 = (function(){\n    \"use strict\";\n    return this === undefined;\n})();\n\nif (isES5) {\n    module.exports = {\n        freeze: Object.freeze,\n        defineProperty: Object.defineProperty,\n        getDescriptor: Object.getOwnPropertyDescriptor,\n        keys: Object.keys,\n        names: Object.getOwnPropertyNames,\n        getPrototypeOf: Object.getPrototypeOf,\n        isArray: Array.isArray,\n        isES5: isES5,\n        propertyIsWritable: function(obj, prop) {\n            var descriptor = Object.getOwnPropertyDescriptor(obj, prop);\n            return !!(!descriptor || descriptor.writable || descriptor.set);\n        }\n    };\n} else {\n    var has = {}.hasOwnProperty;\n    var str = {}.toString;\n    var proto = {}.constructor.prototype;\n\n    var ObjectKeys = function (o) {\n        var ret = [];\n        for (var key in o) {\n            if (has.call(o, key)) {\n                ret.push(key);\n            }\n        }\n        return ret;\n    };\n\n    var ObjectGetDescriptor = function(o, key) {\n        return {value: o[key]};\n    };\n\n    var ObjectDefineProperty = function (o, key, desc) {\n        o[key] = desc.value;\n        return o;\n    };\n\n    var ObjectFreeze = function (obj) {\n        return obj;\n    };\n\n    var ObjectGetPrototypeOf = function (obj) {\n        try {\n            return Object(obj).constructor.prototype;\n        }\n        catch (e) {\n            return proto;\n        }\n    };\n\n    var ArrayIsArray = function (obj) {\n        try {\n            return str.call(obj) === \"[object Array]\";\n        }\n        catch(e) {\n            return false;\n        }\n    };\n\n    module.exports = {\n        isArray: ArrayIsArray,\n        keys: ObjectKeys,\n        names: ObjectKeys,\n        defineProperty: ObjectDefineProperty,\n        getDescriptor: ObjectGetDescriptor,\n        freeze: ObjectFreeze,\n        getPrototypeOf: ObjectGetPrototypeOf,\n        isES5: isES5,\n        propertyIsWritable: function() {\n            return true;\n        }\n    };\n}\n","module.exports = require(\"async_hooks\");","\"use strict\";\nvar firstLineError;\ntry {throw new Error(); } catch (e) {firstLineError = e;}\nvar schedule = require(\"./schedule\");\nvar Queue = require(\"./queue\");\n\nfunction Async() {\n    this._customScheduler = false;\n    this._isTickUsed = false;\n    this._lateQueue = new Queue(16);\n    this._normalQueue = new Queue(16);\n    this._haveDrainedQueues = false;\n    var self = this;\n    this.drainQueues = function () {\n        self._drainQueues();\n    };\n    this._schedule = schedule;\n}\n\nAsync.prototype.setScheduler = function(fn) {\n    var prev = this._schedule;\n    this._schedule = fn;\n    this._customScheduler = true;\n    return prev;\n};\n\nAsync.prototype.hasCustomScheduler = function() {\n    return this._customScheduler;\n};\n\nAsync.prototype.haveItemsQueued = function () {\n    return this._isTickUsed || this._haveDrainedQueues;\n};\n\n\nAsync.prototype.fatalError = function(e, isNode) {\n    if (isNode) {\n        process.stderr.write(\"Fatal \" + (e instanceof Error ? e.stack : e) +\n            \"\\n\");\n        process.exit(2);\n    } else {\n        this.throwLater(e);\n    }\n};\n\nAsync.prototype.throwLater = function(fn, arg) {\n    if (arguments.length === 1) {\n        arg = fn;\n        fn = function () { throw arg; };\n    }\n    if (typeof setTimeout !== \"undefined\") {\n        setTimeout(function() {\n            fn(arg);\n        }, 0);\n    } else try {\n        this._schedule(function() {\n            fn(arg);\n        });\n    } catch (e) {\n        throw new Error(\"No async scheduler available\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n    }\n};\n\nfunction AsyncInvokeLater(fn, receiver, arg) {\n    this._lateQueue.push(fn, receiver, arg);\n    this._queueTick();\n}\n\nfunction AsyncInvoke(fn, receiver, arg) {\n    this._normalQueue.push(fn, receiver, arg);\n    this._queueTick();\n}\n\nfunction AsyncSettlePromises(promise) {\n    this._normalQueue._pushOne(promise);\n    this._queueTick();\n}\n\nAsync.prototype.invokeLater = AsyncInvokeLater;\nAsync.prototype.invoke = AsyncInvoke;\nAsync.prototype.settlePromises = AsyncSettlePromises;\n\n\nfunction _drainQueue(queue) {\n    while (queue.length() > 0) {\n        _drainQueueStep(queue);\n    }\n}\n\nfunction _drainQueueStep(queue) {\n    var fn = queue.shift();\n    if (typeof fn !== \"function\") {\n        fn._settlePromises();\n    } else {\n        var receiver = queue.shift();\n        var arg = queue.shift();\n        fn.call(receiver, arg);\n    }\n}\n\nAsync.prototype._drainQueues = function () {\n    _drainQueue(this._normalQueue);\n    this._reset();\n    this._haveDrainedQueues = true;\n    _drainQueue(this._lateQueue);\n};\n\nAsync.prototype._queueTick = function () {\n    if (!this._isTickUsed) {\n        this._isTickUsed = true;\n        this._schedule(this.drainQueues);\n    }\n};\n\nAsync.prototype._reset = function () {\n    this._isTickUsed = false;\n};\n\nmodule.exports = Async;\nmodule.exports.firstLineError = firstLineError;\n","\"use strict\";\nvar util = require(\"./util\");\nvar schedule;\nvar noAsyncScheduler = function() {\n    throw new Error(\"No async scheduler available\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n};\nvar NativePromise = util.getNativePromise();\nif (util.isNode && typeof MutationObserver === \"undefined\") {\n    var GlobalSetImmediate = global.setImmediate;\n    var ProcessNextTick = process.nextTick;\n    schedule = util.isRecentNode\n                ? function(fn) { GlobalSetImmediate.call(global, fn); }\n                : function(fn) { ProcessNextTick.call(process, fn); };\n} else if (typeof NativePromise === \"function\" &&\n           typeof NativePromise.resolve === \"function\") {\n    var nativePromise = NativePromise.resolve();\n    schedule = function(fn) {\n        nativePromise.then(fn);\n    };\n} else if ((typeof MutationObserver !== \"undefined\") &&\n          !(typeof window !== \"undefined\" &&\n            window.navigator &&\n            (window.navigator.standalone || window.cordova)) &&\n          (\"classList\" in document.documentElement)) {\n    schedule = (function() {\n        var div = document.createElement(\"div\");\n        var opts = {attributes: true};\n        var toggleScheduled = false;\n        var div2 = document.createElement(\"div\");\n        var o2 = new MutationObserver(function() {\n            div.classList.toggle(\"foo\");\n            toggleScheduled = false;\n        });\n        o2.observe(div2, opts);\n\n        var scheduleToggle = function() {\n            if (toggleScheduled) return;\n            toggleScheduled = true;\n            div2.classList.toggle(\"foo\");\n        };\n\n        return function schedule(fn) {\n            var o = new MutationObserver(function() {\n                o.disconnect();\n                fn();\n            });\n            o.observe(div, opts);\n            scheduleToggle();\n        };\n    })();\n} else if (typeof setImmediate !== \"undefined\") {\n    schedule = function (fn) {\n        setImmediate(fn);\n    };\n} else if (typeof setTimeout !== \"undefined\") {\n    schedule = function (fn) {\n        setTimeout(fn, 0);\n    };\n} else {\n    schedule = noAsyncScheduler;\n}\nmodule.exports = schedule;\n","\"use strict\";\nfunction arrayMove(src, srcIndex, dst, dstIndex, len) {\n    for (var j = 0; j < len; ++j) {\n        dst[j + dstIndex] = src[j + srcIndex];\n        src[j + srcIndex] = void 0;\n    }\n}\n\nfunction Queue(capacity) {\n    this._capacity = capacity;\n    this._length = 0;\n    this._front = 0;\n}\n\nQueue.prototype._willBeOverCapacity = function (size) {\n    return this._capacity < size;\n};\n\nQueue.prototype._pushOne = function (arg) {\n    var length = this.length();\n    this._checkCapacity(length + 1);\n    var i = (this._front + length) & (this._capacity - 1);\n    this[i] = arg;\n    this._length = length + 1;\n};\n\nQueue.prototype.push = function (fn, receiver, arg) {\n    var length = this.length() + 3;\n    if (this._willBeOverCapacity(length)) {\n        this._pushOne(fn);\n        this._pushOne(receiver);\n        this._pushOne(arg);\n        return;\n    }\n    var j = this._front + length - 3;\n    this._checkCapacity(length);\n    var wrapMask = this._capacity - 1;\n    this[(j + 0) & wrapMask] = fn;\n    this[(j + 1) & wrapMask] = receiver;\n    this[(j + 2) & wrapMask] = arg;\n    this._length = length;\n};\n\nQueue.prototype.shift = function () {\n    var front = this._front,\n        ret = this[front];\n\n    this[front] = undefined;\n    this._front = (front + 1) & (this._capacity - 1);\n    this._length--;\n    return ret;\n};\n\nQueue.prototype.length = function () {\n    return this._length;\n};\n\nQueue.prototype._checkCapacity = function (size) {\n    if (this._capacity < size) {\n        this._resizeTo(this._capacity << 1);\n    }\n};\n\nQueue.prototype._resizeTo = function (capacity) {\n    var oldCapacity = this._capacity;\n    this._capacity = capacity;\n    var front = this._front;\n    var length = this._length;\n    var moveItemsCount = (front + length) & (oldCapacity - 1);\n    arrayMove(this, 0, this, oldCapacity, moveItemsCount);\n};\n\nmodule.exports = Queue;\n","\"use strict\";\nvar es5 = require(\"./es5\");\nvar Objectfreeze = es5.freeze;\nvar util = require(\"./util\");\nvar inherits = util.inherits;\nvar notEnumerableProp = util.notEnumerableProp;\n\nfunction subError(nameProperty, defaultMessage) {\n    function SubError(message) {\n        if (!(this instanceof SubError)) return new SubError(message);\n        notEnumerableProp(this, \"message\",\n            typeof message === \"string\" ? message : defaultMessage);\n        notEnumerableProp(this, \"name\", nameProperty);\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, this.constructor);\n        } else {\n            Error.call(this);\n        }\n    }\n    inherits(SubError, Error);\n    return SubError;\n}\n\nvar _TypeError, _RangeError;\nvar Warning = subError(\"Warning\", \"warning\");\nvar CancellationError = subError(\"CancellationError\", \"cancellation error\");\nvar TimeoutError = subError(\"TimeoutError\", \"timeout error\");\nvar AggregateError = subError(\"AggregateError\", \"aggregate error\");\ntry {\n    _TypeError = TypeError;\n    _RangeError = RangeError;\n} catch(e) {\n    _TypeError = subError(\"TypeError\", \"type error\");\n    _RangeError = subError(\"RangeError\", \"range error\");\n}\n\nvar methods = (\"join pop push shift unshift slice filter forEach some \" +\n    \"every map indexOf lastIndexOf reduce reduceRight sort reverse\").split(\" \");\n\nfor (var i = 0; i < methods.length; ++i) {\n    if (typeof Array.prototype[methods[i]] === \"function\") {\n        AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];\n    }\n}\n\nes5.defineProperty(AggregateError.prototype, \"length\", {\n    value: 0,\n    configurable: false,\n    writable: true,\n    enumerable: true\n});\nAggregateError.prototype[\"isOperational\"] = true;\nvar level = 0;\nAggregateError.prototype.toString = function() {\n    var indent = Array(level * 4 + 1).join(\" \");\n    var ret = \"\\n\" + indent + \"AggregateError of:\" + \"\\n\";\n    level++;\n    indent = Array(level * 4 + 1).join(\" \");\n    for (var i = 0; i < this.length; ++i) {\n        var str = this[i] === this ? \"[Circular AggregateError]\" : this[i] + \"\";\n        var lines = str.split(\"\\n\");\n        for (var j = 0; j < lines.length; ++j) {\n            lines[j] = indent + lines[j];\n        }\n        str = lines.join(\"\\n\");\n        ret += str + \"\\n\";\n    }\n    level--;\n    return ret;\n};\n\nfunction OperationalError(message) {\n    if (!(this instanceof OperationalError))\n        return new OperationalError(message);\n    notEnumerableProp(this, \"name\", \"OperationalError\");\n    notEnumerableProp(this, \"message\", message);\n    this.cause = message;\n    this[\"isOperational\"] = true;\n\n    if (message instanceof Error) {\n        notEnumerableProp(this, \"message\", message.message);\n        notEnumerableProp(this, \"stack\", message.stack);\n    } else if (Error.captureStackTrace) {\n        Error.captureStackTrace(this, this.constructor);\n    }\n\n}\ninherits(OperationalError, Error);\n\nvar errorTypes = Error[\"__BluebirdErrorTypes__\"];\nif (!errorTypes) {\n    errorTypes = Objectfreeze({\n        CancellationError: CancellationError,\n        TimeoutError: TimeoutError,\n        OperationalError: OperationalError,\n        RejectionError: OperationalError,\n        AggregateError: AggregateError\n    });\n    es5.defineProperty(Error, \"__BluebirdErrorTypes__\", {\n        value: errorTypes,\n        writable: false,\n        enumerable: false,\n        configurable: false\n    });\n}\n\nmodule.exports = {\n    Error: Error,\n    TypeError: _TypeError,\n    RangeError: _RangeError,\n    CancellationError: errorTypes.CancellationError,\n    OperationalError: errorTypes.OperationalError,\n    TimeoutError: errorTypes.TimeoutError,\n    AggregateError: errorTypes.AggregateError,\n    Warning: Warning\n};\n","\"use strict\";\nmodule.exports = function(Promise, INTERNAL) {\nvar util = require(\"./util\");\nvar errorObj = util.errorObj;\nvar isObject = util.isObject;\n\nfunction tryConvertToPromise(obj, context) {\n    if (isObject(obj)) {\n        if (obj instanceof Promise) return obj;\n        var then = getThen(obj);\n        if (then === errorObj) {\n            if (context) context._pushContext();\n            var ret = Promise.reject(then.e);\n            if (context) context._popContext();\n            return ret;\n        } else if (typeof then === \"function\") {\n            if (isAnyBluebirdPromise(obj)) {\n                var ret = new Promise(INTERNAL);\n                obj._then(\n                    ret._fulfill,\n                    ret._reject,\n                    undefined,\n                    ret,\n                    null\n                );\n                return ret;\n            }\n            return doThenable(obj, then, context);\n        }\n    }\n    return obj;\n}\n\nfunction doGetThen(obj) {\n    return obj.then;\n}\n\nfunction getThen(obj) {\n    try {\n        return doGetThen(obj);\n    } catch (e) {\n        errorObj.e = e;\n        return errorObj;\n    }\n}\n\nvar hasProp = {}.hasOwnProperty;\nfunction isAnyBluebirdPromise(obj) {\n    try {\n        return hasProp.call(obj, \"_promise0\");\n    } catch (e) {\n        return false;\n    }\n}\n\nfunction doThenable(x, then, context) {\n    var promise = new Promise(INTERNAL);\n    var ret = promise;\n    if (context) context._pushContext();\n    promise._captureStackTrace();\n    if (context) context._popContext();\n    var synchronous = true;\n    var result = util.tryCatch(then).call(x, resolve, reject);\n    synchronous = false;\n\n    if (promise && result === errorObj) {\n        promise._rejectCallback(result.e, true, true);\n        promise = null;\n    }\n\n    function resolve(value) {\n        if (!promise) return;\n        promise._resolveCallback(value);\n        promise = null;\n    }\n\n    function reject(reason) {\n        if (!promise) return;\n        promise._rejectCallback(reason, synchronous, true);\n        promise = null;\n    }\n    return ret;\n}\n\nreturn tryConvertToPromise;\n};\n","\"use strict\";\nmodule.exports = function(Promise, INTERNAL, tryConvertToPromise,\n    apiRejection, Proxyable) {\nvar util = require(\"./util\");\nvar isArray = util.isArray;\n\nfunction toResolutionValue(val) {\n    switch(val) {\n    case -2: return [];\n    case -3: return {};\n    case -6: return new Map();\n    }\n}\n\nfunction PromiseArray(values) {\n    var promise = this._promise = new Promise(INTERNAL);\n    if (values instanceof Promise) {\n        promise._propagateFrom(values, 3);\n        values.suppressUnhandledRejections();\n    }\n    promise._setOnCancel(this);\n    this._values = values;\n    this._length = 0;\n    this._totalResolved = 0;\n    this._init(undefined, -2);\n}\nutil.inherits(PromiseArray, Proxyable);\n\nPromiseArray.prototype.length = function () {\n    return this._length;\n};\n\nPromiseArray.prototype.promise = function () {\n    return this._promise;\n};\n\nPromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {\n    var values = tryConvertToPromise(this._values, this._promise);\n    if (values instanceof Promise) {\n        values = values._target();\n        var bitField = values._bitField;\n        ;\n        this._values = values;\n\n        if (((bitField & 50397184) === 0)) {\n            this._promise._setAsyncGuaranteed();\n            return values._then(\n                init,\n                this._reject,\n                undefined,\n                this,\n                resolveValueIfEmpty\n           );\n        } else if (((bitField & 33554432) !== 0)) {\n            values = values._value();\n        } else if (((bitField & 16777216) !== 0)) {\n            return this._reject(values._reason());\n        } else {\n            return this._cancel();\n        }\n    }\n    values = util.asArray(values);\n    if (values === null) {\n        var err = apiRejection(\n            \"expecting an array or an iterable object but got \" + util.classString(values)).reason();\n        this._promise._rejectCallback(err, false);\n        return;\n    }\n\n    if (values.length === 0) {\n        if (resolveValueIfEmpty === -5) {\n            this._resolveEmptyArray();\n        }\n        else {\n            this._resolve(toResolutionValue(resolveValueIfEmpty));\n        }\n        return;\n    }\n    this._iterate(values);\n};\n\nPromiseArray.prototype._iterate = function(values) {\n    var len = this.getActualLength(values.length);\n    this._length = len;\n    this._values = this.shouldCopyValues() ? new Array(len) : this._values;\n    var result = this._promise;\n    var isResolved = false;\n    var bitField = null;\n    for (var i = 0; i < len; ++i) {\n        var maybePromise = tryConvertToPromise(values[i], result);\n\n        if (maybePromise instanceof Promise) {\n            maybePromise = maybePromise._target();\n            bitField = maybePromise._bitField;\n        } else {\n            bitField = null;\n        }\n\n        if (isResolved) {\n            if (bitField !== null) {\n                maybePromise.suppressUnhandledRejections();\n            }\n        } else if (bitField !== null) {\n            if (((bitField & 50397184) === 0)) {\n                maybePromise._proxy(this, i);\n                this._values[i] = maybePromise;\n            } else if (((bitField & 33554432) !== 0)) {\n                isResolved = this._promiseFulfilled(maybePromise._value(), i);\n            } else if (((bitField & 16777216) !== 0)) {\n                isResolved = this._promiseRejected(maybePromise._reason(), i);\n            } else {\n                isResolved = this._promiseCancelled(i);\n            }\n        } else {\n            isResolved = this._promiseFulfilled(maybePromise, i);\n        }\n    }\n    if (!isResolved) result._setAsyncGuaranteed();\n};\n\nPromiseArray.prototype._isResolved = function () {\n    return this._values === null;\n};\n\nPromiseArray.prototype._resolve = function (value) {\n    this._values = null;\n    this._promise._fulfill(value);\n};\n\nPromiseArray.prototype._cancel = function() {\n    if (this._isResolved() || !this._promise._isCancellable()) return;\n    this._values = null;\n    this._promise._cancel();\n};\n\nPromiseArray.prototype._reject = function (reason) {\n    this._values = null;\n    this._promise._rejectCallback(reason, false);\n};\n\nPromiseArray.prototype._promiseFulfilled = function (value, index) {\n    this._values[index] = value;\n    var totalResolved = ++this._totalResolved;\n    if (totalResolved >= this._length) {\n        this._resolve(this._values);\n        return true;\n    }\n    return false;\n};\n\nPromiseArray.prototype._promiseCancelled = function() {\n    this._cancel();\n    return true;\n};\n\nPromiseArray.prototype._promiseRejected = function (reason) {\n    this._totalResolved++;\n    this._reject(reason);\n    return true;\n};\n\nPromiseArray.prototype._resultCancelled = function() {\n    if (this._isResolved()) return;\n    var values = this._values;\n    this._cancel();\n    if (values instanceof Promise) {\n        values.cancel();\n    } else {\n        for (var i = 0; i < values.length; ++i) {\n            if (values[i] instanceof Promise) {\n                values[i].cancel();\n            }\n        }\n    }\n};\n\nPromiseArray.prototype.shouldCopyValues = function () {\n    return true;\n};\n\nPromiseArray.prototype.getActualLength = function (len) {\n    return len;\n};\n\nreturn PromiseArray;\n};\n","\"use strict\";\nmodule.exports = function(Promise) {\nvar longStackTraces = false;\nvar contextStack = [];\n\nPromise.prototype._promiseCreated = function() {};\nPromise.prototype._pushContext = function() {};\nPromise.prototype._popContext = function() {return null;};\nPromise._peekContext = Promise.prototype._peekContext = function() {};\n\nfunction Context() {\n    this._trace = new Context.CapturedTrace(peekContext());\n}\nContext.prototype._pushContext = function () {\n    if (this._trace !== undefined) {\n        this._trace._promiseCreated = null;\n        contextStack.push(this._trace);\n    }\n};\n\nContext.prototype._popContext = function () {\n    if (this._trace !== undefined) {\n        var trace = contextStack.pop();\n        var ret = trace._promiseCreated;\n        trace._promiseCreated = null;\n        return ret;\n    }\n    return null;\n};\n\nfunction createContext() {\n    if (longStackTraces) return new Context();\n}\n\nfunction peekContext() {\n    var lastIndex = contextStack.length - 1;\n    if (lastIndex >= 0) {\n        return contextStack[lastIndex];\n    }\n    return undefined;\n}\nContext.CapturedTrace = null;\nContext.create = createContext;\nContext.deactivateLongStackTraces = function() {};\nContext.activateLongStackTraces = function() {\n    var Promise_pushContext = Promise.prototype._pushContext;\n    var Promise_popContext = Promise.prototype._popContext;\n    var Promise_PeekContext = Promise._peekContext;\n    var Promise_peekContext = Promise.prototype._peekContext;\n    var Promise_promiseCreated = Promise.prototype._promiseCreated;\n    Context.deactivateLongStackTraces = function() {\n        Promise.prototype._pushContext = Promise_pushContext;\n        Promise.prototype._popContext = Promise_popContext;\n        Promise._peekContext = Promise_PeekContext;\n        Promise.prototype._peekContext = Promise_peekContext;\n        Promise.prototype._promiseCreated = Promise_promiseCreated;\n        longStackTraces = false;\n    };\n    longStackTraces = true;\n    Promise.prototype._pushContext = Context.prototype._pushContext;\n    Promise.prototype._popContext = Context.prototype._popContext;\n    Promise._peekContext = Promise.prototype._peekContext = peekContext;\n    Promise.prototype._promiseCreated = function() {\n        var ctx = this._peekContext();\n        if (ctx && ctx._promiseCreated == null) ctx._promiseCreated = this;\n    };\n};\nreturn Context;\n};\n","\"use strict\";\nmodule.exports = function(Promise, Context,\n    enableAsyncHooks, disableAsyncHooks) {\nvar async = Promise._async;\nvar Warning = require(\"./errors\").Warning;\nvar util = require(\"./util\");\nvar es5 = require(\"./es5\");\nvar canAttachTrace = util.canAttachTrace;\nvar unhandledRejectionHandled;\nvar possiblyUnhandledRejection;\nvar bluebirdFramePattern =\n    /[\\\\\\/]bluebird[\\\\\\/]js[\\\\\\/](release|debug|instrumented)/;\nvar nodeFramePattern = /\\((?:timers\\.js):\\d+:\\d+\\)/;\nvar parseLinePattern = /[\\/<\\(](.+?):(\\d+):(\\d+)\\)?\\s*$/;\nvar stackFramePattern = null;\nvar formatStack = null;\nvar indentStackFrames = false;\nvar printWarning;\nvar debugging = !!(util.env(\"BLUEBIRD_DEBUG\") != 0 &&\n                        (false ||\n                         util.env(\"BLUEBIRD_DEBUG\") ||\n                         util.env(\"NODE_ENV\") === \"development\"));\n\nvar warnings = !!(util.env(\"BLUEBIRD_WARNINGS\") != 0 &&\n    (debugging || util.env(\"BLUEBIRD_WARNINGS\")));\n\nvar longStackTraces = !!(util.env(\"BLUEBIRD_LONG_STACK_TRACES\") != 0 &&\n    (debugging || util.env(\"BLUEBIRD_LONG_STACK_TRACES\")));\n\nvar wForgottenReturn = util.env(\"BLUEBIRD_W_FORGOTTEN_RETURN\") != 0 &&\n    (warnings || !!util.env(\"BLUEBIRD_W_FORGOTTEN_RETURN\"));\n\nvar deferUnhandledRejectionCheck;\n(function() {\n    var promises = [];\n\n    function unhandledRejectionCheck() {\n        for (var i = 0; i < promises.length; ++i) {\n            promises[i]._notifyUnhandledRejection();\n        }\n        unhandledRejectionClear();\n    }\n\n    function unhandledRejectionClear() {\n        promises.length = 0;\n    }\n\n    deferUnhandledRejectionCheck = function(promise) {\n        promises.push(promise);\n        setTimeout(unhandledRejectionCheck, 1);\n    };\n\n    es5.defineProperty(Promise, \"_unhandledRejectionCheck\", {\n        value: unhandledRejectionCheck\n    });\n    es5.defineProperty(Promise, \"_unhandledRejectionClear\", {\n        value: unhandledRejectionClear\n    });\n})();\n\nPromise.prototype.suppressUnhandledRejections = function() {\n    var target = this._target();\n    target._bitField = ((target._bitField & (~1048576)) |\n                      524288);\n};\n\nPromise.prototype._ensurePossibleRejectionHandled = function () {\n    if ((this._bitField & 524288) !== 0) return;\n    this._setRejectionIsUnhandled();\n    deferUnhandledRejectionCheck(this);\n};\n\nPromise.prototype._notifyUnhandledRejectionIsHandled = function () {\n    fireRejectionEvent(\"rejectionHandled\",\n                                  unhandledRejectionHandled, undefined, this);\n};\n\nPromise.prototype._setReturnedNonUndefined = function() {\n    this._bitField = this._bitField | 268435456;\n};\n\nPromise.prototype._returnedNonUndefined = function() {\n    return (this._bitField & 268435456) !== 0;\n};\n\nPromise.prototype._notifyUnhandledRejection = function () {\n    if (this._isRejectionUnhandled()) {\n        var reason = this._settledValue();\n        this._setUnhandledRejectionIsNotified();\n        fireRejectionEvent(\"unhandledRejection\",\n                                      possiblyUnhandledRejection, reason, this);\n    }\n};\n\nPromise.prototype._setUnhandledRejectionIsNotified = function () {\n    this._bitField = this._bitField | 262144;\n};\n\nPromise.prototype._unsetUnhandledRejectionIsNotified = function () {\n    this._bitField = this._bitField & (~262144);\n};\n\nPromise.prototype._isUnhandledRejectionNotified = function () {\n    return (this._bitField & 262144) > 0;\n};\n\nPromise.prototype._setRejectionIsUnhandled = function () {\n    this._bitField = this._bitField | 1048576;\n};\n\nPromise.prototype._unsetRejectionIsUnhandled = function () {\n    this._bitField = this._bitField & (~1048576);\n    if (this._isUnhandledRejectionNotified()) {\n        this._unsetUnhandledRejectionIsNotified();\n        this._notifyUnhandledRejectionIsHandled();\n    }\n};\n\nPromise.prototype._isRejectionUnhandled = function () {\n    return (this._bitField & 1048576) > 0;\n};\n\nPromise.prototype._warn = function(message, shouldUseOwnTrace, promise) {\n    return warn(message, shouldUseOwnTrace, promise || this);\n};\n\nPromise.onPossiblyUnhandledRejection = function (fn) {\n    var context = Promise._getContext();\n    possiblyUnhandledRejection = util.contextBind(context, fn);\n};\n\nPromise.onUnhandledRejectionHandled = function (fn) {\n    var context = Promise._getContext();\n    unhandledRejectionHandled = util.contextBind(context, fn);\n};\n\nvar disableLongStackTraces = function() {};\nPromise.longStackTraces = function () {\n    if (async.haveItemsQueued() && !config.longStackTraces) {\n        throw new Error(\"cannot enable long stack traces after promises have been created\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n    }\n    if (!config.longStackTraces && longStackTracesIsSupported()) {\n        var Promise_captureStackTrace = Promise.prototype._captureStackTrace;\n        var Promise_attachExtraTrace = Promise.prototype._attachExtraTrace;\n        var Promise_dereferenceTrace = Promise.prototype._dereferenceTrace;\n        config.longStackTraces = true;\n        disableLongStackTraces = function() {\n            if (async.haveItemsQueued() && !config.longStackTraces) {\n                throw new Error(\"cannot enable long stack traces after promises have been created\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n            }\n            Promise.prototype._captureStackTrace = Promise_captureStackTrace;\n            Promise.prototype._attachExtraTrace = Promise_attachExtraTrace;\n            Promise.prototype._dereferenceTrace = Promise_dereferenceTrace;\n            Context.deactivateLongStackTraces();\n            config.longStackTraces = false;\n        };\n        Promise.prototype._captureStackTrace = longStackTracesCaptureStackTrace;\n        Promise.prototype._attachExtraTrace = longStackTracesAttachExtraTrace;\n        Promise.prototype._dereferenceTrace = longStackTracesDereferenceTrace;\n        Context.activateLongStackTraces();\n    }\n};\n\nPromise.hasLongStackTraces = function () {\n    return config.longStackTraces && longStackTracesIsSupported();\n};\n\n\nvar legacyHandlers = {\n    unhandledrejection: {\n        before: function() {\n            var ret = util.global.onunhandledrejection;\n            util.global.onunhandledrejection = null;\n            return ret;\n        },\n        after: function(fn) {\n            util.global.onunhandledrejection = fn;\n        }\n    },\n    rejectionhandled: {\n        before: function() {\n            var ret = util.global.onrejectionhandled;\n            util.global.onrejectionhandled = null;\n            return ret;\n        },\n        after: function(fn) {\n            util.global.onrejectionhandled = fn;\n        }\n    }\n};\n\nvar fireDomEvent = (function() {\n    var dispatch = function(legacy, e) {\n        if (legacy) {\n            var fn;\n            try {\n                fn = legacy.before();\n                return !util.global.dispatchEvent(e);\n            } finally {\n                legacy.after(fn);\n            }\n        } else {\n            return !util.global.dispatchEvent(e);\n        }\n    };\n    try {\n        if (typeof CustomEvent === \"function\") {\n            var event = new CustomEvent(\"CustomEvent\");\n            util.global.dispatchEvent(event);\n            return function(name, event) {\n                name = name.toLowerCase();\n                var eventData = {\n                    detail: event,\n                    cancelable: true\n                };\n                var domEvent = new CustomEvent(name, eventData);\n                es5.defineProperty(\n                    domEvent, \"promise\", {value: event.promise});\n                es5.defineProperty(\n                    domEvent, \"reason\", {value: event.reason});\n\n                return dispatch(legacyHandlers[name], domEvent);\n            };\n        } else if (typeof Event === \"function\") {\n            var event = new Event(\"CustomEvent\");\n            util.global.dispatchEvent(event);\n            return function(name, event) {\n                name = name.toLowerCase();\n                var domEvent = new Event(name, {\n                    cancelable: true\n                });\n                domEvent.detail = event;\n                es5.defineProperty(domEvent, \"promise\", {value: event.promise});\n                es5.defineProperty(domEvent, \"reason\", {value: event.reason});\n                return dispatch(legacyHandlers[name], domEvent);\n            };\n        } else {\n            var event = document.createEvent(\"CustomEvent\");\n            event.initCustomEvent(\"testingtheevent\", false, true, {});\n            util.global.dispatchEvent(event);\n            return function(name, event) {\n                name = name.toLowerCase();\n                var domEvent = document.createEvent(\"CustomEvent\");\n                domEvent.initCustomEvent(name, false, true,\n                    event);\n                return dispatch(legacyHandlers[name], domEvent);\n            };\n        }\n    } catch (e) {}\n    return function() {\n        return false;\n    };\n})();\n\nvar fireGlobalEvent = (function() {\n    if (util.isNode) {\n        return function() {\n            return process.emit.apply(process, arguments);\n        };\n    } else {\n        if (!util.global) {\n            return function() {\n                return false;\n            };\n        }\n        return function(name) {\n            var methodName = \"on\" + name.toLowerCase();\n            var method = util.global[methodName];\n            if (!method) return false;\n            method.apply(util.global, [].slice.call(arguments, 1));\n            return true;\n        };\n    }\n})();\n\nfunction generatePromiseLifecycleEventObject(name, promise) {\n    return {promise: promise};\n}\n\nvar eventToObjectGenerator = {\n    promiseCreated: generatePromiseLifecycleEventObject,\n    promiseFulfilled: generatePromiseLifecycleEventObject,\n    promiseRejected: generatePromiseLifecycleEventObject,\n    promiseResolved: generatePromiseLifecycleEventObject,\n    promiseCancelled: generatePromiseLifecycleEventObject,\n    promiseChained: function(name, promise, child) {\n        return {promise: promise, child: child};\n    },\n    warning: function(name, warning) {\n        return {warning: warning};\n    },\n    unhandledRejection: function (name, reason, promise) {\n        return {reason: reason, promise: promise};\n    },\n    rejectionHandled: generatePromiseLifecycleEventObject\n};\n\nvar activeFireEvent = function (name) {\n    var globalEventFired = false;\n    try {\n        globalEventFired = fireGlobalEvent.apply(null, arguments);\n    } catch (e) {\n        async.throwLater(e);\n        globalEventFired = true;\n    }\n\n    var domEventFired = false;\n    try {\n        domEventFired = fireDomEvent(name,\n                    eventToObjectGenerator[name].apply(null, arguments));\n    } catch (e) {\n        async.throwLater(e);\n        domEventFired = true;\n    }\n\n    return domEventFired || globalEventFired;\n};\n\nPromise.config = function(opts) {\n    opts = Object(opts);\n    if (\"longStackTraces\" in opts) {\n        if (opts.longStackTraces) {\n            Promise.longStackTraces();\n        } else if (!opts.longStackTraces && Promise.hasLongStackTraces()) {\n            disableLongStackTraces();\n        }\n    }\n    if (\"warnings\" in opts) {\n        var warningsOption = opts.warnings;\n        config.warnings = !!warningsOption;\n        wForgottenReturn = config.warnings;\n\n        if (util.isObject(warningsOption)) {\n            if (\"wForgottenReturn\" in warningsOption) {\n                wForgottenReturn = !!warningsOption.wForgottenReturn;\n            }\n        }\n    }\n    if (\"cancellation\" in opts && opts.cancellation && !config.cancellation) {\n        if (async.haveItemsQueued()) {\n            throw new Error(\n                \"cannot enable cancellation after promises are in use\");\n        }\n        Promise.prototype._clearCancellationData =\n            cancellationClearCancellationData;\n        Promise.prototype._propagateFrom = cancellationPropagateFrom;\n        Promise.prototype._onCancel = cancellationOnCancel;\n        Promise.prototype._setOnCancel = cancellationSetOnCancel;\n        Promise.prototype._attachCancellationCallback =\n            cancellationAttachCancellationCallback;\n        Promise.prototype._execute = cancellationExecute;\n        propagateFromFunction = cancellationPropagateFrom;\n        config.cancellation = true;\n    }\n    if (\"monitoring\" in opts) {\n        if (opts.monitoring && !config.monitoring) {\n            config.monitoring = true;\n            Promise.prototype._fireEvent = activeFireEvent;\n        } else if (!opts.monitoring && config.monitoring) {\n            config.monitoring = false;\n            Promise.prototype._fireEvent = defaultFireEvent;\n        }\n    }\n    if (\"asyncHooks\" in opts && util.nodeSupportsAsyncResource) {\n        var prev = config.asyncHooks;\n        var cur = !!opts.asyncHooks;\n        if (prev !== cur) {\n            config.asyncHooks = cur;\n            if (cur) {\n                enableAsyncHooks();\n            } else {\n                disableAsyncHooks();\n            }\n        }\n    }\n    return Promise;\n};\n\nfunction defaultFireEvent() { return false; }\n\nPromise.prototype._fireEvent = defaultFireEvent;\nPromise.prototype._execute = function(executor, resolve, reject) {\n    try {\n        executor(resolve, reject);\n    } catch (e) {\n        return e;\n    }\n};\nPromise.prototype._onCancel = function () {};\nPromise.prototype._setOnCancel = function (handler) { ; };\nPromise.prototype._attachCancellationCallback = function(onCancel) {\n    ;\n};\nPromise.prototype._captureStackTrace = function () {};\nPromise.prototype._attachExtraTrace = function () {};\nPromise.prototype._dereferenceTrace = function () {};\nPromise.prototype._clearCancellationData = function() {};\nPromise.prototype._propagateFrom = function (parent, flags) {\n    ;\n    ;\n};\n\nfunction cancellationExecute(executor, resolve, reject) {\n    var promise = this;\n    try {\n        executor(resolve, reject, function(onCancel) {\n            if (typeof onCancel !== \"function\") {\n                throw new TypeError(\"onCancel must be a function, got: \" +\n                                    util.toString(onCancel));\n            }\n            promise._attachCancellationCallback(onCancel);\n        });\n    } catch (e) {\n        return e;\n    }\n}\n\nfunction cancellationAttachCancellationCallback(onCancel) {\n    if (!this._isCancellable()) return this;\n\n    var previousOnCancel = this._onCancel();\n    if (previousOnCancel !== undefined) {\n        if (util.isArray(previousOnCancel)) {\n            previousOnCancel.push(onCancel);\n        } else {\n            this._setOnCancel([previousOnCancel, onCancel]);\n        }\n    } else {\n        this._setOnCancel(onCancel);\n    }\n}\n\nfunction cancellationOnCancel() {\n    return this._onCancelField;\n}\n\nfunction cancellationSetOnCancel(onCancel) {\n    this._onCancelField = onCancel;\n}\n\nfunction cancellationClearCancellationData() {\n    this._cancellationParent = undefined;\n    this._onCancelField = undefined;\n}\n\nfunction cancellationPropagateFrom(parent, flags) {\n    if ((flags & 1) !== 0) {\n        this._cancellationParent = parent;\n        var branchesRemainingToCancel = parent._branchesRemainingToCancel;\n        if (branchesRemainingToCancel === undefined) {\n            branchesRemainingToCancel = 0;\n        }\n        parent._branchesRemainingToCancel = branchesRemainingToCancel + 1;\n    }\n    if ((flags & 2) !== 0 && parent._isBound()) {\n        this._setBoundTo(parent._boundTo);\n    }\n}\n\nfunction bindingPropagateFrom(parent, flags) {\n    if ((flags & 2) !== 0 && parent._isBound()) {\n        this._setBoundTo(parent._boundTo);\n    }\n}\nvar propagateFromFunction = bindingPropagateFrom;\n\nfunction boundValueFunction() {\n    var ret = this._boundTo;\n    if (ret !== undefined) {\n        if (ret instanceof Promise) {\n            if (ret.isFulfilled()) {\n                return ret.value();\n            } else {\n                return undefined;\n            }\n        }\n    }\n    return ret;\n}\n\nfunction longStackTracesCaptureStackTrace() {\n    this._trace = new CapturedTrace(this._peekContext());\n}\n\nfunction longStackTracesAttachExtraTrace(error, ignoreSelf) {\n    if (canAttachTrace(error)) {\n        var trace = this._trace;\n        if (trace !== undefined) {\n            if (ignoreSelf) trace = trace._parent;\n        }\n        if (trace !== undefined) {\n            trace.attachExtraTrace(error);\n        } else if (!error.__stackCleaned__) {\n            var parsed = parseStackAndMessage(error);\n            util.notEnumerableProp(error, \"stack\",\n                parsed.message + \"\\n\" + parsed.stack.join(\"\\n\"));\n            util.notEnumerableProp(error, \"__stackCleaned__\", true);\n        }\n    }\n}\n\nfunction longStackTracesDereferenceTrace() {\n    this._trace = undefined;\n}\n\nfunction checkForgottenReturns(returnValue, promiseCreated, name, promise,\n                               parent) {\n    if (returnValue === undefined && promiseCreated !== null &&\n        wForgottenReturn) {\n        if (parent !== undefined && parent._returnedNonUndefined()) return;\n        if ((promise._bitField & 65535) === 0) return;\n\n        if (name) name = name + \" \";\n        var handlerLine = \"\";\n        var creatorLine = \"\";\n        if (promiseCreated._trace) {\n            var traceLines = promiseCreated._trace.stack.split(\"\\n\");\n            var stack = cleanStack(traceLines);\n            for (var i = stack.length - 1; i >= 0; --i) {\n                var line = stack[i];\n                if (!nodeFramePattern.test(line)) {\n                    var lineMatches = line.match(parseLinePattern);\n                    if (lineMatches) {\n                        handlerLine  = \"at \" + lineMatches[1] +\n                            \":\" + lineMatches[2] + \":\" + lineMatches[3] + \" \";\n                    }\n                    break;\n                }\n            }\n\n            if (stack.length > 0) {\n                var firstUserLine = stack[0];\n                for (var i = 0; i < traceLines.length; ++i) {\n\n                    if (traceLines[i] === firstUserLine) {\n                        if (i > 0) {\n                            creatorLine = \"\\n\" + traceLines[i - 1];\n                        }\n                        break;\n                    }\n                }\n\n            }\n        }\n        var msg = \"a promise was created in a \" + name +\n            \"handler \" + handlerLine + \"but was not returned from it, \" +\n            \"see http://goo.gl/rRqMUw\" +\n            creatorLine;\n        promise._warn(msg, true, promiseCreated);\n    }\n}\n\nfunction deprecated(name, replacement) {\n    var message = name +\n        \" is deprecated and will be removed in a future version.\";\n    if (replacement) message += \" Use \" + replacement + \" instead.\";\n    return warn(message);\n}\n\nfunction warn(message, shouldUseOwnTrace, promise) {\n    if (!config.warnings) return;\n    var warning = new Warning(message);\n    var ctx;\n    if (shouldUseOwnTrace) {\n        promise._attachExtraTrace(warning);\n    } else if (config.longStackTraces && (ctx = Promise._peekContext())) {\n        ctx.attachExtraTrace(warning);\n    } else {\n        var parsed = parseStackAndMessage(warning);\n        warning.stack = parsed.message + \"\\n\" + parsed.stack.join(\"\\n\");\n    }\n\n    if (!activeFireEvent(\"warning\", warning)) {\n        formatAndLogError(warning, \"\", true);\n    }\n}\n\nfunction reconstructStack(message, stacks) {\n    for (var i = 0; i < stacks.length - 1; ++i) {\n        stacks[i].push(\"From previous event:\");\n        stacks[i] = stacks[i].join(\"\\n\");\n    }\n    if (i < stacks.length) {\n        stacks[i] = stacks[i].join(\"\\n\");\n    }\n    return message + \"\\n\" + stacks.join(\"\\n\");\n}\n\nfunction removeDuplicateOrEmptyJumps(stacks) {\n    for (var i = 0; i < stacks.length; ++i) {\n        if (stacks[i].length === 0 ||\n            ((i + 1 < stacks.length) && stacks[i][0] === stacks[i+1][0])) {\n            stacks.splice(i, 1);\n            i--;\n        }\n    }\n}\n\nfunction removeCommonRoots(stacks) {\n    var current = stacks[0];\n    for (var i = 1; i < stacks.length; ++i) {\n        var prev = stacks[i];\n        var currentLastIndex = current.length - 1;\n        var currentLastLine = current[currentLastIndex];\n        var commonRootMeetPoint = -1;\n\n        for (var j = prev.length - 1; j >= 0; --j) {\n            if (prev[j] === currentLastLine) {\n                commonRootMeetPoint = j;\n                break;\n            }\n        }\n\n        for (var j = commonRootMeetPoint; j >= 0; --j) {\n            var line = prev[j];\n            if (current[currentLastIndex] === line) {\n                current.pop();\n                currentLastIndex--;\n            } else {\n                break;\n            }\n        }\n        current = prev;\n    }\n}\n\nfunction cleanStack(stack) {\n    var ret = [];\n    for (var i = 0; i < stack.length; ++i) {\n        var line = stack[i];\n        var isTraceLine = \"    (No stack trace)\" === line ||\n            stackFramePattern.test(line);\n        var isInternalFrame = isTraceLine && shouldIgnore(line);\n        if (isTraceLine && !isInternalFrame) {\n            if (indentStackFrames && line.charAt(0) !== \" \") {\n                line = \"    \" + line;\n            }\n            ret.push(line);\n        }\n    }\n    return ret;\n}\n\nfunction stackFramesAsArray(error) {\n    var stack = error.stack.replace(/\\s+$/g, \"\").split(\"\\n\");\n    for (var i = 0; i < stack.length; ++i) {\n        var line = stack[i];\n        if (\"    (No stack trace)\" === line || stackFramePattern.test(line)) {\n            break;\n        }\n    }\n    if (i > 0 && error.name != \"SyntaxError\") {\n        stack = stack.slice(i);\n    }\n    return stack;\n}\n\nfunction parseStackAndMessage(error) {\n    var stack = error.stack;\n    var message = error.toString();\n    stack = typeof stack === \"string\" && stack.length > 0\n                ? stackFramesAsArray(error) : [\"    (No stack trace)\"];\n    return {\n        message: message,\n        stack: error.name == \"SyntaxError\" ? stack : cleanStack(stack)\n    };\n}\n\nfunction formatAndLogError(error, title, isSoft) {\n    if (typeof console !== \"undefined\") {\n        var message;\n        if (util.isObject(error)) {\n            var stack = error.stack;\n            message = title + formatStack(stack, error);\n        } else {\n            message = title + String(error);\n        }\n        if (typeof printWarning === \"function\") {\n            printWarning(message, isSoft);\n        } else if (typeof console.log === \"function\" ||\n            typeof console.log === \"object\") {\n            console.log(message);\n        }\n    }\n}\n\nfunction fireRejectionEvent(name, localHandler, reason, promise) {\n    var localEventFired = false;\n    try {\n        if (typeof localHandler === \"function\") {\n            localEventFired = true;\n            if (name === \"rejectionHandled\") {\n                localHandler(promise);\n            } else {\n                localHandler(reason, promise);\n            }\n        }\n    } catch (e) {\n        async.throwLater(e);\n    }\n\n    if (name === \"unhandledRejection\") {\n        if (!activeFireEvent(name, reason, promise) && !localEventFired) {\n            formatAndLogError(reason, \"Unhandled rejection \");\n        }\n    } else {\n        activeFireEvent(name, promise);\n    }\n}\n\nfunction formatNonError(obj) {\n    var str;\n    if (typeof obj === \"function\") {\n        str = \"[function \" +\n            (obj.name || \"anonymous\") +\n            \"]\";\n    } else {\n        str = obj && typeof obj.toString === \"function\"\n            ? obj.toString() : util.toString(obj);\n        var ruselessToString = /\\[object [a-zA-Z0-9$_]+\\]/;\n        if (ruselessToString.test(str)) {\n            try {\n                var newStr = JSON.stringify(obj);\n                str = newStr;\n            }\n            catch(e) {\n\n            }\n        }\n        if (str.length === 0) {\n            str = \"(empty array)\";\n        }\n    }\n    return (\"(<\" + snip(str) + \">, no stack trace)\");\n}\n\nfunction snip(str) {\n    var maxChars = 41;\n    if (str.length < maxChars) {\n        return str;\n    }\n    return str.substr(0, maxChars - 3) + \"...\";\n}\n\nfunction longStackTracesIsSupported() {\n    return typeof captureStackTrace === \"function\";\n}\n\nvar shouldIgnore = function() { return false; };\nvar parseLineInfoRegex = /[\\/<\\(]([^:\\/]+):(\\d+):(?:\\d+)\\)?\\s*$/;\nfunction parseLineInfo(line) {\n    var matches = line.match(parseLineInfoRegex);\n    if (matches) {\n        return {\n            fileName: matches[1],\n            line: parseInt(matches[2], 10)\n        };\n    }\n}\n\nfunction setBounds(firstLineError, lastLineError) {\n    if (!longStackTracesIsSupported()) return;\n    var firstStackLines = (firstLineError.stack || \"\").split(\"\\n\");\n    var lastStackLines = (lastLineError.stack || \"\").split(\"\\n\");\n    var firstIndex = -1;\n    var lastIndex = -1;\n    var firstFileName;\n    var lastFileName;\n    for (var i = 0; i < firstStackLines.length; ++i) {\n        var result = parseLineInfo(firstStackLines[i]);\n        if (result) {\n            firstFileName = result.fileName;\n            firstIndex = result.line;\n            break;\n        }\n    }\n    for (var i = 0; i < lastStackLines.length; ++i) {\n        var result = parseLineInfo(lastStackLines[i]);\n        if (result) {\n            lastFileName = result.fileName;\n            lastIndex = result.line;\n            break;\n        }\n    }\n    if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName ||\n        firstFileName !== lastFileName || firstIndex >= lastIndex) {\n        return;\n    }\n\n    shouldIgnore = function(line) {\n        if (bluebirdFramePattern.test(line)) return true;\n        var info = parseLineInfo(line);\n        if (info) {\n            if (info.fileName === firstFileName &&\n                (firstIndex <= info.line && info.line <= lastIndex)) {\n                return true;\n            }\n        }\n        return false;\n    };\n}\n\nfunction CapturedTrace(parent) {\n    this._parent = parent;\n    this._promisesCreated = 0;\n    var length = this._length = 1 + (parent === undefined ? 0 : parent._length);\n    captureStackTrace(this, CapturedTrace);\n    if (length > 32) this.uncycle();\n}\nutil.inherits(CapturedTrace, Error);\nContext.CapturedTrace = CapturedTrace;\n\nCapturedTrace.prototype.uncycle = function() {\n    var length = this._length;\n    if (length < 2) return;\n    var nodes = [];\n    var stackToIndex = {};\n\n    for (var i = 0, node = this; node !== undefined; ++i) {\n        nodes.push(node);\n        node = node._parent;\n    }\n    length = this._length = i;\n    for (var i = length - 1; i >= 0; --i) {\n        var stack = nodes[i].stack;\n        if (stackToIndex[stack] === undefined) {\n            stackToIndex[stack] = i;\n        }\n    }\n    for (var i = 0; i < length; ++i) {\n        var currentStack = nodes[i].stack;\n        var index = stackToIndex[currentStack];\n        if (index !== undefined && index !== i) {\n            if (index > 0) {\n                nodes[index - 1]._parent = undefined;\n                nodes[index - 1]._length = 1;\n            }\n            nodes[i]._parent = undefined;\n            nodes[i]._length = 1;\n            var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;\n\n            if (index < length - 1) {\n                cycleEdgeNode._parent = nodes[index + 1];\n                cycleEdgeNode._parent.uncycle();\n                cycleEdgeNode._length =\n                    cycleEdgeNode._parent._length + 1;\n            } else {\n                cycleEdgeNode._parent = undefined;\n                cycleEdgeNode._length = 1;\n            }\n            var currentChildLength = cycleEdgeNode._length + 1;\n            for (var j = i - 2; j >= 0; --j) {\n                nodes[j]._length = currentChildLength;\n                currentChildLength++;\n            }\n            return;\n        }\n    }\n};\n\nCapturedTrace.prototype.attachExtraTrace = function(error) {\n    if (error.__stackCleaned__) return;\n    this.uncycle();\n    var parsed = parseStackAndMessage(error);\n    var message = parsed.message;\n    var stacks = [parsed.stack];\n\n    var trace = this;\n    while (trace !== undefined) {\n        stacks.push(cleanStack(trace.stack.split(\"\\n\")));\n        trace = trace._parent;\n    }\n    removeCommonRoots(stacks);\n    removeDuplicateOrEmptyJumps(stacks);\n    util.notEnumerableProp(error, \"stack\", reconstructStack(message, stacks));\n    util.notEnumerableProp(error, \"__stackCleaned__\", true);\n};\n\nvar captureStackTrace = (function stackDetection() {\n    var v8stackFramePattern = /^\\s*at\\s*/;\n    var v8stackFormatter = function(stack, error) {\n        if (typeof stack === \"string\") return stack;\n\n        if (error.name !== undefined &&\n            error.message !== undefined) {\n            return error.toString();\n        }\n        return formatNonError(error);\n    };\n\n    if (typeof Error.stackTraceLimit === \"number\" &&\n        typeof Error.captureStackTrace === \"function\") {\n        Error.stackTraceLimit += 6;\n        stackFramePattern = v8stackFramePattern;\n        formatStack = v8stackFormatter;\n        var captureStackTrace = Error.captureStackTrace;\n\n        shouldIgnore = function(line) {\n            return bluebirdFramePattern.test(line);\n        };\n        return function(receiver, ignoreUntil) {\n            Error.stackTraceLimit += 6;\n            captureStackTrace(receiver, ignoreUntil);\n            Error.stackTraceLimit -= 6;\n        };\n    }\n    var err = new Error();\n\n    if (typeof err.stack === \"string\" &&\n        err.stack.split(\"\\n\")[0].indexOf(\"stackDetection@\") >= 0) {\n        stackFramePattern = /@/;\n        formatStack = v8stackFormatter;\n        indentStackFrames = true;\n        return function captureStackTrace(o) {\n            o.stack = new Error().stack;\n        };\n    }\n\n    var hasStackAfterThrow;\n    try { throw new Error(); }\n    catch(e) {\n        hasStackAfterThrow = (\"stack\" in e);\n    }\n    if (!(\"stack\" in err) && hasStackAfterThrow &&\n        typeof Error.stackTraceLimit === \"number\") {\n        stackFramePattern = v8stackFramePattern;\n        formatStack = v8stackFormatter;\n        return function captureStackTrace(o) {\n            Error.stackTraceLimit += 6;\n            try { throw new Error(); }\n            catch(e) { o.stack = e.stack; }\n            Error.stackTraceLimit -= 6;\n        };\n    }\n\n    formatStack = function(stack, error) {\n        if (typeof stack === \"string\") return stack;\n\n        if ((typeof error === \"object\" ||\n            typeof error === \"function\") &&\n            error.name !== undefined &&\n            error.message !== undefined) {\n            return error.toString();\n        }\n        return formatNonError(error);\n    };\n\n    return null;\n\n})([]);\n\nif (typeof console !== \"undefined\" && typeof console.warn !== \"undefined\") {\n    printWarning = function (message) {\n        console.warn(message);\n    };\n    if (util.isNode && process.stderr.isTTY) {\n        printWarning = function(message, isSoft) {\n            var color = isSoft ? \"\\u001b[33m\" : \"\\u001b[31m\";\n            console.warn(color + message + \"\\u001b[0m\\n\");\n        };\n    } else if (!util.isNode && typeof (new Error().stack) === \"string\") {\n        printWarning = function(message, isSoft) {\n            console.warn(\"%c\" + message,\n                        isSoft ? \"color: darkorange\" : \"color: red\");\n        };\n    }\n}\n\nvar config = {\n    warnings: warnings,\n    longStackTraces: false,\n    cancellation: false,\n    monitoring: false,\n    asyncHooks: false\n};\n\nif (longStackTraces) Promise.longStackTraces();\n\nreturn {\n    asyncHooks: function() {\n        return config.asyncHooks;\n    },\n    longStackTraces: function() {\n        return config.longStackTraces;\n    },\n    warnings: function() {\n        return config.warnings;\n    },\n    cancellation: function() {\n        return config.cancellation;\n    },\n    monitoring: function() {\n        return config.monitoring;\n    },\n    propagateFromFunction: function() {\n        return propagateFromFunction;\n    },\n    boundValueFunction: function() {\n        return boundValueFunction;\n    },\n    checkForgottenReturns: checkForgottenReturns,\n    setBounds: setBounds,\n    warn: warn,\n    deprecated: deprecated,\n    CapturedTrace: CapturedTrace,\n    fireDomEvent: fireDomEvent,\n    fireGlobalEvent: fireGlobalEvent\n};\n};\n","\"use strict\";\nmodule.exports = function(Promise, tryConvertToPromise, NEXT_FILTER) {\nvar util = require(\"./util\");\nvar CancellationError = Promise.CancellationError;\nvar errorObj = util.errorObj;\nvar catchFilter = require(\"./catch_filter\")(NEXT_FILTER);\n\nfunction PassThroughHandlerContext(promise, type, handler) {\n    this.promise = promise;\n    this.type = type;\n    this.handler = handler;\n    this.called = false;\n    this.cancelPromise = null;\n}\n\nPassThroughHandlerContext.prototype.isFinallyHandler = function() {\n    return this.type === 0;\n};\n\nfunction FinallyHandlerCancelReaction(finallyHandler) {\n    this.finallyHandler = finallyHandler;\n}\n\nFinallyHandlerCancelReaction.prototype._resultCancelled = function() {\n    checkCancel(this.finallyHandler);\n};\n\nfunction checkCancel(ctx, reason) {\n    if (ctx.cancelPromise != null) {\n        if (arguments.length > 1) {\n            ctx.cancelPromise._reject(reason);\n        } else {\n            ctx.cancelPromise._cancel();\n        }\n        ctx.cancelPromise = null;\n        return true;\n    }\n    return false;\n}\n\nfunction succeed() {\n    return finallyHandler.call(this, this.promise._target()._settledValue());\n}\nfunction fail(reason) {\n    if (checkCancel(this, reason)) return;\n    errorObj.e = reason;\n    return errorObj;\n}\nfunction finallyHandler(reasonOrValue) {\n    var promise = this.promise;\n    var handler = this.handler;\n\n    if (!this.called) {\n        this.called = true;\n        var ret = this.isFinallyHandler()\n            ? handler.call(promise._boundValue())\n            : handler.call(promise._boundValue(), reasonOrValue);\n        if (ret === NEXT_FILTER) {\n            return ret;\n        } else if (ret !== undefined) {\n            promise._setReturnedNonUndefined();\n            var maybePromise = tryConvertToPromise(ret, promise);\n            if (maybePromise instanceof Promise) {\n                if (this.cancelPromise != null) {\n                    if (maybePromise._isCancelled()) {\n                        var reason =\n                            new CancellationError(\"late cancellation observer\");\n                        promise._attachExtraTrace(reason);\n                        errorObj.e = reason;\n                        return errorObj;\n                    } else if (maybePromise.isPending()) {\n                        maybePromise._attachCancellationCallback(\n                            new FinallyHandlerCancelReaction(this));\n                    }\n                }\n                return maybePromise._then(\n                    succeed, fail, undefined, this, undefined);\n            }\n        }\n    }\n\n    if (promise.isRejected()) {\n        checkCancel(this);\n        errorObj.e = reasonOrValue;\n        return errorObj;\n    } else {\n        checkCancel(this);\n        return reasonOrValue;\n    }\n}\n\nPromise.prototype._passThrough = function(handler, type, success, fail) {\n    if (typeof handler !== \"function\") return this.then();\n    return this._then(success,\n                      fail,\n                      undefined,\n                      new PassThroughHandlerContext(this, type, handler),\n                      undefined);\n};\n\nPromise.prototype.lastly =\nPromise.prototype[\"finally\"] = function (handler) {\n    return this._passThrough(handler,\n                             0,\n                             finallyHandler,\n                             finallyHandler);\n};\n\n\nPromise.prototype.tap = function (handler) {\n    return this._passThrough(handler, 1, finallyHandler);\n};\n\nPromise.prototype.tapCatch = function (handlerOrPredicate) {\n    var len = arguments.length;\n    if(len === 1) {\n        return this._passThrough(handlerOrPredicate,\n                                 1,\n                                 undefined,\n                                 finallyHandler);\n    } else {\n         var catchInstances = new Array(len - 1),\n            j = 0, i;\n        for (i = 0; i < len - 1; ++i) {\n            var item = arguments[i];\n            if (util.isObject(item)) {\n                catchInstances[j++] = item;\n            } else {\n                return Promise.reject(new TypeError(\n                    \"tapCatch statement predicate: \"\n                    + \"expecting an object but got \" + util.classString(item)\n                ));\n            }\n        }\n        catchInstances.length = j;\n        var handler = arguments[i];\n        return this._passThrough(catchFilter(catchInstances, handler, this),\n                                 1,\n                                 undefined,\n                                 finallyHandler);\n    }\n\n};\n\nreturn PassThroughHandlerContext;\n};\n","\"use strict\";\nmodule.exports = function(NEXT_FILTER) {\nvar util = require(\"./util\");\nvar getKeys = require(\"./es5\").keys;\nvar tryCatch = util.tryCatch;\nvar errorObj = util.errorObj;\n\nfunction catchFilter(instances, cb, promise) {\n    return function(e) {\n        var boundTo = promise._boundValue();\n        predicateLoop: for (var i = 0; i < instances.length; ++i) {\n            var item = instances[i];\n\n            if (item === Error ||\n                (item != null && item.prototype instanceof Error)) {\n                if (e instanceof item) {\n                    return tryCatch(cb).call(boundTo, e);\n                }\n            } else if (typeof item === \"function\") {\n                var matchesPredicate = tryCatch(item).call(boundTo, e);\n                if (matchesPredicate === errorObj) {\n                    return matchesPredicate;\n                } else if (matchesPredicate) {\n                    return tryCatch(cb).call(boundTo, e);\n                }\n            } else if (util.isObject(e)) {\n                var keys = getKeys(item);\n                for (var j = 0; j < keys.length; ++j) {\n                    var key = keys[j];\n                    if (item[key] != e[key]) {\n                        continue predicateLoop;\n                    }\n                }\n                return tryCatch(cb).call(boundTo, e);\n            }\n        }\n        return NEXT_FILTER;\n    };\n}\n\nreturn catchFilter;\n};\n","\"use strict\";\nvar util = require(\"./util\");\nvar maybeWrapAsError = util.maybeWrapAsError;\nvar errors = require(\"./errors\");\nvar OperationalError = errors.OperationalError;\nvar es5 = require(\"./es5\");\n\nfunction isUntypedError(obj) {\n    return obj instanceof Error &&\n        es5.getPrototypeOf(obj) === Error.prototype;\n}\n\nvar rErrorKey = /^(?:name|message|stack|cause)$/;\nfunction wrapAsOperationalError(obj) {\n    var ret;\n    if (isUntypedError(obj)) {\n        ret = new OperationalError(obj);\n        ret.name = obj.name;\n        ret.message = obj.message;\n        ret.stack = obj.stack;\n        var keys = es5.keys(obj);\n        for (var i = 0; i < keys.length; ++i) {\n            var key = keys[i];\n            if (!rErrorKey.test(key)) {\n                ret[key] = obj[key];\n            }\n        }\n        return ret;\n    }\n    util.markAsOriginatingFromRejection(obj);\n    return obj;\n}\n\nfunction nodebackForPromise(promise, multiArgs) {\n    return function(err, value) {\n        if (promise === null) return;\n        if (err) {\n            var wrapped = wrapAsOperationalError(maybeWrapAsError(err));\n            promise._attachExtraTrace(wrapped);\n            promise._reject(wrapped);\n        } else if (!multiArgs) {\n            promise._fulfill(value);\n        } else {\n            var $_len = arguments.length;var args = new Array(Math.max($_len - 1, 0)); for(var $_i = 1; $_i < $_len; ++$_i) {args[$_i - 1] = arguments[$_i];};\n            promise._fulfill(args);\n        }\n        promise = null;\n    };\n}\n\nmodule.exports = nodebackForPromise;\n","\"use strict\";\nmodule.exports =\nfunction(Promise, INTERNAL, tryConvertToPromise, apiRejection, debug) {\nvar util = require(\"./util\");\nvar tryCatch = util.tryCatch;\n\nPromise.method = function (fn) {\n    if (typeof fn !== \"function\") {\n        throw new Promise.TypeError(\"expecting a function but got \" + util.classString(fn));\n    }\n    return function () {\n        var ret = new Promise(INTERNAL);\n        ret._captureStackTrace();\n        ret._pushContext();\n        var value = tryCatch(fn).apply(this, arguments);\n        var promiseCreated = ret._popContext();\n        debug.checkForgottenReturns(\n            value, promiseCreated, \"Promise.method\", ret);\n        ret._resolveFromSyncValue(value);\n        return ret;\n    };\n};\n\nPromise.attempt = Promise[\"try\"] = function (fn) {\n    if (typeof fn !== \"function\") {\n        return apiRejection(\"expecting a function but got \" + util.classString(fn));\n    }\n    var ret = new Promise(INTERNAL);\n    ret._captureStackTrace();\n    ret._pushContext();\n    var value;\n    if (arguments.length > 1) {\n        debug.deprecated(\"calling Promise.try with more than 1 argument\");\n        var arg = arguments[1];\n        var ctx = arguments[2];\n        value = util.isArray(arg) ? tryCatch(fn).apply(ctx, arg)\n                                  : tryCatch(fn).call(ctx, arg);\n    } else {\n        value = tryCatch(fn)();\n    }\n    var promiseCreated = ret._popContext();\n    debug.checkForgottenReturns(\n        value, promiseCreated, \"Promise.try\", ret);\n    ret._resolveFromSyncValue(value);\n    return ret;\n};\n\nPromise.prototype._resolveFromSyncValue = function (value) {\n    if (value === util.errorObj) {\n        this._rejectCallback(value.e, false);\n    } else {\n        this._resolveCallback(value, true);\n    }\n};\n};\n","\"use strict\";\nmodule.exports = function(Promise, INTERNAL, tryConvertToPromise, debug) {\nvar calledBind = false;\nvar rejectThis = function(_, e) {\n    this._reject(e);\n};\n\nvar targetRejected = function(e, context) {\n    context.promiseRejectionQueued = true;\n    context.bindingPromise._then(rejectThis, rejectThis, null, this, e);\n};\n\nvar bindingResolved = function(thisArg, context) {\n    if (((this._bitField & 50397184) === 0)) {\n        this._resolveCallback(context.target);\n    }\n};\n\nvar bindingRejected = function(e, context) {\n    if (!context.promiseRejectionQueued) this._reject(e);\n};\n\nPromise.prototype.bind = function (thisArg) {\n    if (!calledBind) {\n        calledBind = true;\n        Promise.prototype._propagateFrom = debug.propagateFromFunction();\n        Promise.prototype._boundValue = debug.boundValueFunction();\n    }\n    var maybePromise = tryConvertToPromise(thisArg);\n    var ret = new Promise(INTERNAL);\n    ret._propagateFrom(this, 1);\n    var target = this._target();\n    ret._setBoundTo(maybePromise);\n    if (maybePromise instanceof Promise) {\n        var context = {\n            promiseRejectionQueued: false,\n            promise: ret,\n            target: target,\n            bindingPromise: maybePromise\n        };\n        target._then(INTERNAL, targetRejected, undefined, ret, context);\n        maybePromise._then(\n            bindingResolved, bindingRejected, undefined, ret, context);\n        ret._setOnCancel(maybePromise);\n    } else {\n        ret._resolveCallback(target);\n    }\n    return ret;\n};\n\nPromise.prototype._setBoundTo = function (obj) {\n    if (obj !== undefined) {\n        this._bitField = this._bitField | 2097152;\n        this._boundTo = obj;\n    } else {\n        this._bitField = this._bitField & (~2097152);\n    }\n};\n\nPromise.prototype._isBound = function () {\n    return (this._bitField & 2097152) === 2097152;\n};\n\nPromise.bind = function (thisArg, value) {\n    return Promise.resolve(value).bind(thisArg);\n};\n};\n","\"use strict\";\nmodule.exports = function(Promise, PromiseArray, apiRejection, debug) {\nvar util = require(\"./util\");\nvar tryCatch = util.tryCatch;\nvar errorObj = util.errorObj;\nvar async = Promise._async;\n\nPromise.prototype[\"break\"] = Promise.prototype.cancel = function() {\n    if (!debug.cancellation()) return this._warn(\"cancellation is disabled\");\n\n    var promise = this;\n    var child = promise;\n    while (promise._isCancellable()) {\n        if (!promise._cancelBy(child)) {\n            if (child._isFollowing()) {\n                child._followee().cancel();\n            } else {\n                child._cancelBranched();\n            }\n            break;\n        }\n\n        var parent = promise._cancellationParent;\n        if (parent == null || !parent._isCancellable()) {\n            if (promise._isFollowing()) {\n                promise._followee().cancel();\n            } else {\n                promise._cancelBranched();\n            }\n            break;\n        } else {\n            if (promise._isFollowing()) promise._followee().cancel();\n            promise._setWillBeCancelled();\n            child = promise;\n            promise = parent;\n        }\n    }\n};\n\nPromise.prototype._branchHasCancelled = function() {\n    this._branchesRemainingToCancel--;\n};\n\nPromise.prototype._enoughBranchesHaveCancelled = function() {\n    return this._branchesRemainingToCancel === undefined ||\n           this._branchesRemainingToCancel <= 0;\n};\n\nPromise.prototype._cancelBy = function(canceller) {\n    if (canceller === this) {\n        this._branchesRemainingToCancel = 0;\n        this._invokeOnCancel();\n        return true;\n    } else {\n        this._branchHasCancelled();\n        if (this._enoughBranchesHaveCancelled()) {\n            this._invokeOnCancel();\n            return true;\n        }\n    }\n    return false;\n};\n\nPromise.prototype._cancelBranched = function() {\n    if (this._enoughBranchesHaveCancelled()) {\n        this._cancel();\n    }\n};\n\nPromise.prototype._cancel = function() {\n    if (!this._isCancellable()) return;\n    this._setCancelled();\n    async.invoke(this._cancelPromises, this, undefined);\n};\n\nPromise.prototype._cancelPromises = function() {\n    if (this._length() > 0) this._settlePromises();\n};\n\nPromise.prototype._unsetOnCancel = function() {\n    this._onCancelField = undefined;\n};\n\nPromise.prototype._isCancellable = function() {\n    return this.isPending() && !this._isCancelled();\n};\n\nPromise.prototype.isCancellable = function() {\n    return this.isPending() && !this.isCancelled();\n};\n\nPromise.prototype._doInvokeOnCancel = function(onCancelCallback, internalOnly) {\n    if (util.isArray(onCancelCallback)) {\n        for (var i = 0; i < onCancelCallback.length; ++i) {\n            this._doInvokeOnCancel(onCancelCallback[i], internalOnly);\n        }\n    } else if (onCancelCallback !== undefined) {\n        if (typeof onCancelCallback === \"function\") {\n            if (!internalOnly) {\n                var e = tryCatch(onCancelCallback).call(this._boundValue());\n                if (e === errorObj) {\n                    this._attachExtraTrace(e.e);\n                    async.throwLater(e.e);\n                }\n            }\n        } else {\n            onCancelCallback._resultCancelled(this);\n        }\n    }\n};\n\nPromise.prototype._invokeOnCancel = function() {\n    var onCancelCallback = this._onCancel();\n    this._unsetOnCancel();\n    async.invoke(this._doInvokeOnCancel, this, onCancelCallback);\n};\n\nPromise.prototype._invokeInternalOnCancel = function() {\n    if (this._isCancellable()) {\n        this._doInvokeOnCancel(this._onCancel(), true);\n        this._unsetOnCancel();\n    }\n};\n\nPromise.prototype._resultCancelled = function() {\n    this.cancel();\n};\n\n};\n","\"use strict\";\nmodule.exports = function(Promise) {\nfunction returner() {\n    return this.value;\n}\nfunction thrower() {\n    throw this.reason;\n}\n\nPromise.prototype[\"return\"] =\nPromise.prototype.thenReturn = function (value) {\n    if (value instanceof Promise) value.suppressUnhandledRejections();\n    return this._then(\n        returner, undefined, undefined, {value: value}, undefined);\n};\n\nPromise.prototype[\"throw\"] =\nPromise.prototype.thenThrow = function (reason) {\n    return this._then(\n        thrower, undefined, undefined, {reason: reason}, undefined);\n};\n\nPromise.prototype.catchThrow = function (reason) {\n    if (arguments.length <= 1) {\n        return this._then(\n            undefined, thrower, undefined, {reason: reason}, undefined);\n    } else {\n        var _reason = arguments[1];\n        var handler = function() {throw _reason;};\n        return this.caught(reason, handler);\n    }\n};\n\nPromise.prototype.catchReturn = function (value) {\n    if (arguments.length <= 1) {\n        if (value instanceof Promise) value.suppressUnhandledRejections();\n        return this._then(\n            undefined, returner, undefined, {value: value}, undefined);\n    } else {\n        var _value = arguments[1];\n        if (_value instanceof Promise) _value.suppressUnhandledRejections();\n        var handler = function() {return _value;};\n        return this.caught(value, handler);\n    }\n};\n};\n","\"use strict\";\nmodule.exports = function(Promise) {\nfunction PromiseInspection(promise) {\n    if (promise !== undefined) {\n        promise = promise._target();\n        this._bitField = promise._bitField;\n        this._settledValueField = promise._isFateSealed()\n            ? promise._settledValue() : undefined;\n    }\n    else {\n        this._bitField = 0;\n        this._settledValueField = undefined;\n    }\n}\n\nPromiseInspection.prototype._settledValue = function() {\n    return this._settledValueField;\n};\n\nvar value = PromiseInspection.prototype.value = function () {\n    if (!this.isFulfilled()) {\n        throw new TypeError(\"cannot get fulfillment value of a non-fulfilled promise\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n    }\n    return this._settledValue();\n};\n\nvar reason = PromiseInspection.prototype.error =\nPromiseInspection.prototype.reason = function () {\n    if (!this.isRejected()) {\n        throw new TypeError(\"cannot get rejection reason of a non-rejected promise\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n    }\n    return this._settledValue();\n};\n\nvar isFulfilled = PromiseInspection.prototype.isFulfilled = function() {\n    return (this._bitField & 33554432) !== 0;\n};\n\nvar isRejected = PromiseInspection.prototype.isRejected = function () {\n    return (this._bitField & 16777216) !== 0;\n};\n\nvar isPending = PromiseInspection.prototype.isPending = function () {\n    return (this._bitField & 50397184) === 0;\n};\n\nvar isResolved = PromiseInspection.prototype.isResolved = function () {\n    return (this._bitField & 50331648) !== 0;\n};\n\nPromiseInspection.prototype.isCancelled = function() {\n    return (this._bitField & 8454144) !== 0;\n};\n\nPromise.prototype.__isCancelled = function() {\n    return (this._bitField & 65536) === 65536;\n};\n\nPromise.prototype._isCancelled = function() {\n    return this._target().__isCancelled();\n};\n\nPromise.prototype.isCancelled = function() {\n    return (this._target()._bitField & 8454144) !== 0;\n};\n\nPromise.prototype.isPending = function() {\n    return isPending.call(this._target());\n};\n\nPromise.prototype.isRejected = function() {\n    return isRejected.call(this._target());\n};\n\nPromise.prototype.isFulfilled = function() {\n    return isFulfilled.call(this._target());\n};\n\nPromise.prototype.isResolved = function() {\n    return isResolved.call(this._target());\n};\n\nPromise.prototype.value = function() {\n    return value.call(this._target());\n};\n\nPromise.prototype.reason = function() {\n    var target = this._target();\n    target._unsetRejectionIsUnhandled();\n    return reason.call(target);\n};\n\nPromise.prototype._value = function() {\n    return this._settledValue();\n};\n\nPromise.prototype._reason = function() {\n    this._unsetRejectionIsUnhandled();\n    return this._settledValue();\n};\n\nPromise.PromiseInspection = PromiseInspection;\n};\n","\"use strict\";\nmodule.exports =\nfunction(Promise, PromiseArray, tryConvertToPromise, INTERNAL, async) {\nvar util = require(\"./util\");\nvar canEvaluate = util.canEvaluate;\nvar tryCatch = util.tryCatch;\nvar errorObj = util.errorObj;\nvar reject;\n\nif (!false) {\nif (canEvaluate) {\n    var thenCallback = function(i) {\n        return new Function(\"value\", \"holder\", \"                             \\n\\\n            'use strict';                                                    \\n\\\n            holder.pIndex = value;                                           \\n\\\n            holder.checkFulfillment(this);                                   \\n\\\n            \".replace(/Index/g, i));\n    };\n\n    var promiseSetter = function(i) {\n        return new Function(\"promise\", \"holder\", \"                           \\n\\\n            'use strict';                                                    \\n\\\n            holder.pIndex = promise;                                         \\n\\\n            \".replace(/Index/g, i));\n    };\n\n    var generateHolderClass = function(total) {\n        var props = new Array(total);\n        for (var i = 0; i < props.length; ++i) {\n            props[i] = \"this.p\" + (i+1);\n        }\n        var assignment = props.join(\" = \") + \" = null;\";\n        var cancellationCode= \"var promise;\\n\" + props.map(function(prop) {\n            return \"                                                         \\n\\\n                promise = \" + prop + \";                                      \\n\\\n                if (promise instanceof Promise) {                            \\n\\\n                    promise.cancel();                                        \\n\\\n                }                                                            \\n\\\n            \";\n        }).join(\"\\n\");\n        var passedArguments = props.join(\", \");\n        var name = \"Holder$\" + total;\n\n\n        var code = \"return function(tryCatch, errorObj, Promise, async) {    \\n\\\n            'use strict';                                                    \\n\\\n            function [TheName](fn) {                                         \\n\\\n                [TheProperties]                                              \\n\\\n                this.fn = fn;                                                \\n\\\n                this.asyncNeeded = true;                                     \\n\\\n                this.now = 0;                                                \\n\\\n            }                                                                \\n\\\n                                                                             \\n\\\n            [TheName].prototype._callFunction = function(promise) {          \\n\\\n                promise._pushContext();                                      \\n\\\n                var ret = tryCatch(this.fn)([ThePassedArguments]);           \\n\\\n                promise._popContext();                                       \\n\\\n                if (ret === errorObj) {                                      \\n\\\n                    promise._rejectCallback(ret.e, false);                   \\n\\\n                } else {                                                     \\n\\\n                    promise._resolveCallback(ret);                           \\n\\\n                }                                                            \\n\\\n            };                                                               \\n\\\n                                                                             \\n\\\n            [TheName].prototype.checkFulfillment = function(promise) {       \\n\\\n                var now = ++this.now;                                        \\n\\\n                if (now === [TheTotal]) {                                    \\n\\\n                    if (this.asyncNeeded) {                                  \\n\\\n                        async.invoke(this._callFunction, this, promise);     \\n\\\n                    } else {                                                 \\n\\\n                        this._callFunction(promise);                         \\n\\\n                    }                                                        \\n\\\n                                                                             \\n\\\n                }                                                            \\n\\\n            };                                                               \\n\\\n                                                                             \\n\\\n            [TheName].prototype._resultCancelled = function() {              \\n\\\n                [CancellationCode]                                           \\n\\\n            };                                                               \\n\\\n                                                                             \\n\\\n            return [TheName];                                                \\n\\\n        }(tryCatch, errorObj, Promise, async);                               \\n\\\n        \";\n\n        code = code.replace(/\\[TheName\\]/g, name)\n            .replace(/\\[TheTotal\\]/g, total)\n            .replace(/\\[ThePassedArguments\\]/g, passedArguments)\n            .replace(/\\[TheProperties\\]/g, assignment)\n            .replace(/\\[CancellationCode\\]/g, cancellationCode);\n\n        return new Function(\"tryCatch\", \"errorObj\", \"Promise\", \"async\", code)\n                           (tryCatch, errorObj, Promise, async);\n    };\n\n    var holderClasses = [];\n    var thenCallbacks = [];\n    var promiseSetters = [];\n\n    for (var i = 0; i < 8; ++i) {\n        holderClasses.push(generateHolderClass(i + 1));\n        thenCallbacks.push(thenCallback(i + 1));\n        promiseSetters.push(promiseSetter(i + 1));\n    }\n\n    reject = function (reason) {\n        this._reject(reason);\n    };\n}}\n\nPromise.join = function () {\n    var last = arguments.length - 1;\n    var fn;\n    if (last > 0 && typeof arguments[last] === \"function\") {\n        fn = arguments[last];\n        if (!false) {\n            if (last <= 8 && canEvaluate) {\n                var ret = new Promise(INTERNAL);\n                ret._captureStackTrace();\n                var HolderClass = holderClasses[last - 1];\n                var holder = new HolderClass(fn);\n                var callbacks = thenCallbacks;\n\n                for (var i = 0; i < last; ++i) {\n                    var maybePromise = tryConvertToPromise(arguments[i], ret);\n                    if (maybePromise instanceof Promise) {\n                        maybePromise = maybePromise._target();\n                        var bitField = maybePromise._bitField;\n                        ;\n                        if (((bitField & 50397184) === 0)) {\n                            maybePromise._then(callbacks[i], reject,\n                                               undefined, ret, holder);\n                            promiseSetters[i](maybePromise, holder);\n                            holder.asyncNeeded = false;\n                        } else if (((bitField & 33554432) !== 0)) {\n                            callbacks[i].call(ret,\n                                              maybePromise._value(), holder);\n                        } else if (((bitField & 16777216) !== 0)) {\n                            ret._reject(maybePromise._reason());\n                        } else {\n                            ret._cancel();\n                        }\n                    } else {\n                        callbacks[i].call(ret, maybePromise, holder);\n                    }\n                }\n\n                if (!ret._isFateSealed()) {\n                    if (holder.asyncNeeded) {\n                        var context = Promise._getContext();\n                        holder.fn = util.contextBind(context, holder.fn);\n                    }\n                    ret._setAsyncGuaranteed();\n                    ret._setOnCancel(holder);\n                }\n                return ret;\n            }\n        }\n    }\n    var $_len = arguments.length;var args = new Array($_len); for(var $_i = 0; $_i < $_len ; ++$_i) {args[$_i] = arguments[$_i ];};\n    if (fn) args.pop();\n    var ret = new PromiseArray(args).promise();\n    return fn !== undefined ? ret.spread(fn) : ret;\n};\n\n};\n","\"use strict\";\nvar cr = Object.create;\nif (cr) {\n    var callerCache = cr(null);\n    var getterCache = cr(null);\n    callerCache[\" size\"] = getterCache[\" size\"] = 0;\n}\n\nmodule.exports = function(Promise) {\nvar util = require(\"./util\");\nvar canEvaluate = util.canEvaluate;\nvar isIdentifier = util.isIdentifier;\n\nvar getMethodCaller;\nvar getGetter;\nif (!false) {\nvar makeMethodCaller = function (methodName) {\n    return new Function(\"ensureMethod\", \"                                    \\n\\\n        return function(obj) {                                               \\n\\\n            'use strict'                                                     \\n\\\n            var len = this.length;                                           \\n\\\n            ensureMethod(obj, 'methodName');                                 \\n\\\n            switch(len) {                                                    \\n\\\n                case 1: return obj.methodName(this[0]);                      \\n\\\n                case 2: return obj.methodName(this[0], this[1]);             \\n\\\n                case 3: return obj.methodName(this[0], this[1], this[2]);    \\n\\\n                case 0: return obj.methodName();                             \\n\\\n                default:                                                     \\n\\\n                    return obj.methodName.apply(obj, this);                  \\n\\\n            }                                                                \\n\\\n        };                                                                   \\n\\\n        \".replace(/methodName/g, methodName))(ensureMethod);\n};\n\nvar makeGetter = function (propertyName) {\n    return new Function(\"obj\", \"                                             \\n\\\n        'use strict';                                                        \\n\\\n        return obj.propertyName;                                             \\n\\\n        \".replace(\"propertyName\", propertyName));\n};\n\nvar getCompiled = function(name, compiler, cache) {\n    var ret = cache[name];\n    if (typeof ret !== \"function\") {\n        if (!isIdentifier(name)) {\n            return null;\n        }\n        ret = compiler(name);\n        cache[name] = ret;\n        cache[\" size\"]++;\n        if (cache[\" size\"] > 512) {\n            var keys = Object.keys(cache);\n            for (var i = 0; i < 256; ++i) delete cache[keys[i]];\n            cache[\" size\"] = keys.length - 256;\n        }\n    }\n    return ret;\n};\n\ngetMethodCaller = function(name) {\n    return getCompiled(name, makeMethodCaller, callerCache);\n};\n\ngetGetter = function(name) {\n    return getCompiled(name, makeGetter, getterCache);\n};\n}\n\nfunction ensureMethod(obj, methodName) {\n    var fn;\n    if (obj != null) fn = obj[methodName];\n    if (typeof fn !== \"function\") {\n        var message = \"Object \" + util.classString(obj) + \" has no method '\" +\n            util.toString(methodName) + \"'\";\n        throw new Promise.TypeError(message);\n    }\n    return fn;\n}\n\nfunction caller(obj) {\n    var methodName = this.pop();\n    var fn = ensureMethod(obj, methodName);\n    return fn.apply(obj, this);\n}\nPromise.prototype.call = function (methodName) {\n    var $_len = arguments.length;var args = new Array(Math.max($_len - 1, 0)); for(var $_i = 1; $_i < $_len; ++$_i) {args[$_i - 1] = arguments[$_i];};\n    if (!false) {\n        if (canEvaluate) {\n            var maybeCaller = getMethodCaller(methodName);\n            if (maybeCaller !== null) {\n                return this._then(\n                    maybeCaller, undefined, undefined, args, undefined);\n            }\n        }\n    }\n    args.push(methodName);\n    return this._then(caller, undefined, undefined, args, undefined);\n};\n\nfunction namedGetter(obj) {\n    return obj[this];\n}\nfunction indexedGetter(obj) {\n    var index = +this;\n    if (index < 0) index = Math.max(0, index + obj.length);\n    return obj[index];\n}\nPromise.prototype.get = function (propertyName) {\n    var isIndex = (typeof propertyName === \"number\");\n    var getter;\n    if (!isIndex) {\n        if (canEvaluate) {\n            var maybeGetter = getGetter(propertyName);\n            getter = maybeGetter !== null ? maybeGetter : namedGetter;\n        } else {\n            getter = namedGetter;\n        }\n    } else {\n        getter = indexedGetter;\n    }\n    return this._then(getter, undefined, undefined, propertyName, undefined);\n};\n};\n","\"use strict\";\nmodule.exports = function(Promise,\n                          apiRejection,\n                          INTERNAL,\n                          tryConvertToPromise,\n                          Proxyable,\n                          debug) {\nvar errors = require(\"./errors\");\nvar TypeError = errors.TypeError;\nvar util = require(\"./util\");\nvar errorObj = util.errorObj;\nvar tryCatch = util.tryCatch;\nvar yieldHandlers = [];\n\nfunction promiseFromYieldHandler(value, yieldHandlers, traceParent) {\n    for (var i = 0; i < yieldHandlers.length; ++i) {\n        traceParent._pushContext();\n        var result = tryCatch(yieldHandlers[i])(value);\n        traceParent._popContext();\n        if (result === errorObj) {\n            traceParent._pushContext();\n            var ret = Promise.reject(errorObj.e);\n            traceParent._popContext();\n            return ret;\n        }\n        var maybePromise = tryConvertToPromise(result, traceParent);\n        if (maybePromise instanceof Promise) return maybePromise;\n    }\n    return null;\n}\n\nfunction PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {\n    if (debug.cancellation()) {\n        var internal = new Promise(INTERNAL);\n        var _finallyPromise = this._finallyPromise = new Promise(INTERNAL);\n        this._promise = internal.lastly(function() {\n            return _finallyPromise;\n        });\n        internal._captureStackTrace();\n        internal._setOnCancel(this);\n    } else {\n        var promise = this._promise = new Promise(INTERNAL);\n        promise._captureStackTrace();\n    }\n    this._stack = stack;\n    this._generatorFunction = generatorFunction;\n    this._receiver = receiver;\n    this._generator = undefined;\n    this._yieldHandlers = typeof yieldHandler === \"function\"\n        ? [yieldHandler].concat(yieldHandlers)\n        : yieldHandlers;\n    this._yieldedPromise = null;\n    this._cancellationPhase = false;\n}\nutil.inherits(PromiseSpawn, Proxyable);\n\nPromiseSpawn.prototype._isResolved = function() {\n    return this._promise === null;\n};\n\nPromiseSpawn.prototype._cleanup = function() {\n    this._promise = this._generator = null;\n    if (debug.cancellation() && this._finallyPromise !== null) {\n        this._finallyPromise._fulfill();\n        this._finallyPromise = null;\n    }\n};\n\nPromiseSpawn.prototype._promiseCancelled = function() {\n    if (this._isResolved()) return;\n    var implementsReturn = typeof this._generator[\"return\"] !== \"undefined\";\n\n    var result;\n    if (!implementsReturn) {\n        var reason = new Promise.CancellationError(\n            \"generator .return() sentinel\");\n        Promise.coroutine.returnSentinel = reason;\n        this._promise._attachExtraTrace(reason);\n        this._promise._pushContext();\n        result = tryCatch(this._generator[\"throw\"]).call(this._generator,\n                                                         reason);\n        this._promise._popContext();\n    } else {\n        this._promise._pushContext();\n        result = tryCatch(this._generator[\"return\"]).call(this._generator,\n                                                          undefined);\n        this._promise._popContext();\n    }\n    this._cancellationPhase = true;\n    this._yieldedPromise = null;\n    this._continue(result);\n};\n\nPromiseSpawn.prototype._promiseFulfilled = function(value) {\n    this._yieldedPromise = null;\n    this._promise._pushContext();\n    var result = tryCatch(this._generator.next).call(this._generator, value);\n    this._promise._popContext();\n    this._continue(result);\n};\n\nPromiseSpawn.prototype._promiseRejected = function(reason) {\n    this._yieldedPromise = null;\n    this._promise._attachExtraTrace(reason);\n    this._promise._pushContext();\n    var result = tryCatch(this._generator[\"throw\"])\n        .call(this._generator, reason);\n    this._promise._popContext();\n    this._continue(result);\n};\n\nPromiseSpawn.prototype._resultCancelled = function() {\n    if (this._yieldedPromise instanceof Promise) {\n        var promise = this._yieldedPromise;\n        this._yieldedPromise = null;\n        promise.cancel();\n    }\n};\n\nPromiseSpawn.prototype.promise = function () {\n    return this._promise;\n};\n\nPromiseSpawn.prototype._run = function () {\n    this._generator = this._generatorFunction.call(this._receiver);\n    this._receiver =\n        this._generatorFunction = undefined;\n    this._promiseFulfilled(undefined);\n};\n\nPromiseSpawn.prototype._continue = function (result) {\n    var promise = this._promise;\n    if (result === errorObj) {\n        this._cleanup();\n        if (this._cancellationPhase) {\n            return promise.cancel();\n        } else {\n            return promise._rejectCallback(result.e, false);\n        }\n    }\n\n    var value = result.value;\n    if (result.done === true) {\n        this._cleanup();\n        if (this._cancellationPhase) {\n            return promise.cancel();\n        } else {\n            return promise._resolveCallback(value);\n        }\n    } else {\n        var maybePromise = tryConvertToPromise(value, this._promise);\n        if (!(maybePromise instanceof Promise)) {\n            maybePromise =\n                promiseFromYieldHandler(maybePromise,\n                                        this._yieldHandlers,\n                                        this._promise);\n            if (maybePromise === null) {\n                this._promiseRejected(\n                    new TypeError(\n                        \"A value %s was yielded that could not be treated as a promise\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\\u000a\".replace(\"%s\", String(value)) +\n                        \"From coroutine:\\u000a\" +\n                        this._stack.split(\"\\n\").slice(1, -7).join(\"\\n\")\n                    )\n                );\n                return;\n            }\n        }\n        maybePromise = maybePromise._target();\n        var bitField = maybePromise._bitField;\n        ;\n        if (((bitField & 50397184) === 0)) {\n            this._yieldedPromise = maybePromise;\n            maybePromise._proxy(this, null);\n        } else if (((bitField & 33554432) !== 0)) {\n            Promise._async.invoke(\n                this._promiseFulfilled, this, maybePromise._value()\n            );\n        } else if (((bitField & 16777216) !== 0)) {\n            Promise._async.invoke(\n                this._promiseRejected, this, maybePromise._reason()\n            );\n        } else {\n            this._promiseCancelled();\n        }\n    }\n};\n\nPromise.coroutine = function (generatorFunction, options) {\n    if (typeof generatorFunction !== \"function\") {\n        throw new TypeError(\"generatorFunction must be a function\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n    }\n    var yieldHandler = Object(options).yieldHandler;\n    var PromiseSpawn$ = PromiseSpawn;\n    var stack = new Error().stack;\n    return function () {\n        var generator = generatorFunction.apply(this, arguments);\n        var spawn = new PromiseSpawn$(undefined, undefined, yieldHandler,\n                                      stack);\n        var ret = spawn.promise();\n        spawn._generator = generator;\n        spawn._promiseFulfilled(undefined);\n        return ret;\n    };\n};\n\nPromise.coroutine.addYieldHandler = function(fn) {\n    if (typeof fn !== \"function\") {\n        throw new TypeError(\"expecting a function but got \" + util.classString(fn));\n    }\n    yieldHandlers.push(fn);\n};\n\nPromise.spawn = function (generatorFunction) {\n    debug.deprecated(\"Promise.spawn()\", \"Promise.coroutine()\");\n    if (typeof generatorFunction !== \"function\") {\n        return apiRejection(\"generatorFunction must be a function\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n    }\n    var spawn = new PromiseSpawn(generatorFunction, this);\n    var ret = spawn.promise();\n    spawn._run(Promise.spawn);\n    return ret;\n};\n};\n","\"use strict\";\nmodule.exports = function(Promise,\n                          PromiseArray,\n                          apiRejection,\n                          tryConvertToPromise,\n                          INTERNAL,\n                          debug) {\nvar util = require(\"./util\");\nvar tryCatch = util.tryCatch;\nvar errorObj = util.errorObj;\nvar async = Promise._async;\n\nfunction MappingPromiseArray(promises, fn, limit, _filter) {\n    this.constructor$(promises);\n    this._promise._captureStackTrace();\n    var context = Promise._getContext();\n    this._callback = util.contextBind(context, fn);\n    this._preservedValues = _filter === INTERNAL\n        ? new Array(this.length())\n        : null;\n    this._limit = limit;\n    this._inFlight = 0;\n    this._queue = [];\n    async.invoke(this._asyncInit, this, undefined);\n    if (util.isArray(promises)) {\n        for (var i = 0; i < promises.length; ++i) {\n            var maybePromise = promises[i];\n            if (maybePromise instanceof Promise) {\n                maybePromise.suppressUnhandledRejections();\n            }\n        }\n    }\n}\nutil.inherits(MappingPromiseArray, PromiseArray);\n\nMappingPromiseArray.prototype._asyncInit = function() {\n    this._init$(undefined, -2);\n};\n\nMappingPromiseArray.prototype._init = function () {};\n\nMappingPromiseArray.prototype._promiseFulfilled = function (value, index) {\n    var values = this._values;\n    var length = this.length();\n    var preservedValues = this._preservedValues;\n    var limit = this._limit;\n\n    if (index < 0) {\n        index = (index * -1) - 1;\n        values[index] = value;\n        if (limit >= 1) {\n            this._inFlight--;\n            this._drainQueue();\n            if (this._isResolved()) return true;\n        }\n    } else {\n        if (limit >= 1 && this._inFlight >= limit) {\n            values[index] = value;\n            this._queue.push(index);\n            return false;\n        }\n        if (preservedValues !== null) preservedValues[index] = value;\n\n        var promise = this._promise;\n        var callback = this._callback;\n        var receiver = promise._boundValue();\n        promise._pushContext();\n        var ret = tryCatch(callback).call(receiver, value, index, length);\n        var promiseCreated = promise._popContext();\n        debug.checkForgottenReturns(\n            ret,\n            promiseCreated,\n            preservedValues !== null ? \"Promise.filter\" : \"Promise.map\",\n            promise\n        );\n        if (ret === errorObj) {\n            this._reject(ret.e);\n            return true;\n        }\n\n        var maybePromise = tryConvertToPromise(ret, this._promise);\n        if (maybePromise instanceof Promise) {\n            maybePromise = maybePromise._target();\n            var bitField = maybePromise._bitField;\n            ;\n            if (((bitField & 50397184) === 0)) {\n                if (limit >= 1) this._inFlight++;\n                values[index] = maybePromise;\n                maybePromise._proxy(this, (index + 1) * -1);\n                return false;\n            } else if (((bitField & 33554432) !== 0)) {\n                ret = maybePromise._value();\n            } else if (((bitField & 16777216) !== 0)) {\n                this._reject(maybePromise._reason());\n                return true;\n            } else {\n                this._cancel();\n                return true;\n            }\n        }\n        values[index] = ret;\n    }\n    var totalResolved = ++this._totalResolved;\n    if (totalResolved >= length) {\n        if (preservedValues !== null) {\n            this._filter(values, preservedValues);\n        } else {\n            this._resolve(values);\n        }\n        return true;\n    }\n    return false;\n};\n\nMappingPromiseArray.prototype._drainQueue = function () {\n    var queue = this._queue;\n    var limit = this._limit;\n    var values = this._values;\n    while (queue.length > 0 && this._inFlight < limit) {\n        if (this._isResolved()) return;\n        var index = queue.pop();\n        this._promiseFulfilled(values[index], index);\n    }\n};\n\nMappingPromiseArray.prototype._filter = function (booleans, values) {\n    var len = values.length;\n    var ret = new Array(len);\n    var j = 0;\n    for (var i = 0; i < len; ++i) {\n        if (booleans[i]) ret[j++] = values[i];\n    }\n    ret.length = j;\n    this._resolve(ret);\n};\n\nMappingPromiseArray.prototype.preservedValues = function () {\n    return this._preservedValues;\n};\n\nfunction map(promises, fn, options, _filter) {\n    if (typeof fn !== \"function\") {\n        return apiRejection(\"expecting a function but got \" + util.classString(fn));\n    }\n\n    var limit = 0;\n    if (options !== undefined) {\n        if (typeof options === \"object\" && options !== null) {\n            if (typeof options.concurrency !== \"number\") {\n                return Promise.reject(\n                    new TypeError(\"'concurrency' must be a number but it is \" +\n                                    util.classString(options.concurrency)));\n            }\n            limit = options.concurrency;\n        } else {\n            return Promise.reject(new TypeError(\n                            \"options argument must be an object but it is \" +\n                             util.classString(options)));\n        }\n    }\n    limit = typeof limit === \"number\" &&\n        isFinite(limit) && limit >= 1 ? limit : 0;\n    return new MappingPromiseArray(promises, fn, limit, _filter).promise();\n}\n\nPromise.prototype.map = function (fn, options) {\n    return map(this, fn, options, null);\n};\n\nPromise.map = function (promises, fn, options, _filter) {\n    return map(promises, fn, options, _filter);\n};\n\n\n};\n","\"use strict\";\nmodule.exports = function(Promise) {\nvar util = require(\"./util\");\nvar async = Promise._async;\nvar tryCatch = util.tryCatch;\nvar errorObj = util.errorObj;\n\nfunction spreadAdapter(val, nodeback) {\n    var promise = this;\n    if (!util.isArray(val)) return successAdapter.call(promise, val, nodeback);\n    var ret =\n        tryCatch(nodeback).apply(promise._boundValue(), [null].concat(val));\n    if (ret === errorObj) {\n        async.throwLater(ret.e);\n    }\n}\n\nfunction successAdapter(val, nodeback) {\n    var promise = this;\n    var receiver = promise._boundValue();\n    var ret = val === undefined\n        ? tryCatch(nodeback).call(receiver, null)\n        : tryCatch(nodeback).call(receiver, null, val);\n    if (ret === errorObj) {\n        async.throwLater(ret.e);\n    }\n}\nfunction errorAdapter(reason, nodeback) {\n    var promise = this;\n    if (!reason) {\n        var newReason = new Error(reason + \"\");\n        newReason.cause = reason;\n        reason = newReason;\n    }\n    var ret = tryCatch(nodeback).call(promise._boundValue(), reason);\n    if (ret === errorObj) {\n        async.throwLater(ret.e);\n    }\n}\n\nPromise.prototype.asCallback = Promise.prototype.nodeify = function (nodeback,\n                                                                     options) {\n    if (typeof nodeback == \"function\") {\n        var adapter = successAdapter;\n        if (options !== undefined && Object(options).spread) {\n            adapter = spreadAdapter;\n        }\n        this._then(\n            adapter,\n            errorAdapter,\n            undefined,\n            this,\n            nodeback\n        );\n    }\n    return this;\n};\n};\n","\"use strict\";\nmodule.exports = function(Promise, INTERNAL) {\nvar THIS = {};\nvar util = require(\"./util\");\nvar nodebackForPromise = require(\"./nodeback\");\nvar withAppended = util.withAppended;\nvar maybeWrapAsError = util.maybeWrapAsError;\nvar canEvaluate = util.canEvaluate;\nvar TypeError = require(\"./errors\").TypeError;\nvar defaultSuffix = \"Async\";\nvar defaultPromisified = {__isPromisified__: true};\nvar noCopyProps = [\n    \"arity\",    \"length\",\n    \"name\",\n    \"arguments\",\n    \"caller\",\n    \"callee\",\n    \"prototype\",\n    \"__isPromisified__\"\n];\nvar noCopyPropsPattern = new RegExp(\"^(?:\" + noCopyProps.join(\"|\") + \")$\");\n\nvar defaultFilter = function(name) {\n    return util.isIdentifier(name) &&\n        name.charAt(0) !== \"_\" &&\n        name !== \"constructor\";\n};\n\nfunction propsFilter(key) {\n    return !noCopyPropsPattern.test(key);\n}\n\nfunction isPromisified(fn) {\n    try {\n        return fn.__isPromisified__ === true;\n    }\n    catch (e) {\n        return false;\n    }\n}\n\nfunction hasPromisified(obj, key, suffix) {\n    var val = util.getDataPropertyOrDefault(obj, key + suffix,\n                                            defaultPromisified);\n    return val ? isPromisified(val) : false;\n}\nfunction checkValid(ret, suffix, suffixRegexp) {\n    for (var i = 0; i < ret.length; i += 2) {\n        var key = ret[i];\n        if (suffixRegexp.test(key)) {\n            var keyWithoutAsyncSuffix = key.replace(suffixRegexp, \"\");\n            for (var j = 0; j < ret.length; j += 2) {\n                if (ret[j] === keyWithoutAsyncSuffix) {\n                    throw new TypeError(\"Cannot promisify an API that has normal methods with '%s'-suffix\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\"\n                        .replace(\"%s\", suffix));\n                }\n            }\n        }\n    }\n}\n\nfunction promisifiableMethods(obj, suffix, suffixRegexp, filter) {\n    var keys = util.inheritedDataKeys(obj);\n    var ret = [];\n    for (var i = 0; i < keys.length; ++i) {\n        var key = keys[i];\n        var value = obj[key];\n        var passesDefaultFilter = filter === defaultFilter\n            ? true : defaultFilter(key, value, obj);\n        if (typeof value === \"function\" &&\n            !isPromisified(value) &&\n            !hasPromisified(obj, key, suffix) &&\n            filter(key, value, obj, passesDefaultFilter)) {\n            ret.push(key, value);\n        }\n    }\n    checkValid(ret, suffix, suffixRegexp);\n    return ret;\n}\n\nvar escapeIdentRegex = function(str) {\n    return str.replace(/([$])/, \"\\\\$\");\n};\n\nvar makeNodePromisifiedEval;\nif (!false) {\nvar switchCaseArgumentOrder = function(likelyArgumentCount) {\n    var ret = [likelyArgumentCount];\n    var min = Math.max(0, likelyArgumentCount - 1 - 3);\n    for(var i = likelyArgumentCount - 1; i >= min; --i) {\n        ret.push(i);\n    }\n    for(var i = likelyArgumentCount + 1; i <= 3; ++i) {\n        ret.push(i);\n    }\n    return ret;\n};\n\nvar argumentSequence = function(argumentCount) {\n    return util.filledRange(argumentCount, \"_arg\", \"\");\n};\n\nvar parameterDeclaration = function(parameterCount) {\n    return util.filledRange(\n        Math.max(parameterCount, 3), \"_arg\", \"\");\n};\n\nvar parameterCount = function(fn) {\n    if (typeof fn.length === \"number\") {\n        return Math.max(Math.min(fn.length, 1023 + 1), 0);\n    }\n    return 0;\n};\n\nmakeNodePromisifiedEval =\nfunction(callback, receiver, originalName, fn, _, multiArgs) {\n    var newParameterCount = Math.max(0, parameterCount(fn) - 1);\n    var argumentOrder = switchCaseArgumentOrder(newParameterCount);\n    var shouldProxyThis = typeof callback === \"string\" || receiver === THIS;\n\n    function generateCallForArgumentCount(count) {\n        var args = argumentSequence(count).join(\", \");\n        var comma = count > 0 ? \", \" : \"\";\n        var ret;\n        if (shouldProxyThis) {\n            ret = \"ret = callback.call(this, {{args}}, nodeback); break;\\n\";\n        } else {\n            ret = receiver === undefined\n                ? \"ret = callback({{args}}, nodeback); break;\\n\"\n                : \"ret = callback.call(receiver, {{args}}, nodeback); break;\\n\";\n        }\n        return ret.replace(\"{{args}}\", args).replace(\", \", comma);\n    }\n\n    function generateArgumentSwitchCase() {\n        var ret = \"\";\n        for (var i = 0; i < argumentOrder.length; ++i) {\n            ret += \"case \" + argumentOrder[i] +\":\" +\n                generateCallForArgumentCount(argumentOrder[i]);\n        }\n\n        ret += \"                                                             \\n\\\n        default:                                                             \\n\\\n            var args = new Array(len + 1);                                   \\n\\\n            var i = 0;                                                       \\n\\\n            for (var i = 0; i < len; ++i) {                                  \\n\\\n               args[i] = arguments[i];                                       \\n\\\n            }                                                                \\n\\\n            args[i] = nodeback;                                              \\n\\\n            [CodeForCall]                                                    \\n\\\n            break;                                                           \\n\\\n        \".replace(\"[CodeForCall]\", (shouldProxyThis\n                                ? \"ret = callback.apply(this, args);\\n\"\n                                : \"ret = callback.apply(receiver, args);\\n\"));\n        return ret;\n    }\n\n    var getFunctionCode = typeof callback === \"string\"\n                                ? (\"this != null ? this['\"+callback+\"'] : fn\")\n                                : \"fn\";\n    var body = \"'use strict';                                                \\n\\\n        var ret = function (Parameters) {                                    \\n\\\n            'use strict';                                                    \\n\\\n            var len = arguments.length;                                      \\n\\\n            var promise = new Promise(INTERNAL);                             \\n\\\n            promise._captureStackTrace();                                    \\n\\\n            var nodeback = nodebackForPromise(promise, \" + multiArgs + \");   \\n\\\n            var ret;                                                         \\n\\\n            var callback = tryCatch([GetFunctionCode]);                      \\n\\\n            switch(len) {                                                    \\n\\\n                [CodeForSwitchCase]                                          \\n\\\n            }                                                                \\n\\\n            if (ret === errorObj) {                                          \\n\\\n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\\n\\\n            }                                                                \\n\\\n            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \\n\\\n            return promise;                                                  \\n\\\n        };                                                                   \\n\\\n        notEnumerableProp(ret, '__isPromisified__', true);                   \\n\\\n        return ret;                                                          \\n\\\n    \".replace(\"[CodeForSwitchCase]\", generateArgumentSwitchCase())\n        .replace(\"[GetFunctionCode]\", getFunctionCode);\n    body = body.replace(\"Parameters\", parameterDeclaration(newParameterCount));\n    return new Function(\"Promise\",\n                        \"fn\",\n                        \"receiver\",\n                        \"withAppended\",\n                        \"maybeWrapAsError\",\n                        \"nodebackForPromise\",\n                        \"tryCatch\",\n                        \"errorObj\",\n                        \"notEnumerableProp\",\n                        \"INTERNAL\",\n                        body)(\n                    Promise,\n                    fn,\n                    receiver,\n                    withAppended,\n                    maybeWrapAsError,\n                    nodebackForPromise,\n                    util.tryCatch,\n                    util.errorObj,\n                    util.notEnumerableProp,\n                    INTERNAL);\n};\n}\n\nfunction makeNodePromisifiedClosure(callback, receiver, _, fn, __, multiArgs) {\n    var defaultThis = (function() {return this;})();\n    var method = callback;\n    if (typeof method === \"string\") {\n        callback = fn;\n    }\n    function promisified() {\n        var _receiver = receiver;\n        if (receiver === THIS) _receiver = this;\n        var promise = new Promise(INTERNAL);\n        promise._captureStackTrace();\n        var cb = typeof method === \"string\" && this !== defaultThis\n            ? this[method] : callback;\n        var fn = nodebackForPromise(promise, multiArgs);\n        try {\n            cb.apply(_receiver, withAppended(arguments, fn));\n        } catch(e) {\n            promise._rejectCallback(maybeWrapAsError(e), true, true);\n        }\n        if (!promise._isFateSealed()) promise._setAsyncGuaranteed();\n        return promise;\n    }\n    util.notEnumerableProp(promisified, \"__isPromisified__\", true);\n    return promisified;\n}\n\nvar makeNodePromisified = canEvaluate\n    ? makeNodePromisifiedEval\n    : makeNodePromisifiedClosure;\n\nfunction promisifyAll(obj, suffix, filter, promisifier, multiArgs) {\n    var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + \"$\");\n    var methods =\n        promisifiableMethods(obj, suffix, suffixRegexp, filter);\n\n    for (var i = 0, len = methods.length; i < len; i+= 2) {\n        var key = methods[i];\n        var fn = methods[i+1];\n        var promisifiedKey = key + suffix;\n        if (promisifier === makeNodePromisified) {\n            obj[promisifiedKey] =\n                makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);\n        } else {\n            var promisified = promisifier(fn, function() {\n                return makeNodePromisified(key, THIS, key,\n                                           fn, suffix, multiArgs);\n            });\n            util.notEnumerableProp(promisified, \"__isPromisified__\", true);\n            obj[promisifiedKey] = promisified;\n        }\n    }\n    util.toFastProperties(obj);\n    return obj;\n}\n\nfunction promisify(callback, receiver, multiArgs) {\n    return makeNodePromisified(callback, receiver, undefined,\n                                callback, null, multiArgs);\n}\n\nPromise.promisify = function (fn, options) {\n    if (typeof fn !== \"function\") {\n        throw new TypeError(\"expecting a function but got \" + util.classString(fn));\n    }\n    if (isPromisified(fn)) {\n        return fn;\n    }\n    options = Object(options);\n    var receiver = options.context === undefined ? THIS : options.context;\n    var multiArgs = !!options.multiArgs;\n    var ret = promisify(fn, receiver, multiArgs);\n    util.copyDescriptors(fn, ret, propsFilter);\n    return ret;\n};\n\nPromise.promisifyAll = function (target, options) {\n    if (typeof target !== \"function\" && typeof target !== \"object\") {\n        throw new TypeError(\"the target of promisifyAll must be an object or a function\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n    }\n    options = Object(options);\n    var multiArgs = !!options.multiArgs;\n    var suffix = options.suffix;\n    if (typeof suffix !== \"string\") suffix = defaultSuffix;\n    var filter = options.filter;\n    if (typeof filter !== \"function\") filter = defaultFilter;\n    var promisifier = options.promisifier;\n    if (typeof promisifier !== \"function\") promisifier = makeNodePromisified;\n\n    if (!util.isIdentifier(suffix)) {\n        throw new RangeError(\"suffix must be a valid identifier\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n    }\n\n    var keys = util.inheritedDataKeys(target);\n    for (var i = 0; i < keys.length; ++i) {\n        var value = target[keys[i]];\n        if (keys[i] !== \"constructor\" &&\n            util.isClass(value)) {\n            promisifyAll(value.prototype, suffix, filter, promisifier,\n                multiArgs);\n            promisifyAll(value, suffix, filter, promisifier, multiArgs);\n        }\n    }\n\n    return promisifyAll(target, suffix, filter, promisifier, multiArgs);\n};\n};\n\n","\"use strict\";\nmodule.exports = function(\n    Promise, PromiseArray, tryConvertToPromise, apiRejection) {\nvar util = require(\"./util\");\nvar isObject = util.isObject;\nvar es5 = require(\"./es5\");\nvar Es6Map;\nif (typeof Map === \"function\") Es6Map = Map;\n\nvar mapToEntries = (function() {\n    var index = 0;\n    var size = 0;\n\n    function extractEntry(value, key) {\n        this[index] = value;\n        this[index + size] = key;\n        index++;\n    }\n\n    return function mapToEntries(map) {\n        size = map.size;\n        index = 0;\n        var ret = new Array(map.size * 2);\n        map.forEach(extractEntry, ret);\n        return ret;\n    };\n})();\n\nvar entriesToMap = function(entries) {\n    var ret = new Es6Map();\n    var length = entries.length / 2 | 0;\n    for (var i = 0; i < length; ++i) {\n        var key = entries[length + i];\n        var value = entries[i];\n        ret.set(key, value);\n    }\n    return ret;\n};\n\nfunction PropertiesPromiseArray(obj) {\n    var isMap = false;\n    var entries;\n    if (Es6Map !== undefined && obj instanceof Es6Map) {\n        entries = mapToEntries(obj);\n        isMap = true;\n    } else {\n        var keys = es5.keys(obj);\n        var len = keys.length;\n        entries = new Array(len * 2);\n        for (var i = 0; i < len; ++i) {\n            var key = keys[i];\n            entries[i] = obj[key];\n            entries[i + len] = key;\n        }\n    }\n    this.constructor$(entries);\n    this._isMap = isMap;\n    this._init$(undefined, isMap ? -6 : -3);\n}\nutil.inherits(PropertiesPromiseArray, PromiseArray);\n\nPropertiesPromiseArray.prototype._init = function () {};\n\nPropertiesPromiseArray.prototype._promiseFulfilled = function (value, index) {\n    this._values[index] = value;\n    var totalResolved = ++this._totalResolved;\n    if (totalResolved >= this._length) {\n        var val;\n        if (this._isMap) {\n            val = entriesToMap(this._values);\n        } else {\n            val = {};\n            var keyOffset = this.length();\n            for (var i = 0, len = this.length(); i < len; ++i) {\n                val[this._values[i + keyOffset]] = this._values[i];\n            }\n        }\n        this._resolve(val);\n        return true;\n    }\n    return false;\n};\n\nPropertiesPromiseArray.prototype.shouldCopyValues = function () {\n    return false;\n};\n\nPropertiesPromiseArray.prototype.getActualLength = function (len) {\n    return len >> 1;\n};\n\nfunction props(promises) {\n    var ret;\n    var castValue = tryConvertToPromise(promises);\n\n    if (!isObject(castValue)) {\n        return apiRejection(\"cannot await properties of a non-object\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n    } else if (castValue instanceof Promise) {\n        ret = castValue._then(\n            Promise.props, undefined, undefined, undefined, undefined);\n    } else {\n        ret = new PropertiesPromiseArray(castValue).promise();\n    }\n\n    if (castValue instanceof Promise) {\n        ret._propagateFrom(castValue, 2);\n    }\n    return ret;\n}\n\nPromise.prototype.props = function () {\n    return props(this);\n};\n\nPromise.props = function (promises) {\n    return props(promises);\n};\n};\n","\"use strict\";\nmodule.exports = function(\n    Promise, INTERNAL, tryConvertToPromise, apiRejection) {\nvar util = require(\"./util\");\n\nvar raceLater = function (promise) {\n    return promise.then(function(array) {\n        return race(array, promise);\n    });\n};\n\nfunction race(promises, parent) {\n    var maybePromise = tryConvertToPromise(promises);\n\n    if (maybePromise instanceof Promise) {\n        return raceLater(maybePromise);\n    } else {\n        promises = util.asArray(promises);\n        if (promises === null)\n            return apiRejection(\"expecting an array or an iterable object but got \" + util.classString(promises));\n    }\n\n    var ret = new Promise(INTERNAL);\n    if (parent !== undefined) {\n        ret._propagateFrom(parent, 3);\n    }\n    var fulfill = ret._fulfill;\n    var reject = ret._reject;\n    for (var i = 0, len = promises.length; i < len; ++i) {\n        var val = promises[i];\n\n        if (val === undefined && !(i in promises)) {\n            continue;\n        }\n\n        Promise.cast(val)._then(fulfill, reject, undefined, ret, null);\n    }\n    return ret;\n}\n\nPromise.race = function (promises) {\n    return race(promises, undefined);\n};\n\nPromise.prototype.race = function () {\n    return race(this, undefined);\n};\n\n};\n","\"use strict\";\nmodule.exports = function(Promise,\n                          PromiseArray,\n                          apiRejection,\n                          tryConvertToPromise,\n                          INTERNAL,\n                          debug) {\nvar util = require(\"./util\");\nvar tryCatch = util.tryCatch;\n\nfunction ReductionPromiseArray(promises, fn, initialValue, _each) {\n    this.constructor$(promises);\n    var context = Promise._getContext();\n    this._fn = util.contextBind(context, fn);\n    if (initialValue !== undefined) {\n        initialValue = Promise.resolve(initialValue);\n        initialValue._attachCancellationCallback(this);\n    }\n    this._initialValue = initialValue;\n    this._currentCancellable = null;\n    if(_each === INTERNAL) {\n        this._eachValues = Array(this._length);\n    } else if (_each === 0) {\n        this._eachValues = null;\n    } else {\n        this._eachValues = undefined;\n    }\n    this._promise._captureStackTrace();\n    this._init$(undefined, -5);\n}\nutil.inherits(ReductionPromiseArray, PromiseArray);\n\nReductionPromiseArray.prototype._gotAccum = function(accum) {\n    if (this._eachValues !== undefined &&\n        this._eachValues !== null &&\n        accum !== INTERNAL) {\n        this._eachValues.push(accum);\n    }\n};\n\nReductionPromiseArray.prototype._eachComplete = function(value) {\n    if (this._eachValues !== null) {\n        this._eachValues.push(value);\n    }\n    return this._eachValues;\n};\n\nReductionPromiseArray.prototype._init = function() {};\n\nReductionPromiseArray.prototype._resolveEmptyArray = function() {\n    this._resolve(this._eachValues !== undefined ? this._eachValues\n                                                 : this._initialValue);\n};\n\nReductionPromiseArray.prototype.shouldCopyValues = function () {\n    return false;\n};\n\nReductionPromiseArray.prototype._resolve = function(value) {\n    this._promise._resolveCallback(value);\n    this._values = null;\n};\n\nReductionPromiseArray.prototype._resultCancelled = function(sender) {\n    if (sender === this._initialValue) return this._cancel();\n    if (this._isResolved()) return;\n    this._resultCancelled$();\n    if (this._currentCancellable instanceof Promise) {\n        this._currentCancellable.cancel();\n    }\n    if (this._initialValue instanceof Promise) {\n        this._initialValue.cancel();\n    }\n};\n\nReductionPromiseArray.prototype._iterate = function (values) {\n    this._values = values;\n    var value;\n    var i;\n    var length = values.length;\n    if (this._initialValue !== undefined) {\n        value = this._initialValue;\n        i = 0;\n    } else {\n        value = Promise.resolve(values[0]);\n        i = 1;\n    }\n\n    this._currentCancellable = value;\n\n    for (var j = i; j < length; ++j) {\n        var maybePromise = values[j];\n        if (maybePromise instanceof Promise) {\n            maybePromise.suppressUnhandledRejections();\n        }\n    }\n\n    if (!value.isRejected()) {\n        for (; i < length; ++i) {\n            var ctx = {\n                accum: null,\n                value: values[i],\n                index: i,\n                length: length,\n                array: this\n            };\n\n            value = value._then(gotAccum, undefined, undefined, ctx, undefined);\n\n            if ((i & 127) === 0) {\n                value._setNoAsyncGuarantee();\n            }\n        }\n    }\n\n    if (this._eachValues !== undefined) {\n        value = value\n            ._then(this._eachComplete, undefined, undefined, this, undefined);\n    }\n    value._then(completed, completed, undefined, value, this);\n};\n\nPromise.prototype.reduce = function (fn, initialValue) {\n    return reduce(this, fn, initialValue, null);\n};\n\nPromise.reduce = function (promises, fn, initialValue, _each) {\n    return reduce(promises, fn, initialValue, _each);\n};\n\nfunction completed(valueOrReason, array) {\n    if (this.isFulfilled()) {\n        array._resolve(valueOrReason);\n    } else {\n        array._reject(valueOrReason);\n    }\n}\n\nfunction reduce(promises, fn, initialValue, _each) {\n    if (typeof fn !== \"function\") {\n        return apiRejection(\"expecting a function but got \" + util.classString(fn));\n    }\n    var array = new ReductionPromiseArray(promises, fn, initialValue, _each);\n    return array.promise();\n}\n\nfunction gotAccum(accum) {\n    this.accum = accum;\n    this.array._gotAccum(accum);\n    var value = tryConvertToPromise(this.value, this.array._promise);\n    if (value instanceof Promise) {\n        this.array._currentCancellable = value;\n        return value._then(gotValue, undefined, undefined, this, undefined);\n    } else {\n        return gotValue.call(this, value);\n    }\n}\n\nfunction gotValue(value) {\n    var array = this.array;\n    var promise = array._promise;\n    var fn = tryCatch(array._fn);\n    promise._pushContext();\n    var ret;\n    if (array._eachValues !== undefined) {\n        ret = fn.call(promise._boundValue(), value, this.index, this.length);\n    } else {\n        ret = fn.call(promise._boundValue(),\n                              this.accum, value, this.index, this.length);\n    }\n    if (ret instanceof Promise) {\n        array._currentCancellable = ret;\n    }\n    var promiseCreated = promise._popContext();\n    debug.checkForgottenReturns(\n        ret,\n        promiseCreated,\n        array._eachValues !== undefined ? \"Promise.each\" : \"Promise.reduce\",\n        promise\n    );\n    return ret;\n}\n};\n","\"use strict\";\nmodule.exports =\n    function(Promise, PromiseArray, debug) {\nvar PromiseInspection = Promise.PromiseInspection;\nvar util = require(\"./util\");\n\nfunction SettledPromiseArray(values) {\n    this.constructor$(values);\n}\nutil.inherits(SettledPromiseArray, PromiseArray);\n\nSettledPromiseArray.prototype._promiseResolved = function (index, inspection) {\n    this._values[index] = inspection;\n    var totalResolved = ++this._totalResolved;\n    if (totalResolved >= this._length) {\n        this._resolve(this._values);\n        return true;\n    }\n    return false;\n};\n\nSettledPromiseArray.prototype._promiseFulfilled = function (value, index) {\n    var ret = new PromiseInspection();\n    ret._bitField = 33554432;\n    ret._settledValueField = value;\n    return this._promiseResolved(index, ret);\n};\nSettledPromiseArray.prototype._promiseRejected = function (reason, index) {\n    var ret = new PromiseInspection();\n    ret._bitField = 16777216;\n    ret._settledValueField = reason;\n    return this._promiseResolved(index, ret);\n};\n\nPromise.settle = function (promises) {\n    debug.deprecated(\".settle()\", \".reflect()\");\n    return new SettledPromiseArray(promises).promise();\n};\n\nPromise.allSettled = function (promises) {\n    return new SettledPromiseArray(promises).promise();\n};\n\nPromise.prototype.settle = function () {\n    return Promise.settle(this);\n};\n};\n","\"use strict\";\nmodule.exports =\nfunction(Promise, PromiseArray, apiRejection) {\nvar util = require(\"./util\");\nvar RangeError = require(\"./errors\").RangeError;\nvar AggregateError = require(\"./errors\").AggregateError;\nvar isArray = util.isArray;\nvar CANCELLATION = {};\n\n\nfunction SomePromiseArray(values) {\n    this.constructor$(values);\n    this._howMany = 0;\n    this._unwrap = false;\n    this._initialized = false;\n}\nutil.inherits(SomePromiseArray, PromiseArray);\n\nSomePromiseArray.prototype._init = function () {\n    if (!this._initialized) {\n        return;\n    }\n    if (this._howMany === 0) {\n        this._resolve([]);\n        return;\n    }\n    this._init$(undefined, -5);\n    var isArrayResolved = isArray(this._values);\n    if (!this._isResolved() &&\n        isArrayResolved &&\n        this._howMany > this._canPossiblyFulfill()) {\n        this._reject(this._getRangeError(this.length()));\n    }\n};\n\nSomePromiseArray.prototype.init = function () {\n    this._initialized = true;\n    this._init();\n};\n\nSomePromiseArray.prototype.setUnwrap = function () {\n    this._unwrap = true;\n};\n\nSomePromiseArray.prototype.howMany = function () {\n    return this._howMany;\n};\n\nSomePromiseArray.prototype.setHowMany = function (count) {\n    this._howMany = count;\n};\n\nSomePromiseArray.prototype._promiseFulfilled = function (value) {\n    this._addFulfilled(value);\n    if (this._fulfilled() === this.howMany()) {\n        this._values.length = this.howMany();\n        if (this.howMany() === 1 && this._unwrap) {\n            this._resolve(this._values[0]);\n        } else {\n            this._resolve(this._values);\n        }\n        return true;\n    }\n    return false;\n\n};\nSomePromiseArray.prototype._promiseRejected = function (reason) {\n    this._addRejected(reason);\n    return this._checkOutcome();\n};\n\nSomePromiseArray.prototype._promiseCancelled = function () {\n    if (this._values instanceof Promise || this._values == null) {\n        return this._cancel();\n    }\n    this._addRejected(CANCELLATION);\n    return this._checkOutcome();\n};\n\nSomePromiseArray.prototype._checkOutcome = function() {\n    if (this.howMany() > this._canPossiblyFulfill()) {\n        var e = new AggregateError();\n        for (var i = this.length(); i < this._values.length; ++i) {\n            if (this._values[i] !== CANCELLATION) {\n                e.push(this._values[i]);\n            }\n        }\n        if (e.length > 0) {\n            this._reject(e);\n        } else {\n            this._cancel();\n        }\n        return true;\n    }\n    return false;\n};\n\nSomePromiseArray.prototype._fulfilled = function () {\n    return this._totalResolved;\n};\n\nSomePromiseArray.prototype._rejected = function () {\n    return this._values.length - this.length();\n};\n\nSomePromiseArray.prototype._addRejected = function (reason) {\n    this._values.push(reason);\n};\n\nSomePromiseArray.prototype._addFulfilled = function (value) {\n    this._values[this._totalResolved++] = value;\n};\n\nSomePromiseArray.prototype._canPossiblyFulfill = function () {\n    return this.length() - this._rejected();\n};\n\nSomePromiseArray.prototype._getRangeError = function (count) {\n    var message = \"Input array must contain at least \" +\n            this._howMany + \" items but contains only \" + count + \" items\";\n    return new RangeError(message);\n};\n\nSomePromiseArray.prototype._resolveEmptyArray = function () {\n    this._reject(this._getRangeError(0));\n};\n\nfunction some(promises, howMany) {\n    if ((howMany | 0) !== howMany || howMany < 0) {\n        return apiRejection(\"expecting a positive integer\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n    }\n    var ret = new SomePromiseArray(promises);\n    var promise = ret.promise();\n    ret.setHowMany(howMany);\n    ret.init();\n    return promise;\n}\n\nPromise.some = function (promises, howMany) {\n    return some(promises, howMany);\n};\n\nPromise.prototype.some = function (howMany) {\n    return some(this, howMany);\n};\n\nPromise._SomePromiseArray = SomePromiseArray;\n};\n","\"use strict\";\nmodule.exports = function(Promise, INTERNAL, debug) {\nvar util = require(\"./util\");\nvar TimeoutError = Promise.TimeoutError;\n\nfunction HandleWrapper(handle)  {\n    this.handle = handle;\n}\n\nHandleWrapper.prototype._resultCancelled = function() {\n    clearTimeout(this.handle);\n};\n\nvar afterValue = function(value) { return delay(+this).thenReturn(value); };\nvar delay = Promise.delay = function (ms, value) {\n    var ret;\n    var handle;\n    if (value !== undefined) {\n        ret = Promise.resolve(value)\n                ._then(afterValue, null, null, ms, undefined);\n        if (debug.cancellation() && value instanceof Promise) {\n            ret._setOnCancel(value);\n        }\n    } else {\n        ret = new Promise(INTERNAL);\n        handle = setTimeout(function() { ret._fulfill(); }, +ms);\n        if (debug.cancellation()) {\n            ret._setOnCancel(new HandleWrapper(handle));\n        }\n        ret._captureStackTrace();\n    }\n    ret._setAsyncGuaranteed();\n    return ret;\n};\n\nPromise.prototype.delay = function (ms) {\n    return delay(ms, this);\n};\n\nvar afterTimeout = function (promise, message, parent) {\n    var err;\n    if (typeof message !== \"string\") {\n        if (message instanceof Error) {\n            err = message;\n        } else {\n            err = new TimeoutError(\"operation timed out\");\n        }\n    } else {\n        err = new TimeoutError(message);\n    }\n    util.markAsOriginatingFromRejection(err);\n    promise._attachExtraTrace(err);\n    promise._reject(err);\n\n    if (parent != null) {\n        parent.cancel();\n    }\n};\n\nfunction successClear(value) {\n    clearTimeout(this.handle);\n    return value;\n}\n\nfunction failureClear(reason) {\n    clearTimeout(this.handle);\n    throw reason;\n}\n\nPromise.prototype.timeout = function (ms, message) {\n    ms = +ms;\n    var ret, parent;\n\n    var handleWrapper = new HandleWrapper(setTimeout(function timeoutTimeout() {\n        if (ret.isPending()) {\n            afterTimeout(ret, message, parent);\n        }\n    }, ms));\n\n    if (debug.cancellation()) {\n        parent = this.then();\n        ret = parent._then(successClear, failureClear,\n                            undefined, handleWrapper, undefined);\n        ret._setOnCancel(handleWrapper);\n    } else {\n        ret = this._then(successClear, failureClear,\n                            undefined, handleWrapper, undefined);\n    }\n\n    return ret;\n};\n\n};\n","\"use strict\";\nmodule.exports = function (Promise, apiRejection, tryConvertToPromise,\n    createContext, INTERNAL, debug) {\n    var util = require(\"./util\");\n    var TypeError = require(\"./errors\").TypeError;\n    var inherits = require(\"./util\").inherits;\n    var errorObj = util.errorObj;\n    var tryCatch = util.tryCatch;\n    var NULL = {};\n\n    function thrower(e) {\n        setTimeout(function(){throw e;}, 0);\n    }\n\n    function castPreservingDisposable(thenable) {\n        var maybePromise = tryConvertToPromise(thenable);\n        if (maybePromise !== thenable &&\n            typeof thenable._isDisposable === \"function\" &&\n            typeof thenable._getDisposer === \"function\" &&\n            thenable._isDisposable()) {\n            maybePromise._setDisposable(thenable._getDisposer());\n        }\n        return maybePromise;\n    }\n    function dispose(resources, inspection) {\n        var i = 0;\n        var len = resources.length;\n        var ret = new Promise(INTERNAL);\n        function iterator() {\n            if (i >= len) return ret._fulfill();\n            var maybePromise = castPreservingDisposable(resources[i++]);\n            if (maybePromise instanceof Promise &&\n                maybePromise._isDisposable()) {\n                try {\n                    maybePromise = tryConvertToPromise(\n                        maybePromise._getDisposer().tryDispose(inspection),\n                        resources.promise);\n                } catch (e) {\n                    return thrower(e);\n                }\n                if (maybePromise instanceof Promise) {\n                    return maybePromise._then(iterator, thrower,\n                                              null, null, null);\n                }\n            }\n            iterator();\n        }\n        iterator();\n        return ret;\n    }\n\n    function Disposer(data, promise, context) {\n        this._data = data;\n        this._promise = promise;\n        this._context = context;\n    }\n\n    Disposer.prototype.data = function () {\n        return this._data;\n    };\n\n    Disposer.prototype.promise = function () {\n        return this._promise;\n    };\n\n    Disposer.prototype.resource = function () {\n        if (this.promise().isFulfilled()) {\n            return this.promise().value();\n        }\n        return NULL;\n    };\n\n    Disposer.prototype.tryDispose = function(inspection) {\n        var resource = this.resource();\n        var context = this._context;\n        if (context !== undefined) context._pushContext();\n        var ret = resource !== NULL\n            ? this.doDispose(resource, inspection) : null;\n        if (context !== undefined) context._popContext();\n        this._promise._unsetDisposable();\n        this._data = null;\n        return ret;\n    };\n\n    Disposer.isDisposer = function (d) {\n        return (d != null &&\n                typeof d.resource === \"function\" &&\n                typeof d.tryDispose === \"function\");\n    };\n\n    function FunctionDisposer(fn, promise, context) {\n        this.constructor$(fn, promise, context);\n    }\n    inherits(FunctionDisposer, Disposer);\n\n    FunctionDisposer.prototype.doDispose = function (resource, inspection) {\n        var fn = this.data();\n        return fn.call(resource, resource, inspection);\n    };\n\n    function maybeUnwrapDisposer(value) {\n        if (Disposer.isDisposer(value)) {\n            this.resources[this.index]._setDisposable(value);\n            return value.promise();\n        }\n        return value;\n    }\n\n    function ResourceList(length) {\n        this.length = length;\n        this.promise = null;\n        this[length-1] = null;\n    }\n\n    ResourceList.prototype._resultCancelled = function() {\n        var len = this.length;\n        for (var i = 0; i < len; ++i) {\n            var item = this[i];\n            if (item instanceof Promise) {\n                item.cancel();\n            }\n        }\n    };\n\n    Promise.using = function () {\n        var len = arguments.length;\n        if (len < 2) return apiRejection(\n                        \"you must pass at least 2 arguments to Promise.using\");\n        var fn = arguments[len - 1];\n        if (typeof fn !== \"function\") {\n            return apiRejection(\"expecting a function but got \" + util.classString(fn));\n        }\n        var input;\n        var spreadArgs = true;\n        if (len === 2 && Array.isArray(arguments[0])) {\n            input = arguments[0];\n            len = input.length;\n            spreadArgs = false;\n        } else {\n            input = arguments;\n            len--;\n        }\n        var resources = new ResourceList(len);\n        for (var i = 0; i < len; ++i) {\n            var resource = input[i];\n            if (Disposer.isDisposer(resource)) {\n                var disposer = resource;\n                resource = resource.promise();\n                resource._setDisposable(disposer);\n            } else {\n                var maybePromise = tryConvertToPromise(resource);\n                if (maybePromise instanceof Promise) {\n                    resource =\n                        maybePromise._then(maybeUnwrapDisposer, null, null, {\n                            resources: resources,\n                            index: i\n                    }, undefined);\n                }\n            }\n            resources[i] = resource;\n        }\n\n        var reflectedResources = new Array(resources.length);\n        for (var i = 0; i < reflectedResources.length; ++i) {\n            reflectedResources[i] = Promise.resolve(resources[i]).reflect();\n        }\n\n        var resultPromise = Promise.all(reflectedResources)\n            .then(function(inspections) {\n                for (var i = 0; i < inspections.length; ++i) {\n                    var inspection = inspections[i];\n                    if (inspection.isRejected()) {\n                        errorObj.e = inspection.error();\n                        return errorObj;\n                    } else if (!inspection.isFulfilled()) {\n                        resultPromise.cancel();\n                        return;\n                    }\n                    inspections[i] = inspection.value();\n                }\n                promise._pushContext();\n\n                fn = tryCatch(fn);\n                var ret = spreadArgs\n                    ? fn.apply(undefined, inspections) : fn(inspections);\n                var promiseCreated = promise._popContext();\n                debug.checkForgottenReturns(\n                    ret, promiseCreated, \"Promise.using\", promise);\n                return ret;\n            });\n\n        var promise = resultPromise.lastly(function() {\n            var inspection = new Promise.PromiseInspection(resultPromise);\n            return dispose(resources, inspection);\n        });\n        resources.promise = promise;\n        promise._setOnCancel(resources);\n        return promise;\n    };\n\n    Promise.prototype._setDisposable = function (disposer) {\n        this._bitField = this._bitField | 131072;\n        this._disposer = disposer;\n    };\n\n    Promise.prototype._isDisposable = function () {\n        return (this._bitField & 131072) > 0;\n    };\n\n    Promise.prototype._getDisposer = function () {\n        return this._disposer;\n    };\n\n    Promise.prototype._unsetDisposable = function () {\n        this._bitField = this._bitField & (~131072);\n        this._disposer = undefined;\n    };\n\n    Promise.prototype.disposer = function (fn) {\n        if (typeof fn === \"function\") {\n            return new FunctionDisposer(fn, this, createContext());\n        }\n        throw new TypeError();\n    };\n\n};\n","\"use strict\";\nmodule.exports = function(Promise) {\nvar SomePromiseArray = Promise._SomePromiseArray;\nfunction any(promises) {\n    var ret = new SomePromiseArray(promises);\n    var promise = ret.promise();\n    ret.setHowMany(1);\n    ret.setUnwrap();\n    ret.init();\n    return promise;\n}\n\nPromise.any = function (promises) {\n    return any(promises);\n};\n\nPromise.prototype.any = function () {\n    return any(this);\n};\n\n};\n","\"use strict\";\nmodule.exports = function(Promise, INTERNAL) {\nvar PromiseReduce = Promise.reduce;\nvar PromiseAll = Promise.all;\n\nfunction promiseAllThis() {\n    return PromiseAll(this);\n}\n\nfunction PromiseMapSeries(promises, fn) {\n    return PromiseReduce(promises, fn, INTERNAL, INTERNAL);\n}\n\nPromise.prototype.each = function (fn) {\n    return PromiseReduce(this, fn, INTERNAL, 0)\n              ._then(promiseAllThis, undefined, undefined, this, undefined);\n};\n\nPromise.prototype.mapSeries = function (fn) {\n    return PromiseReduce(this, fn, INTERNAL, INTERNAL);\n};\n\nPromise.each = function (promises, fn) {\n    return PromiseReduce(promises, fn, INTERNAL, 0)\n              ._then(promiseAllThis, undefined, undefined, promises, undefined);\n};\n\nPromise.mapSeries = PromiseMapSeries;\n};\n\n","\"use strict\";\nmodule.exports = function(Promise, INTERNAL) {\nvar PromiseMap = Promise.map;\n\nPromise.prototype.filter = function (fn, options) {\n    return PromiseMap(this, fn, options, INTERNAL);\n};\n\nPromise.filter = function (promises, fn, options) {\n    return PromiseMap(promises, fn, options, INTERNAL);\n};\n};\n","/* (ignored) */","\"use strict\";\n\nexport function isNumber(val: unknown): val is number {\n  return typeof val === \"number\";\n}\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function isDefined(val: unknown): val is object {\n  return typeof val !== \"undefined\";\n}\n\nexport function isBoolean(val: unknown): val is boolean {\n  return typeof val === \"boolean\";\n}\n\nexport function isString(val: unknown): val is string {\n  return typeof val === \"string\";\n}\n\n/**\n * Check that provided value is Iterable\n * @param val the value to check\n * @returns true if val is iterable, false otherwise\n */\nexport function isIterable(val: unknown): boolean {\n  return Symbol.iterator in Object(val);\n}\n","import {\n  Parser,\n  Composer,\n  LineCounter,\n  ParseOptions,\n  Document,\n  DocumentOptions,\n  SchemaOptions,\n  Node,\n  visit,\n  isNode,\n  isDocument,\n  isPair,\n  isSeq,\n  isScalar,\n  isMap,\n  YAMLMap,\n  YAMLSeq,\n} from \"yaml\";\nimport { coreSchema } from \"./editor-shims\";\nimport { ConfigVar } from \"./esphome-schema\";\nimport { isNumber, isString } from \"./utils/objects\";\nimport { TextBuffer } from \"./utils/text-buffer\";\n\nclass CommonTagImpl {\n  tag: string;\n  readonly type: string;\n  default: boolean = false;\n  constructor(tag: string, type: string) {\n    this.tag = tag;\n    this.type = type;\n  }\n  get collection() {\n    return undefined;\n  }\n\n  identify(value: unknown) {\n    return true;\n  }\n  resolve(value: string | YAMLMap | YAMLSeq): string | YAMLMap | YAMLSeq {\n    return value;\n  }\n}\n\nexport class ESPHomeDocument {\n  public yaml: Document;\n  public bufferText?: string;\n\n  constructor(public text: TextBuffer) {\n    this.bufferText = text.getText();\n    this.yaml = this.parse(this.bufferText);\n  }\n\n  public update(buffer: TextBuffer) {\n    this.text = buffer;\n    const text = this.text.getText();\n    if (this.bufferText === text) {\n      return;\n    }\n    this.bufferText = text;\n    this.yaml = this.parse(this.bufferText);\n  }\n\n  private parse(text: string) {\n    const options: ParseOptions & DocumentOptions & SchemaOptions = {\n      strict: false,\n      version: \"1.2\",\n      customTags: [new CommonTagImpl(\"!secret\", \"scalar\")],\n    };\n    const composer = new Composer(options);\n    const lineCounter = new LineCounter();\n    let isLastLineEmpty = false;\n\n    const parser = isLastLineEmpty\n      ? new Parser()\n      : new Parser(lineCounter.addNewLine);\n\n    const tokens = parser.parse(text);\n    const tokensArr = Array.from(tokens);\n    const docs = composer.compose(tokensArr, true, text.length);\n    return Array.from(docs)[0];\n  }\n\n  public getParent(nodeToFind: Node): Node | undefined {\n    let parentNode: Node | undefined = undefined;\n    visit(this.yaml, (_, node, path) => {\n      if (node === nodeToFind) {\n        parentNode = path[path.length - 1] as Node;\n        return visit.BREAK;\n      }\n      return;\n    });\n\n    if (isDocument(parentNode)) {\n      return;\n    }\n\n    return parentNode;\n  }\n\n  public getPath(node: Node): (number | string)[] {\n    const path: (number | string)[] = [];\n    let child: Node | undefined = undefined;\n    let findingNode: Node | undefined = node;\n    while (findingNode) {\n      if (isPair(findingNode)) {\n        if (isScalar(findingNode.key)) {\n          path.push(findingNode.key.value as string);\n        }\n      }\n      if (isSeq(findingNode) && child !== undefined) {\n        path.push(findingNode.items.indexOf(child));\n      }\n      child = findingNode;\n      findingNode = this.getParent(findingNode);\n    }\n    return path.reverse();\n  }\n\n  public getNodeFromOffset(offset: number): Node | undefined {\n    let closestNode: Node | undefined = undefined;\n    let scalarAfterOffset = false;\n    visit(this.yaml, (key, node) => {\n      if (!node || !isNode(node)) {\n        return;\n      }\n      const range = node.range;\n      if (!range) {\n        return;\n      }\n\n      // tagged node e.g. !secret at the beginning have tag property\n      // but the range does not include this tag space\n      const startPos = node.tag ? range[0] - node.tag.length - 1 : range[0];\n      if (\n        (startPos <= offset && range[2] >= offset) ||\n        // handle edge case of null node values\n        (isScalar(node) &&\n          node.value === null &&\n          startPos > offset &&\n          range[1] > offset &&\n          !isScalar(closestNode) &&\n          !scalarAfterOffset)\n      ) {\n        closestNode = node;\n      } else {\n        if (isScalar(node) && startPos > offset && range[1] > offset) {\n          scalarAfterOffset = true;\n        }\n        return visit.SKIP;\n      }\n      return;\n    });\n\n    return closestNode!;\n  }\n\n  public async getConfigVarAndPathNode(\n    path: (string | number)[],\n  ): Promise<[ConfigVar, Node] | undefined> {\n    let pathNode = this.yaml.contents;\n    let cv: ConfigVar | undefined = undefined;\n    for (let index = 0; index < path.length; index++) {\n      if (isString(path[index]) && isMap(pathNode)) {\n        if (cv === undefined && index <= 2 && pathNode.get(\"platform\")) {\n          const componentName = pathNode.get(\"platform\");\n          if (isString(componentName)) {\n            const platformComponents = await coreSchema.getPlatformList();\n            if (isString(path[0]) && path[0] in platformComponents) {\n              const c = await coreSchema.getComponent(path[0]);\n              if (c.components !== undefined && componentName in c.components) {\n                cv = await coreSchema.getComponentPlatformSchema(\n                  componentName,\n                  path[0],\n                );\n              }\n            }\n          }\n        }\n\n        pathNode = pathNode.get(path[index], true) as Node;\n        if (cv === undefined) {\n          const rootComponents = await coreSchema.getComponentList();\n          if (isString(path[0]) && path[0] in rootComponents) {\n            cv = (await coreSchema.getComponent(path[0])).schemas.CONFIG_SCHEMA;\n          }\n        } else {\n          const pathIndex = path[index];\n          if (isString(pathIndex)) {\n            if (cv.type === \"schema\" || cv.type === \"trigger\") {\n              if (cv.schema !== undefined) {\n                const schema_cv:\n                  | ConfigVar\n                  | undefined = await coreSchema.findConfigVar(\n                  cv.schema,\n                  pathIndex,\n                  this.yaml,\n                );\n                if (schema_cv !== undefined) {\n                  cv = schema_cv;\n                  continue;\n                }\n              }\n\n              if (cv.type === \"trigger\") {\n                if (pathIndex === \"then\") {\n                  continue;\n                }\n                const action = await coreSchema.getActionConfigVar(pathIndex);\n                if (action !== undefined) {\n                  cv = action;\n                  continue;\n                }\n              }\n            }\n            if (cv.type === \"registry\") {\n              cv = await coreSchema.getRegistryConfigVar(\n                cv.registry,\n                pathIndex,\n              );\n            }\n          }\n        }\n      } else if (isNumber(path[index]) && isSeq(pathNode)) {\n        pathNode = pathNode.get(path[index], true) as Node;\n      }\n    }\n    if (!cv || !pathNode) {\n      return undefined;\n    }\n    return [cv, pathNode];\n  }\n}\n\nexport class ESPHomeDocuments {\n  private documents: { [uri: string]: ESPHomeDocument } = {};\n\n  update(uri: string, buffer: TextBuffer) {\n    const doc = this.documents[uri];\n    if (doc === undefined) {\n      this.documents[uri] = new ESPHomeDocument(buffer);\n    } else {\n      doc.update(buffer);\n    }\n  }\n\n  public getDocument(uri: string): ESPHomeDocument {\n    return this.documents[uri];\n  }\n}\n","import { TextDocument } from \"vscode-json-languageservice\";\nimport { Position, Range } from \"vscode-languageserver-types\";\n\ninterface FullTextDocument {\n  getLineOffsets(): number[];\n}\n\nexport class TextBuffer {\n  constructor(private doc: TextDocument) {}\n\n  offsetAt(position: Position) {\n    return this.doc.offsetAt(position);\n  }\n\n  getLineCount(): number {\n    return this.doc.lineCount;\n  }\n\n  getLineLength(lineNumber: number): number {\n    const lineOffsets = (\n      this.doc as unknown as FullTextDocument\n    ).getLineOffsets();\n    if (lineNumber >= lineOffsets.length) {\n      return this.doc.getText().length;\n    } else if (lineNumber < 0) {\n      return 0;\n    }\n\n    const nextLineOffset =\n      lineNumber + 1 < lineOffsets.length\n        ? lineOffsets[lineNumber + 1]\n        : this.doc.getText().length;\n    return nextLineOffset - lineOffsets[lineNumber];\n  }\n\n  getLineContent(lineNumber: number): string {\n    const lineOffsets = (\n      this.doc as unknown as FullTextDocument\n    ).getLineOffsets();\n    if (lineNumber >= lineOffsets.length) {\n      return this.doc.getText();\n    } else if (lineNumber < 0) {\n      return \"\";\n    }\n    const nextLineOffset =\n      lineNumber + 1 < lineOffsets.length\n        ? lineOffsets[lineNumber + 1]\n        : this.doc.getText().length;\n    return this.doc\n      .getText()\n      .substring(lineOffsets[lineNumber], nextLineOffset);\n  }\n\n  getLineCharCode(lineNumber: number, index: number): number {\n    return this.doc\n      .getText(Range.create(lineNumber - 1, index - 1, lineNumber - 1, index))\n      .charCodeAt(0);\n  }\n\n  getText(range?: Range): string {\n    return this.doc.getText(range);\n  }\n\n  getPosition(offest: number): Position {\n    return this.doc.positionAt(offest);\n  }\n\n  // getWordUntilPosition(position : Position) { this.doc.\n}\n","import {\n  isMap,\n  isSeq,\n  isPair,\n  isScalar,\n  YAMLMap,\n  Node,\n  isNode,\n  visit,\n} from \"yaml\";\nimport {\n  CompletionItemKind,\n  coreSchema,\n  Position,\n  Range,\n  createCompletion,\n  CompletionItem,\n  createCompletionSnippet,\n} from \"./editor-shims\";\nimport { ESPHomeDocument, ESPHomeDocuments } from \"./esphome-document\";\nimport {\n  ConfigVar,\n  ConfigVarEnum,\n  ConfigVarRegistry,\n  ConfigVarTrigger,\n  Schema,\n} from \"./esphome-schema\";\nimport { isNumber, isString } from \"./utils/objects\";\n\nexport class CompletionsHandler {\n  constructor(private documents: ESPHomeDocuments) {}\n  private document!: ESPHomeDocument;\n  private docMap!: YAMLMap;\n  private position!: Position;\n  private lineContent!: string;\n\n  public async getCompletions(\n    uri: string,\n    position: Position,\n  ): Promise<CompletionItem[]> {\n    try {\n      this.document = this.documents.getDocument(uri);\n      this.position = position;\n      this.lineContent = this.document.text.getLineContent(position.line);\n      const findByClosest = this.lineContent.trim().length === 0;\n      const offset = this.document.text.offsetAt(position);\n\n      // Do not show completions when next to ':'\n      if (this.document.text.getText().charAt(offset - 1) === \":\") {\n        return [];\n      }\n\n      const docMap = this.document.yaml.contents;\n      if (!isMap(docMap)) {\n        this.docMap = undefined!;\n        return this.getCoreComponents();\n      }\n      this.docMap = docMap;\n\n      let node = findByClosest\n        ? this.findClosestNode(position, offset)\n        : this.document.getNodeFromOffset(offset);\n\n      if (!node) return [];\n\n      const range: Range = {\n        start: this.document.text.getPosition(node.range?.[0]!),\n        end: this.document.text.getPosition(node.range?.[1]!),\n      };\n      if (range.start.character === 0) {\n        return this.getCoreComponents();\n      }\n\n      const p1 = this.document.getParent(node);\n      const p2 = p1 !== undefined ? this.document.getParent(p1) : undefined;\n\n      if (!findByClosest && isScalar(node)) {\n        if (isPair(p1) && p1.value === null) {\n          // seems to be writing on a key still without value\n          if (isMap(p2)) {\n            node = p2;\n          }\n        }\n      }\n\n      const path = this.document.getPath(node);\n      // At this point node and path should be meaningful and consistent\n      // Path is were completions need to be listed, it really doesn't matter where the cursor is, cursor shouldn't be checked\n      // to see what completions are need\n\n      // List items under - platform: |\n      if (isPair(p1) && isScalar(p1.key)) {\n        if (p1.key.value === \"platform\") {\n          if (isMap(p2)) {\n            const p3 = this.document.getParent(p2);\n            if (isSeq(p3)) {\n              const p4 = this.document.getParent(p3);\n              if (isPair(p4) && isScalar(p4.key)) {\n                const platform_name = p4.key.value as string;\n                return await this.getPlatformNames(platform_name, range);\n              }\n            }\n          }\n        }\n      }\n\n      console.log(node, path, path.length, `'${path[0]}'`);\n\n      let pathElement;\n      // First get the root component\n      let cv: ConfigVar | undefined = undefined;\n      let pathIndex = 0;\n      if (path.length) {\n        pathIndex = 1;\n        pathElement = docMap.get(path[0]);\n        if (isString(path[0]) && (await coreSchema.isPlatform(path[0]))) {\n          if (path.length > 1) {\n            // we are in a platform (e.g. sensor) and there are inner stuff\n            if (isNumber(path[1])) {\n              // the index in the sequence\n              const index = path[1];\n              if (isSeq(pathElement)) {\n                pathElement = pathElement.get(index);\n                pathIndex += 1;\n              }\n            }\n          }\n          // else branch not needed here as pathElement should be pointing\n          // to the object with the platform key\n          if (isMap(pathElement)) {\n            const domain = pathElement.get(\"platform\");\n            if (isString(domain)) {\n              cv = await coreSchema.getComponentPlatformSchema(domain, path[0]);\n            }\n          }\n          if (!cv) {\n            return [\n              createCompletion(\n                \"platform\",\n                isSeq(this.document.getParent(node))\n                  ? \"platform: \"\n                  : \"- platform: \",\n                CompletionItemKind.EnumMember,\n                undefined,\n                true,\n              ),\n            ];\n          }\n        } else {\n          pathElement = docMap.get(path[0]);\n          if (isString(path[0])) {\n            cv = await coreSchema.getComponentSchema(path[0]);\n          }\n        }\n      }\n\n      return this.resolveConfigVar(\n        path,\n        pathIndex,\n        cv!,\n        pathElement as YAMLMap,\n        node,\n      );\n    } catch (e) {\n      console.log(`Error during evaluating completions ${e}`);\n      return [];\n    }\n  }\n\n  private async getPlatformNames(platform_name: string, range: Range) {\n    const c = await coreSchema.getComponent(platform_name);\n\n    if (c.components === undefined) {\n      console.log(`Error: not a platform ${platform_name}`);\n      return [];\n    }\n\n    const result = [];\n    for (var component in c.components) {\n      result.push(\n        createCompletion(\n          component,\n          component + \"\\n  \",\n          CompletionItemKind.EnumMember,\n          c.components[component].docs,\n          true,\n        ),\n      );\n    }\n\n    return result;\n  }\n\n  private async getCoreComponents() {\n    // suggest platforms, e.g. sensor:, binary_sensor:\n    const platformList = await coreSchema.getPlatformList();\n    const result: CompletionItem[] = [];\n\n    for (var platformName in platformList) {\n      // Don't add duplicate keys\n      if (this.docMap && this.mapHasScalarKey(this.docMap, platformName)) {\n        continue;\n      }\n\n      result.push(\n        createCompletion(\n          platformName,\n          platformName + \":\\n  - platform: \",\n          CompletionItemKind.Class,\n          platformList[platformName].docs,\n          true,\n        ),\n      );\n    }\n    // suggest component/hub e.g. dallas:, sim800l:\n    const components = await coreSchema.getComponentList();\n    for (var componentName in components) {\n      // skip platforms added in previous loop\n      if (componentName in platformList) {\n        continue;\n      }\n      // Don't add duplicate keys\n      if (this.docMap && this.mapHasScalarKey(this.docMap, componentName)) {\n        continue;\n      }\n\n      // Filter esp32 or esp8266 components only when the other target is used\n      if (this.docMap && components[componentName].dependencies) {\n        let missingDep = false;\n        for (const dep of components[componentName].dependencies!) {\n          if (dep === \"esp8266\" || dep === \"esp32\") {\n            if (this.docMap.get(dep) === undefined) {\n              missingDep = true;\n              break;\n            }\n          }\n        }\n        if (missingDep) {\n          continue;\n        }\n      }\n      result.push(\n        createCompletion(\n          componentName,\n          componentName + \":\\n  \",\n          CompletionItemKind.Field,\n          components[componentName].docs,\n          true,\n        ),\n      );\n    }\n    return result;\n  }\n\n  private getChipset(): \"esp8266\" | \"esp32\" | undefined {\n    if (this.docMap.get(\"esp8266\", true) !== undefined) {\n      return \"esp8266\";\n    }\n    if (this.docMap.get(\"esp32\", true) !== undefined) {\n      return \"esp32\";\n    }\n    const esphome = this.docMap.get(\"esphome\");\n    if (isMap(esphome)) {\n      const chipset = esphome.get(\"platform\");\n      if (isString(chipset)) {\n        if (chipset.toLowerCase() === \"esp32\") {\n          return \"esp32\";\n        }\n        if (chipset.toLowerCase() === \"esp8266\") {\n          return \"esp8266\";\n        }\n      }\n    }\n    return undefined;\n  }\n\n  private mapHasScalarKey(map: YAMLMap, key: string): boolean {\n    for (var item of map.items) {\n      if (isScalar(item.key) && item.key.value === key) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private async resolveConfigVar(\n    path: any[],\n    pathIndex: number,\n    cv: ConfigVar,\n    pathNode: YAMLMap | null,\n    cursorNode: Node,\n  ): Promise<CompletionItem[]> {\n    if (cv.is_list && isNumber(path[pathIndex])) {\n      if (isSeq(pathNode)) {\n        pathNode = (pathNode.get(path[pathIndex]) as any) as YAMLMap;\n      }\n      pathIndex++;\n    }\n    if (cv.type === \"schema\") {\n      if (isMap(pathNode)) {\n        if (pathIndex === path.length) {\n          return this.getConfigVars(cv.schema, pathNode);\n        }\n        return this.resolveSchema(\n          path,\n          pathIndex,\n          cv.schema,\n          pathNode,\n          cursorNode,\n        );\n      } else {\n        if (pathIndex === path.length) {\n          if (isScalar(cursorNode)) {\n            const complete = await coreSchema.getConfigVarComplete2(cv);\n            if (complete[\"maybe\"] !== undefined) {\n              const maybe_cv = await coreSchema.findConfigVar(\n                cv.schema,\n                complete[\"maybe\"],\n                this.document.yaml,\n              );\n              return this.resolveConfigVar(\n                path,\n                pathIndex,\n                maybe_cv!,\n                null,\n                cursorNode,\n              );\n            }\n          }\n\n          return this.getConfigVars(cv.schema, null, cv.is_list);\n        }\n        throw new Error(\"Expected map not found in \" + pathIndex);\n      }\n    } else if (cv.type === \"enum\") {\n      return this.addEnums(cv);\n    } else if (cv.type === \"trigger\") {\n      return this.resolveTrigger(path, pathIndex, pathNode, cv, cursorNode);\n    } else if (cv.type === \"registry\") {\n      let elem: any = pathNode;\n      if (isSeq(elem) && elem.items.length) {\n        elem = elem.items[path[pathIndex]];\n        if (isNode(elem)) {\n          return this.resolveRegistryInner(\n            path,\n            pathIndex + 1,\n            isMap(elem) ? elem : null,\n            cv,\n            cursorNode,\n          );\n        }\n      }\n      if (isMap(elem)) {\n        return this.resolveRegistryInner(path, pathIndex, elem, cv, cursorNode);\n      }\n      return this.resolveRegistryInner(\n        path,\n        pathIndex,\n        isMap(elem) ? elem : null,\n        cv,\n        cursorNode,\n      );\n    } else if (cv.type === \"typed\") {\n      if (!pathNode) {\n        return [\n          createCompletion(\n            cv.typed_key,\n            cv.typed_key + \": \",\n            CompletionItemKind.Enum,\n            undefined,\n            true,\n          ),\n        ];\n      } else if (\n        pathIndex + 1 >= path.length &&\n        path[pathIndex] === cv.typed_key\n      ) {\n        let result = [];\n        for (const schema_type in cv.types) {\n          result.push(\n            createCompletion(\n              schema_type,\n              schema_type + \"\\n\",\n              CompletionItemKind.EnumMember,\n              undefined,\n              true,\n            ),\n          );\n        }\n        return result;\n      } else {\n        if (pathNode !== null && isMap(pathNode)) {\n          const type = pathNode.get(cv.typed_key);\n          if (type !== null && isString(type)) {\n            if (pathIndex === path.length) {\n              return this.getConfigVars(cv.types[type], pathNode);\n            }\n            return this.resolveSchema(\n              path,\n              pathIndex,\n              cv.types[type],\n              pathNode,\n              cursorNode,\n            );\n          }\n          let result: CompletionItem[] = [];\n          // there are other options but still not `type`\n          result.push(\n            createCompletion(\n              cv.typed_key,\n              cv.typed_key + \": \",\n              CompletionItemKind.EnumMember,\n              undefined,\n              true,\n            ),\n          );\n          return result;\n        }\n      }\n    } else if (cv.type === \"string\") {\n      if (cv.templatable) {\n        return [\n          createCompletionSnippet(\n            \"!lambda\",\n            '!lambda return \"${0:<string expression>}\";',\n            CompletionItemKind.Function,\n          ),\n        ];\n      }\n      return [];\n    } else if (cv.type === \"pin\") {\n      //if (parentElement.items.length > 0 && isScalar(node) && node === parentElement.items[0].value) {\n      // cursor is in the value of the pair\n      //    return this.resolvePinNumbers(result, cv);\n      //}\n      if (!cv.schema) {\n        // This pin does not accept schema, e.g. i2c\n        return [];\n      }\n\n      let pinCv: ConfigVar | undefined = undefined;\n\n      if (isMap(pathNode)) {\n        // Check if it is using a port expander\n        for (const expander of await coreSchema.getPins()) {\n          if (\n            expander !== \"esp32\" &&\n            expander !== \"esp8266\" &&\n            (this.document.yaml.contents as YAMLMap).get(expander)\n          ) {\n            if (pathNode.get(expander)) {\n              pinCv = await coreSchema.getPinConfigVar(expander);\n              break;\n            }\n          }\n        }\n      }\n\n      if (pinCv === undefined) {\n        const chipset = this.getChipset();\n        if (chipset === \"esp32\") {\n          pinCv = await coreSchema.getPinConfigVar(\"esp32\");\n        } else if (chipset === \"esp8266\") {\n          pinCv = await coreSchema.getPinConfigVar(\"esp8266\");\n        }\n      }\n\n      if (\n        pinCv !== undefined &&\n        pinCv.type === \"schema\" &&\n        pathNode === null &&\n        !cv.internal\n      ) {\n        // suggest all expanders\n        for (const expander of await coreSchema.getPins()) {\n          if (\n            expander !== \"esp32\" &&\n            expander !== \"esp8266\" &&\n            this.docMap.get(expander)\n          ) {\n            pinCv.schema.config_vars[expander] = {\n              key: \"Optional\",\n              type: \"string\",\n            };\n          }\n        }\n      }\n      if (!pinCv) {\n        return [];\n      }\n      return this.resolveConfigVar(\n        path,\n        pathIndex,\n        pinCv,\n        pathNode,\n        cursorNode,\n      );\n    } else if (cv.type === \"boolean\") {\n      let result: CompletionItem[] = [];\n      if (cv.templatable) {\n        result.push(\n          createCompletionSnippet(\n            \"!lambda \",\n            '!lambda return \"${0:<boolean expression>}\";',\n            CompletionItemKind.Function,\n          ),\n        );\n      }\n      for (var value of [\"True\", \"False\"]) {\n        result.push(\n          createCompletion(\n            value,\n            value,\n            CompletionItemKind.Constant,\n            undefined,\n            false,\n            cv.default === value,\n          ),\n        );\n      }\n      return result;\n    } else if (cv.type === \"use_id\") {\n      let result: CompletionItem[] = [];\n      const usableIds = await coreSchema.getUsableIds(\n        cv.use_id_type,\n        this.document.yaml,\n      );\n      for (var usableId of usableIds) {\n        result.push(\n          createCompletion(usableId, usableId, CompletionItemKind.Variable),\n        );\n      }\n      return result;\n    } else if (cv[\"templatable\"]) {\n      let insertText = \"!lambda return ${0:<expression>};\";\n      if (cv.docs && cv.docs.startsWith(\"**\")) {\n        const endStrType = cv.docs.indexOf(\"**\", 2);\n        if (endStrType !== -1) {\n          const strType = cv.docs.substring(2, cv.docs.indexOf(\"**\", 2));\n          if (strType === \"string\") {\n            insertText = '!lambda return \"${0:<string expression>}\";';\n          } else {\n            insertText = \"!lambda return ${0:<\" + strType + \" expression>};\";\n          }\n        }\n      }\n      return [\n        createCompletionSnippet(\n          \"!lambda\",\n          insertText,\n          CompletionItemKind.Function,\n          cv.docs,\n        ),\n      ];\n    }\n    throw new Error(\"Unexpected path traverse.\");\n  }\n\n  private async getConfigVars(\n    schema: Schema,\n    node: YAMLMap | null,\n    isList = false,\n  ): Promise<CompletionItem[]> {\n    const ret: CompletionItem[] = [];\n\n    let prefix = \"\";\n    if (isList) {\n      const dashPos = this.lineContent.indexOf(\"-\");\n      if (dashPos >= 0 && dashPos < this.position.character) {\n        // there is a dash already, do we need a space?\n        if (dashPos - this.position.character == -1) prefix = \" \";\n      }\n      // there is no dash on the line already, add it\n      else prefix = \"- \";\n    }\n\n    for await (const [prop, config] of coreSchema.iterConfigVars(\n      schema,\n      this.document.yaml,\n    )) {\n      // Skip existent properties\n      if (node !== null && this.mapHasScalarKey(node, prop)) {\n        continue;\n      }\n\n      let insertText = prefix + prop + \": \";\n      let triggerSuggest = false;\n      let snippet = false;\n\n      let sortText: string | undefined = undefined;\n      let detail: string | undefined = undefined;\n\n      if (config.templatable) {\n        detail = \"lambda\";\n        triggerSuggest = true;\n      } else {\n        if (config.key === \"Required\") {\n          sortText = \"00\" + prop;\n          detail = \"Required\";\n        } else {\n          if (config.type === \"integer\" || config.type === \"string\") {\n            if (config.default) {\n              snippet = true;\n              insertText += \"${0:\" + config.default + \"}\";\n            }\n          }\n        }\n      }\n\n      let kind: any = CompletionItemKind.Struct;\n      switch (config.type) {\n        case \"schema\":\n          kind = CompletionItemKind.Struct;\n          insertText += \"\\n  \";\n          triggerSuggest = true;\n          break;\n        case \"typed\":\n          kind = CompletionItemKind.Struct;\n          insertText += \"\\n  \" + config.typed_key + \": \";\n          triggerSuggest = true;\n          break;\n        case \"enum\":\n          kind = CompletionItemKind.Enum;\n          triggerSuggest = true;\n          break;\n        case \"trigger\":\n          kind = CompletionItemKind.Event;\n          if (prop !== \"then\" && !config.has_required_var) {\n            insertText += \"\\n  then:\\n    \";\n          } else {\n            insertText += \"\\n  \";\n          }\n          triggerSuggest = true;\n          break;\n        case \"registry\":\n          kind = CompletionItemKind.Field;\n          break;\n        case \"pin\":\n          kind = CompletionItemKind.Interface;\n          break;\n        case \"boolean\":\n          triggerSuggest = true;\n          kind = CompletionItemKind.Variable;\n          break;\n        default:\n          kind = CompletionItemKind.Property;\n          break;\n      }\n\n      if (config.type === \"use_id\" || config.maybe) {\n        triggerSuggest = true;\n      }\n\n      ret.push(\n        createCompletion(\n          prop,\n          insertText,\n          kind,\n          config.docs,\n          triggerSuggest,\n          undefined,\n          snippet,\n          sortText,\n          detail,\n        ),\n      );\n    }\n    return ret;\n  }\n\n  private async resolveSchema(\n    path: any[],\n    pathIndex: number,\n    schema: Schema,\n    pathElement: YAMLMap | null,\n    node: Node,\n  ): Promise<CompletionItem[]> {\n    console.log(\"component: \" + path[pathIndex]);\n    const cv = await coreSchema.findConfigVar(\n      schema,\n      path[pathIndex],\n      this.document.yaml,\n    );\n    if (cv === undefined) return [];\n    let innerNode =\n      pathElement !== null\n        ? (pathElement.get(path[pathIndex]) as YAMLMap)\n        : null;\n\n    return await this.resolveConfigVar(\n      path,\n      pathIndex + 1,\n      cv,\n      innerNode,\n      node,\n    );\n  }\n\n  private async addEnums(cv: ConfigVarEnum): Promise<CompletionItem[]> {\n    const result: CompletionItem[] = [];\n\n    if (cv.templatable) {\n      result.push(\n        createCompletionSnippet(\n          \"!lambda\",\n          '!lambda return \"${0:<enum expression>}\";',\n          CompletionItemKind.Function,\n        ),\n      );\n    }\n    for (var value in cv.values) {\n      if (isNumber(value as any)) {\n        value = value.toString();\n      }\n      result.push(\n        createCompletion(\n          value,\n          value,\n          CompletionItemKind.EnumMember,\n          cv.values[value]?.docs,\n          false,\n          cv.default === value,\n        ),\n      );\n    }\n    return result;\n  }\n\n  private async resolveTrigger(\n    path: any[],\n    pathIndex: number,\n    pathNode: Node | null,\n    cv: ConfigVarTrigger,\n    node: Node,\n  ): Promise<CompletionItem[]> {\n    console.log(\"trigger: \" + path[pathIndex]);\n    // trigger can be a single item on a map or otherwise a seq.\n    if (isSeq(pathNode)) {\n      let innerNode: Node | null = null;\n      if (pathIndex < path.length) {\n        if (pathNode.items.length) {\n          innerNode = pathNode.items[path[pathIndex]] as Node;\n        }\n        return this.resolveTriggerInner(\n          path,\n          pathIndex + 1,\n          innerNode,\n          cv,\n          node,\n        );\n      }\n      if (cv.schema && !cv.has_required_var) {\n        // if this has a schema, when inside the list we no longer can setup automation props\n        cv = cv.schema.config_vars.then as ConfigVarTrigger;\n      }\n      return this.resolveTriggerInner(path, pathIndex, innerNode, cv, node);\n    }\n\n    return this.resolveTriggerInner(\n      path,\n      pathIndex,\n      isMap(pathNode) ? pathNode : null,\n      cv,\n      node,\n    );\n  }\n\n  private async resolveTriggerInner(\n    path: any[],\n    pathIndex: number,\n    pathNode: Node | null,\n    cv: ConfigVarTrigger,\n    node: Node,\n  ): Promise<CompletionItem[]> {\n    const final = pathIndex === path.length;\n    if (final) {\n      // If this has a schema, use it, these are suggestions so user will see the trigger parameters even when they are optional\n      // However if the only option is 'then:' we should avoid it for readability\n      if (cv.schema !== undefined) {\n        return this.getConfigVars(cv.schema, isMap(pathNode) ? pathNode : null);\n      }\n      if (pathNode && !isScalar(pathNode)) {\n        // here in this trigger there is already an action,\n        // we could suggest another actions but in that case we should convert\n        // this action to a list, so just don't suggest anything\n        return [];\n      }\n      return this.addRegistry({\n        type: \"registry\",\n        registry: \"action\",\n        key: \"\",\n      });\n    }\n\n    if (path[pathIndex] === \"then\") {\n      // all triggers support then, even when they do not have a schema\n      // then is a trigger without schema so...\n      let thenNode = pathNode;\n      if (isMap(pathNode)) {\n        thenNode = pathNode.get(\"then\", true) as Node;\n      }\n      return this.resolveTrigger(\n        path,\n        pathIndex + 1,\n        thenNode,\n        {\n          type: \"trigger\",\n          key: \"Optional\",\n          schema: undefined,\n          has_required_var: false,\n        },\n        node,\n      );\n    }\n\n    // navigate into the prop\n    // this can be an action or a prop of this trigger\n    if (cv.schema !== undefined) {\n      const innerProp = await coreSchema.findConfigVar(\n        cv.schema,\n        path[pathIndex],\n        this.document.yaml,\n      );\n      if (innerProp !== undefined) {\n        return this.resolveSchema(\n          path,\n          pathIndex,\n          cv.schema,\n          isMap(pathNode) ? pathNode : null,\n          node,\n        );\n      }\n    }\n    // is this an action?\n    const action = await coreSchema.getActionConfigVar(path[pathIndex]);\n    if (action !== undefined && action.schema) {\n      var innerNode: Node | null = null;\n      if (isMap(pathNode)) {\n        const innerPathNode = pathNode.get(path[pathIndex]);\n        if (isNode(innerPathNode)) {\n          innerNode = innerPathNode;\n        }\n      }\n      if (pathIndex + 1 === path.length && isMap(pathNode)) {\n        if (isScalar(node)) {\n          const complete = await coreSchema.getConfigVarComplete2(action);\n          if (complete.type === \"schema\" && complete[\"maybe\"] !== undefined) {\n            const maybe_cv = await coreSchema.findConfigVar(\n              action.schema,\n              complete[\"maybe\"],\n              this.document.yaml,\n            );\n            if (!maybe_cv) {\n              return [];\n            }\n            return this.resolveConfigVar(path, pathIndex, maybe_cv, null, node);\n          }\n          return [];\n        }\n\n        return this.getConfigVars(action.schema, innerNode as YAMLMap);\n      }\n\n      return this.resolveSchema(\n        path,\n        pathIndex + 1,\n        action.schema,\n        innerNode as YAMLMap,\n        node,\n      );\n    }\n    return [];\n  }\n  private async addRegistry(\n    configVar: ConfigVarRegistry,\n  ): Promise<CompletionItem[]> {\n    let prefix = \"\";\n    const dashPos = this.lineContent.indexOf(\"-\");\n    if (dashPos >= 0 && dashPos < this.position.character) {\n      // there is a dash already, do we need a space?\n      if (dashPos - this.position.character == -1) prefix = \" \";\n    }\n    // there is no dash on the line already, add it\n    else prefix = \"- \";\n\n    const result: CompletionItem[] = [];\n    for await (const [value, props] of await coreSchema.getRegistry(\n      configVar.registry,\n      this.document.yaml,\n    )) {\n      if (configVar.filter && !configVar.filter.includes(value)) {\n        continue;\n      }\n      let insertText = prefix + value + \": \";\n      const completeCv = await coreSchema.getConfigVarComplete2(props);\n      if (!completeCv.maybe) {\n        insertText += \"\\n    \";\n      }\n\n      result.push(\n        createCompletion(\n          value,\n          insertText,\n          CompletionItemKind.Keyword,\n          props.docs,\n          true,\n        ),\n      );\n    }\n    return result;\n  }\n\n  private async resolveRegistryInner(\n    path: any[],\n    pathIndex: number,\n    pathNode: YAMLMap | null,\n    cv: ConfigVarRegistry,\n    node: Node,\n  ): Promise<CompletionItem[]> {\n    const final = pathIndex === path.length;\n    if (final && pathNode === null) {\n      return this.addRegistry(cv);\n    }\n    const registryCv = await coreSchema.getRegistryConfigVar(\n      cv.registry,\n      path[pathIndex],\n    );\n    if (!registryCv) {\n      return [];\n    }\n    const inner = pathNode !== null ? pathNode.get(path[pathIndex]) : null;\n    return this.resolveConfigVar(\n      path,\n      pathIndex + 1,\n      registryCv,\n      isMap(inner) ? inner : null,\n      node,\n    );\n  }\n\n  private findClosestNode(position: Position, offset: number): Node {\n    const { yaml, text } = this.document;\n\n    let offsetDiff = yaml.contents!.range![2];\n    let maxOffset = yaml.contents!.range![0];\n\n    let closestNode: Node = this.document.yaml.contents!;\n    visit(yaml, (key, node) => {\n      if (!node || !isNode(node)) {\n        return;\n      }\n      const range = node.range;\n      if (!range) {\n        return;\n      }\n      const diff = range[2] - offset;\n      if (maxOffset <= range[0] && diff <= 0 && Math.abs(diff) <= offsetDiff) {\n        offsetDiff = Math.abs(diff);\n        maxOffset = range[0];\n        closestNode = node;\n      }\n    });\n\n    const lineContent = text.getLineContent(position.line);\n    const indentation = this.getIndentation(lineContent, position.character);\n\n    if (closestNode !== undefined && indentation === position.character) {\n      closestNode = this.getProperParentByIndentation(\n        indentation,\n        closestNode,\n      )!;\n    }\n\n    return closestNode!;\n  }\n\n  private getIndentation(lineContent: string, position: number): number {\n    if (lineContent.length < position - 1) {\n      return 0;\n    }\n\n    for (let i = 0; i < position; i++) {\n      const char = lineContent.charCodeAt(i);\n      if (char !== 32 && char !== 9) {\n        return i;\n      }\n    }\n\n    // assuming that current position is indentation\n    return position;\n  }\n\n  private getProperParentByIndentation(\n    indentation: number,\n    node: Node,\n  ): Node | undefined {\n    if (!node) {\n      return this.document.yaml.contents as Node;\n    }\n    const { text } = this.document;\n    if (isNode(node) && node.range) {\n      const position = text.getPosition(node.range[0]);\n      if (position.character > indentation && position.character > 1) {\n        const parent = this.document.getParent(node);\n        if (parent) {\n          return this.getProperParentByIndentation(indentation, parent);\n        }\n      } else if (position.character < indentation) {\n        const parent = this.document.getParent(node);\n        if (isPair(parent) && isNode(parent.value)) {\n          return parent.value;\n        }\n      } else {\n        return node;\n      }\n    } else if (isPair(node)) {\n      if (\n        isScalar(node.value) &&\n        node.value.value === null &&\n        isScalar(node.key) &&\n        text.getPosition(node.key.range![0]).character < indentation\n      ) {\n        return node;\n      }\n      const parent = this.document.getParent(node);\n      if (isNode(parent)) {\n        return this.getProperParentByIndentation(indentation, parent);\n      }\n    }\n    return node;\n  }\n}\n","import { isScalar } from \"yaml\";\nimport { coreSchema, Position } from \"./editor-shims\";\nimport { ESPHomeDocuments } from \"./esphome-document\";\n\nexport class DefinitionHandler {\n  constructor(private documents: ESPHomeDocuments) {}\n\n  public async getDefinition(uri: string, position: Position) {\n    try {\n      const document = this.documents.getDocument(uri);\n      const lineContent = document.text.getLineContent(position.line);\n      if (lineContent.trim().length === 0) {\n        return;\n      }\n      const offset = document.text.offsetAt(position);\n      const node = document.getNodeFromOffset(offset);\n\n      if (!node) return;\n      var path = document.getPath(node);\n\n      if (path.length === 1) {\n        return null;\n      }\n\n      const cvAndPath = await document.getConfigVarAndPathNode(path);\n      if (cvAndPath === undefined) {\n        return;\n      }\n      const [cv, pathNode] = cvAndPath;\n      let fullCv = await coreSchema.getConfigVarComplete2(cv);\n\n      if (fullCv.type === \"schema\" && fullCv.maybe !== undefined) {\n        fullCv = await coreSchema.getConfigVarComplete2(fullCv);\n      }\n      if (fullCv.type === \"use_id\" && isScalar(pathNode)) {\n        const typeId = fullCv.use_id_type;\n        const targetId = pathNode.value as string;\n        const range = await coreSchema.findComponentDefinition(\n          typeId,\n          targetId,\n          document.yaml,\n        );\n        if (!range) {\n          return null;\n        }\n        const definition = {\n          uri: uri,\n          range: {\n            start: document.text.getPosition(range[0]),\n            end: document.text.getPosition(range[0] + targetId.length),\n          },\n        };\n        return definition;\n      }\n    } catch (error) {\n      console.log(\"Definition:\" + error);\n    }\n    return null;\n  }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(0);\n",""],"names":[],"sourceRoot":""}